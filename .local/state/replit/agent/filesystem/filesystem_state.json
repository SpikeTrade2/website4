{"file_contents":{"build/extracted-include-protos/main/google/api/control.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"ControlProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Selects and configures the service controller used by the service.\n//\n// Example:\n//\n//     control:\n//       environment: servicecontrol.googleapis.com\nmessage Control {\n  // The service controller environment to use. If empty, no control plane\n  // feature (like quota and billing) will be enabled. The recommended value for\n  // most services is servicecontrol.googleapis.com\n  string environment = 1;\n}\n","size_bytes":1289},"build/extracted-include-protos/main/google/type/timeofday.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/timeofday;timeofday\";\noption java_multiple_files = true;\noption java_outer_classname = \"TimeOfDayProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a time of day. The date and time zone are either not significant\n// or are specified elsewhere. An API may choose to allow leap seconds. Related\n// types are [google.type.Date][google.type.Date] and\n// `google.protobuf.Timestamp`.\nmessage TimeOfDay {\n  // Hours of day in 24 hour format. Should be from 0 to 23. An API may choose\n  // to allow the value \"24:00:00\" for scenarios like business closing time.\n  int32 hours = 1;\n\n  // Minutes of hour of day. Must be from 0 to 59.\n  int32 minutes = 2;\n\n  // Seconds of minutes of the time. Must normally be from 0 to 59. An API may\n  // allow the value 60 if it allows leap-seconds.\n  int32 seconds = 3;\n\n  // Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.\n  int32 nanos = 4;\n}\n","size_bytes":1667},"build/extracted-include-protos/main/google/rpc/error_details.proto":{"content":"// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.rpc;\n\nimport \"google/protobuf/duration.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/rpc/errdetails;errdetails\";\noption java_multiple_files = true;\noption java_outer_classname = \"ErrorDetailsProto\";\noption java_package = \"com.google.rpc\";\noption objc_class_prefix = \"RPC\";\n\n// Describes the cause of the error with structured details.\n//\n// Example of an error when contacting the \"pubsub.googleapis.com\" API when it\n// is not enabled:\n//\n//     { \"reason\": \"API_DISABLED\"\n//       \"domain\": \"googleapis.com\"\n//       \"metadata\": {\n//         \"resource\": \"projects/123\",\n//         \"service\": \"pubsub.googleapis.com\"\n//       }\n//     }\n//\n// This response indicates that the pubsub.googleapis.com API is not enabled.\n//\n// Example of an error that is returned when attempting to create a Spanner\n// instance in a region that is out of stock:\n//\n//     { \"reason\": \"STOCKOUT\"\n//       \"domain\": \"spanner.googleapis.com\",\n//       \"metadata\": {\n//         \"availableRegions\": \"us-central1,us-east2\"\n//       }\n//     }\nmessage ErrorInfo {\n  // The reason of the error. This is a constant value that identifies the\n  // proximate cause of the error. Error reasons are unique within a particular\n  // domain of errors. This should be at most 63 characters and match a\n  // regular expression of `[A-Z][A-Z0-9_]+[A-Z0-9]`, which represents\n  // UPPER_SNAKE_CASE.\n  string reason = 1;\n\n  // The logical grouping to which the \"reason\" belongs. The error domain\n  // is typically the registered service name of the tool or product that\n  // generates the error. Example: \"pubsub.googleapis.com\". If the error is\n  // generated by some common infrastructure, the error domain must be a\n  // globally unique value that identifies the infrastructure. For Google API\n  // infrastructure, the error domain is \"googleapis.com\".\n  string domain = 2;\n\n  // Additional structured details about this error.\n  //\n  // Keys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in\n  // length. When identifying the current value of an exceeded limit, the units\n  // should be contained in the key, not the value.  For example, rather than\n  // {\"instanceLimit\": \"100/request\"}, should be returned as,\n  // {\"instanceLimitPerRequest\": \"100\"}, if the client exceeds the number of\n  // instances that can be created in a single (batch) request.\n  map<string, string> metadata = 3;\n}\n\n// Describes when the clients can retry a failed request. Clients could ignore\n// the recommendation here or retry when this information is missing from error\n// responses.\n//\n// It's always recommended that clients should use exponential backoff when\n// retrying.\n//\n// Clients should wait until `retry_delay` amount of time has passed since\n// receiving the error response before retrying.  If retrying requests also\n// fail, clients should use an exponential backoff scheme to gradually increase\n// the delay between retries based on `retry_delay`, until either a maximum\n// number of retries have been reached or a maximum retry delay cap has been\n// reached.\nmessage RetryInfo {\n  // Clients should wait at least this long between retrying the same request.\n  google.protobuf.Duration retry_delay = 1;\n}\n\n// Describes additional debugging info.\nmessage DebugInfo {\n  // The stack trace entries indicating where the error occurred.\n  repeated string stack_entries = 1;\n\n  // Additional debugging information provided by the server.\n  string detail = 2;\n}\n\n// Describes how a quota check failed.\n//\n// For example if a daily limit was exceeded for the calling project,\n// a service could respond with a QuotaFailure detail containing the project\n// id and the description of the quota limit that was exceeded.  If the\n// calling project hasn't enabled the service in the developer console, then\n// a service could respond with the project id and set `service_disabled`\n// to true.\n//\n// Also see RetryInfo and Help types for other details about handling a\n// quota failure.\nmessage QuotaFailure {\n  // A message type used to describe a single quota violation.  For example, a\n  // daily quota or a custom quota that was exceeded.\n  message Violation {\n    // The subject on which the quota check failed.\n    // For example, \"clientip:<ip address of client>\" or \"project:<Google\n    // developer project id>\".\n    string subject = 1;\n\n    // A description of how the quota check failed. Clients can use this\n    // description to find more about the quota configuration in the service's\n    // public documentation, or find the relevant quota limit to adjust through\n    // developer console.\n    //\n    // For example: \"Service disabled\" or \"Daily Limit for read operations\n    // exceeded\".\n    string description = 2;\n  }\n\n  // Describes all quota violations.\n  repeated Violation violations = 1;\n}\n\n// Describes what preconditions have failed.\n//\n// For example, if an RPC failed because it required the Terms of Service to be\n// acknowledged, it could list the terms of service violation in the\n// PreconditionFailure message.\nmessage PreconditionFailure {\n  // A message type used to describe a single precondition failure.\n  message Violation {\n    // The type of PreconditionFailure. We recommend using a service-specific\n    // enum type to define the supported precondition violation subjects. For\n    // example, \"TOS\" for \"Terms of Service violation\".\n    string type = 1;\n\n    // The subject, relative to the type, that failed.\n    // For example, \"google.com/cloud\" relative to the \"TOS\" type would indicate\n    // which terms of service is being referenced.\n    string subject = 2;\n\n    // A description of how the precondition failed. Developers can use this\n    // description to understand how to fix the failure.\n    //\n    // For example: \"Terms of service not accepted\".\n    string description = 3;\n  }\n\n  // Describes all precondition violations.\n  repeated Violation violations = 1;\n}\n\n// Describes violations in a client request. This error type focuses on the\n// syntactic aspects of the request.\nmessage BadRequest {\n  // A message type used to describe a single bad request field.\n  message FieldViolation {\n    // A path that leads to a field in the request body. The value will be a\n    // sequence of dot-separated identifiers that identify a protocol buffer\n    // field.\n    //\n    // Consider the following:\n    //\n    //     message CreateContactRequest {\n    //       message EmailAddress {\n    //         enum Type {\n    //           TYPE_UNSPECIFIED = 0;\n    //           HOME = 1;\n    //           WORK = 2;\n    //         }\n    //\n    //         optional string email = 1;\n    //         repeated EmailType type = 2;\n    //       }\n    //\n    //       string full_name = 1;\n    //       repeated EmailAddress email_addresses = 2;\n    //     }\n    //\n    // In this example, in proto `field` could take one of the following values:\n    //\n    // * `full_name` for a violation in the `full_name` value\n    // * `email_addresses[1].email` for a violation in the `email` field of the\n    //   first `email_addresses` message\n    // * `email_addresses[3].type[2]` for a violation in the second `type`\n    //   value in the third `email_addresses` message.\n    //\n    // In JSON, the same values are represented as:\n    //\n    // * `fullName` for a violation in the `fullName` value\n    // * `emailAddresses[1].email` for a violation in the `email` field of the\n    //   first `emailAddresses` message\n    // * `emailAddresses[3].type[2]` for a violation in the second `type`\n    //   value in the third `emailAddresses` message.\n    string field = 1;\n\n    // A description of why the request element is bad.\n    string description = 2;\n  }\n\n  // Describes all violations in a client request.\n  repeated FieldViolation field_violations = 1;\n}\n\n// Contains metadata about the request that clients can attach when filing a bug\n// or providing other forms of feedback.\nmessage RequestInfo {\n  // An opaque string that should only be interpreted by the service generating\n  // it. For example, it can be used to identify requests in the service's logs.\n  string request_id = 1;\n\n  // Any data that was used to serve this request. For example, an encrypted\n  // stack trace that can be sent back to the service provider for debugging.\n  string serving_data = 2;\n}\n\n// Describes the resource that is being accessed.\nmessage ResourceInfo {\n  // A name for the type of resource being accessed, e.g. \"sql table\",\n  // \"cloud storage bucket\", \"file\", \"Google calendar\"; or the type URL\n  // of the resource: e.g. \"type.googleapis.com/google.pubsub.v1.Topic\".\n  string resource_type = 1;\n\n  // The name of the resource being accessed.  For example, a shared calendar\n  // name: \"example.com_4fghdhgsrgh@group.calendar.google.com\", if the current\n  // error is\n  // [google.rpc.Code.PERMISSION_DENIED][google.rpc.Code.PERMISSION_DENIED].\n  string resource_name = 2;\n\n  // The owner of the resource (optional).\n  // For example, \"user:<owner email>\" or \"project:<Google developer project\n  // id>\".\n  string owner = 3;\n\n  // Describes what error is encountered when accessing this resource.\n  // For example, updating a cloud project may require the `writer` permission\n  // on the developer console project.\n  string description = 4;\n}\n\n// Provides links to documentation or for performing an out of band action.\n//\n// For example, if a quota check failed with an error indicating the calling\n// project hasn't enabled the accessed service, this can contain a URL pointing\n// directly to the right place in the developer console to flip the bit.\nmessage Help {\n  // Describes a URL link.\n  message Link {\n    // Describes what the link offers.\n    string description = 1;\n\n    // The URL of the link.\n    string url = 2;\n  }\n\n  // URL(s) pointing to additional information on handling the current error.\n  repeated Link links = 1;\n}\n\n// Provides a localized error message that is safe to return to the user\n// which can be attached to an RPC error.\nmessage LocalizedMessage {\n  // The locale used following the specification defined at\n  // https://www.rfc-editor.org/rfc/bcp/bcp47.txt.\n  // Examples are: \"en-US\", \"fr-CH\", \"es-MX\"\n  string locale = 1;\n\n  // The localized error message in the above locale.\n  string message = 2;\n}\n","size_bytes":10869},"build/resources/main/spike_signals.proto":{"content":"syntax = \"proto3\";\n\npackage spiketrade.proto;\n\noption java_package = \"com.spiketrade.proto\";\noption java_outer_classname = \"SpikeSignalsProto\";\n\n// Technical indicators\nmessage Indicators {\n  // Legacy indicators (keep for backward compatibility)\n  double rsi = 1;\n  double obv = 2;\n  double mfi = 3;\n  double vwap = 4;\n  double bollinger_upper = 5;\n  double bollinger_lower = 6;\n  double bollinger_position = 7;\n  double percent_b = 8;\n  double price_roc = 9;\n  double rsi_roc = 10;\n  double obv_roc = 11;\n  double mfi_roc = 12;\n  double bollinger_pos_roc = 13;\n  double percent_b_roc = 14;\n  double vwap_roc = 15;\n  double volume_roc = 16;\n  \n  // NEW INDICATORS for high volatility, low-priced stocks\n  // MACD (Moving Average Convergence Divergence)\n  double macd_line = 17;\n  double macd_signal = 18;\n  double macd_histogram = 19;\n  \n  // EMA (Exponential Moving Average) - multiple periods\n  double ema_9 = 20;\n  double ema_20 = 21;\n  double ema_50 = 22;\n  \n  // Stochastic Oscillator\n  double stoch_k = 23;  // %K line\n  double stoch_d = 24;  // %D line (signal)\n  \n  // Relative Volume\n  double rvol = 25;\n  \n  // Volume Spike Detection\n  bool volume_spike = 26;\n  double volume_ratio = 27;\n  \n  // ATR (Average True Range) - volatility indicator\n  double atr = 28;\n}\nmessage IndicatorStreamRequest {\n    repeated string symbols = 1;\n}\n\nmessage IndicatorUpdate {\n    string symbol = 1;\n    double rsi = 2;\n    double price_roc = 3;\n    double volume_roc = 4;\n    double obv = 5;\n    double mfi = 6;\n    double bollinger_position = 7;\n    double percent_b = 8;\n    double vwap = 9;\n    \n    // NEW INDICATORS\n    double macd_histogram = 10;\n    double ema_9 = 11;\n    double ema_20 = 12;\n    double ema_50 = 13;\n    double stoch_k = 14;\n    double stoch_d = 15;\n    double rvol = 16;\n    bool volume_spike = 17;\n    double atr = 18;\n}\n// Spike record\nmessage SpikeRecord {\n  int64 timestamp_ms = 1;\n  string symbol = 2;\n  string spike_type = 3;\n  double magnitude = 4;\n  int32 duration = 5;\n  double price_at_spike = 6;\n  int64 volume_at_spike = 7;\n  double rsi_at_spike = 8;\n  double bollinger_position = 9;\n  double market_volatility = 10;\n  int32 time_of_day = 11;\n  int32 day_of_week = 12;\n  \n  Indicators indicators = 13;\n  \n  bool outcome_profitable = 14;\n  double outcome_score = 15;\n  double statistical_z_score = 16;\n  string trend_context = 17;\n  double spike_quality_score = 18;\n  \n  bool is_root_spike = 19;\n  double root_spike_score = 20;\n  bool used_for_signal = 21;\n}\n\n// Buy signal message\nmessage BuySignal {\n  int64 timestamp_ms = 1;\n  string symbol = 2;\n  double price = 3;\n  double signal_probability = 4;\n  Indicators indicators = 5;\n  repeated SpikeRecord spikes = 6;\n  string reason = 7;\n  optional double predicted_gain_target = 8;\n  optional int32 predicted_time_to_target_minutes = 9;\n  optional double prediction_confidence = 10;\n  optional string prediction_reasoning = 11;\n}\n\n// Sell signal message\nmessage SellSignal {\n  int64 timestamp_ms = 1;\n  string symbol = 2;\n  double price = 3;\n  string reason = 4;\n  double profit_loss = 5;\n  double profit_loss_pct = 6;\n}\n\n// Sell warning message\nmessage SellWarning {\n  int64 timestamp_ms = 1;\n  string symbol = 2;\n  double price = 3;\n  double warning_probability = 4;\n  Indicators indicators = 5;\n  string reason = 6;\n}\n\n// Sell warning request\nmessage SellWarningRequest {\n  string symbol = 1;\n}\n\n// Signal stream request\nmessage SignalStreamRequest {\n  repeated string symbols = 1;\n  double min_probability = 2;\n}\n\n// Analysis status\nmessage AnalysisStatus {\n  string symbol = 1;\n  int32 data_points_collected = 2;\n  int32 warmup_required = 3;\n  bool ready_for_trading = 4;\n  int32 total_spikes_detected = 5;\n  int32 buy_signals_generated = 6;\n  Indicators latest_indicators = 7;\n  double latest_buy_probability = 8;\n}\n","size_bytes":3803},"build/extracted-include-protos/test/google/type/color.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\nimport \"google/protobuf/wrappers.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/color;color\";\noption java_multiple_files = true;\noption java_outer_classname = \"ColorProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a color in the RGBA color space. This representation is designed\n// for simplicity of conversion to/from color representations in various\n// languages over compactness. For example, the fields of this representation\n// can be trivially provided to the constructor of `java.awt.Color` in Java; it\n// can also be trivially provided to UIColor's `+colorWithRed:green:blue:alpha`\n// method in iOS; and, with just a little work, it can be easily formatted into\n// a CSS `rgba()` string in JavaScript.\n//\n// This reference page doesn't carry information about the absolute color\n// space\n// that should be used to interpret the RGB value (e.g. sRGB, Adobe RGB,\n// DCI-P3, BT.2020, etc.). By default, applications should assume the sRGB color\n// space.\n//\n// When color equality needs to be decided, implementations, unless\n// documented otherwise, treat two colors as equal if all their red,\n// green, blue, and alpha values each differ by at most 1e-5.\n//\n// Example (Java):\n//\n//      import com.google.type.Color;\n//\n//      // ...\n//      public static java.awt.Color fromProto(Color protocolor) {\n//        float alpha = protocolor.hasAlpha()\n//            ? protocolor.getAlpha().getValue()\n//            : 1.0;\n//\n//        return new java.awt.Color(\n//            protocolor.getRed(),\n//            protocolor.getGreen(),\n//            protocolor.getBlue(),\n//            alpha);\n//      }\n//\n//      public static Color toProto(java.awt.Color color) {\n//        float red = (float) color.getRed();\n//        float green = (float) color.getGreen();\n//        float blue = (float) color.getBlue();\n//        float denominator = 255.0;\n//        Color.Builder resultBuilder =\n//            Color\n//                .newBuilder()\n//                .setRed(red / denominator)\n//                .setGreen(green / denominator)\n//                .setBlue(blue / denominator);\n//        int alpha = color.getAlpha();\n//        if (alpha != 255) {\n//          result.setAlpha(\n//              FloatValue\n//                  .newBuilder()\n//                  .setValue(((float) alpha) / denominator)\n//                  .build());\n//        }\n//        return resultBuilder.build();\n//      }\n//      // ...\n//\n// Example (iOS / Obj-C):\n//\n//      // ...\n//      static UIColor* fromProto(Color* protocolor) {\n//         float red = [protocolor red];\n//         float green = [protocolor green];\n//         float blue = [protocolor blue];\n//         FloatValue* alpha_wrapper = [protocolor alpha];\n//         float alpha = 1.0;\n//         if (alpha_wrapper != nil) {\n//           alpha = [alpha_wrapper value];\n//         }\n//         return [UIColor colorWithRed:red green:green blue:blue alpha:alpha];\n//      }\n//\n//      static Color* toProto(UIColor* color) {\n//          CGFloat red, green, blue, alpha;\n//          if (![color getRed:&red green:&green blue:&blue alpha:&alpha]) {\n//            return nil;\n//          }\n//          Color* result = [[Color alloc] init];\n//          [result setRed:red];\n//          [result setGreen:green];\n//          [result setBlue:blue];\n//          if (alpha <= 0.9999) {\n//            [result setAlpha:floatWrapperWithValue(alpha)];\n//          }\n//          [result autorelease];\n//          return result;\n//     }\n//     // ...\n//\n//  Example (JavaScript):\n//\n//     // ...\n//\n//     var protoToCssColor = function(rgb_color) {\n//        var redFrac = rgb_color.red || 0.0;\n//        var greenFrac = rgb_color.green || 0.0;\n//        var blueFrac = rgb_color.blue || 0.0;\n//        var red = Math.floor(redFrac * 255);\n//        var green = Math.floor(greenFrac * 255);\n//        var blue = Math.floor(blueFrac * 255);\n//\n//        if (!('alpha' in rgb_color)) {\n//           return rgbToCssColor(red, green, blue);\n//        }\n//\n//        var alphaFrac = rgb_color.alpha.value || 0.0;\n//        var rgbParams = [red, green, blue].join(',');\n//        return ['rgba(', rgbParams, ',', alphaFrac, ')'].join('');\n//     };\n//\n//     var rgbToCssColor = function(red, green, blue) {\n//       var rgbNumber = new Number((red << 16) | (green << 8) | blue);\n//       var hexString = rgbNumber.toString(16);\n//       var missingZeros = 6 - hexString.length;\n//       var resultBuilder = ['#'];\n//       for (var i = 0; i < missingZeros; i++) {\n//          resultBuilder.push('0');\n//       }\n//       resultBuilder.push(hexString);\n//       return resultBuilder.join('');\n//     };\n//\n//     // ...\nmessage Color {\n  // The amount of red in the color as a value in the interval [0, 1].\n  float red = 1;\n\n  // The amount of green in the color as a value in the interval [0, 1].\n  float green = 2;\n\n  // The amount of blue in the color as a value in the interval [0, 1].\n  float blue = 3;\n\n  // The fraction of this color that should be applied to the pixel. That is,\n  // the final pixel color is defined by the equation:\n  //\n  //   `pixel color = alpha * (this color) + (1.0 - alpha) * (background color)`\n  //\n  // This means that a value of 1.0 corresponds to a solid color, whereas\n  // a value of 0.0 corresponds to a completely transparent color. This\n  // uses a wrapper message rather than a simple float scalar so that it is\n  // possible to distinguish between a default value and the value being unset.\n  // If omitted, this color object is rendered as a solid color\n  // (as if the alpha value had been explicitly given a value of 1.0).\n  google.protobuf.FloatValue alpha = 4;\n}\n","size_bytes":6376},"build/extracted-include-protos/main/google/type/fraction.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption go_package = \"google.golang.org/genproto/googleapis/type/fraction;fraction\";\noption java_multiple_files = true;\noption java_outer_classname = \"FractionProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a fraction in terms of a numerator divided by a denominator.\nmessage Fraction {\n  // The numerator in the fraction, e.g. 2 in 2/3.\n  int64 numerator = 1;\n\n  // The value by which the numerator is divided, e.g. 3 in 2/3. Must be\n  // positive.\n  int64 denominator = 2;\n}\n","size_bytes":1156},"src/main/java/com/spiketrade/backend/Candle.java":{"content":"package com.spiketrade.backend;\n\nimport java.time.Instant;\n\npublic class Candle {\n    public Instant timestamp;\n    public double open;\n    public double high;\n    public double low;\n    public double close;\n    public long volume;\n    \n    public Candle() {\n        this.timestamp = Instant.now();\n    }\n    \n    public Candle(Instant timestamp, double open, double high, double low, double close, long volume) {\n        this.timestamp = timestamp;\n        this.open = open;\n        this.high = high;\n        this.low = low;\n        this.close = close;\n        this.volume = volume;\n    }\n}\n","size_bytes":592},"build/extracted-include-protos/main/google/protobuf/wrappers.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Wrappers for primitive (non-message) types. These types are useful\n// for embedding primitives in the `google.protobuf.Any` type and for places\n// where we need to distinguish between the absence of a primitive\n// typed field and its default value.\n//\n// These wrappers have no meaningful use within repeated fields as they lack\n// the ability to detect presence on individual elements.\n// These wrappers have no meaningful use within a map or a oneof since\n// individual entries of a map or fields of a oneof can already detect presence.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/protobuf/types/known/wrapperspb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"WrappersProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\n\n// Wrapper message for `double`.\n//\n// The JSON representation for `DoubleValue` is JSON number.\nmessage DoubleValue {\n  // The double value.\n  double value = 1;\n}\n\n// Wrapper message for `float`.\n//\n// The JSON representation for `FloatValue` is JSON number.\nmessage FloatValue {\n  // The float value.\n  float value = 1;\n}\n\n// Wrapper message for `int64`.\n//\n// The JSON representation for `Int64Value` is JSON string.\nmessage Int64Value {\n  // The int64 value.\n  int64 value = 1;\n}\n\n// Wrapper message for `uint64`.\n//\n// The JSON representation for `UInt64Value` is JSON string.\nmessage UInt64Value {\n  // The uint64 value.\n  uint64 value = 1;\n}\n\n// Wrapper message for `int32`.\n//\n// The JSON representation for `Int32Value` is JSON number.\nmessage Int32Value {\n  // The int32 value.\n  int32 value = 1;\n}\n\n// Wrapper message for `uint32`.\n//\n// The JSON representation for `UInt32Value` is JSON number.\nmessage UInt32Value {\n  // The uint32 value.\n  uint32 value = 1;\n}\n\n// Wrapper message for `bool`.\n//\n// The JSON representation for `BoolValue` is JSON `true` and `false`.\nmessage BoolValue {\n  // The bool value.\n  bool value = 1;\n}\n\n// Wrapper message for `string`.\n//\n// The JSON representation for `StringValue` is JSON string.\nmessage StringValue {\n  // The string value.\n  string value = 1;\n}\n\n// Wrapper message for `bytes`.\n//\n// The JSON representation for `BytesValue` is JSON string.\nmessage BytesValue {\n  // The bytes value.\n  bytes value = 1;\n}\n","size_bytes":4044},"build/extracted-include-protos/test/google/protobuf/source_context.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"SourceContextProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\noption go_package = \"google.golang.org/protobuf/types/known/sourcecontextpb\";\n\n// `SourceContext` represents information about the source of a\n// protobuf element, like the file in which it is defined.\nmessage SourceContext {\n  // The path-qualified name of the .proto file that contained the associated\n  // protobuf element.  For example: `\"google/protobuf/source_context.proto\"`.\n  string file_name = 1;\n}\n","size_bytes":2341},"build/extracted-include-protos/main/google/api/metric.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/api/label.proto\";\nimport \"google/api/launch_stage.proto\";\nimport \"google/protobuf/duration.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/metric;metric\";\noption java_multiple_files = true;\noption java_outer_classname = \"MetricProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Defines a metric type and its schema. Once a metric descriptor is created,\n// deleting or altering it stops data collection and makes the metric type's\n// existing data unusable.\n//\nmessage MetricDescriptor {\n  // The kind of measurement. It describes how the data is reported.\n  // For information on setting the start time and end time based on\n  // the MetricKind, see [TimeInterval][google.monitoring.v3.TimeInterval].\n  enum MetricKind {\n    // Do not use this default value.\n    METRIC_KIND_UNSPECIFIED = 0;\n\n    // An instantaneous measurement of a value.\n    GAUGE = 1;\n\n    // The change in a value during a time interval.\n    DELTA = 2;\n\n    // A value accumulated over a time interval.  Cumulative\n    // measurements in a time series should have the same start time\n    // and increasing end times, until an event resets the cumulative\n    // value to zero and sets a new start time for the following\n    // points.\n    CUMULATIVE = 3;\n  }\n\n  // The value type of a metric.\n  enum ValueType {\n    // Do not use this default value.\n    VALUE_TYPE_UNSPECIFIED = 0;\n\n    // The value is a boolean.\n    // This value type can be used only if the metric kind is `GAUGE`.\n    BOOL = 1;\n\n    // The value is a signed 64-bit integer.\n    INT64 = 2;\n\n    // The value is a double precision floating point number.\n    DOUBLE = 3;\n\n    // The value is a text string.\n    // This value type can be used only if the metric kind is `GAUGE`.\n    STRING = 4;\n\n    // The value is a [`Distribution`][google.api.Distribution].\n    DISTRIBUTION = 5;\n\n    // The value is money.\n    MONEY = 6;\n  }\n\n  // Additional annotations that can be used to guide the usage of a metric.\n  message MetricDescriptorMetadata {\n    // Deprecated. Must use the\n    // [MetricDescriptor.launch_stage][google.api.MetricDescriptor.launch_stage]\n    // instead.\n    LaunchStage launch_stage = 1 [deprecated = true];\n\n    // The sampling period of metric data points. For metrics which are written\n    // periodically, consecutive data points are stored at this time interval,\n    // excluding data loss due to errors. Metrics with a higher granularity have\n    // a smaller sampling period.\n    google.protobuf.Duration sample_period = 2;\n\n    // The delay of data points caused by ingestion. Data points older than this\n    // age are guaranteed to be ingested and available to be read, excluding\n    // data loss due to errors.\n    google.protobuf.Duration ingest_delay = 3;\n  }\n\n  // The resource name of the metric descriptor.\n  string name = 1;\n\n  // The metric type, including its DNS name prefix. The type is not\n  // URL-encoded. All user-defined metric types have the DNS name\n  // `custom.googleapis.com` or `external.googleapis.com`. Metric types should\n  // use a natural hierarchical grouping. For example:\n  //\n  //     \"custom.googleapis.com/invoice/paid/amount\"\n  //     \"external.googleapis.com/prometheus/up\"\n  //     \"appengine.googleapis.com/http/server/response_latencies\"\n  string type = 8;\n\n  // The set of labels that can be used to describe a specific\n  // instance of this metric type. For example, the\n  // `appengine.googleapis.com/http/server/response_latencies` metric\n  // type has a label for the HTTP response code, `response_code`, so\n  // you can look at latencies for successful responses or just\n  // for responses that failed.\n  repeated LabelDescriptor labels = 2;\n\n  // Whether the metric records instantaneous values, changes to a value, etc.\n  // Some combinations of `metric_kind` and `value_type` might not be supported.\n  MetricKind metric_kind = 3;\n\n  // Whether the measurement is an integer, a floating-point number, etc.\n  // Some combinations of `metric_kind` and `value_type` might not be supported.\n  ValueType value_type = 4;\n\n  // The units in which the metric value is reported. It is only applicable\n  // if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit`\n  // defines the representation of the stored metric values.\n  //\n  // Different systems might scale the values to be more easily displayed (so a\n  // value of `0.02kBy` _might_ be displayed as `20By`, and a value of\n  // `3523kBy` _might_ be displayed as `3.5MBy`). However, if the `unit` is\n  // `kBy`, then the value of the metric is always in thousands of bytes, no\n  // matter how it might be displayed.\n  //\n  // If you want a custom metric to record the exact number of CPU-seconds used\n  // by a job, you can create an `INT64 CUMULATIVE` metric whose `unit` is\n  // `s{CPU}` (or equivalently `1s{CPU}` or just `s`). If the job uses 12,005\n  // CPU-seconds, then the value is written as `12005`.\n  //\n  // Alternatively, if you want a custom metric to record data in a more\n  // granular way, you can create a `DOUBLE CUMULATIVE` metric whose `unit` is\n  // `ks{CPU}`, and then write the value `12.005` (which is `12005/1000`),\n  // or use `Kis{CPU}` and write `11.723` (which is `12005/1024`).\n  //\n  // The supported units are a subset of [The Unified Code for Units of\n  // Measure](https://unitsofmeasure.org/ucum.html) standard:\n  //\n  // **Basic units (UNIT)**\n  //\n  // * `bit`   bit\n  // * `By`    byte\n  // * `s`     second\n  // * `min`   minute\n  // * `h`     hour\n  // * `d`     day\n  // * `1`     dimensionless\n  //\n  // **Prefixes (PREFIX)**\n  //\n  // * `k`     kilo    (10^3)\n  // * `M`     mega    (10^6)\n  // * `G`     giga    (10^9)\n  // * `T`     tera    (10^12)\n  // * `P`     peta    (10^15)\n  // * `E`     exa     (10^18)\n  // * `Z`     zetta   (10^21)\n  // * `Y`     yotta   (10^24)\n  //\n  // * `m`     milli   (10^-3)\n  // * `u`     micro   (10^-6)\n  // * `n`     nano    (10^-9)\n  // * `p`     pico    (10^-12)\n  // * `f`     femto   (10^-15)\n  // * `a`     atto    (10^-18)\n  // * `z`     zepto   (10^-21)\n  // * `y`     yocto   (10^-24)\n  //\n  // * `Ki`    kibi    (2^10)\n  // * `Mi`    mebi    (2^20)\n  // * `Gi`    gibi    (2^30)\n  // * `Ti`    tebi    (2^40)\n  // * `Pi`    pebi    (2^50)\n  //\n  // **Grammar**\n  //\n  // The grammar also includes these connectors:\n  //\n  // * `/`    division or ratio (as an infix operator). For examples,\n  //          `kBy/{email}` or `MiBy/10ms` (although you should almost never\n  //          have `/s` in a metric `unit`; rates should always be computed at\n  //          query time from the underlying cumulative or delta value).\n  // * `.`    multiplication or composition (as an infix operator). For\n  //          examples, `GBy.d` or `k{watt}.h`.\n  //\n  // The grammar for a unit is as follows:\n  //\n  //     Expression = Component { \".\" Component } { \"/\" Component } ;\n  //\n  //     Component = ( [ PREFIX ] UNIT | \"%\" ) [ Annotation ]\n  //               | Annotation\n  //               | \"1\"\n  //               ;\n  //\n  //     Annotation = \"{\" NAME \"}\" ;\n  //\n  // Notes:\n  //\n  // * `Annotation` is just a comment if it follows a `UNIT`. If the annotation\n  //    is used alone, then the unit is equivalent to `1`. For examples,\n  //    `{request}/s == 1/s`, `By{transmitted}/s == By/s`.\n  // * `NAME` is a sequence of non-blank printable ASCII characters not\n  //    containing `{` or `}`.\n  // * `1` represents a unitary [dimensionless\n  //    unit](https://en.wikipedia.org/wiki/Dimensionless_quantity) of 1, such\n  //    as in `1/s`. It is typically used when none of the basic units are\n  //    appropriate. For example, \"new users per day\" can be represented as\n  //    `1/d` or `{new-users}/d` (and a metric value `5` would mean \"5 new\n  //    users). Alternatively, \"thousands of page views per day\" would be\n  //    represented as `1000/d` or `k1/d` or `k{page_views}/d` (and a metric\n  //    value of `5.3` would mean \"5300 page views per day\").\n  // * `%` represents dimensionless value of 1/100, and annotates values giving\n  //    a percentage (so the metric values are typically in the range of 0..100,\n  //    and a metric value `3` means \"3 percent\").\n  // * `10^2.%` indicates a metric contains a ratio, typically in the range\n  //    0..1, that will be multiplied by 100 and displayed as a percentage\n  //    (so a metric value `0.03` means \"3 percent\").\n  string unit = 5;\n\n  // A detailed description of the metric, which can be used in documentation.\n  string description = 6;\n\n  // A concise name for the metric, which can be displayed in user interfaces.\n  // Use sentence case without an ending period, for example \"Request count\".\n  // This field is optional but it is recommended to be set for any metrics\n  // associated with user-visible concepts, such as Quota.\n  string display_name = 7;\n\n  // Optional. Metadata which can be used to guide usage of the metric.\n  MetricDescriptorMetadata metadata = 10;\n\n  // Optional. The launch stage of the metric definition.\n  LaunchStage launch_stage = 12;\n\n  // Read-only. If present, then a [time\n  // series][google.monitoring.v3.TimeSeries], which is identified partially by\n  // a metric type and a\n  // [MonitoredResourceDescriptor][google.api.MonitoredResourceDescriptor], that\n  // is associated with this metric type can only be associated with one of the\n  // monitored resource types listed here.\n  repeated string monitored_resource_types = 13;\n}\n\n// A specific metric, identified by specifying values for all of the\n// labels of a [`MetricDescriptor`][google.api.MetricDescriptor].\nmessage Metric {\n  // An existing metric type, see\n  // [google.api.MetricDescriptor][google.api.MetricDescriptor]. For example,\n  // `custom.googleapis.com/invoice/paid/amount`.\n  string type = 3;\n\n  // The set of label values that uniquely identify this metric. All\n  // labels listed in the `MetricDescriptor` must be assigned values.\n  map<string, string> labels = 2;\n}\n","size_bytes":10605},"src/main/java/com/spiketrade/util/CacheManager.java":{"content":"package com.spiketrade.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\npublic class CacheManager {\n    private static final Logger logger = LoggerFactory.getLogger(CacheManager.class);\n    \n    private final Map<String, CacheEntry<?>> cache = new ConcurrentHashMap<>();\n    private final long defaultTtlMs;\n    \n    public CacheManager(long defaultTtlSeconds) {\n        this.defaultTtlMs = TimeUnit.SECONDS.toMillis(defaultTtlSeconds);\n    }\n    \n    public <T> void put(String key, T value) {\n        put(key, value, defaultTtlMs);\n    }\n    \n    public <T> void put(String key, T value, long ttlMs) {\n        long expiryTime = System.currentTimeMillis() + ttlMs;\n        cache.put(key, new CacheEntry<>(value, expiryTime));\n        logger.debug(\"Cached value for key: {} with TTL: {}ms\", key, ttlMs);\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T get(String key) {\n        CacheEntry<?> entry = cache.get(key);\n        \n        if (entry == null) {\n            return null;\n        }\n        \n        if (entry.isExpired()) {\n            cache.remove(key);\n            logger.debug(\"Cache entry expired and removed: {}\", key);\n            return null;\n        }\n        \n        return (T) entry.getValue();\n    }\n    \n    public boolean containsKey(String key) {\n        CacheEntry<?> entry = cache.get(key);\n        if (entry == null) {\n            return false;\n        }\n        if (entry.isExpired()) {\n            cache.remove(key);\n            return false;\n        }\n        return true;\n    }\n    \n    public void invalidate(String key) {\n        cache.remove(key);\n        logger.debug(\"Invalidated cache key: {}\", key);\n    }\n    \n    public void invalidateAll() {\n        cache.clear();\n        logger.info(\"Cleared all cache entries\");\n    }\n    \n    public void cleanupExpired() {\n        int removed = 0;\n        for (Map.Entry<String, CacheEntry<?>> entry : cache.entrySet()) {\n            if (entry.getValue().isExpired()) {\n                cache.remove(entry.getKey());\n                removed++;\n            }\n        }\n        if (removed > 0) {\n            logger.debug(\"Cleaned up {} expired cache entries\", removed);\n        }\n    }\n    \n    public int size() {\n        cleanupExpired();\n        return cache.size();\n    }\n    \n    private static class CacheEntry<T> {\n        private final T value;\n        private final long expiryTime;\n        \n        public CacheEntry(T value, long expiryTime) {\n            this.value = value;\n            this.expiryTime = expiryTime;\n        }\n        \n        public T getValue() {\n            return value;\n        }\n        \n        public boolean isExpired() {\n            return System.currentTimeMillis() > expiryTime;\n        }\n    }\n}\n","size_bytes":2852},"build/extracted-include-protos/main/google/logging/type/log_severity.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.logging.type;\n\noption csharp_namespace = \"Google.Cloud.Logging.Type\";\noption go_package = \"google.golang.org/genproto/googleapis/logging/type;ltype\";\noption java_multiple_files = true;\noption java_outer_classname = \"LogSeverityProto\";\noption java_package = \"com.google.logging.type\";\noption objc_class_prefix = \"GLOG\";\noption php_namespace = \"Google\\\\Cloud\\\\Logging\\\\Type\";\noption ruby_package = \"Google::Cloud::Logging::Type\";\n\n// The severity of the event described in a log entry, expressed as one of the\n// standard severity levels listed below.  For your reference, the levels are\n// assigned the listed numeric values. The effect of using numeric values other\n// than those listed is undefined.\n//\n// You can filter for log entries by severity.  For example, the following\n// filter expression will match log entries with severities `INFO`, `NOTICE`,\n// and `WARNING`:\n//\n//     severity > DEBUG AND severity <= WARNING\n//\n// If you are writing log entries, you should map other severity encodings to\n// one of these standard levels. For example, you might map all of Java's FINE,\n// FINER, and FINEST levels to `LogSeverity.DEBUG`. You can preserve the\n// original severity level in the log entry payload if you wish.\nenum LogSeverity {\n  // (0) The log entry has no assigned severity level.\n  DEFAULT = 0;\n\n  // (100) Debug or trace information.\n  DEBUG = 100;\n\n  // (200) Routine information, such as ongoing status or performance.\n  INFO = 200;\n\n  // (300) Normal but significant events, such as start up, shut down, or\n  // a configuration change.\n  NOTICE = 300;\n\n  // (400) Warning events might cause problems.\n  WARNING = 400;\n\n  // (500) Error events are likely to cause problems.\n  ERROR = 500;\n\n  // (600) Critical events cause more severe problems or outages.\n  CRITICAL = 600;\n\n  // (700) A person must take an action immediately.\n  ALERT = 700;\n\n  // (800) One or more systems are unusable.\n  EMERGENCY = 800;\n}\n","size_bytes":2555},"src/main/java/com/spiketrade/backend/CandleAggregator.java":{"content":"package com.spiketrade.backend;\n\nimport java.time.Instant;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * CandleAggregator - Aggregates 1-minute candles into N-minute candles based on timeframe mode\n * \n * This is the fix for the timeframe analysis bug where the app was always analyzing 1-minute candles\n * regardless of the selected timeframe (1 min, 10 min, 30 min, etc.)\n * \n * Key Concept:\n * - When timeframe is \"10 minutes\", it batches ten 1-minute candles into one 10-minute candle\n * - When timeframe is \"30 minutes\", it batches thirty 1-minute candles into one 30-minute candle\n * - This allows the analysis to truly work at different timescales, not just with longer periods\n * \n * Important: Uses timestamp-based bucketing to align to real timeframe boundaries\n * (e.g., 10-minute candles always start at :00, :10, :20, :30, :40, :50)\n */\npublic class CandleAggregator {\n    // Symbol -> Bucket timestamp -> list of candles in that bucket\n    private final Map<String, Map<Long, List<Candle>>> candleBuckets;\n    private final Map<String, Integer> timeframeMultipliers;  // Symbol -> timeframe multiplier (1, 10, 30, 60, 180)\n    private final Object lock = new Object();\n    \n    public CandleAggregator() {\n        this.candleBuckets = new ConcurrentHashMap<>();\n        this.timeframeMultipliers = new ConcurrentHashMap<>();\n    }\n    \n    /**\n     * Set the timeframe multiplier for a symbol\n     * @param symbol Stock symbol\n     * @param multiplier Timeframe multiplier (1=1min, 10=10min, 30=30min, 60=1hour, 180=3hours)\n     */\n    public void setTimeframeMultiplier(String symbol, int multiplier) {\n        synchronized (lock) {\n            timeframeMultipliers.put(symbol, multiplier);\n            System.out.println(\"CandleAggregator: Set timeframe multiplier for \" + symbol + \" to \" + multiplier + \"x\");\n        }\n    }\n    \n    /**\n     * Add a 1-minute candle and get back an aggregated candle if the timeframe bucket is complete\n     * \n     * Uses timestamp-based bucketing to ensure candles align to real timeframe boundaries.\n     * For example, with 10-minute timeframe, buckets start at :00, :10, :20, :30, :40, :50\n     * \n     * @param symbol Stock symbol\n     * @param oneMinCandle The 1-minute candle to add\n     * @return Aggregated candle if the bucket is complete, null otherwise\n     */\n    public Candle addCandleAndGetAggregated(String symbol, Candle oneMinCandle) {\n        synchronized (lock) {\n            // Get the timeframe multiplier for this symbol (default to 1 if not set)\n            int multiplier = timeframeMultipliers.getOrDefault(symbol, 1);\n            \n            // If multiplier is 1, just return the candle as-is (no aggregation needed)\n            if (multiplier == 1) {\n                return oneMinCandle;\n            }\n            \n            // Calculate the bucket this candle belongs to\n            // Floor the timestamp to the nearest N-minute boundary\n            long bucketTimestamp = getBucketTimestamp(oneMinCandle.timestamp, multiplier);\n            \n            // Get or create the bucket map for this symbol\n            candleBuckets.putIfAbsent(symbol, new ConcurrentHashMap<>());\n            Map<Long, List<Candle>> symbolBuckets = candleBuckets.get(symbol);\n            \n            // Get or create the list of candles for this bucket\n            symbolBuckets.putIfAbsent(bucketTimestamp, new ArrayList<>());\n            List<Candle> bucketCandles = symbolBuckets.get(bucketTimestamp);\n            \n            // Add the candle to the bucket\n            bucketCandles.add(oneMinCandle);\n            \n            // Check if bucket is complete (has N candles where N = multiplier)\n            if (bucketCandles.size() >= multiplier) {\n                // Aggregate the candles in this bucket\n                Candle aggregated = aggregateCandles(bucketCandles, bucketTimestamp);\n                \n                // Remove the completed bucket\n                symbolBuckets.remove(bucketTimestamp);\n                \n                System.out.println(\"CandleAggregator: Completed \" + multiplier + \"-minute bucket for \" + symbol + \n                                 \" starting at \" + Instant.ofEpochMilli(bucketTimestamp) + \n                                 \" (\" + bucketCandles.size() + \" candles)\");\n                \n                return aggregated;\n            }\n            \n            // Bucket not complete yet, return null\n            return null;\n        }\n    }\n    \n    /**\n     * Calculate the bucket timestamp by flooring to the nearest N-minute boundary\n     * \n     * For example, with 10-minute multiplier:\n     * - 09:31 -> 09:30\n     * - 09:39 -> 09:30\n     * - 09:40 -> 09:40\n     */\n    private long getBucketTimestamp(Instant timestamp, int multiplierMinutes) {\n        long epochMillis = timestamp.toEpochMilli();\n        long minutesMillis = 60 * 1000L;\n        long bucketSizeMillis = multiplierMinutes * minutesMillis;\n        \n        // Floor to nearest bucket boundary\n        return (epochMillis / bucketSizeMillis) * bucketSizeMillis;\n    }\n    \n    /**\n     * Aggregate multiple 1-minute candles into a single N-minute candle\n     * \n     * Rules for aggregation:\n     * - Open: First candle's open price (chronologically)\n     * - High: Highest high across all candles\n     * - Low: Lowest low across all candles\n     * - Close: Last candle's close price (chronologically)\n     * - Volume: Sum of all volumes\n     * - Timestamp: Bucket timestamp (aligned to timeframe boundary)\n     */\n    private Candle aggregateCandles(List<Candle> candles, long bucketTimestamp) {\n        if (candles.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot aggregate empty list of candles\");\n        }\n        \n        // Sort candles by timestamp to ensure correct chronological order\n        candles.sort(Comparator.comparing(c -> c.timestamp));\n        \n        Candle first = candles.get(0);\n        Candle last = candles.get(candles.size() - 1);\n        \n        // Create aggregated candle\n        Candle aggregated = new Candle();\n        aggregated.timestamp = Instant.ofEpochMilli(bucketTimestamp);  // Use bucket timestamp (aligned)\n        aggregated.open = first.open;           // Open of first candle\n        aggregated.close = last.close;          // Close of last candle\n        \n        // Find highest high and lowest low across all candles\n        double highestHigh = Double.NEGATIVE_INFINITY;\n        double lowestLow = Double.POSITIVE_INFINITY;\n        long totalVolume = 0;\n        \n        for (Candle c : candles) {\n            if (c.high > highestHigh) highestHigh = c.high;\n            if (c.low < lowestLow) lowestLow = c.low;\n            totalVolume += c.volume;\n        }\n        \n        aggregated.high = highestHigh;\n        aggregated.low = lowestLow;\n        aggregated.volume = totalVolume;\n        \n        return aggregated;\n    }\n    \n    /**\n     * Clear all buckets for a symbol (useful when changing timeframes)\n     */\n    public void clearPendingCandles(String symbol) {\n        synchronized (lock) {\n            candleBuckets.remove(symbol);\n            System.out.println(\"CandleAggregator: Cleared all buckets for \" + symbol);\n        }\n    }\n    \n    /**\n     * Get the total number of pending (not yet aggregated) candles across all buckets for a symbol\n     */\n    public int getPendingCount(String symbol) {\n        synchronized (lock) {\n            Map<Long, List<Candle>> symbolBuckets = candleBuckets.get(symbol);\n            if (symbolBuckets == null) return 0;\n            \n            int total = 0;\n            for (List<Candle> bucket : symbolBuckets.values()) {\n                total += bucket.size();\n            }\n            return total;\n        }\n    }\n}\n","size_bytes":7820},"build/extracted-include-protos/test/google/rpc/status.proto":{"content":"// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.rpc;\n\nimport \"google/protobuf/any.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/rpc/status;status\";\noption java_multiple_files = true;\noption java_outer_classname = \"StatusProto\";\noption java_package = \"com.google.rpc\";\noption objc_class_prefix = \"RPC\";\n\n// The `Status` type defines a logical error model that is suitable for\n// different programming environments, including REST APIs and RPC APIs. It is\n// used by [gRPC](https://github.com/grpc). Each `Status` message contains\n// three pieces of data: error code, error message, and error details.\n//\n// You can find out more about this error model and how to work with it in the\n// [API Design Guide](https://cloud.google.com/apis/design/errors).\nmessage Status {\n  // The status code, which should be an enum value of\n  // [google.rpc.Code][google.rpc.Code].\n  int32 code = 1;\n\n  // A developer-facing error message, which should be in English. Any\n  // user-facing error message should be localized and sent in the\n  // [google.rpc.Status.details][google.rpc.Status.details] field, or localized\n  // by the client.\n  string message = 2;\n\n  // A list of messages that carry the error details.  There is a common set of\n  // message types for APIs to use.\n  repeated google.protobuf.Any details = 3;\n}\n","size_bytes":1934},"build/extracted-include-protos/main/google/rpc/code.proto":{"content":"// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.rpc;\n\noption go_package = \"google.golang.org/genproto/googleapis/rpc/code;code\";\noption java_multiple_files = true;\noption java_outer_classname = \"CodeProto\";\noption java_package = \"com.google.rpc\";\noption objc_class_prefix = \"RPC\";\n\n// The canonical error codes for gRPC APIs.\n//\n//\n// Sometimes multiple error codes may apply.  Services should return\n// the most specific error code that applies.  For example, prefer\n// `OUT_OF_RANGE` over `FAILED_PRECONDITION` if both codes apply.\n// Similarly prefer `NOT_FOUND` or `ALREADY_EXISTS` over `FAILED_PRECONDITION`.\nenum Code {\n  // Not an error; returned on success.\n  //\n  // HTTP Mapping: 200 OK\n  OK = 0;\n\n  // The operation was cancelled, typically by the caller.\n  //\n  // HTTP Mapping: 499 Client Closed Request\n  CANCELLED = 1;\n\n  // Unknown error.  For example, this error may be returned when\n  // a `Status` value received from another address space belongs to\n  // an error space that is not known in this address space.  Also\n  // errors raised by APIs that do not return enough error information\n  // may be converted to this error.\n  //\n  // HTTP Mapping: 500 Internal Server Error\n  UNKNOWN = 2;\n\n  // The client specified an invalid argument.  Note that this differs\n  // from `FAILED_PRECONDITION`.  `INVALID_ARGUMENT` indicates arguments\n  // that are problematic regardless of the state of the system\n  // (e.g., a malformed file name).\n  //\n  // HTTP Mapping: 400 Bad Request\n  INVALID_ARGUMENT = 3;\n\n  // The deadline expired before the operation could complete. For operations\n  // that change the state of the system, this error may be returned\n  // even if the operation has completed successfully.  For example, a\n  // successful response from a server could have been delayed long\n  // enough for the deadline to expire.\n  //\n  // HTTP Mapping: 504 Gateway Timeout\n  DEADLINE_EXCEEDED = 4;\n\n  // Some requested entity (e.g., file or directory) was not found.\n  //\n  // Note to server developers: if a request is denied for an entire class\n  // of users, such as gradual feature rollout or undocumented allowlist,\n  // `NOT_FOUND` may be used. If a request is denied for some users within\n  // a class of users, such as user-based access control, `PERMISSION_DENIED`\n  // must be used.\n  //\n  // HTTP Mapping: 404 Not Found\n  NOT_FOUND = 5;\n\n  // The entity that a client attempted to create (e.g., file or directory)\n  // already exists.\n  //\n  // HTTP Mapping: 409 Conflict\n  ALREADY_EXISTS = 6;\n\n  // The caller does not have permission to execute the specified\n  // operation. `PERMISSION_DENIED` must not be used for rejections\n  // caused by exhausting some resource (use `RESOURCE_EXHAUSTED`\n  // instead for those errors). `PERMISSION_DENIED` must not be\n  // used if the caller can not be identified (use `UNAUTHENTICATED`\n  // instead for those errors). This error code does not imply the\n  // request is valid or the requested entity exists or satisfies\n  // other pre-conditions.\n  //\n  // HTTP Mapping: 403 Forbidden\n  PERMISSION_DENIED = 7;\n\n  // The request does not have valid authentication credentials for the\n  // operation.\n  //\n  // HTTP Mapping: 401 Unauthorized\n  UNAUTHENTICATED = 16;\n\n  // Some resource has been exhausted, perhaps a per-user quota, or\n  // perhaps the entire file system is out of space.\n  //\n  // HTTP Mapping: 429 Too Many Requests\n  RESOURCE_EXHAUSTED = 8;\n\n  // The operation was rejected because the system is not in a state\n  // required for the operation's execution.  For example, the directory\n  // to be deleted is non-empty, an rmdir operation is applied to\n  // a non-directory, etc.\n  //\n  // Service implementors can use the following guidelines to decide\n  // between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`:\n  //  (a) Use `UNAVAILABLE` if the client can retry just the failing call.\n  //  (b) Use `ABORTED` if the client should retry at a higher level. For\n  //      example, when a client-specified test-and-set fails, indicating the\n  //      client should restart a read-modify-write sequence.\n  //  (c) Use `FAILED_PRECONDITION` if the client should not retry until\n  //      the system state has been explicitly fixed. For example, if an \"rmdir\"\n  //      fails because the directory is non-empty, `FAILED_PRECONDITION`\n  //      should be returned since the client should not retry unless\n  //      the files are deleted from the directory.\n  //\n  // HTTP Mapping: 400 Bad Request\n  FAILED_PRECONDITION = 9;\n\n  // The operation was aborted, typically due to a concurrency issue such as\n  // a sequencer check failure or transaction abort.\n  //\n  // See the guidelines above for deciding between `FAILED_PRECONDITION`,\n  // `ABORTED`, and `UNAVAILABLE`.\n  //\n  // HTTP Mapping: 409 Conflict\n  ABORTED = 10;\n\n  // The operation was attempted past the valid range.  E.g., seeking or\n  // reading past end-of-file.\n  //\n  // Unlike `INVALID_ARGUMENT`, this error indicates a problem that may\n  // be fixed if the system state changes. For example, a 32-bit file\n  // system will generate `INVALID_ARGUMENT` if asked to read at an\n  // offset that is not in the range [0,2^32-1], but it will generate\n  // `OUT_OF_RANGE` if asked to read from an offset past the current\n  // file size.\n  //\n  // There is a fair bit of overlap between `FAILED_PRECONDITION` and\n  // `OUT_OF_RANGE`.  We recommend using `OUT_OF_RANGE` (the more specific\n  // error) when it applies so that callers who are iterating through\n  // a space can easily look for an `OUT_OF_RANGE` error to detect when\n  // they are done.\n  //\n  // HTTP Mapping: 400 Bad Request\n  OUT_OF_RANGE = 11;\n\n  // The operation is not implemented or is not supported/enabled in this\n  // service.\n  //\n  // HTTP Mapping: 501 Not Implemented\n  UNIMPLEMENTED = 12;\n\n  // Internal errors.  This means that some invariants expected by the\n  // underlying system have been broken.  This error code is reserved\n  // for serious errors.\n  //\n  // HTTP Mapping: 500 Internal Server Error\n  INTERNAL = 13;\n\n  // The service is currently unavailable.  This is most likely a\n  // transient condition, which can be corrected by retrying with\n  // a backoff. Note that it is not always safe to retry\n  // non-idempotent operations.\n  //\n  // See the guidelines above for deciding between `FAILED_PRECONDITION`,\n  // `ABORTED`, and `UNAVAILABLE`.\n  //\n  // HTTP Mapping: 503 Service Unavailable\n  UNAVAILABLE = 14;\n\n  // Unrecoverable data loss or corruption.\n  //\n  // HTTP Mapping: 500 Internal Server Error\n  DATA_LOSS = 15;\n}\n","size_bytes":7138},"build/extracted-include-protos/test/google/protobuf/descriptor.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Author: kenton@google.com (Kenton Varda)\n//  Based on original Protocol Buffers design by\n//  Sanjay Ghemawat, Jeff Dean, and others.\n//\n// The messages in this file describe the definitions found in .proto files.\n// A valid .proto file can be translated directly to a FileDescriptorProto\n// without any other information (e.g. without reading its imports).\n\nsyntax = \"proto2\";\n\npackage google.protobuf;\n\noption go_package = \"google.golang.org/protobuf/types/descriptorpb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"DescriptorProtos\";\noption csharp_namespace = \"Google.Protobuf.Reflection\";\noption objc_class_prefix = \"GPB\";\noption cc_enable_arenas = true;\n\n// descriptor.proto must be optimized for speed because reflection-based\n// algorithms don't work during bootstrapping.\noption optimize_for = SPEED;\n\n// The protocol compiler can output a FileDescriptorSet containing the .proto\n// files it parses.\nmessage FileDescriptorSet {\n  repeated FileDescriptorProto file = 1;\n}\n\n// The full set of known editions.\nenum Edition {\n  // A placeholder for an unknown edition value.\n  EDITION_UNKNOWN = 0;\n\n  // Legacy syntax \"editions\".  These pre-date editions, but behave much like\n  // distinct editions.  These can't be used to specify the edition of proto\n  // files, but feature definitions must supply proto2/proto3 defaults for\n  // backwards compatibility.\n  EDITION_PROTO2 = 998;\n  EDITION_PROTO3 = 999;\n\n  // Editions that have been released.  The specific values are arbitrary and\n  // should not be depended on, but they will always be time-ordered for easy\n  // comparison.\n  EDITION_2023 = 1000;\n\n  // Placeholder editions for testing feature resolution.  These should not be\n  // used or relyed on outside of tests.\n  EDITION_1_TEST_ONLY = 1;\n  EDITION_2_TEST_ONLY = 2;\n  EDITION_99997_TEST_ONLY = 99997;\n  EDITION_99998_TEST_ONLY = 99998;\n  EDITION_99999_TEST_ONLY = 99999;\n}\n\n// Describes a complete .proto file.\nmessage FileDescriptorProto {\n  optional string name = 1;     // file name, relative to root of source tree\n  optional string package = 2;  // e.g. \"foo\", \"foo.bar\", etc.\n\n  // Names of files imported by this file.\n  repeated string dependency = 3;\n  // Indexes of the public imported files in the dependency list above.\n  repeated int32 public_dependency = 10;\n  // Indexes of the weak imported files in the dependency list.\n  // For Google-internal migration only. Do not use.\n  repeated int32 weak_dependency = 11;\n\n  // All top-level definitions in this file.\n  repeated DescriptorProto message_type = 4;\n  repeated EnumDescriptorProto enum_type = 5;\n  repeated ServiceDescriptorProto service = 6;\n  repeated FieldDescriptorProto extension = 7;\n\n  optional FileOptions options = 8;\n\n  // This field contains optional information about the original source code.\n  // You may safely remove this entire field without harming runtime\n  // functionality of the descriptors -- the information is needed only by\n  // development tools.\n  optional SourceCodeInfo source_code_info = 9;\n\n  // The syntax of the proto file.\n  // The supported values are \"proto2\", \"proto3\", and \"editions\".\n  //\n  // If `edition` is present, this value must be \"editions\".\n  optional string syntax = 12;\n\n  // The edition of the proto file.\n  optional Edition edition = 14;\n}\n\n// Describes a message type.\nmessage DescriptorProto {\n  optional string name = 1;\n\n  repeated FieldDescriptorProto field = 2;\n  repeated FieldDescriptorProto extension = 6;\n\n  repeated DescriptorProto nested_type = 3;\n  repeated EnumDescriptorProto enum_type = 4;\n\n  message ExtensionRange {\n    optional int32 start = 1;  // Inclusive.\n    optional int32 end = 2;    // Exclusive.\n\n    optional ExtensionRangeOptions options = 3;\n  }\n  repeated ExtensionRange extension_range = 5;\n\n  repeated OneofDescriptorProto oneof_decl = 8;\n\n  optional MessageOptions options = 7;\n\n  // Range of reserved tag numbers. Reserved tag numbers may not be used by\n  // fields or extension ranges in the same message. Reserved ranges may\n  // not overlap.\n  message ReservedRange {\n    optional int32 start = 1;  // Inclusive.\n    optional int32 end = 2;    // Exclusive.\n  }\n  repeated ReservedRange reserved_range = 9;\n  // Reserved field names, which may not be used by fields in the same message.\n  // A given name may only be reserved once.\n  repeated string reserved_name = 10;\n}\n\nmessage ExtensionRangeOptions {\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  message Declaration {\n    // The extension number declared within the extension range.\n    optional int32 number = 1;\n\n    // The fully-qualified name of the extension field. There must be a leading\n    // dot in front of the full name.\n    optional string full_name = 2;\n\n    // The fully-qualified type name of the extension field. Unlike\n    // Metadata.type, Declaration.type must have a leading dot for messages\n    // and enums.\n    optional string type = 3;\n\n    // If true, indicates that the number is reserved in the extension range,\n    // and any extension field with the number will fail to compile. Set this\n    // when a declared extension field is deleted.\n    optional bool reserved = 5;\n\n    // If true, indicates that the extension must be defined as repeated.\n    // Otherwise the extension must be defined as optional.\n    optional bool repeated = 6;\n\n    reserved 4;  // removed is_repeated\n  }\n\n  // For external users: DO NOT USE. We are in the process of open sourcing\n  // extension declaration and executing internal cleanups before it can be\n  // used externally.\n  repeated Declaration declaration = 2 [retention = RETENTION_SOURCE];\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 50;\n\n  // The verification state of the extension range.\n  enum VerificationState {\n    // All the extensions of the range must be declared.\n    DECLARATION = 0;\n    UNVERIFIED = 1;\n  }\n\n  // The verification state of the range.\n  // TODO: flip the default to DECLARATION once all empty ranges\n  // are marked as UNVERIFIED.\n  optional VerificationState verification = 3 [default = UNVERIFIED];\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\n// Describes a field within a message.\nmessage FieldDescriptorProto {\n  enum Type {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    TYPE_DOUBLE = 1;\n    TYPE_FLOAT = 2;\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    TYPE_INT64 = 3;\n    TYPE_UINT64 = 4;\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    TYPE_INT32 = 5;\n    TYPE_FIXED64 = 6;\n    TYPE_FIXED32 = 7;\n    TYPE_BOOL = 8;\n    TYPE_STRING = 9;\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported after google.protobuf. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.  In Editions, the group wire format\n    // can be enabled via the `message_encoding` feature.\n    TYPE_GROUP = 10;\n    TYPE_MESSAGE = 11;  // Length-delimited aggregate.\n\n    // New in version 2.\n    TYPE_BYTES = 12;\n    TYPE_UINT32 = 13;\n    TYPE_ENUM = 14;\n    TYPE_SFIXED32 = 15;\n    TYPE_SFIXED64 = 16;\n    TYPE_SINT32 = 17;  // Uses ZigZag encoding.\n    TYPE_SINT64 = 18;  // Uses ZigZag encoding.\n  }\n\n  enum Label {\n    // 0 is reserved for errors\n    LABEL_OPTIONAL = 1;\n    LABEL_REPEATED = 3;\n    // The required label is only allowed in google.protobuf.  In proto3 and Editions\n    // it's explicitly prohibited.  In Editions, the `field_presence` feature\n    // can be used to get this behavior.\n    LABEL_REQUIRED = 2;\n  }\n\n  optional string name = 1;\n  optional int32 number = 3;\n  optional Label label = 4;\n\n  // If type_name is set, this need not be set.  If both this and type_name\n  // are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.\n  optional Type type = 5;\n\n  // For message and enum types, this is the name of the type.  If the name\n  // starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping\n  // rules are used to find the type (i.e. first the nested types within this\n  // message are searched, then within the parent, on up to the root\n  // namespace).\n  optional string type_name = 6;\n\n  // For extensions, this is the name of the type being extended.  It is\n  // resolved in the same manner as type_name.\n  optional string extendee = 2;\n\n  // For numeric types, contains the original text representation of the value.\n  // For booleans, \"true\" or \"false\".\n  // For strings, contains the default text contents (not escaped in any way).\n  // For bytes, contains the C escaped value.  All bytes >= 128 are escaped.\n  optional string default_value = 7;\n\n  // If set, gives the index of a oneof in the containing type's oneof_decl\n  // list.  This field is a member of that oneof.\n  optional int32 oneof_index = 9;\n\n  // JSON name of this field. The value is set by protocol compiler. If the\n  // user has set a \"json_name\" option on this field, that option's value\n  // will be used. Otherwise, it's deduced from the field's name by converting\n  // it to camelCase.\n  optional string json_name = 10;\n\n  optional FieldOptions options = 8;\n\n  // If true, this is a proto3 \"optional\". When a proto3 field is optional, it\n  // tracks presence regardless of field type.\n  //\n  // When proto3_optional is true, this field must be belong to a oneof to\n  // signal to old proto3 clients that presence is tracked for this field. This\n  // oneof is known as a \"synthetic\" oneof, and this field must be its sole\n  // member (each proto3 optional field gets its own synthetic oneof). Synthetic\n  // oneofs exist in the descriptor only, and do not generate any API. Synthetic\n  // oneofs must be ordered after all \"real\" oneofs.\n  //\n  // For message fields, proto3_optional doesn't create any semantic change,\n  // since non-repeated message fields always track presence. However it still\n  // indicates the semantic detail of whether the user wrote \"optional\" or not.\n  // This can be useful for round-tripping the .proto file. For consistency we\n  // give message fields a synthetic oneof also, even though it is not required\n  // to track presence. This is especially important because the parser can't\n  // tell if a field is a message or an enum, so it must always create a\n  // synthetic oneof.\n  //\n  // Proto2 optional fields do not set this flag, because they already indicate\n  // optional with `LABEL_OPTIONAL`.\n  optional bool proto3_optional = 17;\n}\n\n// Describes a oneof.\nmessage OneofDescriptorProto {\n  optional string name = 1;\n  optional OneofOptions options = 2;\n}\n\n// Describes an enum type.\nmessage EnumDescriptorProto {\n  optional string name = 1;\n\n  repeated EnumValueDescriptorProto value = 2;\n\n  optional EnumOptions options = 3;\n\n  // Range of reserved numeric values. Reserved values may not be used by\n  // entries in the same enum. Reserved ranges may not overlap.\n  //\n  // Note that this is distinct from DescriptorProto.ReservedRange in that it\n  // is inclusive such that it can appropriately represent the entire int32\n  // domain.\n  message EnumReservedRange {\n    optional int32 start = 1;  // Inclusive.\n    optional int32 end = 2;    // Inclusive.\n  }\n\n  // Range of reserved numeric values. Reserved numeric values may not be used\n  // by enum values in the same enum declaration. Reserved ranges may not\n  // overlap.\n  repeated EnumReservedRange reserved_range = 4;\n\n  // Reserved enum value names, which may not be reused. A given name may only\n  // be reserved once.\n  repeated string reserved_name = 5;\n}\n\n// Describes a value within an enum.\nmessage EnumValueDescriptorProto {\n  optional string name = 1;\n  optional int32 number = 2;\n\n  optional EnumValueOptions options = 3;\n}\n\n// Describes a service.\nmessage ServiceDescriptorProto {\n  optional string name = 1;\n  repeated MethodDescriptorProto method = 2;\n\n  optional ServiceOptions options = 3;\n}\n\n// Describes a method of a service.\nmessage MethodDescriptorProto {\n  optional string name = 1;\n\n  // Input and output type names.  These are resolved in the same way as\n  // FieldDescriptorProto.type_name, but must refer to a message type.\n  optional string input_type = 2;\n  optional string output_type = 3;\n\n  optional MethodOptions options = 4;\n\n  // Identifies if client streams multiple client messages\n  optional bool client_streaming = 5 [default = false];\n  // Identifies if server streams multiple server messages\n  optional bool server_streaming = 6 [default = false];\n}\n\n// ===================================================================\n// Options\n\n// Each of the definitions above may have \"options\" attached.  These are\n// just annotations which may cause code to be generated slightly differently\n// or may contain hints for code that manipulates protocol messages.\n//\n// Clients may define custom options as extensions of the *Options messages.\n// These extensions may not yet be known at parsing time, so the parser cannot\n// store the values in them.  Instead it stores them in a field in the *Options\n// message called uninterpreted_option. This field must have the same name\n// across all *Options messages. We then use this field to populate the\n// extensions when we build a descriptor, at which point all protos have been\n// parsed and so all extensions are known.\n//\n// Extension numbers for custom options may be chosen as follows:\n// * For options which will only be used within a single application or\n//   organization, or for experimental options, use field numbers 50000\n//   through 99999.  It is up to you to ensure that you do not use the\n//   same number for multiple options.\n// * For options which will be published and used publicly by multiple\n//   independent entities, e-mail protobuf-global-extension-registry@google.com\n//   to reserve extension numbers. Simply provide your project name (e.g.\n//   Objective-C plugin) and your project website (if available) -- there's no\n//   need to explain how you intend to use them. Usually you only need one\n//   extension number. You can declare multiple options with only one extension\n//   number by putting them in a sub-message. See the Custom Options section of\n//   the docs for examples:\n//   https://developers.google.com/protocol-buffers/docs/proto#options\n//   If this turns out to be popular, a web service will be set up\n//   to automatically assign option numbers.\n\nmessage FileOptions {\n\n  // Sets the Java package where classes generated from this .proto will be\n  // placed.  By default, the proto package is used, but this is often\n  // inappropriate because proto packages do not normally start with backwards\n  // domain names.\n  optional string java_package = 1;\n\n  // Controls the name of the wrapper Java class generated for the .proto file.\n  // That class will always contain the .proto file's getDescriptor() method as\n  // well as any top-level extensions defined in the .proto file.\n  // If java_multiple_files is disabled, then all the other classes from the\n  // .proto file will be nested inside the single wrapper outer class.\n  optional string java_outer_classname = 8;\n\n  // If enabled, then the Java code generator will generate a separate .java\n  // file for each top-level message, enum, and service defined in the .proto\n  // file.  Thus, these types will *not* be nested inside the wrapper class\n  // named by java_outer_classname.  However, the wrapper class will still be\n  // generated to contain the file's getDescriptor() method as well as any\n  // top-level extensions defined in the file.\n  optional bool java_multiple_files = 10 [default = false];\n\n  // This option does nothing.\n  optional bool java_generate_equals_and_hash = 20 [deprecated=true];\n\n  // If set true, then the Java2 code generator will generate code that\n  // throws an exception whenever an attempt is made to assign a non-UTF-8\n  // byte sequence to a string field.\n  // Message reflection will do the same.\n  // However, an extension field still accepts non-UTF-8 byte sequences.\n  // This option has no effect on when used with the lite runtime.\n  optional bool java_string_check_utf8 = 27 [default = false];\n\n  // Generated classes can be optimized for speed or code size.\n  enum OptimizeMode {\n    SPEED = 1;         // Generate complete code for parsing, serialization,\n                       // etc.\n    CODE_SIZE = 2;     // Use ReflectionOps to implement these methods.\n    LITE_RUNTIME = 3;  // Generate code using MessageLite and the lite runtime.\n  }\n  optional OptimizeMode optimize_for = 9 [default = SPEED];\n\n  // Sets the Go package where structs generated from this .proto will be\n  // placed. If omitted, the Go package will be derived from the following:\n  //   - The basename of the package import path, if provided.\n  //   - Otherwise, the package statement in the .proto file, if present.\n  //   - Otherwise, the basename of the .proto file, without extension.\n  optional string go_package = 11;\n\n  // Should generic services be generated in each language?  \"Generic\" services\n  // are not specific to any particular RPC system.  They are generated by the\n  // main code generators in each language (without additional plugins).\n  // Generic services were the only kind of service generation supported by\n  // early versions of google.protobuf.\n  //\n  // Generic services are now considered deprecated in favor of using plugins\n  // that generate code specific to your particular RPC system.  Therefore,\n  // these default to false.  Old code which depends on generic services should\n  // explicitly set them to true.\n  optional bool cc_generic_services = 16 [default = false];\n  optional bool java_generic_services = 17 [default = false];\n  optional bool py_generic_services = 18 [default = false];\n  optional bool php_generic_services = 42 [default = false];\n\n  // Is this file deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for everything in the file, or it will be completely ignored; in the very\n  // least, this is a formalization for deprecating files.\n  optional bool deprecated = 23 [default = false];\n\n  // Enables the use of arenas for the proto messages in this file. This applies\n  // only to generated classes for C++.\n  optional bool cc_enable_arenas = 31 [default = true];\n\n  // Sets the objective c class prefix which is prepended to all objective c\n  // generated classes from this .proto. There is no default.\n  optional string objc_class_prefix = 36;\n\n  // Namespace for generated classes; defaults to the package.\n  optional string csharp_namespace = 37;\n\n  // By default Swift generators will take the proto package and CamelCase it\n  // replacing '.' with underscore and use that to prefix the types/symbols\n  // defined. When this options is provided, they will use this value instead\n  // to prefix the types/symbols defined.\n  optional string swift_prefix = 39;\n\n  // Sets the php class prefix which is prepended to all php generated classes\n  // from this .proto. Default is empty.\n  optional string php_class_prefix = 40;\n\n  // Use this option to change the namespace of php generated classes. Default\n  // is empty. When this option is empty, the package name will be used for\n  // determining the namespace.\n  optional string php_namespace = 41;\n\n  // Use this option to change the namespace of php generated metadata classes.\n  // Default is empty. When this option is empty, the proto file name will be\n  // used for determining the namespace.\n  optional string php_metadata_namespace = 44;\n\n  // Use this option to change the package of ruby generated classes. Default\n  // is empty. When this option is not set, the package name will be used for\n  // determining the ruby package.\n  optional string ruby_package = 45;\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 50;\n\n  // The parser stores options it doesn't recognize here.\n  // See the documentation for the \"Options\" section above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message.\n  // See the documentation for the \"Options\" section above.\n  extensions 1000 to max;\n\n  reserved 38;\n}\n\nmessage MessageOptions {\n  // Set true to use the old proto1 MessageSet wire format for extensions.\n  // This is provided for backwards-compatibility with the MessageSet wire\n  // format.  You should not use this for any other reason:  It's less\n  // efficient, has fewer features, and is more complicated.\n  //\n  // The message must be defined exactly as follows:\n  //   message Foo {\n  //     option message_set_wire_format = true;\n  //     extensions 4 to max;\n  //   }\n  // Note that the message cannot have any defined fields; MessageSets only\n  // have extensions.\n  //\n  // All extensions of your type must be singular messages; e.g. they cannot\n  // be int32s, enums, or repeated messages.\n  //\n  // Because this is an option, the above two restrictions are not enforced by\n  // the protocol compiler.\n  optional bool message_set_wire_format = 1 [default = false];\n\n  // Disables the generation of the standard \"descriptor()\" accessor, which can\n  // conflict with a field of the same name.  This is meant to make migration\n  // from proto1 easier; new code should avoid fields named \"descriptor\".\n  optional bool no_standard_descriptor_accessor = 2 [default = false];\n\n  // Is this message deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for the message, or it will be completely ignored; in the very least,\n  // this is a formalization for deprecating messages.\n  optional bool deprecated = 3 [default = false];\n\n  reserved 4, 5, 6;\n\n  // NOTE: Do not set the option in .proto files. Always use the maps syntax\n  // instead. The option should only be implicitly set by the proto compiler\n  // parser.\n  //\n  // Whether the message is an automatically generated map entry type for the\n  // maps field.\n  //\n  // For maps fields:\n  //     map<KeyType, ValueType> map_field = 1;\n  // The parsed descriptor looks like:\n  //     message MapFieldEntry {\n  //         option map_entry = true;\n  //         optional KeyType key = 1;\n  //         optional ValueType value = 2;\n  //     }\n  //     repeated MapFieldEntry map_field = 1;\n  //\n  // Implementations may choose not to generate the map_entry=true message, but\n  // use a native map in the target language to hold the keys and values.\n  // The reflection APIs in such implementations still need to work as\n  // if the field is a repeated message field.\n  optional bool map_entry = 7;\n\n  reserved 8;  // javalite_serializable\n  reserved 9;  // javanano_as_lite\n\n  // Enable the legacy handling of JSON field name conflicts.  This lowercases\n  // and strips underscored from the fields before comparison in proto3 only.\n  // The new behavior takes `json_name` into account and applies to proto2 as\n  // well.\n  //\n  // This should only be used as a temporary measure against broken builds due\n  // to the change in behavior for JSON field name conflicts.\n  //\n  // TODO This is legacy behavior we plan to remove once downstream\n  // teams have had time to migrate.\n  optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 12;\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\nmessage FieldOptions {\n  // The ctype option instructs the C++ code generator to use a different\n  // representation of the field than it normally would.  See the specific\n  // options below.  This option is only implemented to support use of\n  // [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of\n  // type \"bytes\" in the open source release -- sorry, we'll try to include\n  // other types in a future version!\n  optional CType ctype = 1 [default = STRING];\n  enum CType {\n    // Default mode.\n    STRING = 0;\n\n    // The option [ctype=CORD] may be applied to a non-repeated field of type\n    // \"bytes\". It indicates that in C++, the data should be stored in a Cord\n    // instead of a string.  For very large strings, this may reduce memory\n    // fragmentation. It may also allow better performance when parsing from a\n    // Cord, or when parsing with aliasing enabled, as the parsed Cord may then\n    // alias the original buffer.\n    CORD = 1;\n\n    STRING_PIECE = 2;\n  }\n  // The packed option can be enabled for repeated primitive fields to enable\n  // a more efficient representation on the wire. Rather than repeatedly\n  // writing the tag and type for each element, the entire array is encoded as\n  // a single length-delimited blob. In proto3, only explicit setting it to\n  // false will avoid using packed encoding.  This option is prohibited in\n  // Editions, but the `repeated_field_encoding` feature can be used to control\n  // the behavior.\n  optional bool packed = 2;\n\n  // The jstype option determines the JavaScript type used for values of the\n  // field.  The option is permitted only for 64 bit integral and fixed types\n  // (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING\n  // is represented as JavaScript string, which avoids loss of precision that\n  // can happen when a large value is converted to a floating point JavaScript.\n  // Specifying JS_NUMBER for the jstype causes the generated JavaScript code to\n  // use the JavaScript \"number\" type.  The behavior of the default option\n  // JS_NORMAL is implementation dependent.\n  //\n  // This option is an enum to permit additional types to be added, e.g.\n  // goog.math.Integer.\n  optional JSType jstype = 6 [default = JS_NORMAL];\n  enum JSType {\n    // Use the default type.\n    JS_NORMAL = 0;\n\n    // Use JavaScript strings.\n    JS_STRING = 1;\n\n    // Use JavaScript numbers.\n    JS_NUMBER = 2;\n  }\n\n  // Should this field be parsed lazily?  Lazy applies only to message-type\n  // fields.  It means that when the outer message is initially parsed, the\n  // inner message's contents will not be parsed but instead stored in encoded\n  // form.  The inner message will actually be parsed when it is first accessed.\n  //\n  // This is only a hint.  Implementations are free to choose whether to use\n  // eager or lazy parsing regardless of the value of this option.  However,\n  // setting this option true suggests that the protocol author believes that\n  // using lazy parsing on this field is worth the additional bookkeeping\n  // overhead typically needed to implement it.\n  //\n  // This option does not affect the public interface of any generated code;\n  // all method signatures remain the same.  Furthermore, thread-safety of the\n  // interface is not affected by this option; const methods remain safe to\n  // call from multiple threads concurrently, while non-const methods continue\n  // to require exclusive access.\n  //\n  // Note that implementations may choose not to check required fields within\n  // a lazy sub-message.  That is, calling IsInitialized() on the outer message\n  // may return true even if the inner message has missing required fields.\n  // This is necessary because otherwise the inner message would have to be\n  // parsed in order to perform the check, defeating the purpose of lazy\n  // parsing.  An implementation which chooses not to check required fields\n  // must be consistent about it.  That is, for any particular sub-message, the\n  // implementation must either *always* check its required fields, or *never*\n  // check its required fields, regardless of whether or not the message has\n  // been parsed.\n  //\n  // As of May 2022, lazy verifies the contents of the byte stream during\n  // parsing.  An invalid byte stream will cause the overall parsing to fail.\n  optional bool lazy = 5 [default = false];\n\n  // unverified_lazy does no correctness checks on the byte stream. This should\n  // only be used where lazy with verification is prohibitive for performance\n  // reasons.\n  optional bool unverified_lazy = 15 [default = false];\n\n  // Is this field deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for accessors, or it will be completely ignored; in the very least, this\n  // is a formalization for deprecating fields.\n  optional bool deprecated = 3 [default = false];\n\n  // For Google-internal migration only. Do not use.\n  optional bool weak = 10 [default = false];\n\n  // Indicate that the field value should not be printed out when using debug\n  // formats, e.g. when the field contains sensitive credentials.\n  optional bool debug_redact = 16 [default = false];\n\n  // If set to RETENTION_SOURCE, the option will be omitted from the binary.\n  // Note: as of January 2023, support for this is in progress and does not yet\n  // have an effect (b/264593489).\n  enum OptionRetention {\n    RETENTION_UNKNOWN = 0;\n    RETENTION_RUNTIME = 1;\n    RETENTION_SOURCE = 2;\n  }\n\n  optional OptionRetention retention = 17;\n\n  // This indicates the types of entities that the field may apply to when used\n  // as an option. If it is unset, then the field may be freely used as an\n  // option on any kind of entity. Note: as of January 2023, support for this is\n  // in progress and does not yet have an effect (b/264593489).\n  enum OptionTargetType {\n    TARGET_TYPE_UNKNOWN = 0;\n    TARGET_TYPE_FILE = 1;\n    TARGET_TYPE_EXTENSION_RANGE = 2;\n    TARGET_TYPE_MESSAGE = 3;\n    TARGET_TYPE_FIELD = 4;\n    TARGET_TYPE_ONEOF = 5;\n    TARGET_TYPE_ENUM = 6;\n    TARGET_TYPE_ENUM_ENTRY = 7;\n    TARGET_TYPE_SERVICE = 8;\n    TARGET_TYPE_METHOD = 9;\n  }\n\n  repeated OptionTargetType targets = 19;\n\n  message EditionDefault {\n    optional Edition edition = 3;\n    optional string value = 2;  // Textproto value.\n  }\n  repeated EditionDefault edition_defaults = 20;\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 21;\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n\n  reserved 4;   // removed jtype\n  reserved 18;  // reserve target, target_obsolete_do_not_use\n}\n\nmessage OneofOptions {\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 1;\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\nmessage EnumOptions {\n\n  // Set this option to true to allow mapping different tag names to the same\n  // value.\n  optional bool allow_alias = 2;\n\n  // Is this enum deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for the enum, or it will be completely ignored; in the very least, this\n  // is a formalization for deprecating enums.\n  optional bool deprecated = 3 [default = false];\n\n  reserved 5;  // javanano_as_lite\n\n  // Enable the legacy handling of JSON field name conflicts.  This lowercases\n  // and strips underscored from the fields before comparison in proto3 only.\n  // The new behavior takes `json_name` into account and applies to proto2 as\n  // well.\n  // TODO Remove this legacy behavior once downstream teams have\n  // had time to migrate.\n  optional bool deprecated_legacy_json_field_conflicts = 6 [deprecated = true];\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 7;\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\nmessage EnumValueOptions {\n  // Is this enum value deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for the enum value, or it will be completely ignored; in the very least,\n  // this is a formalization for deprecating enum values.\n  optional bool deprecated = 1 [default = false];\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 2;\n\n  // Indicate that fields annotated with this enum value should not be printed\n  // out when using debug formats, e.g. when the field contains sensitive\n  // credentials.\n  optional bool debug_redact = 3 [default = false];\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\nmessage ServiceOptions {\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 34;\n\n  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC\n  //   framework.  We apologize for hoarding these numbers to ourselves, but\n  //   we were already using them long before we decided to release Protocol\n  //   Buffers.\n\n  // Is this service deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for the service, or it will be completely ignored; in the very least,\n  // this is a formalization for deprecating services.\n  optional bool deprecated = 33 [default = false];\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\nmessage MethodOptions {\n\n  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC\n  //   framework.  We apologize for hoarding these numbers to ourselves, but\n  //   we were already using them long before we decided to release Protocol\n  //   Buffers.\n\n  // Is this method deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for the method, or it will be completely ignored; in the very least,\n  // this is a formalization for deprecating methods.\n  optional bool deprecated = 33 [default = false];\n\n  // Is this method side-effect-free (or safe in HTTP parlance), or idempotent,\n  // or neither? HTTP based RPC implementation may choose GET verb for safe\n  // methods, and PUT verb for idempotent methods instead of the default POST.\n  enum IdempotencyLevel {\n    IDEMPOTENCY_UNKNOWN = 0;\n    NO_SIDE_EFFECTS = 1;  // implies idempotent\n    IDEMPOTENT = 2;       // idempotent, but may have side effects\n  }\n  optional IdempotencyLevel idempotency_level = 34\n      [default = IDEMPOTENCY_UNKNOWN];\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 35;\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\n// A message representing a option the parser does not recognize. This only\n// appears in options protos created by the compiler::Parser class.\n// DescriptorPool resolves these when building Descriptor objects. Therefore,\n// options protos in descriptor objects (e.g. returned by Descriptor::options(),\n// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions\n// in them.\nmessage UninterpretedOption {\n  // The name of the uninterpreted option.  Each string represents a segment in\n  // a dot-separated name.  is_extension is true iff a segment represents an\n  // extension (denoted with parentheses in options specs in .proto files).\n  // E.g.,{ [\"foo\", false], [\"bar.baz\", true], [\"moo\", false] } represents\n  // \"foo.(bar.baz).moo\".\n  message NamePart {\n    required string name_part = 1;\n    required bool is_extension = 2;\n  }\n  repeated NamePart name = 2;\n\n  // The value of the uninterpreted option, in whatever type the tokenizer\n  // identified it as during parsing. Exactly one of these should be set.\n  optional string identifier_value = 3;\n  optional uint64 positive_int_value = 4;\n  optional int64 negative_int_value = 5;\n  optional double double_value = 6;\n  optional bytes string_value = 7;\n  optional string aggregate_value = 8;\n}\n\n// ===================================================================\n// Features\n\n// TODO Enums in C++ gencode (and potentially other languages) are\n// not well scoped.  This means that each of the feature enums below can clash\n// with each other.  The short names we've chosen maximize call-site\n// readability, but leave us very open to this scenario.  A future feature will\n// be designed and implemented to handle this, hopefully before we ever hit a\n// conflict here.\nmessage FeatureSet {\n  enum FieldPresence {\n    FIELD_PRESENCE_UNKNOWN = 0;\n    EXPLICIT = 1;\n    IMPLICIT = 2;\n    LEGACY_REQUIRED = 3;\n  }\n  optional FieldPresence field_presence = 1 [\n    retention = RETENTION_RUNTIME,\n    targets = TARGET_TYPE_FIELD,\n    targets = TARGET_TYPE_FILE,\n    edition_defaults = { edition: EDITION_PROTO2, value: \"EXPLICIT\" },\n    edition_defaults = { edition: EDITION_PROTO3, value: \"IMPLICIT\" },\n    edition_defaults = { edition: EDITION_2023, value: \"EXPLICIT\" }\n  ];\n\n  enum EnumType {\n    ENUM_TYPE_UNKNOWN = 0;\n    OPEN = 1;\n    CLOSED = 2;\n  }\n  optional EnumType enum_type = 2 [\n    retention = RETENTION_RUNTIME,\n    targets = TARGET_TYPE_ENUM,\n    targets = TARGET_TYPE_FILE,\n    edition_defaults = { edition: EDITION_PROTO2, value: \"CLOSED\" },\n    edition_defaults = { edition: EDITION_PROTO3, value: \"OPEN\" }\n  ];\n\n  enum RepeatedFieldEncoding {\n    REPEATED_FIELD_ENCODING_UNKNOWN = 0;\n    PACKED = 1;\n    EXPANDED = 2;\n  }\n  optional RepeatedFieldEncoding repeated_field_encoding = 3 [\n    retention = RETENTION_RUNTIME,\n    targets = TARGET_TYPE_FIELD,\n    targets = TARGET_TYPE_FILE,\n    edition_defaults = { edition: EDITION_PROTO2, value: \"EXPANDED\" },\n    edition_defaults = { edition: EDITION_PROTO3, value: \"PACKED\" }\n  ];\n\n  enum Utf8Validation {\n    UTF8_VALIDATION_UNKNOWN = 0;\n    NONE = 1;\n    VERIFY = 2;\n  }\n  optional Utf8Validation utf8_validation = 4 [\n    retention = RETENTION_RUNTIME,\n    targets = TARGET_TYPE_FIELD,\n    targets = TARGET_TYPE_FILE,\n    edition_defaults = { edition: EDITION_PROTO2, value: \"NONE\" },\n    edition_defaults = { edition: EDITION_PROTO3, value: \"VERIFY\" }\n  ];\n\n  enum MessageEncoding {\n    MESSAGE_ENCODING_UNKNOWN = 0;\n    LENGTH_PREFIXED = 1;\n    DELIMITED = 2;\n  }\n  optional MessageEncoding message_encoding = 5 [\n    retention = RETENTION_RUNTIME,\n    targets = TARGET_TYPE_FIELD,\n    targets = TARGET_TYPE_FILE,\n    edition_defaults = { edition: EDITION_PROTO2, value: \"LENGTH_PREFIXED\" }\n  ];\n\n  enum JsonFormat {\n    JSON_FORMAT_UNKNOWN = 0;\n    ALLOW = 1;\n    LEGACY_BEST_EFFORT = 2;\n  }\n  optional JsonFormat json_format = 6 [\n    retention = RETENTION_RUNTIME,\n    targets = TARGET_TYPE_MESSAGE,\n    targets = TARGET_TYPE_ENUM,\n    targets = TARGET_TYPE_FILE,\n    edition_defaults = { edition: EDITION_PROTO2, value: \"LEGACY_BEST_EFFORT\" },\n    edition_defaults = { edition: EDITION_PROTO3, value: \"ALLOW\" }\n  ];\n\n  reserved 999;\n\n  extensions 1000;  // for Protobuf C++\n  extensions 1001;  // for Protobuf Java\n\n  extensions 9995 to 9999;  // For internal testing\n}\n\n// A compiled specification for the defaults of a set of features.  These\n// messages are generated from FeatureSet extensions and can be used to seed\n// feature resolution. The resolution with this object becomes a simple search\n// for the closest matching edition, followed by proto merges.\nmessage FeatureSetDefaults {\n  // A map from every known edition with a unique set of defaults to its\n  // defaults. Not all editions may be contained here.  For a given edition,\n  // the defaults at the closest matching edition ordered at or before it should\n  // be used.  This field must be in strict ascending order by edition.\n  message FeatureSetEditionDefault {\n    optional Edition edition = 3;\n    optional FeatureSet features = 2;\n  }\n  repeated FeatureSetEditionDefault defaults = 1;\n\n  // The minimum supported edition (inclusive) when this was constructed.\n  // Editions before this will not have defaults.\n  optional Edition minimum_edition = 4;\n\n  // The maximum known edition (inclusive) when this was constructed. Editions\n  // after this will not have reliable defaults.\n  optional Edition maximum_edition = 5;\n}\n\n// ===================================================================\n// Optional source code info\n\n// Encapsulates information about the original source file from which a\n// FileDescriptorProto was generated.\nmessage SourceCodeInfo {\n  // A Location identifies a piece of source code in a .proto file which\n  // corresponds to a particular definition.  This information is intended\n  // to be useful to IDEs, code indexers, documentation generators, and similar\n  // tools.\n  //\n  // For example, say we have a file like:\n  //   message Foo {\n  //     optional string foo = 1;\n  //   }\n  // Let's look at just the field definition:\n  //   optional string foo = 1;\n  //   ^       ^^     ^^  ^  ^^^\n  //   a       bc     de  f  ghi\n  // We have the following locations:\n  //   span   path               represents\n  //   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.\n  //   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).\n  //   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).\n  //   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).\n  //   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).\n  //\n  // Notes:\n  // - A location may refer to a repeated field itself (i.e. not to any\n  //   particular index within it).  This is used whenever a set of elements are\n  //   logically enclosed in a single code segment.  For example, an entire\n  //   extend block (possibly containing multiple extension definitions) will\n  //   have an outer location whose path refers to the \"extensions\" repeated\n  //   field without an index.\n  // - Multiple locations may have the same path.  This happens when a single\n  //   logical declaration is spread out across multiple places.  The most\n  //   obvious example is the \"extend\" block again -- there may be multiple\n  //   extend blocks in the same scope, each of which will have the same path.\n  // - A location's span is not always a subset of its parent's span.  For\n  //   example, the \"extendee\" of an extension declaration appears at the\n  //   beginning of the \"extend\" block and is shared by all extensions within\n  //   the block.\n  // - Just because a location's span is a subset of some other location's span\n  //   does not mean that it is a descendant.  For example, a \"group\" defines\n  //   both a type and a field in a single declaration.  Thus, the locations\n  //   corresponding to the type and field and their components will overlap.\n  // - Code which tries to interpret locations should probably be designed to\n  //   ignore those that it doesn't understand, as more types of locations could\n  //   be recorded in the future.\n  repeated Location location = 1;\n  message Location {\n    // Identifies which part of the FileDescriptorProto was defined at this\n    // location.\n    //\n    // Each element is a field number or an index.  They form a path from\n    // the root FileDescriptorProto to the place where the definition occurs.\n    // For example, this path:\n    //   [ 4, 3, 2, 7, 1 ]\n    // refers to:\n    //   file.message_type(3)  // 4, 3\n    //       .field(7)         // 2, 7\n    //       .name()           // 1\n    // This is because FileDescriptorProto.message_type has field number 4:\n    //   repeated DescriptorProto message_type = 4;\n    // and DescriptorProto.field has field number 2:\n    //   repeated FieldDescriptorProto field = 2;\n    // and FieldDescriptorProto.name has field number 1:\n    //   optional string name = 1;\n    //\n    // Thus, the above path gives the location of a field name.  If we removed\n    // the last element:\n    //   [ 4, 3, 2, 7 ]\n    // this path refers to the whole field declaration (from the beginning\n    // of the label to the terminating semicolon).\n    repeated int32 path = 1 [packed = true];\n\n    // Always has exactly three or four elements: start line, start column,\n    // end line (optional, otherwise assumed same as start line), end column.\n    // These are packed into a single field for efficiency.  Note that line\n    // and column numbers are zero-based -- typically you will want to add\n    // 1 to each before displaying to a user.\n    repeated int32 span = 2 [packed = true];\n\n    // If this SourceCodeInfo represents a complete declaration, these are any\n    // comments appearing before and after the declaration which appear to be\n    // attached to the declaration.\n    //\n    // A series of line comments appearing on consecutive lines, with no other\n    // tokens appearing on those lines, will be treated as a single comment.\n    //\n    // leading_detached_comments will keep paragraphs of comments that appear\n    // before (but not connected to) the current element. Each paragraph,\n    // separated by empty lines, will be one comment element in the repeated\n    // field.\n    //\n    // Only the comment content is provided; comment markers (e.g. //) are\n    // stripped out.  For block comments, leading whitespace and an asterisk\n    // will be stripped from the beginning of each line other than the first.\n    // Newlines are included in the output.\n    //\n    // Examples:\n    //\n    //   optional int32 foo = 1;  // Comment attached to foo.\n    //   // Comment attached to bar.\n    //   optional int32 bar = 2;\n    //\n    //   optional string baz = 3;\n    //   // Comment attached to baz.\n    //   // Another line attached to baz.\n    //\n    //   // Comment attached to moo.\n    //   //\n    //   // Another line attached to moo.\n    //   optional double moo = 4;\n    //\n    //   // Detached comment for corge. This is not leading or trailing comments\n    //   // to moo or corge because there are blank lines separating it from\n    //   // both.\n    //\n    //   // Detached comment for corge paragraph 2.\n    //\n    //   optional string corge = 5;\n    //   /* Block comment attached\n    //    * to corge.  Leading asterisks\n    //    * will be removed. */\n    //   /* Block comment attached to\n    //    * grault. */\n    //   optional int32 grault = 6;\n    //\n    //   // ignored detached comments.\n    optional string leading_comments = 3;\n    optional string trailing_comments = 4;\n    repeated string leading_detached_comments = 6;\n  }\n}\n\n// Describes the relationship between generated code and its original source\n// file. A GeneratedCodeInfo message is associated with only one generated\n// source file, but may contain references to different source .proto files.\nmessage GeneratedCodeInfo {\n  // An Annotation connects some span of text in generated code to an element\n  // of its generating .proto file.\n  repeated Annotation annotation = 1;\n  message Annotation {\n    // Identifies the element in the original source .proto file. This field\n    // is formatted the same as SourceCodeInfo.Location.path.\n    repeated int32 path = 1 [packed = true];\n\n    // Identifies the filesystem path to the original source .proto.\n    optional string source_file = 2;\n\n    // Identifies the starting offset in bytes in the generated code\n    // that relates to the identified object.\n    optional int32 begin = 3;\n\n    // Identifies the ending offset in bytes in the generated code that\n    // relates to the identified object. The end offset should be one past\n    // the last relevant byte (so the length of the text = end - begin).\n    optional int32 end = 4;\n\n    // Represents the identified object's effect on the element in the original\n    // .proto file.\n    enum Semantic {\n      // There is no effect or the effect is indescribable.\n      NONE = 0;\n      // The element is set or otherwise mutated.\n      SET = 1;\n      // An alias to the element is returned.\n      ALIAS = 2;\n    }\n    optional Semantic semantic = 5;\n  }\n}\n","size_bytes":49985},"src/main/java/com/spiketrade/backend/ProbabilityCalibrator.java":{"content":"package com.spiketrade.backend;\n\nimport java.util.*;\nimport java.io.*;\nimport java.time.Instant;\n\n/**\n * FIX #1: Probability Calibrator for Statistical Weight Optimization\n * \n * PURPOSE:\n * The current probability weights in SpikeAnalyzer are ARBITRARY heuristic values (0.30, 0.15, etc.)\n * that are NOT based on actual historical win rates. This class provides infrastructure for\n * statistical calibration using real trade outcomes.\n * \n * PROBLEM WITH CURRENT APPROACH:\n * - Weights are made-up numbers that get summed together\n * - Multiple correlated indicators artificially inflate probability\n * - A \"70% probability\" signal doesn't actually mean 70% chance of profit\n * - Price ROC and Volume ROC often move together but are counted as independent signals\n * \n * SOLUTION OPTIONS:\n * \n * Option A: Logistic Regression (RECOMMENDED - IMPLEMENTED BELOW)\n * - Collect historical trade data with indicator values and outcomes (win/loss)\n * - Use logistic regression to find optimal weights based on actual win rates\n * - Transform linear combination of indicators using logistic function\n * - Formula: probability = 1.0 / (1.0 + exp(-logit_score))\n * \n * Option B: Machine Learning (Advanced)\n * - Use Random Forest or XGBoost to learn optimal indicator combinations\n * - Can capture non-linear relationships and indicator interactions\n * - Requires more training data but potentially more accurate\n * \n * Option C: Simple Independent Win Rates (Baseline)\n * - Measure actual win rate for each indicator independently\n * - Use those percentages as weights\n * - Easier to implement but doesn't account for correlations\n * \n * USAGE INSTRUCTIONS:\n * \n * 1. DATA COLLECTION PHASE (Run for 30+ days):\n *    - For each trade, record:\n *      * All indicator values at signal time (priceRoc, volumeRoc, rsi, etc.)\n *      * Trade outcome (1 = profitable, 0 = loss)\n *      * Save to CSV file: indicators.csv\n * \n * 2. CALIBRATION PHASE (Run weekly):\n *    - Load historical trade data from CSV\n *    - Call calibrateWeights() to run logistic regression\n *    - This will calculate optimal weights based on actual win rates\n *    - Save calibrated weights to config file\n * \n * 3. LIVE TRADING PHASE:\n *    - Use calibrated weights instead of arbitrary constants\n *    - Periodically re-calibrate as more data is collected\n * \n * EXAMPLE DATA FORMAT (indicators.csv):\n * priceRoc,volumeRoc,rsi,obv,mfi,bollingerB,vwap,outcome\n * 2.5,1.2,35,1000000,45,0.3,100.5,1\n * -1.3,0.5,55,500000,60,0.7,99.8,0\n * 3.1,2.0,28,1200000,40,0.2,101.2,1\n */\npublic class ProbabilityCalibrator {\n    \n    // Calibrated weights (adjusted for realistic probability ranges)\n    // These weights can produce both positive and negative contributions\n    private double weightPriceRoc = 0.6;\n    private double weightVolumeRoc = 0.5;\n    private double weightRSI = 0.6;\n    private double weightOBV = 0.4;\n    private double weightMFI = 0.4;\n    private double weightBollinger = 0.5;\n    private double weightVWAP = 0.3;\n    private double weightSpikeQuality = 1.0;\n    \n    // Intercept term for logistic regression (neutral baseline)\n    // CRITICAL FIX: Changed from 1.0 to -2.0 for realistic probabilities\n    // With intercept of 1.0, logistic(1.0) = 0.73, making ALL signals appear 70%+ likely to win\n    // With intercept of -2.0, logistic(-2.0) = 0.12, requiring positive indicators to reach 50%+\n    // This prevents false confidence and ensures only strong signals exceed probability thresholds\n    private double intercept = -2.0;\n    \n    // Probability scaling factor (controlled by slider to adjust overall probability range)\n    private double probabilityScale = 1.0;\n    \n    // Training data storage\n    private List<TrainingRecord> trainingData = new ArrayList<>();\n    \n    // Warning flag for uncalibrated weights\n    private boolean weightsCalibrated = false;\n    \n    public ProbabilityCalibrator() {\n        System.out.println(\"WARNING: ProbabilityCalibrator initialized with UNCALIBRATED weights!\");\n        System.out.println(\"These are heuristic baseline values, NOT trained on actual trade outcomes.\");\n        System.out.println(\"To improve accuracy: (1) Collect trade data, (2) Call calibrateWeightsSimple(), (3) Save weights to config\");\n        System.out.println(\"Current intercept: \" + intercept + \" (produces ~12% baseline probability)\");\n    }\n    \n    /**\n     * Record for storing historical trade data for calibration\n     */\n    public static class TrainingRecord {\n        public double priceRoc;\n        public double volumeRoc;\n        public double rsi;\n        public double obvRoc;\n        public double mfiRoc;\n        public double bollingerB;\n        public double vwapRoc;\n        public boolean spikeDetected;\n        public boolean tradeWon;  // 1 = profitable, 0 = loss\n        public Instant timestamp;\n        \n        public TrainingRecord() {\n            this.timestamp = Instant.now();\n        }\n    }\n    \n    /**\n     * FIX #1: Record a trade outcome for future calibration\n     * \n     * Call this method AFTER each trade closes to build training dataset.\n     * Store indicator values at signal time and final trade outcome.\n     * \n     * @param indicators The indicator values when buy signal was generated\n     * @param tradeWon True if trade was profitable, false if loss\n     */\n    public void recordTradeOutcome(IndicatorsData indicators, boolean spikeDetected, boolean tradeWon) {\n        TrainingRecord record = new TrainingRecord();\n        record.priceRoc = indicators.priceRoc;\n        record.volumeRoc = indicators.volumeRoc;\n        record.rsi = indicators.rsi;\n        record.obvRoc = indicators.obvRoc;\n        record.mfiRoc = indicators.mfiRoc;\n        record.bollingerB = indicators.percentB;\n        record.vwapRoc = indicators.vwapRoc;\n        record.spikeDetected = spikeDetected;\n        record.tradeWon = tradeWon;\n        \n        trainingData.add(record);\n        \n        System.out.println(\"Recorded trade outcome for calibration: \" + \n            (tradeWon ? \"WIN\" : \"LOSS\") + \" (total training records: \" + trainingData.size() + \")\");\n    }\n    \n    /**\n     * FIX #1: Save training data to CSV file for analysis\n     * \n     * Export all collected trade outcomes to CSV for:\n     * - Manual analysis in Excel/Python\n     * - External machine learning model training\n     * - Backup of historical performance data\n     */\n    public void saveTrainingData(String filename) throws IOException {\n        try (PrintWriter writer = new PrintWriter(new FileWriter(filename))) {\n            // CSV header\n            writer.println(\"timestamp,priceRoc,volumeRoc,rsi,obvRoc,mfiRoc,bollingerB,vwapRoc,spikeDetected,tradeWon\");\n            \n            // Data rows\n            for (TrainingRecord record : trainingData) {\n                writer.printf(\"%s,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%d,%d%n\",\n                    record.timestamp.toString(),\n                    record.priceRoc,\n                    record.volumeRoc,\n                    record.rsi,\n                    record.obvRoc,\n                    record.mfiRoc,\n                    record.bollingerB,\n                    record.vwapRoc,\n                    record.spikeDetected ? 1 : 0,\n                    record.tradeWon ? 1 : 0\n                );\n            }\n            \n            System.out.println(\"Saved \" + trainingData.size() + \" training records to \" + filename);\n        }\n    }\n    \n    /**\n     * FIX #1: Load training data from CSV file\n     */\n    public void loadTrainingData(String filename) throws IOException {\n        trainingData.clear();\n        \n        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {\n            String line = reader.readLine(); // Skip header\n            \n            while ((line = reader.readLine()) != null) {\n                String[] parts = line.split(\",\");\n                if (parts.length < 10) continue;\n                \n                TrainingRecord record = new TrainingRecord();\n                record.timestamp = Instant.parse(parts[0]);\n                record.priceRoc = Double.parseDouble(parts[1]);\n                record.volumeRoc = Double.parseDouble(parts[2]);\n                record.rsi = Double.parseDouble(parts[3]);\n                record.obvRoc = Double.parseDouble(parts[4]);\n                record.mfiRoc = Double.parseDouble(parts[5]);\n                record.bollingerB = Double.parseDouble(parts[6]);\n                record.vwapRoc = Double.parseDouble(parts[7]);\n                record.spikeDetected = Integer.parseInt(parts[8]) == 1;\n                record.tradeWon = Integer.parseInt(parts[9]) == 1;\n                \n                trainingData.add(record);\n            }\n            \n            System.out.println(\"Loaded \" + trainingData.size() + \" training records from \" + filename);\n        }\n    }\n    \n    /**\n     * FIX #1: Calibrate weights using simple win-rate analysis\n     * \n     * This is a SIMPLIFIED calibration method that measures win rate for each indicator.\n     * For production use, implement proper logistic regression or use external ML library.\n     * \n     * LIMITATION: This method treats indicators as independent, which they are NOT.\n     * Correlated indicators will still inflate probabilities.\n     * \n     * TODO: Implement full logistic regression using Apache Commons Math or similar library\n     */\n    public void calibrateWeightsSimple() {\n        if (trainingData.size() < 30) {\n            System.out.println(\"WARNING: Not enough training data for calibration (need at least 30 trades, have \" + \n                trainingData.size() + \")\");\n            return;\n        }\n        \n        System.out.println(\"Starting simple weight calibration with \" + trainingData.size() + \" trades...\");\n        \n        // Calculate win rate for each indicator condition\n        int priceRocWins = 0, priceRocTotal = 0;\n        int volumeRocWins = 0, volumeRocTotal = 0;\n        int rsiWins = 0, rsiTotal = 0;\n        int spikeWins = 0, spikeTotal = 0;\n        \n        for (TrainingRecord record : trainingData) {\n            // Price ROC > 0.5\n            if (record.priceRoc > 0.5) {\n                priceRocTotal++;\n                if (record.tradeWon) priceRocWins++;\n            }\n            \n            // Volume ROC > 0.3\n            if (record.volumeRoc > 0.3) {\n                volumeRocTotal++;\n                if (record.tradeWon) volumeRocWins++;\n            }\n            \n            // RSI < 40 (oversold)\n            if (record.rsi < 40) {\n                rsiTotal++;\n                if (record.tradeWon) rsiWins++;\n            }\n            \n            // Spike detected\n            if (record.spikeDetected) {\n                spikeTotal++;\n                if (record.tradeWon) spikeWins++;\n            }\n        }\n        \n        // Set weights based on actual win rates (normalized to sum to ~1.0)\n        double priceRocWinRate = priceRocTotal > 0 ? (double) priceRocWins / priceRocTotal : 0.5;\n        double volumeRocWinRate = volumeRocTotal > 0 ? (double) volumeRocWins / volumeRocTotal : 0.5;\n        double rsiWinRate = rsiTotal > 0 ? (double) rsiWins / rsiTotal : 0.5;\n        double spikeWinRate = spikeTotal > 0 ? (double) spikeWins / spikeTotal : 0.5;\n        \n        System.out.println(\"Calibration Results:\");\n        System.out.println(\"  Price ROC > 0.5:  Win rate = \" + String.format(\"%.1f%%\", priceRocWinRate * 100) + \n            \" (\" + priceRocWins + \"/\" + priceRocTotal + \" trades)\");\n        System.out.println(\"  Volume ROC > 0.3: Win rate = \" + String.format(\"%.1f%%\", volumeRocWinRate * 100) + \n            \" (\" + volumeRocWins + \"/\" + volumeRocTotal + \" trades)\");\n        System.out.println(\"  RSI < 40:         Win rate = \" + String.format(\"%.1f%%\", rsiWinRate * 100) + \n            \" (\" + rsiWins + \"/\" + rsiTotal + \" trades)\");\n        System.out.println(\"  Spike detected:   Win rate = \" + String.format(\"%.1f%%\", spikeWinRate * 100) + \n            \" (\" + spikeWins + \"/\" + spikeTotal + \" trades)\");\n        \n        // Update weights (these are actual probabilities now, not arbitrary heuristics)\n        this.weightPriceRoc = priceRocWinRate * 0.25;  // Scaled down to prevent over-confidence\n        this.weightVolumeRoc = volumeRocWinRate * 0.15;\n        this.weightRSI = rsiWinRate * 0.20;\n        this.weightSpikeQuality = spikeWinRate * 0.40;\n        \n        System.out.println(\"Weights updated based on historical win rates (ready for use in live trading)\");\n    }\n    \n    /**\n     * FIX #1: Calculate probability using LOGISTIC FUNCTION (proper statistical method)\n     * \n     * This is the CORRECT way to combine multiple indicators into a probability.\n     * Unlike simple addition, this:\n     * - Keeps result in [0, 1] range\n     * - Accounts for diminishing returns when multiple indicators agree\n     * - Uses calibrated weights from historical data\n     * \n     * Formula: P(win) = 1 / (1 + exp(-z))\n     * Where: z = intercept + w1*x1 + w2*x2 + ... (linear combination of indicators)\n     * \n     * @param indicators Current indicator values\n     * @param spikeDetected Whether spike was detected\n     * @return Calibrated probability of trade success [0.0, 1.0]\n     */\n    public double calculateCalibratedProbability(IndicatorsData indicators, boolean spikeDetected) {\n        // Calculate logit score (linear combination of features)\n        double logitScore = intercept;\n        \n        // Symmetric scaling: indicators can add OR subtract from probability\n        // This ensures realistic probability ranges and penalizes unfavorable conditions\n        \n        // Price ROC: Positive adds, negative subtracts (clamp to [-1, 1])\n        double scaledPriceRoc = Math.max(-1.0, Math.min(1.0, indicators.priceRoc / 2.0));\n        logitScore += weightPriceRoc * scaledPriceRoc;\n        \n        // Volume ROC: Positive adds, negative subtracts (clamp to [-1, 1])\n        double scaledVolumeRoc = Math.max(-1.0, Math.min(1.0, indicators.volumeRoc / 2.0));\n        logitScore += weightVolumeRoc * scaledVolumeRoc;\n        \n        // RSI: Oversold (0-30) adds, Overbought (70-100) subtracts, Neutral (30-70) near zero\n        // Map: 0->+1, 30->0, 50->0, 70->0, 100->-1\n        double rsiContribution;\n        if (indicators.rsi < 30) {\n            rsiContribution = (30 - indicators.rsi) / 30.0;  // Oversold: +1 to 0\n        } else if (indicators.rsi > 70) {\n            rsiContribution = (70 - indicators.rsi) / 30.0;  // Overbought: 0 to -1\n        } else {\n            rsiContribution = 0;  // Neutral range\n        }\n        logitScore += weightRSI * rsiContribution;\n        \n        // OBV ROC: Positive adds, negative subtracts\n        double scaledObvRoc = Math.max(-1.0, Math.min(1.0, indicators.obvRoc / 2.0));\n        logitScore += weightOBV * scaledObvRoc;\n        \n        // MFI ROC: Positive adds, negative subtracts\n        double scaledMfiRoc = Math.max(-1.0, Math.min(1.0, indicators.mfiRoc / 2.0));\n        logitScore += weightMFI * scaledMfiRoc;\n        \n        // Bollinger %B: Low values (<0.3) add, high values (>0.7) subtract\n        // Map: 0->+1, 0.3->0, 0.5->0, 0.7->0, 1->-1\n        double bollingerContribution;\n        if (indicators.percentB < 0.3) {\n            bollingerContribution = (0.3 - indicators.percentB) / 0.3;  // Oversold: +1 to 0\n        } else if (indicators.percentB > 0.7) {\n            bollingerContribution = (0.7 - indicators.percentB) / 0.3;  // Overbought: 0 to -1\n        } else {\n            bollingerContribution = 0;  // Neutral range\n        }\n        logitScore += weightBollinger * bollingerContribution;\n        \n        // VWAP ROC: Positive adds, negative subtracts\n        double scaledVwapRoc = Math.max(-1.0, Math.min(1.0, indicators.vwapRoc / 2.0));\n        logitScore += weightVWAP * scaledVwapRoc;\n        \n        // Spike quality provides strong signal (only positive contribution)\n        if (spikeDetected) {\n            logitScore += weightSpikeQuality;\n        }\n        \n        // Apply logistic function to convert to probability\n        // This ensures output is always between 0 and 1\n        // Apply probability scaling factor to adjust the range\n        double scaledLogitScore = logitScore * probabilityScale;\n        double probability = 1.0 / (1.0 + Math.exp(-scaledLogitScore));\n        \n        return probability;\n    }\n    \n    /**\n     * Get current calibrated weights (for inspection/debugging)\n     */\n    public Map<String, Double> getWeights() {\n        Map<String, Double> weights = new HashMap<>();\n        weights.put(\"priceRoc\", weightPriceRoc);\n        weights.put(\"volumeRoc\", weightVolumeRoc);\n        weights.put(\"rsi\", weightRSI);\n        weights.put(\"obv\", weightOBV);\n        weights.put(\"mfi\", weightMFI);\n        weights.put(\"bollinger\", weightBollinger);\n        weights.put(\"vwap\", weightVWAP);\n        weights.put(\"spikeQuality\", weightSpikeQuality);\n        weights.put(\"intercept\", intercept);\n        return weights;\n    }\n    \n    /**\n     * Set calibrated weights manually (for testing or loading from config)\n     */\n    public void setWeights(double priceRoc, double volumeRoc, double rsi, double obv, \n                          double mfi, double bollinger, double vwap, double spikeQuality, double intercept) {\n        this.weightPriceRoc = priceRoc;\n        this.weightVolumeRoc = volumeRoc;\n        this.weightRSI = rsi;\n        this.weightOBV = obv;\n        this.weightMFI = mfi;\n        this.weightBollinger = bollinger;\n        this.weightVWAP = vwap;\n        this.weightSpikeQuality = spikeQuality;\n        this.intercept = intercept;\n        \n        System.out.println(\"Manually set calibrated weights\");\n    }\n    \n    /**\n     * Set probability scaling factor (controlled by highProbThreshold slider)\n     * This adjusts the overall probability range produced by the calculation\n     * - Scale < 1.0: Lower probabilities (more conservative)\n     * - Scale = 1.0: Normal probabilities  \n     * - Scale > 1.0: Higher probabilities (more aggressive)\n     */\n    public void setProbabilityScale(double scale) {\n        this.probabilityScale = Math.max(0.5, Math.min(2.0, scale));\n    }\n}\n","size_bytes":18148},"src/main/java/com/spiketrade/util/ResilienceUtil.java":{"content":"package com.spiketrade.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.*;\nimport java.util.function.Predicate;\nimport java.util.function.Consumer;\n\npublic class ResilienceUtil {\n    private static final Logger logger = LoggerFactory.getLogger(ResilienceUtil.class);\n    private static final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);\n    \n    public static class RetryPolicy {\n        private final int maxAttempts;\n        private final long initialDelayMs;\n        private final long maxDelayMs;\n        private final double backoffMultiplier;\n        private final Predicate<Exception> retryCondition;\n        \n        private RetryPolicy(Builder builder) {\n            this.maxAttempts = builder.maxAttempts;\n            this.initialDelayMs = builder.initialDelayMs;\n            this.maxDelayMs = builder.maxDelayMs;\n            this.backoffMultiplier = builder.backoffMultiplier;\n            this.retryCondition = builder.retryCondition;\n        }\n        \n        public static Builder builder() {\n            return new Builder();\n        }\n        \n        public static class Builder {\n            private int maxAttempts = 3;\n            private long initialDelayMs = 1000;\n            private long maxDelayMs = 30000;\n            private double backoffMultiplier = 2.0;\n            private Predicate<Exception> retryCondition = e -> true;\n            \n            public Builder maxAttempts(int maxAttempts) {\n                this.maxAttempts = maxAttempts;\n                return this;\n            }\n            \n            public Builder initialDelay(long delayMs) {\n                this.initialDelayMs = delayMs;\n                return this;\n            }\n            \n            public Builder maxDelay(long maxDelayMs) {\n                this.maxDelayMs = maxDelayMs;\n                return this;\n            }\n            \n            public Builder backoffMultiplier(double multiplier) {\n                this.backoffMultiplier = multiplier;\n                return this;\n            }\n            \n            public Builder retryOn(Predicate<Exception> condition) {\n                this.retryCondition = condition;\n                return this;\n            }\n            \n            public RetryPolicy build() {\n                return new RetryPolicy(this);\n            }\n        }\n        \n        public int getMaxAttempts() {\n            return maxAttempts;\n        }\n        \n        public long getInitialDelayMs() {\n            return initialDelayMs;\n        }\n        \n        public long getMaxDelayMs() {\n            return maxDelayMs;\n        }\n        \n        public double getBackoffMultiplier() {\n            return backoffMultiplier;\n        }\n        \n        public boolean shouldRetry(Exception e) {\n            return retryCondition.test(e);\n        }\n    }\n    \n    public static <T> CompletableFuture<T> executeWithRetryAsync(\n            Callable<CompletableFuture<T>> operation, \n            RetryPolicy policy, \n            String operationName) {\n        \n        return executeAttempt(operation, policy, operationName, 1, policy.getInitialDelayMs());\n    }\n    \n    private static <T> CompletableFuture<T> executeAttempt(\n            Callable<CompletableFuture<T>> operation,\n            RetryPolicy policy,\n            String operationName,\n            int attempt,\n            long currentDelay) {\n        \n        CompletableFuture<T> result = new CompletableFuture<>();\n        \n        try {\n            logger.debug(\"Executing {} - Attempt {}/{}\", operationName, attempt, policy.getMaxAttempts());\n            \n            CompletableFuture<T> operationFuture = operation.call();\n            \n            operationFuture.whenComplete((value, error) -> {\n                if (error == null) {\n                    result.complete(value);\n                } else {\n                    Exception exception = (error instanceof Exception) ? \n                        (Exception) error : new RuntimeException(error);\n                    \n                    if (!policy.shouldRetry(exception)) {\n                        logger.warn(\"{} failed with non-retryable exception: {}\", \n                                   operationName, exception.getMessage());\n                        result.completeExceptionally(exception);\n                        return;\n                    }\n                    \n                    if (attempt >= policy.getMaxAttempts()) {\n                        logger.error(\"{} failed after {} attempts\", operationName, policy.getMaxAttempts());\n                        result.completeExceptionally(exception);\n                        return;\n                    }\n                    \n                    long nextDelay = Math.min(\n                        (long)(currentDelay * policy.getBackoffMultiplier()), \n                        policy.getMaxDelayMs()\n                    );\n                    \n                    logger.warn(\"{} failed (attempt {}/{}), retrying after {}ms: {}\", \n                               operationName, attempt, policy.getMaxAttempts(), currentDelay, \n                               exception.getMessage());\n                    \n                    scheduler.schedule(() -> {\n                        executeAttempt(operation, policy, operationName, attempt + 1, nextDelay)\n                            .whenComplete((retryValue, retryError) -> {\n                                if (retryError == null) {\n                                    result.complete(retryValue);\n                                } else {\n                                    result.completeExceptionally(retryError);\n                                }\n                            });\n                    }, currentDelay, TimeUnit.MILLISECONDS);\n                }\n            });\n            \n        } catch (Exception e) {\n            result.completeExceptionally(e);\n        }\n        \n        return result;\n    }\n    \n    public static <T> T executeWithRetry(Callable<T> operation, RetryPolicy policy, String operationName) throws Exception {\n        return executeWithRetrySync(operation, policy, operationName);\n    }\n    \n    public static <T> T executeWithRetrySync(Callable<T> operation, RetryPolicy policy, String operationName) throws Exception {\n        Exception lastException = null;\n        long currentDelay = policy.getInitialDelayMs();\n        \n        for (int attempt = 1; attempt <= policy.getMaxAttempts(); attempt++) {\n            try {\n                logger.debug(\"Executing {} - Attempt {}/{}\", operationName, attempt, policy.getMaxAttempts());\n                return operation.call();\n            } catch (Exception e) {\n                lastException = e;\n                \n                if (!policy.shouldRetry(e)) {\n                    logger.warn(\"{} failed with non-retryable exception: {}\", operationName, e.getMessage());\n                    throw e;\n                }\n                \n                if (attempt == policy.getMaxAttempts()) {\n                    logger.error(\"{} failed after {} attempts\", operationName, policy.getMaxAttempts());\n                    break;\n                }\n                \n                logger.warn(\"{} failed (attempt {}/{}), retrying after {}ms: {}\", \n                           operationName, attempt, policy.getMaxAttempts(), currentDelay, e.getMessage());\n                \n                Thread.sleep(currentDelay);\n                currentDelay = Math.min((long)(currentDelay * policy.getBackoffMultiplier()), policy.getMaxDelayMs());\n            }\n        }\n        \n        throw lastException;\n    }\n    \n    public static RetryPolicy defaultGrpcPolicy() {\n        return RetryPolicy.builder()\n            .maxAttempts(3)\n            .initialDelay(1000)\n            .maxDelay(10000)\n            .backoffMultiplier(2.0)\n            .retryOn(e -> \n                e.getMessage() != null && (\n                    e.getMessage().contains(\"UNAVAILABLE\") ||\n                    e.getMessage().contains(\"DEADLINE_EXCEEDED\") ||\n                    e.getMessage().contains(\"Connection refused\")\n                )\n            )\n            .build();\n    }\n    \n    public static RetryPolicy defaultApiPolicy() {\n        return RetryPolicy.builder()\n            .maxAttempts(5)\n            .initialDelay(2000)\n            .maxDelay(30000)\n            .backoffMultiplier(2.0)\n            .retryOn(e -> \n                e.getMessage() != null && (\n                    e.getMessage().contains(\"rate limit\") ||\n                    e.getMessage().contains(\"timeout\") ||\n                    e.getMessage().contains(\"503\") ||\n                    e.getMessage().contains(\"429\")\n                )\n            )\n            .build();\n    }\n    \n    public static RetryPolicy conservativePolicy() {\n        return RetryPolicy.builder()\n            .maxAttempts(10)\n            .initialDelay(500)\n            .maxDelay(60000)\n            .backoffMultiplier(1.5)\n            .build();\n    }\n    \n    public static void shutdown() {\n        scheduler.shutdown();\n    }\n}\n","size_bytes":9067},"src/main/java/com/spiketrade/backend/ConfigValidator.java":{"content":"package com.spiketrade.backend;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\npublic class ConfigValidator {\n    private TradingConfig config;\n    private List<String> validationWarnings;\n    private ObjectMapper objectMapper;\n    \n    public ConfigValidator() {\n        this.config = new TradingConfig();\n        this.validationWarnings = new ArrayList<>();\n        this.objectMapper = new ObjectMapper();\n    }\n    \n    public boolean validateIntegerParam(String name, int value, int min, int max) {\n        if (value < min || value > max) {\n            validationWarnings.add(\n                String.format(\"Parameter %s value %d outside valid range [%d, %d]\", \n                    name, value, min, max)\n            );\n            return false;\n        }\n        return true;\n    }\n    \n    public boolean validateDoubleParam(String name, double value, double min, double max) {\n        if (value < min || value > max) {\n            validationWarnings.add(\n                String.format(\"Parameter %s value %f outside valid range [%f, %f]\", \n                    name, value, min, max)\n            );\n            return false;\n        }\n        return true;\n    }\n    \n    public boolean validateConfig(Map<String, String> params) {\n        validationWarnings.clear();\n        boolean valid = true;\n        \n        if (params.containsKey(\"buy_period_minutes\")) {\n            int val = Integer.parseInt(params.get(\"buy_period_minutes\"));\n            valid &= validateIntegerParam(\"buy_period_minutes\", val, 1, 500);\n        }\n        \n        if (params.containsKey(\"data_points\")) {\n            int val = Integer.parseInt(params.get(\"data_points\"));\n            valid &= validateIntegerParam(\"data_points\", val, 1, 1000);\n        }\n        \n        if (params.containsKey(\"combo_signal_threshold\")) {\n            double val = Double.parseDouble(params.get(\"combo_signal_threshold\"));\n            valid &= validateDoubleParam(\"combo_signal_threshold\", val, 0.0, 1.0);\n        }\n        \n        return valid;\n    }\n    \n    /**\n     * Comprehensive validation for TradingConfig object\n     * All parameters must be positive except RSI-related thresholds (which can be negative)\n     * RSI periods must still be positive\n     */\n    public boolean validateTradingConfig(TradingConfig cfg) {\n        validationWarnings.clear();\n        boolean valid = true;\n        \n        // Window parameters - must be positive\n        valid &= validateIntegerParam(\"buyPeriodMinutes\", cfg.buyPeriodMinutes, 1, 500);\n        valid &= validateIntegerParam(\"bbLengthMinutes\", cfg.bbLengthMinutes, 1, 500);\n        valid &= validateIntegerParam(\"rsiLengthMinutes\", cfg.rsiLengthMinutes, 1, 500);\n        valid &= validateIntegerParam(\"priceRocPeriodMinutes\", cfg.priceRocPeriodMinutes, 1, 500);\n        valid &= validateIntegerParam(\"obvRocPeriodMinutes\", cfg.obvRocPeriodMinutes, 1, 500);\n        valid &= validateIntegerParam(\"mfiPeriodMinutes\", cfg.mfiPeriodMinutes, 1, 500);\n        valid &= validateIntegerParam(\"mfiRocPeriodMinutes\", cfg.mfiRocPeriodMinutes, 1, 500);\n        valid &= validateIntegerParam(\"vwapPeriodMinutes\", cfg.vwapPeriodMinutes, 1, 500);\n        valid &= validateIntegerParam(\"dataPoints\", cfg.dataPoints, 1, 5000);\n        valid &= validateIntegerParam(\"warmupDataPoints\", cfg.warmupDataPoints, 1, 1000);\n        \n        // Spike Z-score thresholds - must be strictly positive (> 0)\n        valid &= validateDoubleParam(\"spikePriceRocZThreshold\", cfg.spikePriceRocZThreshold, 0.0001, 10.0);\n        valid &= validateDoubleParam(\"spikeRsiRocZThreshold\", cfg.spikeRsiRocZThreshold, 0.0001, 10.0);\n        valid &= validateDoubleParam(\"spikeObvRocZThreshold\", cfg.spikeObvRocZThreshold, 0.0001, 10.0);\n        valid &= validateDoubleParam(\"spikeMfiRocZThreshold\", cfg.spikeMfiRocZThreshold, 0.0001, 10.0);\n        valid &= validateDoubleParam(\"spikePercentBRocZThreshold\", cfg.spikePercentBRocZThreshold, 0.0001, 10.0);\n        valid &= validateDoubleParam(\"spikeVwapRocZThreshold\", cfg.spikeVwapRocZThreshold, 0.0001, 10.0);\n        valid &= validateDoubleParam(\"spikeVolumeRocZThreshold\", cfg.spikeVolumeRocZThreshold, 0.0001, 10.0);\n        \n        // Regular ROC thresholds - must be strictly positive (EXCEPT RSI which can be negative)\n        valid &= validateDoubleParam(\"regularPriceRocThreshold\", cfg.regularPriceRocThreshold, 0.0001, 100.0);\n        // RSI ROC threshold CAN be negative (mean reversion strategy)\n        valid &= validateDoubleParam(\"regularRsiRocThreshold\", cfg.regularRsiRocThreshold, -100.0, 100.0);\n        valid &= validateDoubleParam(\"regularObvRocThreshold\", cfg.regularObvRocThreshold, 0.0001, 1000.0);\n        valid &= validateDoubleParam(\"regularMfiRocThreshold\", cfg.regularMfiRocThreshold, 0.0001, 100.0);\n        valid &= validateDoubleParam(\"regularPercentBRocThreshold\", cfg.regularPercentBRocThreshold, 0.0001, 100.0);\n        valid &= validateDoubleParam(\"regularVwapRocThreshold\", cfg.regularVwapRocThreshold, 0.0001, 100.0);\n        valid &= validateDoubleParam(\"regularVolumeRocThreshold\", cfg.regularVolumeRocThreshold, 0.0001, 1000.0);\n        \n        // Regular ROC periods - must be positive\n        valid &= validateIntegerParam(\"regularPriceRocPeriod\", cfg.regularPriceRocPeriod, 1, 500);\n        valid &= validateIntegerParam(\"regularRsiRocPeriod\", cfg.regularRsiRocPeriod, 1, 500);\n        valid &= validateIntegerParam(\"regularObvRocPeriod\", cfg.regularObvRocPeriod, 1, 500);\n        valid &= validateIntegerParam(\"regularMfiRocPeriod\", cfg.regularMfiRocPeriod, 1, 500);\n        valid &= validateIntegerParam(\"regularPercentBRocPeriod\", cfg.regularPercentBRocPeriod, 1, 500);\n        valid &= validateIntegerParam(\"regularVwapRocPeriod\", cfg.regularVwapRocPeriod, 1, 500);\n        valid &= validateIntegerParam(\"regularVolumeRocPeriod\", cfg.regularVolumeRocPeriod, 1, 500);\n        \n        // Signal and risk parameters - must be strictly positive (> 0)\n        valid &= validateDoubleParam(\"comboSignalThreshold\", cfg.comboSignalThreshold, 0.0001, 1.0);\n        valid &= validateDoubleParam(\"highProbThreshold\", cfg.highProbThreshold, 0.0001, 1.0);\n        valid &= validateDoubleParam(\"stopLossPct\", cfg.stopLossPct, 0.0001, 1.0);\n        valid &= validateDoubleParam(\"initialProfitFloorPct\", cfg.initialProfitFloorPct, 0.0001, 1.0);\n        valid &= validateDoubleParam(\"subsequentProfitFloorPct\", cfg.subsequentProfitFloorPct, 0.0001, 1.0);\n        valid &= validateDoubleParam(\"spikeCooldownStddevThreshold\", cfg.spikeCooldownStddevThreshold, 0.0001, 10.0);\n        \n        // Trading capital parameters - must be positive\n        valid &= validateDoubleParam(\"equityPerTrade\", cfg.equityPerTrade, 1.0, 1000000.0);\n        valid &= validateDoubleParam(\"maxOpenTrades\", cfg.maxOpenTrades, 1.0, 100.0);\n        valid &= validateDoubleParam(\"totalEquityAvailable\", cfg.totalEquityAvailable, 1.0, 10000000.0);\n        \n        if (!valid) {\n            System.err.println(\"Configuration validation failed:\");\n            for (String warning : validationWarnings) {\n                System.err.println(\"  - \" + warning);\n            }\n        }\n        \n        return valid;\n    }\n    \n    public boolean loadFromJson(String filepath) {\n        try {\n            File file = new File(filepath);\n            if (!file.exists()) {\n                return false;\n            }\n            this.config = objectMapper.readValue(file, TradingConfig.class);\n            return true;\n        } catch (IOException e) {\n            System.err.println(\"Error loading config from JSON: \" + e.getMessage());\n            return false;\n        }\n    }\n    \n    public boolean saveToJson(String filepath) {\n        try {\n            objectMapper.writerWithDefaultPrettyPrinter()\n                .writeValue(new File(filepath), config);\n            return true;\n        } catch (IOException e) {\n            System.err.println(\"Error saving config to JSON: \" + e.getMessage());\n            return false;\n        }\n    }\n    \n    public TradingConfig getConfig() {\n        return config;\n    }\n    \n    public List<String> getWarnings() {\n        return validationWarnings;\n    }\n}\n","size_bytes":8264},"src/main/java/com/spiketrade/backend/SpikeAnalyzer.java":{"content":"package com.spiketrade.backend;\n\nimport java.time.Instant;\nimport java.time.ZonedDateTime;\nimport java.time.ZoneId;\nimport java.time.LocalDate;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class SpikeAnalyzer {\n    private SpikeAnalysisConfig config;\n    private final Map<String, Deque<Candle>> candleData;\n    private final Map<String, List<SpikeRecord>> spikeHistory;\n    private final Object lock = new Object();\n    private final PredictionEngine predictionEngine;\n    private double targetGainPercent = 2.0;\n    \n    public SpikeAnalyzer(SpikeAnalysisConfig config) {\n        this.config = config;\n        this.candleData = new ConcurrentHashMap<>();\n        this.spikeHistory = new ConcurrentHashMap<>();\n        this.predictionEngine = new PredictionEngine();\n    }\n    \n    public void setTargetGainPercent(double targetGainPercent) {\n        synchronized (lock) {\n            this.targetGainPercent = targetGainPercent;\n        }\n    }\n    \n    public double getTargetGainPercent() {\n        synchronized (lock) {\n            return this.targetGainPercent;\n        }\n    }\n    \n    public void updateConfig(SpikeAnalysisConfig newConfig) {\n        synchronized (lock) {\n            this.config = newConfig;\n            System.out.println(\"SpikeAnalyzer config updated:\");\n            System.out.println(\"  - Statistical threshold: \" + config.statisticalThreshold);\n            System.out.println(\"  - Quality score threshold: \" + config.qualityScoreThreshold);\n            System.out.println(\"  - Spike cooldown threshold: \" + config.spikeCooldownStddevThreshold);\n        }\n    }\n    \n    public SpikeAnalysisConfig getConfig() {\n        synchronized (lock) {\n            return config;\n        }\n    }\n    \n    public void addCandle(String symbol, Candle candle) {\n        synchronized (lock) {\n            candleData.putIfAbsent(symbol, new ArrayDeque<>());\n            Deque<Candle> candles = candleData.get(symbol);\n            candles.addLast(candle);\n            \n            if (candles.size() > 500) {\n                candles.removeFirst();\n            }\n        }\n    }\n    \n    // FIX #5: Calculate 20-bar average volume for liquidity filtering\n    public double getAverageVolume(String symbol) {\n        synchronized (lock) {\n            if (!candleData.containsKey(symbol)) return 0.0;\n            \n            Deque<Candle> candles = candleData.get(symbol);\n            if (candles.size() < 20) return 0.0;\n            \n            // Get last 20 candles\n            List<Candle> recentCandles = new ArrayList<>(candles);\n            int startIdx = Math.max(0, recentCandles.size() - 20);\n            List<Candle> last20 = recentCandles.subList(startIdx, recentCandles.size());\n            \n            long totalVolume = 0;\n            for (Candle c : last20) {\n                totalVolume += c.volume;\n            }\n            \n            return totalVolume / 20.0;\n        }\n    }\n    \n    public List<SpikeRecord> detectSpikes(String symbol) {\n        synchronized (lock) {\n            List<SpikeRecord> spikes = new ArrayList<>();\n            \n            if (!candleData.containsKey(symbol)) return spikes;\n            Deque<Candle> candles = candleData.get(symbol);\n            if (candles.size() < 50) return spikes;\n            \n            List<Double> priceRocs = new ArrayList<>();\n            List<Double> closes = new ArrayList<>();\n            for (Candle c : candles) {\n                closes.add(c.close);\n            }\n            \n            for (int i = 20; i < closes.size(); i++) {\n                double roc = ((closes.get(i) - closes.get(i - 20)) / closes.get(i - 20)) * 100.0;\n                priceRocs.add(roc);\n            }\n            \n            double zScore = calculateZScore(priceRocs);\n            \n            if (Math.abs(zScore) > config.statisticalThreshold) {\n                Candle lastCandle = ((ArrayDeque<Candle>) candles).getLast();\n                SpikeRecord spike = new SpikeRecord();\n                spike.timestamp = lastCandle.timestamp;\n                spike.symbol = symbol;\n                spike.spikeType = \"price_roc\";\n                spike.magnitude = zScore;\n                spike.priceAtSpike = lastCandle.close;\n                spike.volumeAtSpike = lastCandle.volume;\n                spike.statisticalZScore = zScore;\n                spike.isRootSpike = false;\n                spike.usedForSignal = false;\n                \n                spikes.add(spike);\n            }\n            \n            return spikes;\n        }\n    }\n    \n    public BuySignal analyzeBuySignal(String symbol) {\n        synchronized (lock) {\n            if (!candleData.containsKey(symbol)) return null;\n            \n            Deque<Candle> candles = candleData.get(symbol);\n            // No minimum candle requirement - use what's available\n            \n            List<Double> closes = new ArrayList<>();\n            List<Double> volumes = new ArrayList<>();\n            List<Candle> candleList = new ArrayList<>(candles);\n            \n            for (Candle c : candleList) {\n                closes.add(c.close);\n                volumes.add((double) c.volume);\n            }\n            \n            // Calculate all indicators using configured periods\n            double rsi = calculateRSI(closes, config.rsiLengthMinutes);\n            double mfi = calculateMFI(candleList, config.mfiPeriodMinutes);\n            double priceRoc = calculateROC(closes, config.regularPriceRocPeriod);\n            double rsiRoc = calculateROC(calculateRSIValues(closes, config.rsiLengthMinutes), config.regularRsiRocPeriod);\n            double volumeRoc = calculateROC(volumes, config.regularVolumeRocPeriod);\n            \n            // Calculate OBV and its ROC\n            List<Double> obvValues = new ArrayList<>();\n            double obv = 0;\n            for (int i = 1; i < candleList.size(); i++) {\n                obv += (candleList.get(i).close > candleList.get(i - 1).close) \n                    ? candleList.get(i).volume \n                    : -candleList.get(i).volume;\n                obvValues.add(obv);\n            }\n            double obvRoc = calculateROC(obvValues, config.regularObvRocPeriod);\n            \n            // Calculate MFI ROC\n            List<Double> mfiValues = calculateMFIValues(candleList, config.mfiPeriodMinutes);\n            double mfiRoc = calculateROC(mfiValues, config.regularMfiRocPeriod);\n            \n            // Calculate Bollinger Bands %B\n            List<Double> percentBValues = calculateBollingerPercentB(closes, config.bbLengthMinutes);\n            double percentBRoc = calculateROC(percentBValues, config.regularPercentBRocPeriod);\n            \n            // Calculate VWAP\n            List<Double> vwapValues = calculateVWAP(candleList, config.vwapPeriodMinutes);\n            double vwapRoc = calculateROC(vwapValues, config.regularVwapRocPeriod);\n            \n            // ===== CALCULATE NEW PENNY STOCK INDICATORS FOR SIGNAL LOGIC =====\n            \n            // MACD - use configured periods (optimized for volatile 1-min candles)\n            double[] macd = calculateMACD(closes, config.macdFastPeriod, config.macdSlowPeriod, config.macdSignalPeriod);\n            double macdLine = macd[0];\n            double macdSignal = macd[1];\n            double macdHistogram = macd[2];\n            \n            // Calculate MACD Histogram ROC (predictive convergence indicator)\n            // Formula: r_t = (H_t - H_{t-1}) / P_t\n            // This measures how quickly the histogram is converging (bullish acceleration)\n            double macdHistogramRoc = 0.0;\n            if (closes.size() >= 2) {\n                // Get previous histogram by calculating MACD for the window excluding last candle\n                List<Double> closesMinusOne = closes.subList(0, closes.size() - 1);\n                if (closesMinusOne.size() >= Math.max(config.macdFastPeriod, config.macdSlowPeriod)) {\n                    double[] macdPrev = calculateMACD(closesMinusOne, config.macdFastPeriod, config.macdSlowPeriod, config.macdSignalPeriod);\n                    double macdHistogramPrev = macdPrev[2];\n                    \n                    // Calculate discrete rate of change\n                    double deltaH = macdHistogram - macdHistogramPrev;\n                    \n                    // Normalize to current price (as % of price)\n                    double currentPrice = closes.get(closes.size() - 1);\n                    macdHistogramRoc = deltaH / currentPrice;\n                }\n            }\n            \n            // EMAs - use configured periods\n            double ema9 = calculateEMA(closes, config.ema9Period);\n            double ema20 = calculateEMA(closes, config.ema20Period);\n            double ema50 = calculateEMA(closes, config.ema50Period);\n            \n            // Stochastic Oscillator - use configured periods\n            double[] stoch = calculateStochastic(candleList, config.stochasticPeriod, config.stochasticKSmooth, config.stochasticDSmooth);\n            double stochK = stoch[0];\n            double stochD = stoch[1];\n            \n            // Relative Volume - use configured period\n            double rvol = calculateRVOL(candleList, config.rvolPeriod);\n            \n            // Volume Spike Detection - use configured threshold\n            double[] volSpike = detectVolumeSpike(candleList, config.rvolPeriod, config.volumeSpikeThreshold);\n            boolean hasVolumeSpike = volSpike[0] > 0;\n            double volumeRatio = volSpike[1];\n            \n            // Current price (for EMA position checks)\n            double currentPrice = closes.get(closes.size() - 1);\n            \n            // Current Bollinger %B value\n            double percentB = percentBValues.isEmpty() ? 0.5 : percentBValues.get(percentBValues.size() - 1);\n            \n            // Calculate spike Z-scores using configured thresholds and periods\n            double priceRocZScore = calculateZScoreForList(closes, config.regularPriceRocPeriod);\n            double rsiRocZScore = calculateZScoreForList(calculateRSIValues(closes, config.rsiLengthMinutes), config.regularRsiRocPeriod);\n            double obvRocZScore = calculateZScoreForList(obvValues, config.regularObvRocPeriod);\n            double mfiRocZScore = calculateZScoreForList(mfiValues, config.regularMfiRocPeriod);\n            double percentBRocZScore = calculateZScoreForList(percentBValues, config.regularPercentBRocPeriod);\n            double vwapRocZScore = calculateZScoreForList(vwapValues, config.regularVwapRocPeriod);\n            double volumeRocZScore = calculateZScoreForList(volumes, config.regularVolumeRocPeriod);\n            \n            // Detect spikes using individual configured thresholds\n            // ONLY POSITIVE z-scores (bullish momentum) count for buy signals\n            boolean priceSpike = priceRocZScore > config.spikePriceRocZThreshold;\n            boolean rsiSpike = rsiRocZScore > config.spikeRsiRocZThreshold;\n            boolean obvSpike = obvRocZScore > config.spikeObvRocZThreshold;\n            boolean mfiSpike = mfiRocZScore > config.spikeMfiRocZThreshold;\n            boolean percentBSpike = percentBRocZScore > config.spikePercentBRocZThreshold;\n            boolean vwapSpike = vwapRocZScore > config.spikeVwapRocZThreshold;\n            boolean volumeSpike = volumeRocZScore > config.spikeVolumeRocZThreshold;\n            \n            // Check if at least one spike has been detected\n            if (!priceSpike && !rsiSpike && !obvSpike && !mfiSpike && !percentBSpike && !vwapSpike && !volumeSpike) {\n                System.out.println(String.format(\"No spikes detected for %s, blocking buy signal\", symbol));\n                return null;\n            }\n            \n            // ========== BUILD SIGNAL PROBABILITY RESPECTING ALL SIGNAL RULES ==========\n            // Count enabled conditions and check which ones are met\n            int enabledConditions = 0;\n            int metConditions = 0;\n            \n            // 1. Spike quality check (if enabled)\n            if (config.useMlSpikes) {\n                enabledConditions++;\n                if (priceSpike || volumeSpike || rsiSpike || obvSpike || mfiSpike || percentBSpike || vwapSpike) {\n                    metConditions++;\n                }\n            }\n            \n            // 2. Price condition (if enabled)\n            if (config.enablePriceRocSpike) {\n                enabledConditions++;\n                if (priceRoc > config.regularPriceRocThreshold) {\n                    metConditions++;\n                }\n            }\n            \n            // 3. RSI condition (if enabled) - NOW USES CONFIGURED THRESHOLD\n            if (config.enableRsiRocSpike) {\n                enabledConditions++;\n                // Check if RSI ROC exceeds configured threshold (positive momentum)\n                if (rsiRoc > config.regularRsiRocThreshold) {\n                    metConditions++;\n                }\n            }\n            \n            // 4. OBV condition (if enabled)\n            if (config.enableObvRocSpike) {\n                enabledConditions++;\n                // Check if OBV ROC exceeds configured threshold (positive momentum only)\n                if (obvRoc > config.regularObvRocThreshold) {\n                    metConditions++;\n                }\n            }\n            \n            // 5. MFI condition (if enabled) - REMOVED restrictive volumeRoc requirement\n            if (config.enableMfiRocSpike) {\n                enabledConditions++;\n                // MFI already incorporates volume, don't need extra volume check\n                if (mfiRoc > config.regularMfiRocThreshold) {\n                    metConditions++;\n                }\n            }\n            \n            // 6. Bollinger %B condition (if enabled) - NOW USING ACTUAL PERCENT B\n            if (config.enablePercentBRocSpike) {\n                enabledConditions++;\n                // %B ROC > threshold indicates strong momentum through bands\n                if (percentBRoc > config.regularPercentBRocThreshold) {\n                    metConditions++;\n                }\n            }\n            \n            // 7. VWAP condition (if enabled) - NOW USING ACTUAL VWAP ROC\n            if (config.enableVwapRocSpike) {\n                enabledConditions++;\n                // VWAP ROC > threshold indicates price moving above volume-weighted average\n                if (vwapRoc > config.regularVwapRocThreshold) {\n                    metConditions++;\n                }\n            }\n            \n            // 8. Volume spike condition (if enabled)\n            if (config.enableVolumeRocSpike) {\n                enabledConditions++;\n                if (volumeSpike) {\n                    metConditions++;\n                }\n            }\n            \n            // ========== GLOBAL BULLISH VALIDATOR (RESPECTS ENABLE FLAGS) ==========\n            // Only check enabled indicators for bullish condition\n            // Disabled indicators should not block signal generation\n            if (config.enablePriceRocSpike && priceRoc <= 0) {\n                return null;  // Enabled Price ROC is bearish\n            }\n            if (config.enableVolumeRocSpike && volumeRoc <= 0) {\n                return null;  // Enabled Volume ROC is bearish\n            }\n            if (config.enableObvRocSpike && obvRoc <= 0) {\n                return null;  // Enabled OBV ROC is bearish\n            }\n            if (config.enableMfiRocSpike && mfiRoc <= 0) {\n                return null;  // Enabled MFI ROC is bearish\n            }\n            if (config.enablePercentBRocSpike && percentBRoc <= 0) {\n                return null;  // Enabled Bollinger %B ROC is bearish\n            }\n            if (config.enableVwapRocSpike && vwapRoc <= 0) {\n                return null;  // Enabled VWAP ROC is bearish\n            }\n            \n            // ===== PENNY STOCK INDICATOR FILTERS =====\n            // These are HARD REQUIREMENTS for penny stock trading, not soft probability contributors\n            \n            // MACD Histogram ROC Filter: Predictive convergence detection (early warning before crossover)\n            // Triggers when histogram is still negative BUT accelerating toward bullish crossover\n            // Formula: histogram <= 0 AND (histogram_roc >= threshold)\n            // This catches bullish momentum BEFORE the MACD line crosses the signal line\n            if (config.enableMacdHistogramRoc) {\n                // Convert threshold from % (e.g., 0.5) to decimal (0.005)\n                double thresholdDecimal = config.macdHistogramRocThreshold / 100.0;\n                \n                // Check predictive trigger: histogram at/below zero AND rising fast enough\n                if (!(macdHistogram <= 0 && macdHistogramRoc >= thresholdDecimal)) {\n                    System.out.println(String.format(\"Blocking buy signal for %s: MACD Histogram ROC not triggering - Histogram=%.4f, ROC=%.6f (need <=0 and >=%6f)\", \n                                                     symbol, macdHistogram, macdHistogramRoc, thresholdDecimal));\n                    return null;  // Predictive convergence not detected\n                }\n            }\n            \n            // Stochastic Filter: Require oversold condition (for mean reversion) if enabled\n            if (config.enableStochasticIndicator && stochK >= config.stochasticOversoldThreshold) {\n                System.out.println(String.format(\"Blocking buy signal for %s: Stochastic K (%.2f) not oversold - need < %.2f for mean reversion\", \n                                                 symbol, stochK, config.stochasticOversoldThreshold));\n                return null;  // Stochastic not oversold\n            }\n            \n            // RVOL Filter: Require unusual volume activity if enabled\n            if (config.enableRvolIndicator && rvol <= config.rvolThreshold) {\n                System.out.println(String.format(\"Blocking buy signal for %s: RVOL (%.2f) too low - need > %.2f for unusual volume\", \n                                                 symbol, rvol, config.rvolThreshold));\n                return null;  // RVOL not high enough\n            }\n            \n            // ===== PENNY STOCK EMA TREND FILTER =====\n            // Avoid trades when price is below ALL 3 EMAs (strong downtrend)\n            if (config.enableEmaTrendFilter) {\n                if (ema9 > 0 && ema20 > 0 && ema50 > 0) {  // Only check if EMAs are calculated\n                    if (currentPrice < ema9 && currentPrice < ema20 && currentPrice < ema50) {\n                        System.out.println(String.format(\"Blocking buy signal for %s: Price (%.2f) below all 3 EMAs (EMA9=%.2f, EMA20=%.2f, EMA50=%.2f) - strong downtrend\", \n                                                         symbol, currentPrice, ema9, ema20, ema50));\n                        return null;  // Price below all EMAs indicates strong downtrend\n                    }\n                }\n            }\n            \n            // FIX #3: Use proper probabilistic model instead of simple averaging\n            // Create temporary indicators object for probability calculation\n            IndicatorsData tempIndicators = new IndicatorsData();\n            tempIndicators.rsi = rsi;\n            tempIndicators.priceRoc = priceRoc;\n            tempIndicators.volumeRoc = volumeRoc;\n            tempIndicators.obvRoc = obvRoc;\n            tempIndicators.mfiRoc = mfiRoc;\n            tempIndicators.percentB = percentBValues.isEmpty() ? 0.5 : percentBValues.get(percentBValues.size() - 1);\n            tempIndicators.vwapRoc = vwapRoc;\n            \n            // Use logistic regression-based probability calculation\n            ProbabilityCalibrator calibrator = new ProbabilityCalibrator();\n            \n            // Apply probability scaling from config (controlled by highProbThreshold slider)\n            // This allows users to adjust the overall probability range\n            calibrator.setProbabilityScale(config.highProbThreshold * 2.0);  // Scale 0.5-1.0 slider to 1.0-2.0 range\n            \n            double signalProbability = calibrator.calculateCalibratedProbability(tempIndicators, true);\n            \n            // RE-ENABLED PROBABILITY FILTER: Only generate signal if probability exceeds combo threshold\n            // This makes the comboSignalThreshold slider actually work!\n            if (enabledConditions == 0) {\n                return null;  // No enabled conditions\n            }\n            \n            if (signalProbability < config.comboSignalThreshold) {\n                System.out.println(String.format(\"Blocking buy signal for %s: Probability %.1f%% below threshold %.1f%%\",\n                                                 symbol, signalProbability * 100, config.comboSignalThreshold * 100));\n                return null;  // Probability too low\n            }\n            \n            // Create buy signal\n            BuySignal signal = new BuySignal();\n            signal.timestamp = Instant.now();\n            signal.symbol = symbol;\n            signal.signalProbability = signalProbability;\n            signal.reason = String.format(\"Buy signal: %d/%d conditions met (%.1f%% probability)\", \n                                         metConditions, enabledConditions, signalProbability * 100);\n            \n            // Populate ALL calculated indicators\n            IndicatorsData indicators = new IndicatorsData();\n            indicators.rsi = rsi;\n            indicators.mfi = mfi;\n            indicators.priceRoc = priceRoc;\n            indicators.volumeRoc = volumeRoc;\n            indicators.obv = obvValues.isEmpty() ? 0 : obvValues.get(obvValues.size() - 1);\n            \n            // Add ROC values for all indicators\n            indicators.rsiRoc = rsiRoc;\n            indicators.obvRoc = obvRoc;\n            indicators.mfiRoc = mfiRoc;\n            \n            // Add Bollinger Bands and %B values\n            if (!percentBValues.isEmpty()) {\n                indicators.percentB = percentBValues.get(percentBValues.size() - 1);\n                indicators.percentBRoc = percentBRoc;\n                indicators.bollingerPosition = indicators.percentB;  // Same as %B\n                indicators.bollingerPosRoc = percentBRoc;\n                \n                // Calculate Bollinger upper and lower bands for current price\n                int period = config.bbLengthMinutes;\n                if (closes.size() >= period) {\n                    double sum = 0;\n                    for (int i = closes.size() - period; i < closes.size(); i++) {\n                        sum += closes.get(i);\n                    }\n                    double sma = sum / period;\n                    \n                    double sqSum = 0;\n                    for (int i = closes.size() - period; i < closes.size(); i++) {\n                        double diff = closes.get(i) - sma;\n                        sqSum += diff * diff;\n                    }\n                    double stdev = Math.sqrt(sqSum / period);\n                    \n                    indicators.bollingerUpper = sma + 2 * stdev;\n                    indicators.bollingerLower = sma - 2 * stdev;\n                }\n            }\n            \n            // Add VWAP values\n            if (!vwapValues.isEmpty()) {\n                indicators.vwap = vwapValues.get(vwapValues.size() - 1);\n                indicators.vwapRoc = vwapRoc;\n            }\n            \n            // ===== ADD NEW PENNY STOCK INDICATORS (already calculated earlier) =====\n            \n            // Add MACD values (calculated earlier)\n            indicators.macdLine = macdLine;\n            indicators.macdSignal = macdSignal;\n            indicators.macdHistogram = macdHistogram;\n            indicators.macdHistogramRoc = macdHistogramRoc;\n            \n            // Add EMA values (calculated earlier)\n            indicators.ema9 = ema9;\n            indicators.ema20 = ema20;\n            indicators.ema50 = ema50;\n            \n            // Add Stochastic values (calculated earlier)\n            indicators.stochK = stochK;\n            indicators.stochD = stochD;\n            \n            // Add Relative Volume (calculated earlier)\n            indicators.rvol = rvol;\n            \n            // Add Volume Spike (calculated earlier)\n            indicators.volumeSpike = hasVolumeSpike;\n            indicators.volumeRatio = volumeRatio;\n            \n            // Add ATR (Average True Range) for volatility measurement\n            indicators.atr = calculateATR(candleList, 14);  // Standard 14-period ATR\n            \n            signal.indicators = indicators;\n            \n            // Create spike records for detected spikes\n            List<SpikeRecord> spikes = new ArrayList<>();\n            Candle lastCandle = candleList.get(candleList.size() - 1);\n            \n            if (priceSpike && config.enablePriceRocSpike) {\n                SpikeRecord spike = new SpikeRecord();\n                spike.timestamp = lastCandle.timestamp;\n                spike.symbol = symbol;\n                spike.spikeType = \"price_roc\";\n                spike.magnitude = priceRocZScore;\n                spike.priceAtSpike = lastCandle.close;\n                spike.volumeAtSpike = lastCandle.volume;\n                spike.statisticalZScore = priceRocZScore;\n                spikes.add(spike);\n            }\n            \n            if (volumeSpike && config.enableVolumeRocSpike) {\n                SpikeRecord spike = new SpikeRecord();\n                spike.timestamp = lastCandle.timestamp;\n                spike.symbol = symbol;\n                spike.spikeType = \"volume_roc\";\n                spike.magnitude = volumeRocZScore;\n                spike.priceAtSpike = lastCandle.close;\n                spike.volumeAtSpike = lastCandle.volume;\n                spike.statisticalZScore = volumeRocZScore;\n                spikes.add(spike);\n            }\n            \n            signal.spikes = spikes;\n            \n            // Store spikes in spike history for tracking\n            if (!spikes.isEmpty()) {\n                spikeHistory.putIfAbsent(symbol, new ArrayList<>());\n                List<SpikeRecord> history = spikeHistory.get(symbol);\n                history.addAll(spikes);\n                \n                // Keep history limited to prevent memory issues\n                if (history.size() > config.maxSpikeHistory) {\n                    history.subList(0, history.size() - config.maxSpikeHistory).clear();\n                }\n                \n                System.out.println(String.format(\"Recorded %d spike(s) for %s. Total spikes for symbol: %d\", \n                                                spikes.size(), symbol, history.size()));\n            }\n            \n            System.out.println(String.format(\"Generated buy signal for %s: probability=%.2f, conditions=%d/%d\", \n                                            symbol, signalProbability, metConditions, enabledConditions));\n            \n            // FIX: Pass ROC periods to prediction engine for accurate timeframe calculations\n            PredictionEngine.PredictionResult prediction = predictionEngine.predictTimeToTarget(\n                symbol, signal, targetGainPercent,\n                config.regularPriceRocPeriod,\n                config.regularRsiRocPeriod,\n                config.regularVolumeRocPeriod);\n            \n            if (prediction != null) {\n                signal.predictedGainTarget = prediction.targetGainPercent;\n                signal.predictedTimeToTargetMinutes = prediction.predictedMinutes;\n                signal.predictionConfidence = prediction.confidence;\n                signal.predictionReasoning = prediction.reasoning;\n                \n                System.out.println(String.format(\"Prediction for %s: Target %.1f%% gain in %s (confidence: %.1f%%)\",\n                    symbol, prediction.targetGainPercent, prediction.getFormattedTimeframe(), \n                    prediction.confidence * 100));\n            }\n            \n            return signal;\n        }\n    }\n    \n    // Helper method to calculate RSI values series for ROC calculation\n    private List<Double> calculateRSIValues(List<Double> prices, int period) {\n        List<Double> rsiValues = new ArrayList<>();\n        if (prices.size() < period + 1) return rsiValues;\n        \n        // Calculate RSI for each point where we have enough historical data\n        // Using a minimal window of period+1 prices (generates period price changes)\n        for (int i = period; i < prices.size(); i++) {\n            // Use a sliding window of the last period+1 prices\n            int windowStart = Math.max(0, i - period);\n            List<Double> window = prices.subList(windowStart, i + 1);\n            // Ensure we have enough data for RSI calculation\n            if (window.size() >= period + 1) {\n                rsiValues.add(calculateRSI(window, period));\n            }\n        }\n        return rsiValues;\n    }\n    \n    // Helper method to calculate MFI values series for ROC calculation\n    private List<Double> calculateMFIValues(List<Candle> candles, int period) {\n        List<Double> mfiValues = new ArrayList<>();\n        if (candles.size() < period + 1) return mfiValues;\n        \n        for (int i = period; i < candles.size(); i++) {\n            List<Candle> window = candles.subList(Math.max(0, i - period * 2), i + 1);\n            mfiValues.add(calculateMFI(window, period));\n        }\n        return mfiValues;\n    }\n    \n    public SellWarning analyzeSellWarning(String symbol) {\n        synchronized (lock) {\n            if (!candleData.containsKey(symbol)) return null;\n            \n            Deque<Candle> candles = candleData.get(symbol);\n            if (candles.size() < 100) return null;\n            \n            // Calculate comprehensive indicators (mirroring buy signal logic)\n            List<Double> closes = new ArrayList<>();\n            List<Double> volumes = new ArrayList<>();\n            List<Candle> candleList = new ArrayList<>(candles);\n            \n            for (Candle c : candleList) {\n                closes.add(c.close);\n                volumes.add((double) c.volume);\n            }\n            \n            // Calculate RSI\n            double rsi = calculateRSI(closes, 14);\n            \n            // Calculate Price ROC\n            double priceRoc = calculateROC(closes, 20);\n            \n            // Calculate Volume ROC\n            double volumeRoc = calculateROC(volumes, 20);\n            \n            // Calculate Z-scores for spike detection\n            double priceRocZScore = calculateZScoreForList(closes, 20);\n            double volumeRocZScore = calculateZScoreForList(volumes, 20);\n            \n            // Spike detection (negative spikes indicate sharp drops)\n            boolean priceDownSpike = priceRocZScore < -1.5;\n            boolean volumeSpike = Math.abs(volumeRocZScore) > 1.5;\n            \n            // Overbought condition (opposite of oversold for buy signals)\n            boolean rsiOverbought = rsi > 60;\n            \n            // Composite sell warning probability (mirrors buy signal logic with inverted conditions)\n            double warningProbability = 0.0;\n            int conditions = 0;\n            \n            // 1. Spike quality (negative price spike or volume spike)\n            if (priceDownSpike || volumeSpike) {\n                warningProbability += 0.30;\n                conditions++;\n            }\n            \n            // 2. Price condition (negative price ROC indicates downtrend)\n            if (priceRoc < -0.5) {\n                warningProbability += 0.15;\n                conditions++;\n            }\n            \n            // 3. RSI overbought condition\n            if (rsiOverbought) {\n                warningProbability += 0.15;\n                conditions++;\n            }\n            \n            // 4. Volume condition (declining volume with falling price)\n            if (volumeRoc < -0.3) {\n                warningProbability += 0.10;\n                conditions++;\n            }\n            \n            // 5. Money flow (negative volume and price momentum)\n            if (volumeRoc < 0 && priceRoc < 0) {\n                warningProbability += 0.10;\n                conditions++;\n            }\n            \n            // 6. Momentum condition (strong negative price movement)\n            if (priceRoc < -1.0) {\n                warningProbability += 0.10;\n                conditions++;\n            }\n            \n            // 7. Combined negative momentum\n            if (priceRoc < 0 && volumeRoc < 0) {\n                warningProbability += 0.05;\n                conditions++;\n            }\n            \n            // 8. Trend strength (large absolute price movement)\n            if (Math.abs(priceRoc) > 1.0) {\n                warningProbability += 0.05;\n                conditions++;\n            }\n            \n            // 9. Volume spike with negative price movement\n            if (volumeSpike && priceRoc < 0) {\n                warningProbability += 0.10;\n                conditions++;\n            }\n            \n            // Threshold for sell warning (using similar threshold to buy signals ~0.7)\n            if (warningProbability >= 0.5) {\n                SellWarning warning = new SellWarning();\n                warning.timestamp = Instant.now();\n                warning.symbol = symbol;\n                \n                // Create full indicators data\n                IndicatorsData indicators = new IndicatorsData();\n                indicators.rsi = rsi;\n                indicators.priceRoc = priceRoc;\n                indicators.volumeRoc = volumeRoc;\n                indicators.mfi = calculateMFI(candleList, 14);\n                \n                // Calculate OBV\n                double obv = 0;\n                for (int i = 1; i < candleList.size(); i++) {\n                    obv += (candleList.get(i).close > candleList.get(i - 1).close) \n                        ? candleList.get(i).volume \n                        : -candleList.get(i).volume;\n                }\n                indicators.obv = obv;\n                \n                warning.indicators = indicators;\n                \n                Candle lastCandle = candleList.get(candleList.size() - 1);\n                warning.price = lastCandle.close;\n                warning.warningProbability = Math.min(warningProbability, 1.0);\n                warning.reason = String.format(\"Sell warning: %d bearish conditions detected (%.1f%% probability)\", \n                                              conditions, warningProbability * 100);\n                \n                return warning;\n            }\n            \n            return null;\n        }\n    }\n    \n    private double calculateZScoreForList(List<Double> values, int period) {\n        if (values.size() < period + 1) return 0.0;\n        \n        List<Double> rocs = new ArrayList<>();\n        for (int i = period; i < values.size(); i++) {\n            double roc = ((values.get(i) - values.get(i - period)) / values.get(i - period)) * 100.0;\n            rocs.add(roc);\n        }\n        \n        if (rocs.isEmpty()) return 0.0;\n        \n        double sum = 0;\n        for (double v : rocs) {\n            sum += v;\n        }\n        double mean = sum / rocs.size();\n        \n        double sqSum = 0;\n        for (double v : rocs) {\n            sqSum += (v - mean) * (v - mean);\n        }\n        double stdev = Math.sqrt(sqSum / rocs.size());\n        \n        if (stdev == 0) return 0.0;\n        return (rocs.get(rocs.size() - 1) - mean) / stdev;\n    }\n    \n    public IndicatorsData calculateIndicators(String symbol) {\n        synchronized (lock) {\n            IndicatorsData ind = new IndicatorsData();\n            if (!candleData.containsKey(symbol)) return ind;\n            \n            Deque<Candle> candles = candleData.get(symbol);\n            if (candles.isEmpty()) return ind;\n            \n            List<Double> closes = new ArrayList<>();\n            List<Double> volumes = new ArrayList<>();\n            List<Candle> candleList = new ArrayList<>(candles);\n            \n            for (Candle c : candleList) {\n                closes.add(c.close);\n                volumes.add((double) c.volume);\n            }\n            \n            // Calculate basic indicators\n            ind.rsi = calculateRSI(closes, config.rsiLengthMinutes);\n            ind.mfi = calculateMFI(candleList, config.mfiPeriodMinutes);\n            ind.priceRoc = calculateROC(closes, config.regularPriceRocPeriod);\n            ind.volumeRoc = calculateROC(volumes, config.regularVolumeRocPeriod);\n            \n            // Calculate OBV and its ROC\n            List<Double> obvValues = new ArrayList<>();\n            double obv = 0;\n            for (int i = 1; i < candleList.size(); i++) {\n                obv += (candleList.get(i).close > candleList.get(i - 1).close) \n                    ? candleList.get(i).volume \n                    : -candleList.get(i).volume;\n                obvValues.add(obv);\n            }\n            ind.obv = obv;\n            ind.obvRoc = calculateROC(obvValues, config.regularObvRocPeriod);\n            \n            // Calculate RSI ROC\n            List<Double> rsiValues = calculateRSIValues(closes, config.rsiLengthMinutes);\n            ind.rsiRoc = calculateROC(rsiValues, config.regularRsiRocPeriod);\n            \n            // Calculate MFI ROC\n            List<Double> mfiValues = calculateMFIValues(candleList, config.mfiPeriodMinutes);\n            ind.mfiRoc = calculateROC(mfiValues, config.regularMfiRocPeriod);\n            \n            // Calculate Bollinger Bands and %B\n            List<Double> percentBValues = calculateBollingerPercentB(closes, config.bbLengthMinutes);\n            if (!percentBValues.isEmpty()) {\n                ind.percentB = percentBValues.get(percentBValues.size() - 1);\n                ind.percentBRoc = calculateROC(percentBValues, config.regularPercentBRocPeriod);\n                \n                // Calculate Bollinger position (0 = at lower band, 0.5 = at SMA, 1 = at upper band)\n                ind.bollingerPosition = ind.percentB;\n                ind.bollingerPosRoc = ind.percentBRoc;\n            }\n            \n            // Calculate VWAP and its ROC\n            List<Double> vwapValues = calculateVWAP(candleList, config.vwapPeriodMinutes);\n            if (!vwapValues.isEmpty()) {\n                ind.vwap = vwapValues.get(vwapValues.size() - 1);\n                ind.vwapRoc = calculateROC(vwapValues, config.regularVwapRocPeriod);\n            }\n            \n            // ===== NEW INDICATORS FOR HIGH VOLATILITY, LOW-PRICED STOCKS =====\n            \n            // Calculate MACD - use configured periods (optimized for volatile 1-min candles)\n            double[] macd = calculateMACD(closes, config.macdFastPeriod, config.macdSlowPeriod, config.macdSignalPeriod);\n            ind.macdLine = macd[0];\n            ind.macdSignal = macd[1];\n            ind.macdHistogram = macd[2];\n            \n            // Calculate MACD Histogram ROC (predictive convergence indicator)\n            ind.macdHistogramRoc = 0.0;\n            if (closes.size() >= 2) {\n                List<Double> closesMinusOne = closes.subList(0, closes.size() - 1);\n                if (closesMinusOne.size() >= Math.max(config.macdFastPeriod, config.macdSlowPeriod)) {\n                    double[] macdPrev = calculateMACD(closesMinusOne, config.macdFastPeriod, config.macdSlowPeriod, config.macdSignalPeriod);\n                    double deltaH = ind.macdHistogram - macdPrev[2];\n                    double currentPrice = closes.get(closes.size() - 1);\n                    ind.macdHistogramRoc = deltaH / currentPrice;\n                }\n            }\n            \n            // Calculate EMAs - use configured periods\n            ind.ema9 = calculateEMA(closes, config.ema9Period);\n            ind.ema20 = calculateEMA(closes, config.ema20Period);\n            ind.ema50 = calculateEMA(closes, config.ema50Period);\n            \n            // Calculate Stochastic Oscillator - use configured periods\n            double[] stoch = calculateStochastic(candleList, config.stochasticPeriod, config.stochasticKSmooth, config.stochasticDSmooth);\n            ind.stochK = stoch[0];\n            ind.stochD = stoch[1];\n            \n            // Calculate Relative Volume - use configured period\n            ind.rvol = calculateRVOL(candleList, config.rvolPeriod);\n            \n            // Detect Volume Spike - use configured threshold\n            double[] volSpike = detectVolumeSpike(candleList, config.rvolPeriod, config.volumeSpikeThreshold);\n            ind.volumeSpike = volSpike[0] > 0;\n            ind.volumeRatio = volSpike[1];\n            \n            // Calculate ATR (Average True Range) for volatility measurement\n            ind.atr = calculateATR(candleList, 14);  // Standard 14-period ATR\n            \n            return ind;\n        }\n    }\n    \n    private double calculateRSI(List<Double> prices, int period) {\n        if (prices.size() < period + 1) return 50.0;\n        \n        List<Double> gains = new ArrayList<>();\n        List<Double> losses = new ArrayList<>();\n        \n        for (int i = 1; i < prices.size(); i++) {\n            double change = prices.get(i) - prices.get(i - 1);\n            gains.add(change > 0 ? change : 0);\n            losses.add(change < 0 ? -change : 0);\n        }\n        \n        double avgGain = 0;\n        double avgLoss = 0;\n        for (int i = gains.size() - period; i < gains.size(); i++) {\n            avgGain += gains.get(i);\n            avgLoss += losses.get(i);\n        }\n        avgGain /= period;\n        avgLoss /= period;\n        \n        if (avgLoss == 0) return 100.0;\n        double rs = avgGain / avgLoss;\n        return 100.0 - (100.0 / (1.0 + rs));\n    }\n    \n    private double calculateMFI(List<Candle> candles, int period) {\n        if (candles.size() < period + 1) return 50.0;\n        \n        List<Double> positiveFlow = new ArrayList<>();\n        List<Double> negativeFlow = new ArrayList<>();\n        \n        for (int i = 1; i < candles.size(); i++) {\n            double typicalPrice = (candles.get(i).high + candles.get(i).low + candles.get(i).close) / 3.0;\n            double prevTypicalPrice = (candles.get(i - 1).high + candles.get(i - 1).low + candles.get(i - 1).close) / 3.0;\n            double moneyFlow = typicalPrice * candles.get(i).volume;\n            \n            if (typicalPrice > prevTypicalPrice) {\n                positiveFlow.add(moneyFlow);\n                negativeFlow.add(0.0);\n            } else {\n                positiveFlow.add(0.0);\n                negativeFlow.add(moneyFlow);\n            }\n        }\n        \n        double posSum = 0;\n        double negSum = 0;\n        for (int i = positiveFlow.size() - period; i < positiveFlow.size(); i++) {\n            posSum += positiveFlow.get(i);\n            negSum += negativeFlow.get(i);\n        }\n        \n        if (negSum == 0) return 100.0;\n        double moneyFlowRatio = posSum / negSum;\n        return 100.0 - (100.0 / (1.0 + moneyFlowRatio));\n    }\n    \n    // FIX #3: Calculate ATR (Average True Range) for volatility measurement\n    // ATR measures market volatility and is essential for:\n    // - Normalizing price movements (a 2% move means different things for different stocks)\n    // - Setting dynamic stop losses (e.g., 2-3 ATRs below entry)\n    // - Sizing positions properly (more volatile = smaller position)\n    private double calculateATR(List<Candle> candles, int period) {\n        if (candles.size() < period + 1) return 0.0;\n        \n        // Step 1: Calculate True Range for each candle\n        // TR = max(High - Low, |High - Previous Close|, |Low - Previous Close|)\n        List<Double> trueRanges = new ArrayList<>();\n        \n        for (int i = 1; i < candles.size(); i++) {\n            Candle current = candles.get(i);\n            Candle previous = candles.get(i - 1);\n            \n            double highLow = current.high - current.low;\n            double highPrevClose = Math.abs(current.high - previous.close);\n            double lowPrevClose = Math.abs(current.low - previous.close);\n            \n            double tr = Math.max(highLow, Math.max(highPrevClose, lowPrevClose));\n            trueRanges.add(tr);\n        }\n        \n        if (trueRanges.size() < period) return 0.0;\n        \n        // Step 2: Calculate ATR using Wilder's smoothing method (same as RSI)\n        // First ATR = SMA of first N true ranges\n        double firstATR = 0.0;\n        for (int i = 0; i < period; i++) {\n            firstATR += trueRanges.get(i);\n        }\n        firstATR /= period;\n        \n        // Subsequent ATR = (Previous ATR * (period - 1) + Current TR) / period\n        double atr = firstATR;\n        for (int i = period; i < trueRanges.size(); i++) {\n            atr = ((atr * (period - 1)) + trueRanges.get(i)) / period;\n        }\n        \n        return atr;\n    }\n    \n    // FIX #3: Public method to get current ATR for a symbol\n    public double getATR(String symbol, int period) {\n        synchronized (lock) {\n            if (!candleData.containsKey(symbol)) return 0.0;\n            \n            Deque<Candle> candles = candleData.get(symbol);\n            if (candles.size() < period + 1) return 0.0;\n            \n            List<Candle> candleList = new ArrayList<>(candles);\n            return calculateATR(candleList, period);\n        }\n    }\n    \n    private double calculateROC(List<Double> values, int period) {\n        if (values.size() < 2) return 0.0;  // Need at least 2 values for ROC\n        \n        int idx = values.size() - 1;\n        // Use the requested period, or all available data if we don't have enough\n        int actualPeriod = Math.min(period, idx);\n        int prevIdx = idx - actualPeriod;\n        \n        // Avoid division by zero\n        if (Math.abs(values.get(prevIdx)) < 0.0001) return 0.0;\n        \n        return ((values.get(idx) - values.get(prevIdx)) / values.get(prevIdx)) * 100.0;\n    }\n    \n    private double calculateZScore(List<Double> values) {\n        if (values.size() < 2) return 0.0;\n        \n        double sum = 0;\n        for (double v : values) {\n            sum += v;\n        }\n        double mean = sum / values.size();\n        \n        double sqSum = 0;\n        for (double v : values) {\n            sqSum += v * v;\n        }\n        double stdev = Math.sqrt(sqSum / values.size() - mean * mean);\n        \n        if (stdev == 0) return 0.0;\n        return (values.get(values.size() - 1) - mean) / stdev;\n    }\n    \n    public int getDataPointsCollected(String symbol) {\n        synchronized (lock) {\n            if (!candleData.containsKey(symbol)) return 0;\n            return candleData.get(symbol).size();\n        }\n    }\n    \n    public boolean isReadyForTrading(String symbol) {\n        return getDataPointsCollected(symbol) >= config.warmupDataPoints;\n    }\n    \n    public IndicatorsData getCurrentIndicators(String symbol) {\n        synchronized (lock) {\n            IndicatorsData indicators = new IndicatorsData();\n            \n            if (!candleData.containsKey(symbol)) {\n                System.out.println(\" getCurrentIndicators(\" + symbol + \"): NO CANDLE DATA - returning defaults\");\n                return indicators;\n            }\n            \n            Deque<Candle> candles = candleData.get(symbol);\n            if (candles.isEmpty()) {\n                System.out.println(\" getCurrentIndicators(\" + symbol + \"): EMPTY CANDLES - returning defaults\");\n                return indicators;\n            }\n            \n            List<Double> closes = new ArrayList<>();\n            List<Double> volumes = new ArrayList<>();\n            List<Candle> candleList = new ArrayList<>(candles);\n            \n            for (Candle c : candleList) {\n                closes.add(c.close);\n                volumes.add((double) c.volume);\n            }\n            \n            int dataPoints = closes.size();\n            if (dataPoints < 2) {\n                System.out.println(\" getCurrentIndicators(\" + symbol + \"): INSUFFICIENT DATA (\" + dataPoints + \" candles, need 2+) - returning defaults\");\n                return indicators;\n            }\n            \n            // Log data availability every 10 candles\n            if (dataPoints % 10 == 0 || dataPoints < 50) {\n                System.out.println(\" getCurrentIndicators(\" + symbol + \"): \" + dataPoints + \" candles available (need \" + config.warmupDataPoints + \" for trading)\");\n            }\n            \n            try {\n                double rsi = calculateRSI(closes, config.rsiLengthMinutes);\n                double mfi = calculateMFI(candleList, config.mfiPeriodMinutes);\n                double priceRoc = calculateROC(closes, config.regularPriceRocPeriod);\n                double volumeRoc = calculateROC(volumes, config.regularVolumeRocPeriod);\n                \n                List<Double> obvValues = new ArrayList<>();\n                double obv = 0;\n                for (int i = 1; i < candleList.size(); i++) {\n                    obv += (candleList.get(i).close > candleList.get(i - 1).close) \n                        ? candleList.get(i).volume \n                        : -candleList.get(i).volume;\n                    obvValues.add(obv);\n                }\n                double obvRoc = calculateROC(obvValues, config.regularObvRocPeriod);\n                \n                List<Double> percentBValues = calculateBollingerPercentB(closes, config.bbLengthMinutes);\n                double percentBRoc = calculateROC(percentBValues, config.regularPercentBRocPeriod);\n                \n                List<Double> vwapValues = calculateVWAP(candleList, config.vwapPeriodMinutes);\n                double vwapRoc = calculateROC(vwapValues, config.regularVwapRocPeriod);\n                \n                double[] macd = calculateMACD(closes, config.macdFastPeriod, config.macdSlowPeriod, config.macdSignalPeriod);\n                double macdLine = macd[0];\n                double macdSignal = macd[1];\n                double macdHistogram = macd[2];\n                \n                double macdHistogramRoc = 0.0;\n                if (closes.size() >= 2) {\n                    List<Double> closesMinusOne = closes.subList(0, closes.size() - 1);\n                    if (closesMinusOne.size() >= Math.max(config.macdFastPeriod, config.macdSlowPeriod)) {\n                        double[] macdPrev = calculateMACD(closesMinusOne, config.macdFastPeriod, config.macdSlowPeriod, config.macdSignalPeriod);\n                        double macdHistogramPrev = macdPrev[2];\n                        double deltaH = macdHistogram - macdHistogramPrev;\n                        double currentPrice = closes.get(closes.size() - 1);\n                        macdHistogramRoc = deltaH / currentPrice;\n                    }\n                }\n                \n                double ema9 = calculateEMA(closes, config.ema9Period);\n                double ema20 = calculateEMA(closes, config.ema20Period);\n                double ema50 = calculateEMA(closes, config.ema50Period);\n                \n                double[] stoch = calculateStochastic(candleList, config.stochasticPeriod, config.stochasticKSmooth, config.stochasticDSmooth);\n                double stochK = stoch[0];\n                double stochD = stoch[1];\n                \n                double rvol = calculateRVOL(candleList, config.rvolPeriod);\n                \n                double[] volSpike = detectVolumeSpike(candleList, config.rvolPeriod, config.volumeSpikeThreshold);\n                boolean hasVolumeSpike = volSpike[0] > 0;\n                double volumeRatio = volSpike[1];\n                \n                List<Double> rsiValues = calculateRSIValues(closes, config.rsiLengthMinutes);\n                double rsiRoc = calculateROC(rsiValues, config.regularRsiRocPeriod);\n                \n                List<Double> mfiValues = calculateMFIValues(candleList, config.mfiPeriodMinutes);\n                double mfiRoc = calculateROC(mfiValues, config.regularMfiRocPeriod);\n                \n                indicators.rsi = rsi;\n                indicators.mfi = mfi;\n                indicators.priceRoc = priceRoc;\n                indicators.volumeRoc = volumeRoc;\n                indicators.obv = obvValues.isEmpty() ? 0 : obvValues.get(obvValues.size() - 1);\n                indicators.rsiRoc = rsiRoc;\n                indicators.obvRoc = obvRoc;\n                indicators.mfiRoc = mfiRoc;\n                \n                if (!percentBValues.isEmpty()) {\n                    indicators.percentB = percentBValues.get(percentBValues.size() - 1);\n                    indicators.percentBRoc = percentBRoc;\n                    indicators.bollingerPosition = indicators.percentB;\n                    indicators.bollingerPosRoc = percentBRoc;\n                    \n                    int period = config.bbLengthMinutes;\n                    if (closes.size() >= period) {\n                        double sum = 0;\n                        for (int i = closes.size() - period; i < closes.size(); i++) {\n                            sum += closes.get(i);\n                        }\n                        double sma = sum / period;\n                        \n                        double sqSum = 0;\n                        for (int i = closes.size() - period; i < closes.size(); i++) {\n                            double diff = closes.get(i) - sma;\n                            sqSum += diff * diff;\n                        }\n                        double stdev = Math.sqrt(sqSum / period);\n                        \n                        indicators.bollingerUpper = sma + 2 * stdev;\n                        indicators.bollingerLower = sma - 2 * stdev;\n                    }\n                }\n                \n                if (!vwapValues.isEmpty()) {\n                    indicators.vwap = vwapValues.get(vwapValues.size() - 1);\n                    indicators.vwapRoc = vwapRoc;\n                }\n                \n                indicators.macdLine = macdLine;\n                indicators.macdSignal = macdSignal;\n                indicators.macdHistogram = macdHistogram;\n                indicators.macdHistogramRoc = macdHistogramRoc;\n                \n                indicators.ema9 = ema9;\n                indicators.ema20 = ema20;\n                indicators.ema50 = ema50;\n                \n                indicators.stochK = stochK;\n                indicators.stochD = stochD;\n                \n                indicators.rvol = rvol;\n                \n                indicators.volumeSpike = hasVolumeSpike;\n                indicators.volumeRatio = volumeRatio;\n                \n                // Calculate ATR (Average True Range) for volatility measurement\n                indicators.atr = calculateATR(candleList, 14);  // Standard 14-period ATR\n                \n                // Calculate probability using ProbabilityCalibrator (same as analyzeBuySignal)\n                ProbabilityCalibrator calibrator = new ProbabilityCalibrator();\n                calibrator.setProbabilityScale(config.highProbThreshold * 2.0);\n                indicators.probability = calibrator.calculateCalibratedProbability(indicators, hasVolumeSpike);\n                \n                // Log successful calculation every 20 candles\n                if (dataPoints % 20 == 0) {\n                    System.out.println(\" Indicators calculated for \" + symbol + \" (\" + dataPoints + \" candles): \" +\n                        \"Prob=\" + String.format(\"%.1f%%\", indicators.probability * 100) +\n                        \" | RSI=\" + String.format(\"%.1f\", indicators.rsi) +\n                        \" | MACD=\" + String.format(\"%.4f\", indicators.macdHistogram) +\n                        \" | StochK=\" + String.format(\"%.1f\", indicators.stochK) +\n                        \" | RVOL=\" + String.format(\"%.2f\", indicators.rvol) +\n                        \" | ATR=\" + String.format(\"%.4f\", indicators.atr));\n                }\n                \n            } catch (Exception e) {\n                System.err.println(\" Error calculating indicators for \" + symbol + \": \" + e.getMessage());\n                e.printStackTrace();  // Print stack trace for debugging\n            }\n            \n            return indicators;\n        }\n    }\n    \n    public int getTotalSpikeCount(String symbol) {\n        synchronized (lock) {\n            if (!spikeHistory.containsKey(symbol)) return 0;\n            return spikeHistory.get(symbol).size();\n        }\n    }\n    \n    // Calculate Bollinger Bands %B values over time\n    private List<Double> calculateBollingerPercentB(List<Double> closes, int period) {\n        List<Double> percentBValues = new ArrayList<>();\n        if (closes.size() < period) return percentBValues;\n        \n        for (int i = period - 1; i < closes.size(); i++) {\n            // Calculate SMA for this window\n            double sum = 0;\n            for (int j = i - period + 1; j <= i; j++) {\n                sum += closes.get(j);\n            }\n            double sma = sum / period;\n            \n            // Calculate standard deviation\n            double sqSum = 0;\n            for (int j = i - period + 1; j <= i; j++) {\n                double diff = closes.get(j) - sma;\n                sqSum += diff * diff;\n            }\n            double stdev = Math.sqrt(sqSum / period);\n            \n            // Calculate %B: (price - lower band) / (upper band - lower band)\n            // Lower band = SMA - 2*stdev, Upper band = SMA + 2*stdev\n            // %B = (price - (SMA - 2*stdev)) / (4*stdev) = (price - SMA + 2*stdev) / (4*stdev)\n            double percentB = 0.5; // default to middle\n            if (stdev > 0) {\n                double lowerBand = sma - 2 * stdev;\n                double upperBand = sma + 2 * stdev;\n                double bandWidth = upperBand - lowerBand;\n                if (bandWidth > 0) {\n                    percentB = (closes.get(i) - lowerBand) / bandWidth;\n                }\n            }\n            \n            percentBValues.add(percentB);\n        }\n        \n        return percentBValues;\n    }\n    \n    // Calculate Anchored VWAP (Volume Weighted Average Price) from market open (9:30 AM ET)\n    // This provides a true \"average price\" reference point for intraday mean reversion\n    private List<Double> calculateVWAP(List<Candle> candles, int period) {\n        List<Double> vwapValues = new ArrayList<>();\n        if (candles.isEmpty()) return vwapValues;\n        \n        // Track session start (market open at 9:30 AM ET)\n        double sessionCumulativePV = 0;  // price * volume from session start\n        double sessionCumulativeVolume = 0;\n        LocalDate currentSessionDate = null;  // Track trading day\n        boolean sessionStarted = false;       // Track if we've crossed 9:30 AM for current day\n        \n        // Market opens at 9:30 AM ET\n        final int MARKET_OPEN_HOUR = 9;\n        final int MARKET_OPEN_MINUTE = 30;\n        final ZoneId ET_ZONE = ZoneId.of(\"America/New_York\");\n        \n        for (int i = 0; i < candles.size(); i++) {\n            Candle candle = candles.get(i);\n            \n            // Convert timestamp to Eastern Time\n            ZonedDateTime candleTimeET = candle.timestamp.atZone(ET_ZONE);\n            LocalDate candleDate = candleTimeET.toLocalDate();\n            int hour = candleTimeET.getHour();\n            int minute = candleTimeET.getMinute();\n            \n            // Calculate time in minutes since midnight for easier comparison\n            int candleMinutes = hour * 60 + minute;\n            int openMinutes = MARKET_OPEN_HOUR * 60 + MARKET_OPEN_MINUTE;\n            boolean isPastMarketOpen = candleMinutes >= openMinutes;\n            \n            // Detect new trading session\n            boolean isNewSession = false;\n            if (currentSessionDate == null || !candleDate.equals(currentSessionDate)) {\n                // New calendar day\n                currentSessionDate = candleDate;\n                sessionStarted = false;  // Reset session flag for new day\n            }\n            \n            // Reset VWAP when we first cross 9:30 AM ET\n            if (!sessionStarted && isPastMarketOpen) {\n                // First candle at or after 9:30 AM ET for this day\n                isNewSession = true;\n                sessionStarted = true;\n                sessionCumulativePV = 0;\n                sessionCumulativeVolume = 0;\n            }\n            \n            // Only accumulate candles at or after 9:30 AM ET\n            if (sessionStarted) {\n                double typicalPrice = (candle.high + candle.low + candle.close) / 3.0;\n                sessionCumulativePV += typicalPrice * candle.volume;\n                sessionCumulativeVolume += candle.volume;\n            }\n            \n            // Calculate session VWAP\n            double vwap = 0;\n            if (sessionCumulativeVolume > 0) {\n                vwap = sessionCumulativePV / sessionCumulativeVolume;\n            }\n            \n            vwapValues.add(vwap);\n        }\n        \n        return vwapValues;\n    }\n    \n    // ===== NEW INDICATORS FOR HIGH VOLATILITY, LOW-PRICED STOCKS =====\n    \n    /**\n     * Calculate EMA (Exponential Moving Average)\n     * Better for volatile stocks than SMA as it weights recent prices more heavily\n     */\n    private double calculateEMA(List<Double> prices, int period) {\n        if (prices.size() < period) return 0.0;\n        \n        // Calculate initial SMA for first EMA value\n        double sum = 0;\n        for (int i = 0; i < period; i++) {\n            sum += prices.get(i);\n        }\n        double ema = sum / period;\n        \n        // Calculate multiplier: (2 / (period + 1))\n        double multiplier = 2.0 / (period + 1);\n        \n        // Calculate EMA for remaining values\n        for (int i = period; i < prices.size(); i++) {\n            ema = (prices.get(i) - ema) * multiplier + ema;\n        }\n        \n        return ema;\n    }\n    \n    /**\n     * Calculate MACD (Moving Average Convergence Divergence)\n     * Excellent momentum indicator for volatile stocks\n     * Returns array: [macdLine, signalLine, histogram]\n     */\n    private double[] calculateMACD(List<Double> prices, int fastPeriod, int slowPeriod, int signalPeriod) {\n        if (prices.size() < slowPeriod) {\n            return new double[]{0.0, 0.0, 0.0};\n        }\n        \n        // Calculate fast EMA (typically 12)\n        double fastEMA = calculateEMA(prices, fastPeriod);\n        \n        // Calculate slow EMA (typically 26)\n        double slowEMA = calculateEMA(prices, slowPeriod);\n        \n        // MACD Line = Fast EMA - Slow EMA\n        double macdLine = fastEMA - slowEMA;\n        \n        // Calculate Signal Line (EMA of MACD Line, typically 9 periods)\n        // For simplicity, we'll use a list of recent MACD values\n        List<Double> macdValues = new ArrayList<>();\n        \n        // We need to calculate MACD for each point to get signal line\n        for (int i = slowPeriod; i <= prices.size(); i++) {\n            List<Double> window = prices.subList(0, i);\n            double tempFast = calculateEMA(window, fastPeriod);\n            double tempSlow = calculateEMA(window, slowPeriod);\n            macdValues.add(tempFast - tempSlow);\n        }\n        \n        double signalLine = 0.0;\n        if (macdValues.size() >= signalPeriod) {\n            signalLine = calculateEMA(macdValues, signalPeriod);\n        }\n        \n        // MACD Histogram = MACD Line - Signal Line\n        double histogram = macdLine - signalLine;\n        \n        return new double[]{macdLine, signalLine, histogram};\n    }\n    \n    /**\n     * Calculate Stochastic Oscillator\n     * Excellent for identifying overbought/oversold conditions in volatile stocks\n     * Returns array: [%K, %D]\n     */\n    private double[] calculateStochastic(List<Candle> candles, int period, int kSmooth, int dSmooth) {\n        if (candles.size() < period) {\n            return new double[]{50.0, 50.0};\n        }\n        \n        List<Double> kValues = new ArrayList<>();\n        \n        // Calculate %K for each period\n        for (int i = period - 1; i < candles.size(); i++) {\n            // Find highest high and lowest low in period\n            double highestHigh = Double.MIN_VALUE;\n            double lowestLow = Double.MAX_VALUE;\n            \n            for (int j = i - period + 1; j <= i; j++) {\n                if (candles.get(j).high > highestHigh) highestHigh = candles.get(j).high;\n                if (candles.get(j).low < lowestLow) lowestLow = candles.get(j).low;\n            }\n            \n            // %K = 100 * (Current Close - Lowest Low) / (Highest High - Lowest Low)\n            double range = highestHigh - lowestLow;\n            double stochK = 50.0; // default to middle\n            if (range > 0) {\n                stochK = 100.0 * (candles.get(i).close - lowestLow) / range;\n            }\n            \n            kValues.add(stochK);\n        }\n        \n        // Smooth %K if kSmooth > 1\n        double smoothedK = kValues.get(kValues.size() - 1);\n        if (kSmooth > 1 && kValues.size() >= kSmooth) {\n            double sum = 0;\n            for (int i = kValues.size() - kSmooth; i < kValues.size(); i++) {\n                sum += kValues.get(i);\n            }\n            smoothedK = sum / kSmooth;\n        }\n        \n        // %D = SMA of %K over dSmooth periods\n        double stochD = smoothedK;\n        if (dSmooth > 1 && kValues.size() >= dSmooth) {\n            double sum = 0;\n            int count = 0;\n            for (int i = Math.max(0, kValues.size() - dSmooth); i < kValues.size(); i++) {\n                sum += kValues.get(i);\n                count++;\n            }\n            if (count > 0) stochD = sum / count;\n        }\n        \n        return new double[]{smoothedK, stochD};\n    }\n    \n    /**\n     * Calculate Relative Volume (RVOL)\n     * More reliable than raw volume for penny stocks\n     * RVOL = Current Volume / Average Volume\n     */\n    private double calculateRVOL(List<Candle> candles, int avgPeriod) {\n        if (candles.size() < avgPeriod + 1) return 1.0;\n        \n        // Calculate average volume over the period (excluding current)\n        double sumVolume = 0;\n        for (int i = candles.size() - avgPeriod - 1; i < candles.size() - 1; i++) {\n            sumVolume += candles.get(i).volume;\n        }\n        double avgVolume = sumVolume / avgPeriod;\n        \n        // Current volume\n        double currentVolume = candles.get(candles.size() - 1).volume;\n        \n        // RVOL = current / average\n        if (avgVolume > 0) {\n            return currentVolume / avgVolume;\n        }\n        \n        return 1.0;\n    }\n    \n    /**\n     * Detect Volume Spike\n     * Returns [volumeSpike (1.0 or 0.0), volumeRatio]\n     * Simpler and more reliable than OBV for penny stocks\n     */\n    private double[] detectVolumeSpike(List<Candle> candles, int avgPeriod, double threshold) {\n        if (candles.size() < avgPeriod + 1) {\n            return new double[]{0.0, 1.0};\n        }\n        \n        double rvol = calculateRVOL(candles, avgPeriod);\n        boolean isSpike = rvol > threshold;\n        \n        return new double[]{isSpike ? 1.0 : 0.0, rvol};\n    }\n}\n","size_bytes":67156},"build/extracted-include-protos/test/google/type/date.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/date;date\";\noption java_multiple_files = true;\noption java_outer_classname = \"DateProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a whole or partial calendar date, such as a birthday. The time of\n// day and time zone are either specified elsewhere or are insignificant. The\n// date is relative to the Gregorian Calendar. This can represent one of the\n// following:\n//\n// * A full date, with non-zero year, month, and day values\n// * A month and day value, with a zero year, such as an anniversary\n// * A year on its own, with zero month and day values\n// * A year and month value, with a zero day, such as a credit card expiration\n// date\n//\n// Related types are [google.type.TimeOfDay][google.type.TimeOfDay] and\n// `google.protobuf.Timestamp`.\nmessage Date {\n  // Year of the date. Must be from 1 to 9999, or 0 to specify a date without\n  // a year.\n  int32 year = 1;\n\n  // Month of a year. Must be from 1 to 12, or 0 to specify a year without a\n  // month and day.\n  int32 month = 2;\n\n  // Day of a month. Must be from 1 to 31 and valid for the year and month, or 0\n  // to specify a year by itself or a year and month where the day isn't\n  // significant.\n  int32 day = 3;\n}\n","size_bytes":1955},"build/extracted-include-protos/test/google/api/visibility.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/descriptor.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/api/visibility;visibility\";\noption java_multiple_files = true;\noption java_outer_classname = \"VisibilityProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\nextend google.protobuf.EnumOptions {\n  // See `VisibilityRule`.\n  google.api.VisibilityRule enum_visibility = 72295727;\n}\n\nextend google.protobuf.EnumValueOptions {\n  // See `VisibilityRule`.\n  google.api.VisibilityRule value_visibility = 72295727;\n}\n\nextend google.protobuf.FieldOptions {\n  // See `VisibilityRule`.\n  google.api.VisibilityRule field_visibility = 72295727;\n}\n\nextend google.protobuf.MessageOptions {\n  // See `VisibilityRule`.\n  google.api.VisibilityRule message_visibility = 72295727;\n}\n\nextend google.protobuf.MethodOptions {\n  // See `VisibilityRule`.\n  google.api.VisibilityRule method_visibility = 72295727;\n}\n\nextend google.protobuf.ServiceOptions {\n  // See `VisibilityRule`.\n  google.api.VisibilityRule api_visibility = 72295727;\n}\n\n// `Visibility` restricts service consumer's access to service elements,\n// such as whether an application can call a visibility-restricted method.\n// The restriction is expressed by applying visibility labels on service\n// elements. The visibility labels are elsewhere linked to service consumers.\n//\n// A service can define multiple visibility labels, but a service consumer\n// should be granted at most one visibility label. Multiple visibility\n// labels for a single service consumer are not supported.\n//\n// If an element and all its parents have no visibility label, its visibility\n// is unconditionally granted.\n//\n// Example:\n//\n//     visibility:\n//       rules:\n//       - selector: google.calendar.Calendar.EnhancedSearch\n//         restriction: PREVIEW\n//       - selector: google.calendar.Calendar.Delegate\n//         restriction: INTERNAL\n//\n// Here, all methods are publicly visible except for the restricted methods\n// EnhancedSearch and Delegate.\nmessage Visibility {\n  // A list of visibility rules that apply to individual API elements.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated VisibilityRule rules = 1;\n}\n\n// A visibility rule provides visibility configuration for an individual API\n// element.\nmessage VisibilityRule {\n  // Selects methods, messages, fields, enums, etc. to which this rule applies.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // A comma-separated list of visibility labels that apply to the `selector`.\n  // Any of the listed labels can be used to grant the visibility.\n  //\n  // If a rule has multiple labels, removing one of the labels but not all of\n  // them can break clients.\n  //\n  // Example:\n  //\n  //     visibility:\n  //       rules:\n  //       - selector: google.calendar.Calendar.EnhancedSearch\n  //         restriction: INTERNAL, PREVIEW\n  //\n  // Removing INTERNAL from this restriction will break clients that rely on\n  // this method and only had access to it through INTERNAL.\n  string restriction = 2;\n}\n","size_bytes":3799},"build/extracted-include-protos/main/google/type/localized_text.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/localized_text;localized_text\";\noption java_multiple_files = true;\noption java_outer_classname = \"LocalizedTextProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Localized variant of a text in a particular language.\nmessage LocalizedText {\n  // Localized string in the language corresponding to `language_code' below.\n  string text = 1;\n\n  // The text's BCP-47 language code, such as \"en-US\" or \"sr-Latn\".\n  //\n  // For more information, see\n  // http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.\n  string language_code = 2;\n}\n","size_bytes":1303},"build/extracted-include-protos/main/google/api/visibility.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/descriptor.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/api/visibility;visibility\";\noption java_multiple_files = true;\noption java_outer_classname = \"VisibilityProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\nextend google.protobuf.EnumOptions {\n  // See `VisibilityRule`.\n  google.api.VisibilityRule enum_visibility = 72295727;\n}\n\nextend google.protobuf.EnumValueOptions {\n  // See `VisibilityRule`.\n  google.api.VisibilityRule value_visibility = 72295727;\n}\n\nextend google.protobuf.FieldOptions {\n  // See `VisibilityRule`.\n  google.api.VisibilityRule field_visibility = 72295727;\n}\n\nextend google.protobuf.MessageOptions {\n  // See `VisibilityRule`.\n  google.api.VisibilityRule message_visibility = 72295727;\n}\n\nextend google.protobuf.MethodOptions {\n  // See `VisibilityRule`.\n  google.api.VisibilityRule method_visibility = 72295727;\n}\n\nextend google.protobuf.ServiceOptions {\n  // See `VisibilityRule`.\n  google.api.VisibilityRule api_visibility = 72295727;\n}\n\n// `Visibility` restricts service consumer's access to service elements,\n// such as whether an application can call a visibility-restricted method.\n// The restriction is expressed by applying visibility labels on service\n// elements. The visibility labels are elsewhere linked to service consumers.\n//\n// A service can define multiple visibility labels, but a service consumer\n// should be granted at most one visibility label. Multiple visibility\n// labels for a single service consumer are not supported.\n//\n// If an element and all its parents have no visibility label, its visibility\n// is unconditionally granted.\n//\n// Example:\n//\n//     visibility:\n//       rules:\n//       - selector: google.calendar.Calendar.EnhancedSearch\n//         restriction: PREVIEW\n//       - selector: google.calendar.Calendar.Delegate\n//         restriction: INTERNAL\n//\n// Here, all methods are publicly visible except for the restricted methods\n// EnhancedSearch and Delegate.\nmessage Visibility {\n  // A list of visibility rules that apply to individual API elements.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated VisibilityRule rules = 1;\n}\n\n// A visibility rule provides visibility configuration for an individual API\n// element.\nmessage VisibilityRule {\n  // Selects methods, messages, fields, enums, etc. to which this rule applies.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // A comma-separated list of visibility labels that apply to the `selector`.\n  // Any of the listed labels can be used to grant the visibility.\n  //\n  // If a rule has multiple labels, removing one of the labels but not all of\n  // them can break clients.\n  //\n  // Example:\n  //\n  //     visibility:\n  //       rules:\n  //       - selector: google.calendar.Calendar.EnhancedSearch\n  //         restriction: INTERNAL, PREVIEW\n  //\n  // Removing INTERNAL from this restriction will break clients that rely on\n  // this method and only had access to it through INTERNAL.\n  string restriction = 2;\n}\n","size_bytes":3799},"build/extracted-include-protos/main/google/api/label.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/api/label;label\";\noption java_multiple_files = true;\noption java_outer_classname = \"LabelProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// A description of a label.\nmessage LabelDescriptor {\n  // Value types that can be used as label values.\n  enum ValueType {\n    // A variable-length string. This is the default.\n    STRING = 0;\n\n    // Boolean; true or false.\n    BOOL = 1;\n\n    // A 64-bit signed integer.\n    INT64 = 2;\n  }\n\n  // The label key.\n  string key = 1;\n\n  // The type of data that can be assigned to the label.\n  ValueType value_type = 2;\n\n  // A human-readable description for the label.\n  string description = 3;\n}\n","size_bytes":1389},"build/extracted-include-protos/main/google/cloud/audit/audit_log.proto":{"content":"// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.cloud.audit;\n\nimport \"google/api/field_behavior.proto\";\nimport \"google/protobuf/any.proto\";\nimport \"google/protobuf/struct.proto\";\nimport \"google/rpc/context/attribute_context.proto\";\nimport \"google/rpc/status.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/cloud/audit;audit\";\noption java_multiple_files = true;\noption java_outer_classname = \"AuditLogProto\";\noption java_package = \"com.google.cloud.audit\";\n\n// Common audit log format for Google Cloud Platform API operations.\nmessage AuditLog {\n  // The name of the API service performing the operation. For example,\n  // `\"compute.googleapis.com\"`.\n  string service_name = 7;\n\n  // The name of the service method or operation.\n  // For API calls, this should be the name of the API method.\n  // For example,\n  //\n  //     \"google.cloud.bigquery.v2.TableService.InsertTable\"\n  //     \"google.logging.v2.ConfigServiceV2.CreateSink\"\n  string method_name = 8;\n\n  // The resource or collection that is the target of the operation.\n  // The name is a scheme-less URI, not including the API service name.\n  // For example:\n  //\n  //     \"projects/PROJECT_ID/zones/us-central1-a/instances\"\n  //     \"projects/PROJECT_ID/datasets/DATASET_ID\"\n  string resource_name = 11;\n\n  // The resource location information.\n  ResourceLocation resource_location = 20;\n\n  // The resource's original state before mutation. Present only for\n  // operations which have successfully modified the targeted resource(s).\n  // In general, this field should contain all changed fields, except those\n  // that are already been included in `request`, `response`, `metadata` or\n  // `service_data` fields.\n  // When the JSON object represented here has a proto equivalent,\n  // the proto name will be indicated in the `@type` property.\n  google.protobuf.Struct resource_original_state = 19;\n\n  // The number of items returned from a List or Query API method,\n  // if applicable.\n  int64 num_response_items = 12;\n\n  // The status of the overall operation.\n  google.rpc.Status status = 2;\n\n  // Authentication information.\n  AuthenticationInfo authentication_info = 3;\n\n  // Authorization information. If there are multiple\n  // resources or permissions involved, then there is\n  // one AuthorizationInfo element for each {resource, permission} tuple.\n  repeated AuthorizationInfo authorization_info = 9;\n\n  // Indicates the policy violations for this request. If the request\n  // is denied by the policy, violation information will be logged\n  // here.\n  PolicyViolationInfo policy_violation_info = 25;\n\n  // Metadata about the operation.\n  RequestMetadata request_metadata = 4;\n\n  // The operation request. This may not include all request parameters,\n  // such as those that are too large, privacy-sensitive, or duplicated\n  // elsewhere in the log record.\n  // It should never include user-generated data, such as file contents.\n  // When the JSON object represented here has a proto equivalent, the proto\n  // name will be indicated in the `@type` property.\n  google.protobuf.Struct request = 16;\n\n  // The operation response. This may not include all response elements,\n  // such as those that are too large, privacy-sensitive, or duplicated\n  // elsewhere in the log record.\n  // It should never include user-generated data, such as file contents.\n  // When the JSON object represented here has a proto equivalent, the proto\n  // name will be indicated in the `@type` property.\n  google.protobuf.Struct response = 17;\n\n  // Other service-specific data about the request, response, and other\n  // information associated with the current audited event.\n  google.protobuf.Struct metadata = 18;\n\n  // Deprecated. Use the `metadata` field instead.\n  // Other service-specific data about the request, response, and other\n  // activities.\n  google.protobuf.Any service_data = 15 [deprecated = true];\n}\n\n// Authentication information for the operation.\nmessage AuthenticationInfo {\n  // The email address of the authenticated user (or service account on behalf\n  // of third party principal) making the request. For third party identity\n  // callers, the `principal_subject` field is populated instead of this field.\n  // For privacy reasons, the principal email address is sometimes redacted.\n  // For more information, see [Caller identities in audit\n  // logs](https://cloud.google.com/logging/docs/audit#user-id).\n  string principal_email = 1;\n\n  // The authority selector specified by the requestor, if any.\n  // It is not guaranteed that the principal was allowed to use this authority.\n  string authority_selector = 2;\n\n  // The third party identification (if any) of the authenticated user making\n  // the request.\n  // When the JSON object represented here has a proto equivalent, the proto\n  // name will be indicated in the `@type` property.\n  google.protobuf.Struct third_party_principal = 4;\n\n  // The name of the service account key used to create or exchange\n  // credentials for authenticating the service account making the request.\n  // This is a scheme-less URI full resource name. For example:\n  //\n  // \"//iam.googleapis.com/projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}\"\n  string service_account_key_name = 5;\n\n  // Identity delegation history of an authenticated service account that makes\n  // the request. It contains information on the real authorities that try to\n  // access GCP resources by delegating on a service account. When multiple\n  // authorities present, they are guaranteed to be sorted based on the original\n  // ordering of the identity delegation events.\n  repeated ServiceAccountDelegationInfo service_account_delegation_info = 6;\n\n  // String representation of identity of requesting party.\n  // Populated for both first and third party identities.\n  string principal_subject = 8;\n}\n\n// Authorization information for the operation.\nmessage AuthorizationInfo {\n  // The resource being accessed, as a REST-style or cloud resource string.\n  // For example:\n  //\n  //     bigquery.googleapis.com/projects/PROJECTID/datasets/DATASETID\n  // or\n  //     projects/PROJECTID/datasets/DATASETID\n  string resource = 1;\n\n  // The required IAM permission.\n  string permission = 2;\n\n  // Whether or not authorization for `resource` and `permission`\n  // was granted.\n  bool granted = 3;\n\n  // Resource attributes used in IAM condition evaluation. This field contains\n  // resource attributes like resource type and resource name.\n  //\n  // To get the whole view of the attributes used in IAM\n  // condition evaluation, the user must also look into\n  // `AuditLog.request_metadata.request_attributes`.\n  google.rpc.context.AttributeContext.Resource resource_attributes = 5;\n}\n\n// Metadata about the request.\nmessage RequestMetadata {\n  // The IP address of the caller.\n  // For a caller from the internet, this will be the public IPv4 or IPv6\n  // address. For calls made from inside Google's internal production network\n  // from one GCP service to another, `caller_ip` will be redacted to \"private\".\n  // For a caller from a Compute Engine VM with a external IP address,\n  // `caller_ip` will be the VM's external IP address. For a caller from a\n  // Compute Engine VM without a external IP address, if the VM is in the same\n  // organization (or project) as the accessed resource, `caller_ip` will be the\n  // VM's internal IPv4 address, otherwise `caller_ip` will be redacted to\n  // \"gce-internal-ip\". See https://cloud.google.com/compute/docs/vpc/ for more\n  // information.\n  string caller_ip = 1;\n\n  // The user agent of the caller.\n  // This information is not authenticated and should be treated accordingly.\n  // For example:\n  //\n  // +   `google-api-python-client/1.4.0`:\n  //     The request was made by the Google API client for Python.\n  // +   `Cloud SDK Command Line Tool apitools-client/1.0 gcloud/0.9.62`:\n  //     The request was made by the Google Cloud SDK CLI (gcloud).\n  // +   `AppEngine-Google; (+http://code.google.com/appengine; appid:\n  // s~my-project`:\n  //     The request was made from the `my-project` App Engine app.\n  string caller_supplied_user_agent = 2;\n\n  // The network of the caller.\n  // Set only if the network host project is part of the same GCP organization\n  // (or project) as the accessed resource.\n  // See https://cloud.google.com/compute/docs/vpc/ for more information.\n  // This is a scheme-less URI full resource name. For example:\n  //\n  //     \"//compute.googleapis.com/projects/PROJECT_ID/global/networks/NETWORK_ID\"\n  string caller_network = 3;\n\n  // Request attributes used in IAM condition evaluation. This field contains\n  // request attributes like request time and access levels associated with\n  // the request.\n  //\n  //\n  // To get the whole view of the attributes used in IAM\n  // condition evaluation, the user must also look into\n  // `AuditLog.authentication_info.resource_attributes`.\n  google.rpc.context.AttributeContext.Request request_attributes = 7;\n\n  // The destination of a network activity, such as accepting a TCP connection.\n  // In a multi hop network activity, the destination represents the receiver of\n  // the last hop. Only two fields are used in this message, Peer.port and\n  // Peer.ip. These fields are optionally populated by those services utilizing\n  // the IAM condition feature.\n  google.rpc.context.AttributeContext.Peer destination_attributes = 8;\n}\n\n// Location information about a resource.\nmessage ResourceLocation {\n  // The locations of a resource after the execution of the operation.\n  // Requests to create or delete a location based resource must populate\n  // the 'current_locations' field and not the 'original_locations' field.\n  // For example:\n  //\n  //     \"europe-west1-a\"\n  //     \"us-east1\"\n  //     \"nam3\"\n  repeated string current_locations = 1;\n\n  // The locations of a resource prior to the execution of the operation.\n  // Requests that mutate the resource's location must populate both the\n  // 'original_locations' as well as the 'current_locations' fields.\n  // For example:\n  //\n  //     \"europe-west1-a\"\n  //     \"us-east1\"\n  //     \"nam3\"\n  repeated string original_locations = 2;\n}\n\n// Identity delegation history of an authenticated service account.\nmessage ServiceAccountDelegationInfo {\n  // First party identity principal.\n  message FirstPartyPrincipal {\n    // The email address of a Google account.\n    string principal_email = 1;\n\n    // Metadata about the service that uses the service account.\n    google.protobuf.Struct service_metadata = 2;\n  }\n\n  // Third party identity principal.\n  message ThirdPartyPrincipal {\n    // Metadata about third party identity.\n    google.protobuf.Struct third_party_claims = 1;\n  }\n\n  // A string representing the principal_subject associated with the identity.\n  // For most identities, the format will be\n  // `principal://iam.googleapis.com/{identity pool name}/subject/{subject)`\n  // except for some GKE identities (GKE_WORKLOAD, FREEFORM, GKE_HUB_WORKLOAD)\n  // that are still in the legacy format `serviceAccount:{identity pool\n  // name}[{subject}]`\n  string principal_subject = 3;\n\n  // Entity that creates credentials for service account and assumes its\n  // identity for authentication.\n  oneof Authority {\n    // First party (Google) identity as the real authority.\n    FirstPartyPrincipal first_party_principal = 1;\n\n    // Third party identity as the real authority.\n    ThirdPartyPrincipal third_party_principal = 2;\n  }\n}\n\n// Information related to policy violations for this request.\nmessage PolicyViolationInfo {\n  // Indicates the orgpolicy violations for this resource.\n  OrgPolicyViolationInfo org_policy_violation_info = 1;\n}\n\n// Represents OrgPolicy Violation information.\nmessage OrgPolicyViolationInfo {\n  // Optional. Resource payload that is currently in scope and is subjected to orgpolicy\n  // conditions. This payload may be the subset of the actual Resource that may\n  // come in the request. This payload should not contain any core content.\n  google.protobuf.Struct payload = 1 [(google.api.field_behavior) = OPTIONAL];\n\n  // Optional. Resource type that the orgpolicy is checked against.\n  // Example: compute.googleapis.com/Instance, store.googleapis.com/bucket\n  string resource_type = 2 [(google.api.field_behavior) = OPTIONAL];\n\n  // Optional. Tags referenced on the resource at the time of evaluation. These also\n  // include the federated tags, if they are supplied in the CheckOrgPolicy\n  // or CheckCustomConstraints Requests.\n  //\n  // Optional field as of now. These tags are the Cloud tags that are\n  // available on the resource during the policy evaluation and will\n  // be available as part of the OrgPolicy check response for logging purposes.\n  map<string, string> resource_tags = 3 [(google.api.field_behavior) = OPTIONAL];\n\n  // Optional. Policy violations\n  repeated ViolationInfo violation_info = 4 [(google.api.field_behavior) = OPTIONAL];\n}\n\n// Provides information about the Policy violation info for this request.\nmessage ViolationInfo {\n  // Policy Type enum\n  enum PolicyType {\n    // Default value. This value should not be used.\n    POLICY_TYPE_UNSPECIFIED = 0;\n\n    // Indicates boolean policy constraint\n    BOOLEAN_CONSTRAINT = 1;\n\n    // Indicates list policy constraint\n    LIST_CONSTRAINT = 2;\n\n    // Indicates custom policy constraint\n    CUSTOM_CONSTRAINT = 3;\n  }\n\n  // Optional. Constraint name\n  string constraint = 1 [(google.api.field_behavior) = OPTIONAL];\n\n  // Optional. Error message that policy is indicating.\n  string error_message = 2 [(google.api.field_behavior) = OPTIONAL];\n\n  // Optional. Value that is being checked for the policy.\n  // This could be in encrypted form (if pii sensitive).\n  // This field will only be emitted in LIST_POLICY types\n  string checked_value = 3 [(google.api.field_behavior) = OPTIONAL];\n\n  // Optional. Indicates the type of the policy.\n  PolicyType policy_type = 4 [(google.api.field_behavior) = OPTIONAL];\n}","size_bytes":14531},"build/extracted-include-protos/main/google/protobuf/struct.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/protobuf/types/known/structpb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"StructProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\n\n// `Struct` represents a structured data value, consisting of fields\n// which map to dynamically typed values. In some languages, `Struct`\n// might be supported by a native representation. For example, in\n// scripting languages like JS a struct is represented as an\n// object. The details of that representation are described together\n// with the proto support for the language.\n//\n// The JSON representation for `Struct` is JSON object.\nmessage Struct {\n  // Unordered map of dynamically typed values.\n  map<string, Value> fields = 1;\n}\n\n// `Value` represents a dynamically typed value which can be either\n// null, a number, a string, a boolean, a recursive struct value, or a\n// list of values. A producer of value is expected to set one of these\n// variants. Absence of any variant indicates an error.\n//\n// The JSON representation for `Value` is JSON value.\nmessage Value {\n  // The kind of value.\n  oneof kind {\n    // Represents a null value.\n    NullValue null_value = 1;\n    // Represents a double value.\n    double number_value = 2;\n    // Represents a string value.\n    string string_value = 3;\n    // Represents a boolean value.\n    bool bool_value = 4;\n    // Represents a structured value.\n    Struct struct_value = 5;\n    // Represents a repeated `Value`.\n    ListValue list_value = 6;\n  }\n}\n\n// `NullValue` is a singleton enumeration to represent the null value for the\n// `Value` type union.\n//\n// The JSON representation for `NullValue` is JSON `null`.\nenum NullValue {\n  // Null value.\n  NULL_VALUE = 0;\n}\n\n// `ListValue` is a wrapper around a repeated field of values.\n//\n// The JSON representation for `ListValue` is JSON array.\nmessage ListValue {\n  // Repeated field of dynamically typed values.\n  repeated Value values = 1;\n}\n","size_bytes":3778},"build/extracted-include-protos/main/google/rpc/status.proto":{"content":"// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.rpc;\n\nimport \"google/protobuf/any.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/rpc/status;status\";\noption java_multiple_files = true;\noption java_outer_classname = \"StatusProto\";\noption java_package = \"com.google.rpc\";\noption objc_class_prefix = \"RPC\";\n\n// The `Status` type defines a logical error model that is suitable for\n// different programming environments, including REST APIs and RPC APIs. It is\n// used by [gRPC](https://github.com/grpc). Each `Status` message contains\n// three pieces of data: error code, error message, and error details.\n//\n// You can find out more about this error model and how to work with it in the\n// [API Design Guide](https://cloud.google.com/apis/design/errors).\nmessage Status {\n  // The status code, which should be an enum value of\n  // [google.rpc.Code][google.rpc.Code].\n  int32 code = 1;\n\n  // A developer-facing error message, which should be in English. Any\n  // user-facing error message should be localized and sent in the\n  // [google.rpc.Status.details][google.rpc.Status.details] field, or localized\n  // by the client.\n  string message = 2;\n\n  // A list of messages that carry the error details.  There is a common set of\n  // message types for APIs to use.\n  repeated google.protobuf.Any details = 3;\n}\n","size_bytes":1934},"src/main/java/com/spiketrade/backend/MarketTime.java":{"content":"package com.spiketrade.backend;\n\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\n\n/**\n * Utility class for consistent market timezone handling.\n * All market data time calculations should use this class to ensure\n * consistency between different data providers (Questrade, Yahoo Finance, etc.)\n */\npublic class MarketTime {\n    \n    /**\n     * Market timezone (Eastern Time) - used for all US/Canadian stock markets\n     */\n    public static final ZoneId MARKET_ZONE = ZoneId.of(\"America/New_York\");\n    \n    /**\n     * Trading minutes per day (9:30 AM - 4:00 PM ET = 390 minutes)\n     */\n    public static final int TRADING_MINUTES_PER_DAY = 390;\n    \n    /**\n     * ISO 8601 formatter with timezone offset for API requests\n     */\n    public static final DateTimeFormatter ISO_FORMATTER = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ssXXX\");\n    \n    /**\n     * Get the current time in market timezone\n     * @return Current time in America/New_York timezone\n     */\n    public static ZonedDateTime now() {\n        return ZonedDateTime.now(MARKET_ZONE);\n    }\n    \n    /**\n     * Calculate the start time for historical data retrieval.\n     * Accounts for market hours, weekends, and different intervals.\n     * \n     * @param intervalMinutes Interval in minutes (1, 5, 60, 1440, etc.)\n     * @param numBars Number of bars/candles requested\n     * @return Start time in market timezone\n     */\n    public static ZonedDateTime calculateStartTime(int intervalMinutes, int numBars) {\n        ZonedDateTime endTime = now();\n        return calculateStartTime(endTime, intervalMinutes, numBars);\n    }\n    \n    /**\n     * Calculate the start time for historical data retrieval from a given end time.\n     * Accounts for market hours, weekends, and different intervals.\n     * \n     * @param endTime End time in market timezone\n     * @param intervalMinutes Interval in minutes (1, 5, 60, 1440, etc.)\n     * @param numBars Number of bars/candles requested\n     * @return Start time in market timezone\n     */\n    public static ZonedDateTime calculateStartTime(ZonedDateTime endTime, int intervalMinutes, int numBars) {\n        if (intervalMinutes < TRADING_MINUTES_PER_DAY) {\n            // Intraday data - account for market hours and weekends\n            // Use ceiling division to avoid division by zero for intervals > 390 minutes\n            int barsPerDay = Math.max(1, TRADING_MINUTES_PER_DAY / intervalMinutes);\n            int tradingDaysNeeded = (numBars / barsPerDay) + 2;\n            // Multiply by 2 to account for weekends\n            return endTime.minusDays(tradingDaysNeeded * 2);\n        } else {\n            // Daily or longer intervals\n            return endTime.minusDays(numBars + 10);\n        }\n    }\n    \n    /**\n     * Calculate time range in minutes accounting for market hours.\n     * This is useful for Yahoo Finance which needs minute-based calculations.\n     * \n     * @param intervalMinutes Interval in minutes\n     * @param numBars Number of bars requested\n     * @return Total minutes to subtract from current time\n     */\n    public static long calculateMinutesBack(int intervalMinutes, int numBars) {\n        if (intervalMinutes < TRADING_MINUTES_PER_DAY) {\n            // For intraday, we need to account for non-trading hours\n            // Add extra time to ensure we get enough data\n            // Use ceiling division to avoid division by zero for intervals > 390 minutes\n            int barsPerDay = Math.max(1, TRADING_MINUTES_PER_DAY / intervalMinutes);\n            int tradingDaysNeeded = (numBars / barsPerDay) + 2;\n            // Use full 24-hour days to be safe\n            return (long) tradingDaysNeeded * 2 * 1440;\n        } else {\n            // Daily data - just use the number of bars times interval\n            return (long) numBars * intervalMinutes + 14400; // Add 10 days buffer\n        }\n    }\n    \n    /**\n     * Format a ZonedDateTime for API requests (ISO 8601 with timezone)\n     * \n     * @param time Time to format\n     * @return Formatted string\n     */\n    public static String formatForApi(ZonedDateTime time) {\n        return time.format(ISO_FORMATTER);\n    }\n    \n    /**\n     * Ensure a ZonedDateTime is in market timezone.\n     * If the input is in a different timezone, converts it to market timezone.\n     * \n     * @param time Time to convert\n     * @return Time in market timezone\n     */\n    public static ZonedDateTime toMarketTime(ZonedDateTime time) {\n        if (time.getZone().equals(MARKET_ZONE)) {\n            return time;\n        }\n        return time.withZoneSameInstant(MARKET_ZONE);\n    }\n}\n","size_bytes":4629},"build/extracted-include-protos/test/google/type/timeofday.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/timeofday;timeofday\";\noption java_multiple_files = true;\noption java_outer_classname = \"TimeOfDayProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a time of day. The date and time zone are either not significant\n// or are specified elsewhere. An API may choose to allow leap seconds. Related\n// types are [google.type.Date][google.type.Date] and\n// `google.protobuf.Timestamp`.\nmessage TimeOfDay {\n  // Hours of day in 24 hour format. Should be from 0 to 23. An API may choose\n  // to allow the value \"24:00:00\" for scenarios like business closing time.\n  int32 hours = 1;\n\n  // Minutes of hour of day. Must be from 0 to 59.\n  int32 minutes = 2;\n\n  // Seconds of minutes of the time. Must normally be from 0 to 59. An API may\n  // allow the value 60 if it allows leap-seconds.\n  int32 seconds = 3;\n\n  // Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.\n  int32 nanos = 4;\n}\n","size_bytes":1667},"build/extracted-include-protos/main/google/protobuf/source_context.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"SourceContextProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\noption go_package = \"google.golang.org/protobuf/types/known/sourcecontextpb\";\n\n// `SourceContext` represents information about the source of a\n// protobuf element, like the file in which it is defined.\nmessage SourceContext {\n  // The path-qualified name of the .proto file that contained the associated\n  // protobuf element.  For example: `\"google/protobuf/source_context.proto\"`.\n  string file_name = 1;\n}\n","size_bytes":2341},"build/extracted-include-protos/test/google/rpc/context/attribute_context.proto":{"content":"// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.rpc.context;\n\nimport \"google/protobuf/any.proto\";\nimport \"google/protobuf/duration.proto\";\nimport \"google/protobuf/struct.proto\";\nimport \"google/protobuf/timestamp.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/rpc/context/attribute_context;attribute_context\";\noption java_multiple_files = true;\noption java_outer_classname = \"AttributeContextProto\";\noption java_package = \"com.google.rpc.context\";\n\n// This message defines the standard attribute vocabulary for Google APIs.\n//\n// An attribute is a piece of metadata that describes an activity on a network\n// service. For example, the size of an HTTP request, or the status code of\n// an HTTP response.\n//\n// Each attribute has a type and a name, which is logically defined as\n// a proto message field in `AttributeContext`. The field type becomes the\n// attribute type, and the field path becomes the attribute name. For example,\n// the attribute `source.ip` maps to field `AttributeContext.source.ip`.\n//\n// This message definition is guaranteed not to have any wire breaking change.\n// So you can use it directly for passing attributes across different systems.\n//\n// NOTE: Different system may generate different subset of attributes. Please\n// verify the system specification before relying on an attribute generated\n// a system.\nmessage AttributeContext {\n  // This message defines attributes for a node that handles a network request.\n  // The node can be either a service or an application that sends, forwards,\n  // or receives the request. Service peers should fill in\n  // `principal` and `labels` as appropriate.\n  message Peer {\n    // The IP address of the peer.\n    string ip = 1;\n\n    // The network port of the peer.\n    int64 port = 2;\n\n    // The labels associated with the peer.\n    map<string, string> labels = 6;\n\n    // The identity of this peer. Similar to `Request.auth.principal`, but\n    // relative to the peer instead of the request. For example, the\n    // identity associated with a load balancer that forwarded the request.\n    string principal = 7;\n\n    // The CLDR country/region code associated with the above IP address.\n    // If the IP address is private, the `region_code` should reflect the\n    // physical location where this peer is running.\n    string region_code = 8;\n  }\n\n  // This message defines attributes associated with API operations, such as\n  // a network API request. The terminology is based on the conventions used\n  // by Google APIs, Istio, and OpenAPI.\n  message Api {\n    // The API service name. It is a logical identifier for a networked API,\n    // such as \"pubsub.googleapis.com\". The naming syntax depends on the\n    // API management system being used for handling the request.\n    string service = 1;\n\n    // The API operation name. For gRPC requests, it is the fully qualified API\n    // method name, such as \"google.pubsub.v1.Publisher.Publish\". For OpenAPI\n    // requests, it is the `operationId`, such as \"getPet\".\n    string operation = 2;\n\n    // The API protocol used for sending the request, such as \"http\", \"https\",\n    // \"grpc\", or \"internal\".\n    string protocol = 3;\n\n    // The API version associated with the API operation above, such as \"v1\" or\n    // \"v1alpha1\".\n    string version = 4;\n  }\n\n  // This message defines request authentication attributes. Terminology is\n  // based on the JSON Web Token (JWT) standard, but the terms also\n  // correlate to concepts in other standards.\n  message Auth {\n    // The authenticated principal. Reflects the issuer (`iss`) and subject\n    // (`sub`) claims within a JWT. The issuer and subject should be `/`\n    // delimited, with `/` percent-encoded within the subject fragment. For\n    // Google accounts, the principal format is:\n    // \"https://accounts.google.com/{id}\"\n    string principal = 1;\n\n    // The intended audience(s) for this authentication information. Reflects\n    // the audience (`aud`) claim within a JWT. The audience\n    // value(s) depends on the `issuer`, but typically include one or more of\n    // the following pieces of information:\n    //\n    // *  The services intended to receive the credential. For example,\n    //    [\"https://pubsub.googleapis.com/\", \"https://storage.googleapis.com/\"].\n    // *  A set of service-based scopes. For example,\n    //    [\"https://www.googleapis.com/auth/cloud-platform\"].\n    // *  The client id of an app, such as the Firebase project id for JWTs\n    //    from Firebase Auth.\n    //\n    // Consult the documentation for the credential issuer to determine the\n    // information provided.\n    repeated string audiences = 2;\n\n    // The authorized presenter of the credential. Reflects the optional\n    // Authorized Presenter (`azp`) claim within a JWT or the\n    // OAuth client id. For example, a Google Cloud Platform client id looks\n    // as follows: \"123456789012.apps.googleusercontent.com\".\n    string presenter = 3;\n\n    // Structured claims presented with the credential. JWTs include\n    // `{key: value}` pairs for standard and private claims. The following\n    // is a subset of the standard required and optional claims that would\n    // typically be presented for a Google-based JWT:\n    //\n    //    {'iss': 'accounts.google.com',\n    //     'sub': '113289723416554971153',\n    //     'aud': ['123456789012', 'pubsub.googleapis.com'],\n    //     'azp': '123456789012.apps.googleusercontent.com',\n    //     'email': 'jsmith@example.com',\n    //     'iat': 1353601026,\n    //     'exp': 1353604926}\n    //\n    // SAML assertions are similarly specified, but with an identity provider\n    // dependent structure.\n    google.protobuf.Struct claims = 4;\n\n    // A list of access level resource names that allow resources to be\n    // accessed by authenticated requester. It is part of Secure GCP processing\n    // for the incoming request. An access level string has the format:\n    // \"//{api_service_name}/accessPolicies/{policy_id}/accessLevels/{short_name}\"\n    //\n    // Example:\n    // \"//accesscontextmanager.googleapis.com/accessPolicies/MY_POLICY_ID/accessLevels/MY_LEVEL\"\n    repeated string access_levels = 5;\n  }\n\n  // This message defines attributes for an HTTP request. If the actual\n  // request is not an HTTP request, the runtime system should try to map\n  // the actual request to an equivalent HTTP request.\n  message Request {\n    // The unique ID for a request, which can be propagated to downstream\n    // systems. The ID should have low probability of collision\n    // within a single day for a specific service.\n    string id = 1;\n\n    // The HTTP request method, such as `GET`, `POST`.\n    string method = 2;\n\n    // The HTTP request headers. If multiple headers share the same key, they\n    // must be merged according to the HTTP spec. All header keys must be\n    // lowercased, because HTTP header keys are case-insensitive.\n    map<string, string> headers = 3;\n\n    // The HTTP URL path, excluding the query parameters.\n    string path = 4;\n\n    // The HTTP request `Host` header value.\n    string host = 5;\n\n    // The HTTP URL scheme, such as `http` and `https`.\n    string scheme = 6;\n\n    // The HTTP URL query in the format of `name1=value1&name2=value2`, as it\n    // appears in the first line of the HTTP request. No decoding is performed.\n    string query = 7;\n\n    // The timestamp when the `destination` service receives the last byte of\n    // the request.\n    google.protobuf.Timestamp time = 9;\n\n    // The HTTP request size in bytes. If unknown, it must be -1.\n    int64 size = 10;\n\n    // The network protocol used with the request, such as \"http/1.1\",\n    // \"spdy/3\", \"h2\", \"h2c\", \"webrtc\", \"tcp\", \"udp\", \"quic\". See\n    // https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids\n    // for details.\n    string protocol = 11;\n\n    // A special parameter for request reason. It is used by security systems\n    // to associate auditing information with a request.\n    string reason = 12;\n\n    // The request authentication. May be absent for unauthenticated requests.\n    // Derived from the HTTP request `Authorization` header or equivalent.\n    Auth auth = 13;\n  }\n\n  // This message defines attributes for a typical network response. It\n  // generally models semantics of an HTTP response.\n  message Response {\n    // The HTTP response status code, such as `200` and `404`.\n    int64 code = 1;\n\n    // The HTTP response size in bytes. If unknown, it must be -1.\n    int64 size = 2;\n\n    // The HTTP response headers. If multiple headers share the same key, they\n    // must be merged according to HTTP spec. All header keys must be\n    // lowercased, because HTTP header keys are case-insensitive.\n    map<string, string> headers = 3;\n\n    // The timestamp when the `destination` service sends the last byte of\n    // the response.\n    google.protobuf.Timestamp time = 4;\n\n    // The amount of time it takes the backend service to fully respond to a\n    // request. Measured from when the destination service starts to send the\n    // request to the backend until when the destination service receives the\n    // complete response from the backend.\n    google.protobuf.Duration backend_latency = 5;\n  }\n\n  // This message defines core attributes for a resource. A resource is an\n  // addressable (named) entity provided by the destination service. For\n  // example, a file stored on a network storage service.\n  message Resource {\n    // The name of the service that this resource belongs to, such as\n    // `pubsub.googleapis.com`. The service may be different from the DNS\n    // hostname that actually serves the request.\n    string service = 1;\n\n    // The stable identifier (name) of a resource on the `service`. A resource\n    // can be logically identified as \"//{resource.service}/{resource.name}\".\n    // The differences between a resource name and a URI are:\n    //\n    // *   Resource name is a logical identifier, independent of network\n    //     protocol and API version. For example,\n    //     `//pubsub.googleapis.com/projects/123/topics/news-feed`.\n    // *   URI often includes protocol and version information, so it can\n    //     be used directly by applications. For example,\n    //     `https://pubsub.googleapis.com/v1/projects/123/topics/news-feed`.\n    //\n    // See https://cloud.google.com/apis/design/resource_names for details.\n    string name = 2;\n\n    // The type of the resource. The syntax is platform-specific because\n    // different platforms define their resources differently.\n    //\n    // For Google APIs, the type format must be \"{service}/{kind}\", such as\n    // \"pubsub.googleapis.com/Topic\".\n    string type = 3;\n\n    // The labels or tags on the resource, such as AWS resource tags and\n    // Kubernetes resource labels.\n    map<string, string> labels = 4;\n\n    // The unique identifier of the resource. UID is unique in the time\n    // and space for this resource within the scope of the service. It is\n    // typically generated by the server on successful creation of a resource\n    // and must not be changed. UID is used to uniquely identify resources\n    // with resource name reuses. This should be a UUID4.\n    string uid = 5;\n\n    // Annotations is an unstructured key-value map stored with a resource that\n    // may be set by external tools to store and retrieve arbitrary metadata.\n    // They are not queryable and should be preserved when modifying objects.\n    //\n    // More info: https://kubernetes.io/docs/user-guide/annotations\n    map<string, string> annotations = 6;\n\n    // Mutable. The display name set by clients. Must be <= 63 characters.\n    string display_name = 7;\n\n    // Output only. The timestamp when the resource was created. This may\n    // be either the time creation was initiated or when it was completed.\n    google.protobuf.Timestamp create_time = 8;\n\n    // Output only. The timestamp when the resource was last updated. Any\n    // change to the resource made by users must refresh this value.\n    // Changes to a resource made by the service should refresh this value.\n    google.protobuf.Timestamp update_time = 9;\n\n    // Output only. The timestamp when the resource was deleted.\n    // If the resource is not deleted, this must be empty.\n    google.protobuf.Timestamp delete_time = 10;\n\n    // Output only. An opaque value that uniquely identifies a version or\n    // generation of a resource. It can be used to confirm that the client\n    // and server agree on the ordering of a resource being written.\n    string etag = 11;\n\n    // Immutable. The location of the resource. The location encoding is\n    // specific to the service provider, and new encoding may be introduced\n    // as the service evolves.\n    //\n    // For Google Cloud products, the encoding is what is used by Google Cloud\n    // APIs, such as `us-east1`, `aws-us-east-1`, and `azure-eastus2`. The\n    // semantics of `location` is identical to the\n    // `cloud.googleapis.com/location` label used by some Google Cloud APIs.\n    string location = 12;\n  }\n\n  // The origin of a network activity. In a multi hop network activity,\n  // the origin represents the sender of the first hop. For the first hop,\n  // the `source` and the `origin` must have the same content.\n  Peer origin = 7;\n\n  // The source of a network activity, such as starting a TCP connection.\n  // In a multi hop network activity, the source represents the sender of the\n  // last hop.\n  Peer source = 1;\n\n  // The destination of a network activity, such as accepting a TCP connection.\n  // In a multi hop network activity, the destination represents the receiver of\n  // the last hop.\n  Peer destination = 2;\n\n  // Represents a network request, such as an HTTP request.\n  Request request = 3;\n\n  // Represents a network response, such as an HTTP response.\n  Response response = 4;\n\n  // Represents a target resource that is involved with a network activity.\n  // If multiple resources are involved with an activity, this must be the\n  // primary one.\n  Resource resource = 5;\n\n  // Represents an API operation that is involved to a network activity.\n  Api api = 6;\n\n  // Supports extensions for advanced use cases, such as logs and metrics.\n  repeated google.protobuf.Any extensions = 8;\n}\n","size_bytes":14852},"build/extracted-include-protos/test/google/type/decimal.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/decimal;decimal\";\noption java_multiple_files = true;\noption java_outer_classname = \"DecimalProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// A representation of a decimal value, such as 2.5. Clients may convert values\n// into language-native decimal formats, such as Java's [BigDecimal][] or\n// Python's [decimal.Decimal][].\n//\n// [BigDecimal]:\n// https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html\n// [decimal.Decimal]: https://docs.python.org/3/library/decimal.html\nmessage Decimal {\n  // The decimal value, as a string.\n  //\n  // The string representation consists of an optional sign, `+` (`U+002B`)\n  // or `-` (`U+002D`), followed by a sequence of zero or more decimal digits\n  // (\"the integer\"), optionally followed by a fraction, optionally followed\n  // by an exponent.\n  //\n  // The fraction consists of a decimal point followed by zero or more decimal\n  // digits. The string must contain at least one digit in either the integer\n  // or the fraction. The number formed by the sign, the integer and the\n  // fraction is referred to as the significand.\n  //\n  // The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`)\n  // followed by one or more decimal digits.\n  //\n  // Services **should** normalize decimal values before storing them by:\n  //\n  //   - Removing an explicitly-provided `+` sign (`+2.5` -> `2.5`).\n  //   - Replacing a zero-length integer value with `0` (`.5` -> `0.5`).\n  //   - Coercing the exponent character to lower-case (`2.5E8` -> `2.5e8`).\n  //   - Removing an explicitly-provided zero exponent (`2.5e0` -> `2.5`).\n  //\n  // Services **may** perform additional normalization based on its own needs\n  // and the internal decimal implementation selected, such as shifting the\n  // decimal point and exponent value together (example: `2.5e-1` <-> `0.25`).\n  // Additionally, services **may** preserve trailing zeroes in the fraction\n  // to indicate increased precision, but are not required to do so.\n  //\n  // Note that only the `.` character is supported to divide the integer\n  // and the fraction; `,` **should not** be supported regardless of locale.\n  // Additionally, thousand separators **should not** be supported. If a\n  // service does support them, values **must** be normalized.\n  //\n  // The ENBF grammar is:\n  //\n  //     DecimalString =\n  //       [Sign] Significand [Exponent];\n  //\n  //     Sign = '+' | '-';\n  //\n  //     Significand =\n  //       Digits ['.'] [Digits] | [Digits] '.' Digits;\n  //\n  //     Exponent = ('e' | 'E') [Sign] Digits;\n  //\n  //     Digits = { '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' };\n  //\n  // Services **should** clearly document the range of supported values, the\n  // maximum supported precision (total number of digits), and, if applicable,\n  // the scale (number of digits after the decimal point), as well as how it\n  // behaves when receiving out-of-bounds values.\n  //\n  // Services **may** choose to accept values passed as input even when the\n  // value has a higher precision or scale than the service supports, and\n  // **should** round the value to fit the supported scale. Alternatively, the\n  // service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC)\n  // if precision would be lost.\n  //\n  // Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in\n  // gRPC) if the service receives a value outside of the supported range.\n  string value = 1;\n}\n","size_bytes":4213},"build/extracted-include-protos/test/google/type/quaternion.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/quaternion;quaternion\";\noption java_multiple_files = true;\noption java_outer_classname = \"QuaternionProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// A quaternion is defined as the quotient of two directed lines in a\n// three-dimensional space or equivalently as the quotient of two Euclidean\n// vectors (https://en.wikipedia.org/wiki/Quaternion).\n//\n// Quaternions are often used in calculations involving three-dimensional\n// rotations (https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation),\n// as they provide greater mathematical robustness by avoiding the gimbal lock\n// problems that can be encountered when using Euler angles\n// (https://en.wikipedia.org/wiki/Gimbal_lock).\n//\n// Quaternions are generally represented in this form:\n//\n//     w + xi + yj + zk\n//\n// where x, y, z, and w are real numbers, and i, j, and k are three imaginary\n// numbers.\n//\n// Our naming choice `(x, y, z, w)` comes from the desire to avoid confusion for\n// those interested in the geometric properties of the quaternion in the 3D\n// Cartesian space. Other texts often use alternative names or subscripts, such\n// as `(a, b, c, d)`, `(1, i, j, k)`, or `(0, 1, 2, 3)`, which are perhaps\n// better suited for mathematical interpretations.\n//\n// To avoid any confusion, as well as to maintain compatibility with a large\n// number of software libraries, the quaternions represented using the protocol\n// buffer below *must* follow the Hamilton convention, which defines `ij = k`\n// (i.e. a right-handed algebra), and therefore:\n//\n//     i^2 = j^2 = k^2 = ijk = 1\n//     ij = ji = k\n//     jk = kj = i\n//     ki = ik = j\n//\n// Please DO NOT use this to represent quaternions that follow the JPL\n// convention, or any of the other quaternion flavors out there.\n//\n// Definitions:\n//\n//   - Quaternion norm (or magnitude): `sqrt(x^2 + y^2 + z^2 + w^2)`.\n//   - Unit (or normalized) quaternion: a quaternion whose norm is 1.\n//   - Pure quaternion: a quaternion whose scalar component (`w`) is 0.\n//   - Rotation quaternion: a unit quaternion used to represent rotation.\n//   - Orientation quaternion: a unit quaternion used to represent orientation.\n//\n// A quaternion can be normalized by dividing it by its norm. The resulting\n// quaternion maintains the same direction, but has a norm of 1, i.e. it moves\n// on the unit sphere. This is generally necessary for rotation and orientation\n// quaternions, to avoid rounding errors:\n// https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions\n//\n// Note that `(x, y, z, w)` and `(-x, -y, -z, -w)` represent the same rotation,\n// but normalization would be even more useful, e.g. for comparison purposes, if\n// it would produce a unique representation. It is thus recommended that `w` be\n// kept positive, which can be achieved by changing all the signs when `w` is\n// negative.\n//\nmessage Quaternion {\n  // The x component.\n  double x = 1;\n\n  // The y component.\n  double y = 2;\n\n  // The z component.\n  double z = 3;\n\n  // The scalar component.\n  double w = 4;\n}\n","size_bytes":3791},"src/main/java/com/spiketrade/backend/TradeTracker.java":{"content":"package com.spiketrade.backend;\n\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TradeTracker {\n    private final List<Trade> openTrades;\n    private final List<Trade> closedTrades;\n    private final Object lock = new Object();\n    \n    public TradeTracker() {\n        this.openTrades = new ArrayList<>();\n        this.closedTrades = new ArrayList<>();\n    }\n    \n    public void openTrade(String symbol, double price, int shares) {\n        synchronized (lock) {\n            Trade trade = new Trade();\n            trade.symbol = symbol;\n            trade.entryPrice = price;\n            trade.shares = shares;\n            trade.entryTime = Instant.now();\n            trade.isOpen = true;\n            \n            openTrades.add(trade);\n        }\n    }\n    \n    public void closeTrade(String symbol, double price) {\n        synchronized (lock) {\n            for (int i = 0; i < openTrades.size(); i++) {\n                Trade trade = openTrades.get(i);\n                if (trade.symbol.equals(symbol)) {\n                    trade.exitPrice = price;\n                    trade.exitTime = Instant.now();\n                    trade.isOpen = false;\n                    trade.profitLoss = (trade.exitPrice - trade.entryPrice) * trade.shares;\n                    trade.profitLossPct = ((trade.exitPrice - trade.entryPrice) / trade.entryPrice) * 100.0;\n                    \n                    closedTrades.add(trade);\n                    openTrades.remove(i);\n                    break;\n                }\n            }\n        }\n    }\n    \n    public List<Trade> getOpenTrades() {\n        synchronized (lock) {\n            return new ArrayList<>(openTrades);\n        }\n    }\n    \n    public List<Trade> getClosedTrades() {\n        synchronized (lock) {\n            return new ArrayList<>(closedTrades);\n        }\n    }\n    \n    public double getTotalProfitLoss() {\n        synchronized (lock) {\n            double total = 0.0;\n            for (Trade trade : closedTrades) {\n                total += trade.profitLoss;\n            }\n            return total;\n        }\n    }\n}\n","size_bytes":2109},"build/extracted-include-protos/test/google/api/annotations.proto":{"content":"// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/api/http.proto\";\nimport \"google/protobuf/descriptor.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/annotations;annotations\";\noption java_multiple_files = true;\noption java_outer_classname = \"AnnotationsProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\nextend google.protobuf.MethodOptions {\n  // See `HttpRule`.\n  HttpRule http = 72295728;\n}\n","size_bytes":1045},"build/extracted-include-protos/test/google/type/month.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption go_package = \"google.golang.org/genproto/googleapis/type/month;month\";\noption java_multiple_files = true;\noption java_outer_classname = \"MonthProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a month in the Gregorian calendar.\nenum Month {\n  // The unspecified month.\n  MONTH_UNSPECIFIED = 0;\n\n  // The month of January.\n  JANUARY = 1;\n\n  // The month of February.\n  FEBRUARY = 2;\n\n  // The month of March.\n  MARCH = 3;\n\n  // The month of April.\n  APRIL = 4;\n\n  // The month of May.\n  MAY = 5;\n\n  // The month of June.\n  JUNE = 6;\n\n  // The month of July.\n  JULY = 7;\n\n  // The month of August.\n  AUGUST = 8;\n\n  // The month of September.\n  SEPTEMBER = 9;\n\n  // The month of October.\n  OCTOBER = 10;\n\n  // The month of November.\n  NOVEMBER = 11;\n\n  // The month of December.\n  DECEMBER = 12;\n}\n","size_bytes":1479},"build/extracted-include-protos/main/google/type/quaternion.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/quaternion;quaternion\";\noption java_multiple_files = true;\noption java_outer_classname = \"QuaternionProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// A quaternion is defined as the quotient of two directed lines in a\n// three-dimensional space or equivalently as the quotient of two Euclidean\n// vectors (https://en.wikipedia.org/wiki/Quaternion).\n//\n// Quaternions are often used in calculations involving three-dimensional\n// rotations (https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation),\n// as they provide greater mathematical robustness by avoiding the gimbal lock\n// problems that can be encountered when using Euler angles\n// (https://en.wikipedia.org/wiki/Gimbal_lock).\n//\n// Quaternions are generally represented in this form:\n//\n//     w + xi + yj + zk\n//\n// where x, y, z, and w are real numbers, and i, j, and k are three imaginary\n// numbers.\n//\n// Our naming choice `(x, y, z, w)` comes from the desire to avoid confusion for\n// those interested in the geometric properties of the quaternion in the 3D\n// Cartesian space. Other texts often use alternative names or subscripts, such\n// as `(a, b, c, d)`, `(1, i, j, k)`, or `(0, 1, 2, 3)`, which are perhaps\n// better suited for mathematical interpretations.\n//\n// To avoid any confusion, as well as to maintain compatibility with a large\n// number of software libraries, the quaternions represented using the protocol\n// buffer below *must* follow the Hamilton convention, which defines `ij = k`\n// (i.e. a right-handed algebra), and therefore:\n//\n//     i^2 = j^2 = k^2 = ijk = 1\n//     ij = ji = k\n//     jk = kj = i\n//     ki = ik = j\n//\n// Please DO NOT use this to represent quaternions that follow the JPL\n// convention, or any of the other quaternion flavors out there.\n//\n// Definitions:\n//\n//   - Quaternion norm (or magnitude): `sqrt(x^2 + y^2 + z^2 + w^2)`.\n//   - Unit (or normalized) quaternion: a quaternion whose norm is 1.\n//   - Pure quaternion: a quaternion whose scalar component (`w`) is 0.\n//   - Rotation quaternion: a unit quaternion used to represent rotation.\n//   - Orientation quaternion: a unit quaternion used to represent orientation.\n//\n// A quaternion can be normalized by dividing it by its norm. The resulting\n// quaternion maintains the same direction, but has a norm of 1, i.e. it moves\n// on the unit sphere. This is generally necessary for rotation and orientation\n// quaternions, to avoid rounding errors:\n// https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions\n//\n// Note that `(x, y, z, w)` and `(-x, -y, -z, -w)` represent the same rotation,\n// but normalization would be even more useful, e.g. for comparison purposes, if\n// it would produce a unique representation. It is thus recommended that `w` be\n// kept positive, which can be achieved by changing all the signs when `w` is\n// negative.\n//\nmessage Quaternion {\n  // The x component.\n  double x = 1;\n\n  // The y component.\n  double y = 2;\n\n  // The z component.\n  double z = 3;\n\n  // The scalar component.\n  double w = 4;\n}\n","size_bytes":3791},"build/extracted-include-protos/main/google/rpc/context/attribute_context.proto":{"content":"// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.rpc.context;\n\nimport \"google/protobuf/any.proto\";\nimport \"google/protobuf/duration.proto\";\nimport \"google/protobuf/struct.proto\";\nimport \"google/protobuf/timestamp.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/rpc/context/attribute_context;attribute_context\";\noption java_multiple_files = true;\noption java_outer_classname = \"AttributeContextProto\";\noption java_package = \"com.google.rpc.context\";\n\n// This message defines the standard attribute vocabulary for Google APIs.\n//\n// An attribute is a piece of metadata that describes an activity on a network\n// service. For example, the size of an HTTP request, or the status code of\n// an HTTP response.\n//\n// Each attribute has a type and a name, which is logically defined as\n// a proto message field in `AttributeContext`. The field type becomes the\n// attribute type, and the field path becomes the attribute name. For example,\n// the attribute `source.ip` maps to field `AttributeContext.source.ip`.\n//\n// This message definition is guaranteed not to have any wire breaking change.\n// So you can use it directly for passing attributes across different systems.\n//\n// NOTE: Different system may generate different subset of attributes. Please\n// verify the system specification before relying on an attribute generated\n// a system.\nmessage AttributeContext {\n  // This message defines attributes for a node that handles a network request.\n  // The node can be either a service or an application that sends, forwards,\n  // or receives the request. Service peers should fill in\n  // `principal` and `labels` as appropriate.\n  message Peer {\n    // The IP address of the peer.\n    string ip = 1;\n\n    // The network port of the peer.\n    int64 port = 2;\n\n    // The labels associated with the peer.\n    map<string, string> labels = 6;\n\n    // The identity of this peer. Similar to `Request.auth.principal`, but\n    // relative to the peer instead of the request. For example, the\n    // identity associated with a load balancer that forwarded the request.\n    string principal = 7;\n\n    // The CLDR country/region code associated with the above IP address.\n    // If the IP address is private, the `region_code` should reflect the\n    // physical location where this peer is running.\n    string region_code = 8;\n  }\n\n  // This message defines attributes associated with API operations, such as\n  // a network API request. The terminology is based on the conventions used\n  // by Google APIs, Istio, and OpenAPI.\n  message Api {\n    // The API service name. It is a logical identifier for a networked API,\n    // such as \"pubsub.googleapis.com\". The naming syntax depends on the\n    // API management system being used for handling the request.\n    string service = 1;\n\n    // The API operation name. For gRPC requests, it is the fully qualified API\n    // method name, such as \"google.pubsub.v1.Publisher.Publish\". For OpenAPI\n    // requests, it is the `operationId`, such as \"getPet\".\n    string operation = 2;\n\n    // The API protocol used for sending the request, such as \"http\", \"https\",\n    // \"grpc\", or \"internal\".\n    string protocol = 3;\n\n    // The API version associated with the API operation above, such as \"v1\" or\n    // \"v1alpha1\".\n    string version = 4;\n  }\n\n  // This message defines request authentication attributes. Terminology is\n  // based on the JSON Web Token (JWT) standard, but the terms also\n  // correlate to concepts in other standards.\n  message Auth {\n    // The authenticated principal. Reflects the issuer (`iss`) and subject\n    // (`sub`) claims within a JWT. The issuer and subject should be `/`\n    // delimited, with `/` percent-encoded within the subject fragment. For\n    // Google accounts, the principal format is:\n    // \"https://accounts.google.com/{id}\"\n    string principal = 1;\n\n    // The intended audience(s) for this authentication information. Reflects\n    // the audience (`aud`) claim within a JWT. The audience\n    // value(s) depends on the `issuer`, but typically include one or more of\n    // the following pieces of information:\n    //\n    // *  The services intended to receive the credential. For example,\n    //    [\"https://pubsub.googleapis.com/\", \"https://storage.googleapis.com/\"].\n    // *  A set of service-based scopes. For example,\n    //    [\"https://www.googleapis.com/auth/cloud-platform\"].\n    // *  The client id of an app, such as the Firebase project id for JWTs\n    //    from Firebase Auth.\n    //\n    // Consult the documentation for the credential issuer to determine the\n    // information provided.\n    repeated string audiences = 2;\n\n    // The authorized presenter of the credential. Reflects the optional\n    // Authorized Presenter (`azp`) claim within a JWT or the\n    // OAuth client id. For example, a Google Cloud Platform client id looks\n    // as follows: \"123456789012.apps.googleusercontent.com\".\n    string presenter = 3;\n\n    // Structured claims presented with the credential. JWTs include\n    // `{key: value}` pairs for standard and private claims. The following\n    // is a subset of the standard required and optional claims that would\n    // typically be presented for a Google-based JWT:\n    //\n    //    {'iss': 'accounts.google.com',\n    //     'sub': '113289723416554971153',\n    //     'aud': ['123456789012', 'pubsub.googleapis.com'],\n    //     'azp': '123456789012.apps.googleusercontent.com',\n    //     'email': 'jsmith@example.com',\n    //     'iat': 1353601026,\n    //     'exp': 1353604926}\n    //\n    // SAML assertions are similarly specified, but with an identity provider\n    // dependent structure.\n    google.protobuf.Struct claims = 4;\n\n    // A list of access level resource names that allow resources to be\n    // accessed by authenticated requester. It is part of Secure GCP processing\n    // for the incoming request. An access level string has the format:\n    // \"//{api_service_name}/accessPolicies/{policy_id}/accessLevels/{short_name}\"\n    //\n    // Example:\n    // \"//accesscontextmanager.googleapis.com/accessPolicies/MY_POLICY_ID/accessLevels/MY_LEVEL\"\n    repeated string access_levels = 5;\n  }\n\n  // This message defines attributes for an HTTP request. If the actual\n  // request is not an HTTP request, the runtime system should try to map\n  // the actual request to an equivalent HTTP request.\n  message Request {\n    // The unique ID for a request, which can be propagated to downstream\n    // systems. The ID should have low probability of collision\n    // within a single day for a specific service.\n    string id = 1;\n\n    // The HTTP request method, such as `GET`, `POST`.\n    string method = 2;\n\n    // The HTTP request headers. If multiple headers share the same key, they\n    // must be merged according to the HTTP spec. All header keys must be\n    // lowercased, because HTTP header keys are case-insensitive.\n    map<string, string> headers = 3;\n\n    // The HTTP URL path, excluding the query parameters.\n    string path = 4;\n\n    // The HTTP request `Host` header value.\n    string host = 5;\n\n    // The HTTP URL scheme, such as `http` and `https`.\n    string scheme = 6;\n\n    // The HTTP URL query in the format of `name1=value1&name2=value2`, as it\n    // appears in the first line of the HTTP request. No decoding is performed.\n    string query = 7;\n\n    // The timestamp when the `destination` service receives the last byte of\n    // the request.\n    google.protobuf.Timestamp time = 9;\n\n    // The HTTP request size in bytes. If unknown, it must be -1.\n    int64 size = 10;\n\n    // The network protocol used with the request, such as \"http/1.1\",\n    // \"spdy/3\", \"h2\", \"h2c\", \"webrtc\", \"tcp\", \"udp\", \"quic\". See\n    // https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids\n    // for details.\n    string protocol = 11;\n\n    // A special parameter for request reason. It is used by security systems\n    // to associate auditing information with a request.\n    string reason = 12;\n\n    // The request authentication. May be absent for unauthenticated requests.\n    // Derived from the HTTP request `Authorization` header or equivalent.\n    Auth auth = 13;\n  }\n\n  // This message defines attributes for a typical network response. It\n  // generally models semantics of an HTTP response.\n  message Response {\n    // The HTTP response status code, such as `200` and `404`.\n    int64 code = 1;\n\n    // The HTTP response size in bytes. If unknown, it must be -1.\n    int64 size = 2;\n\n    // The HTTP response headers. If multiple headers share the same key, they\n    // must be merged according to HTTP spec. All header keys must be\n    // lowercased, because HTTP header keys are case-insensitive.\n    map<string, string> headers = 3;\n\n    // The timestamp when the `destination` service sends the last byte of\n    // the response.\n    google.protobuf.Timestamp time = 4;\n\n    // The amount of time it takes the backend service to fully respond to a\n    // request. Measured from when the destination service starts to send the\n    // request to the backend until when the destination service receives the\n    // complete response from the backend.\n    google.protobuf.Duration backend_latency = 5;\n  }\n\n  // This message defines core attributes for a resource. A resource is an\n  // addressable (named) entity provided by the destination service. For\n  // example, a file stored on a network storage service.\n  message Resource {\n    // The name of the service that this resource belongs to, such as\n    // `pubsub.googleapis.com`. The service may be different from the DNS\n    // hostname that actually serves the request.\n    string service = 1;\n\n    // The stable identifier (name) of a resource on the `service`. A resource\n    // can be logically identified as \"//{resource.service}/{resource.name}\".\n    // The differences between a resource name and a URI are:\n    //\n    // *   Resource name is a logical identifier, independent of network\n    //     protocol and API version. For example,\n    //     `//pubsub.googleapis.com/projects/123/topics/news-feed`.\n    // *   URI often includes protocol and version information, so it can\n    //     be used directly by applications. For example,\n    //     `https://pubsub.googleapis.com/v1/projects/123/topics/news-feed`.\n    //\n    // See https://cloud.google.com/apis/design/resource_names for details.\n    string name = 2;\n\n    // The type of the resource. The syntax is platform-specific because\n    // different platforms define their resources differently.\n    //\n    // For Google APIs, the type format must be \"{service}/{kind}\", such as\n    // \"pubsub.googleapis.com/Topic\".\n    string type = 3;\n\n    // The labels or tags on the resource, such as AWS resource tags and\n    // Kubernetes resource labels.\n    map<string, string> labels = 4;\n\n    // The unique identifier of the resource. UID is unique in the time\n    // and space for this resource within the scope of the service. It is\n    // typically generated by the server on successful creation of a resource\n    // and must not be changed. UID is used to uniquely identify resources\n    // with resource name reuses. This should be a UUID4.\n    string uid = 5;\n\n    // Annotations is an unstructured key-value map stored with a resource that\n    // may be set by external tools to store and retrieve arbitrary metadata.\n    // They are not queryable and should be preserved when modifying objects.\n    //\n    // More info: https://kubernetes.io/docs/user-guide/annotations\n    map<string, string> annotations = 6;\n\n    // Mutable. The display name set by clients. Must be <= 63 characters.\n    string display_name = 7;\n\n    // Output only. The timestamp when the resource was created. This may\n    // be either the time creation was initiated or when it was completed.\n    google.protobuf.Timestamp create_time = 8;\n\n    // Output only. The timestamp when the resource was last updated. Any\n    // change to the resource made by users must refresh this value.\n    // Changes to a resource made by the service should refresh this value.\n    google.protobuf.Timestamp update_time = 9;\n\n    // Output only. The timestamp when the resource was deleted.\n    // If the resource is not deleted, this must be empty.\n    google.protobuf.Timestamp delete_time = 10;\n\n    // Output only. An opaque value that uniquely identifies a version or\n    // generation of a resource. It can be used to confirm that the client\n    // and server agree on the ordering of a resource being written.\n    string etag = 11;\n\n    // Immutable. The location of the resource. The location encoding is\n    // specific to the service provider, and new encoding may be introduced\n    // as the service evolves.\n    //\n    // For Google Cloud products, the encoding is what is used by Google Cloud\n    // APIs, such as `us-east1`, `aws-us-east-1`, and `azure-eastus2`. The\n    // semantics of `location` is identical to the\n    // `cloud.googleapis.com/location` label used by some Google Cloud APIs.\n    string location = 12;\n  }\n\n  // The origin of a network activity. In a multi hop network activity,\n  // the origin represents the sender of the first hop. For the first hop,\n  // the `source` and the `origin` must have the same content.\n  Peer origin = 7;\n\n  // The source of a network activity, such as starting a TCP connection.\n  // In a multi hop network activity, the source represents the sender of the\n  // last hop.\n  Peer source = 1;\n\n  // The destination of a network activity, such as accepting a TCP connection.\n  // In a multi hop network activity, the destination represents the receiver of\n  // the last hop.\n  Peer destination = 2;\n\n  // Represents a network request, such as an HTTP request.\n  Request request = 3;\n\n  // Represents a network response, such as an HTTP response.\n  Response response = 4;\n\n  // Represents a target resource that is involved with a network activity.\n  // If multiple resources are involved with an activity, this must be the\n  // primary one.\n  Resource resource = 5;\n\n  // Represents an API operation that is involved to a network activity.\n  Api api = 6;\n\n  // Supports extensions for advanced use cases, such as logs and metrics.\n  repeated google.protobuf.Any extensions = 8;\n}\n","size_bytes":14852},"run.sh":{"content":"#!/bin/bash\necho \"===================================\"\necho \"  SpikeTrade Professional Launcher\"\necho \"  100% Java Application\"\necho \"===================================\"\necho \"\"\necho \"Starting SpikeTrade...\"\necho \"\"\n\ncd \"$(dirname \"$0\")\"\n\n./gradlew run\n\necho \"\"\necho \"SpikeTrade has exited.\"\n","size_bytes":293},"build/extracted-include-protos/main/google/logging/type/http_request.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.logging.type;\n\nimport \"google/protobuf/duration.proto\";\n\noption csharp_namespace = \"Google.Cloud.Logging.Type\";\noption go_package = \"google.golang.org/genproto/googleapis/logging/type;ltype\";\noption java_multiple_files = true;\noption java_outer_classname = \"HttpRequestProto\";\noption java_package = \"com.google.logging.type\";\noption php_namespace = \"Google\\\\Cloud\\\\Logging\\\\Type\";\noption ruby_package = \"Google::Cloud::Logging::Type\";\n\n// A common proto for logging HTTP requests. Only contains semantics\n// defined by the HTTP specification. Product-specific logging\n// information MUST be defined in a separate message.\nmessage HttpRequest {\n  // The request method. Examples: `\"GET\"`, `\"HEAD\"`, `\"PUT\"`, `\"POST\"`.\n  string request_method = 1;\n\n  // The scheme (http, https), the host name, the path and the query\n  // portion of the URL that was requested.\n  // Example: `\"http://example.com/some/info?color=red\"`.\n  string request_url = 2;\n\n  // The size of the HTTP request message in bytes, including the request\n  // headers and the request body.\n  int64 request_size = 3;\n\n  // The response code indicating the status of response.\n  // Examples: 200, 404.\n  int32 status = 4;\n\n  // The size of the HTTP response message sent back to the client, in bytes,\n  // including the response headers and the response body.\n  int64 response_size = 5;\n\n  // The user agent sent by the client. Example:\n  // `\"Mozilla/4.0 (compatible; MSIE 6.0; Windows 98; Q312461; .NET\n  // CLR 1.0.3705)\"`.\n  string user_agent = 6;\n\n  // The IP address (IPv4 or IPv6) of the client that issued the HTTP\n  // request. This field can include port information. Examples:\n  // `\"192.168.1.1\"`, `\"10.0.0.1:80\"`, `\"FE80::0202:B3FF:FE1E:8329\"`.\n  string remote_ip = 7;\n\n  // The IP address (IPv4 or IPv6) of the origin server that the request was\n  // sent to. This field can include port information. Examples:\n  // `\"192.168.1.1\"`, `\"10.0.0.1:80\"`, `\"FE80::0202:B3FF:FE1E:8329\"`.\n  string server_ip = 13;\n\n  // The referer URL of the request, as defined in\n  // [HTTP/1.1 Header Field\n  // Definitions](https://datatracker.ietf.org/doc/html/rfc2616#section-14.36).\n  string referer = 8;\n\n  // The request processing latency on the server, from the time the request was\n  // received until the response was sent.\n  google.protobuf.Duration latency = 14;\n\n  // Whether or not a cache lookup was attempted.\n  bool cache_lookup = 11;\n\n  // Whether or not an entity was served from cache\n  // (with or without validation).\n  bool cache_hit = 9;\n\n  // Whether or not the response was validated with the origin server before\n  // being served from cache. This field is only meaningful if `cache_hit` is\n  // True.\n  bool cache_validated_with_origin_server = 10;\n\n  // The number of HTTP response bytes inserted into cache. Set only when a\n  // cache fill was attempted.\n  int64 cache_fill_bytes = 12;\n\n  // Protocol used for the request. Examples: \"HTTP/1.1\", \"HTTP/2\", \"websocket\"\n  string protocol = 15;\n}\n","size_bytes":3601},"src/main/java/com/spiketrade/backend/BuySignal.java":{"content":"package com.spiketrade.backend;\n\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class BuySignal {\n    public Instant timestamp;\n    public String symbol;\n    public double price;\n    public double signalProbability;\n    public IndicatorsData indicators;\n    public List<SpikeRecord> spikes;\n    public String reason;\n    \n    public double predictedGainTarget;\n    public int predictedTimeToTargetMinutes;\n    public double predictionConfidence;\n    public String predictionReasoning;\n    \n    // FIX #4: Bid-ask spread monitoring for small-cap stocks\n    public double bid;\n    public double ask;\n    public double spreadPercent;  // (ask - bid) / midpoint * 100\n    \n    public BuySignal() {\n        this.timestamp = Instant.now();\n        this.indicators = new IndicatorsData();\n        this.spikes = new ArrayList<>();\n        this.signalProbability = 0.0;\n        this.price = 0.0;\n        this.predictedGainTarget = 0.0;\n        this.predictedTimeToTargetMinutes = -1;\n        this.predictionConfidence = 0.0;\n        this.predictionReasoning = \"\";\n        this.bid = 0.0;\n        this.ask = 0.0;\n        this.spreadPercent = 0.0;\n    }\n}\n","size_bytes":1183},"src/main/java/com/spiketrade/backend/PredictionEngine.java":{"content":"package com.spiketrade.backend;\n\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class PredictionEngine {\n    \n    private static class HistoricalPattern {\n        public Instant timestamp;\n        public String symbol;\n        public double priceAtEntry;\n        public double priceRocZScore;\n        public double volumeRocZScore;\n        public double rsiRocZScore;\n        public double obvRocZScore;\n        public double mfiRocZScore;\n        public double percentBRocZScore;\n        public double vwapRocZScore;\n        public double priceRoc;\n        public double volumeRoc;\n        public double rsiRoc;\n        public double obvRoc;\n        public double mfiRoc;\n        public double percentBRoc;\n        public double vwapRoc;\n        public int priceRocPeriod;\n        public int rsiRocPeriod;\n        public int volumeRocPeriod;\n        public Map<Double, Integer> gainToTimeMinutes;\n        \n        public HistoricalPattern() {\n            gainToTimeMinutes = new HashMap<>();\n            priceRocPeriod = 20;  // Default values\n            rsiRocPeriod = 14;\n            volumeRocPeriod = 20;\n        }\n    }\n    \n    private final Map<String, List<HistoricalPattern>> historicalPatterns;\n    private final int maxPatternsPerSymbol = 500;\n    private final Object lock = new Object();\n    \n    public PredictionEngine() {\n        this.historicalPatterns = new ConcurrentHashMap<>();\n    }\n    \n    public void recordPattern(String symbol, BuySignal signal, double entryPrice, \n                             List<Double> priceHistory, int candlesPerMinute, \n                             int priceRocPeriod, int rsiRocPeriod, int volumeRocPeriod) {\n        synchronized (lock) {\n            if (signal == null || signal.indicators == null || signal.spikes == null) {\n                return;\n            }\n        \n        HistoricalPattern pattern = new HistoricalPattern();\n        pattern.timestamp = signal.timestamp;\n        pattern.symbol = symbol;\n        pattern.priceAtEntry = entryPrice;\n        \n        pattern.priceRoc = signal.indicators.priceRoc;\n        pattern.volumeRoc = signal.indicators.volumeRoc;\n        pattern.rsiRoc = signal.indicators.rsiRoc;\n        pattern.obvRoc = signal.indicators.obvRoc;\n        pattern.mfiRoc = signal.indicators.mfiRoc;\n        pattern.percentBRoc = signal.indicators.percentBRoc;\n        pattern.vwapRoc = signal.indicators.vwapRoc;\n        \n        // Store the ROC periods for accurate prediction\n        pattern.priceRocPeriod = priceRocPeriod;\n        pattern.rsiRocPeriod = rsiRocPeriod;\n        pattern.volumeRocPeriod = volumeRocPeriod;\n        \n        for (SpikeRecord spike : signal.spikes) {\n            if (spike.spikeType.equals(\"price_roc\")) {\n                pattern.priceRocZScore = spike.statisticalZScore != null ? spike.statisticalZScore : 0.0;\n            } else if (spike.spikeType.equals(\"volume_roc\")) {\n                pattern.volumeRocZScore = spike.statisticalZScore != null ? spike.statisticalZScore : 0.0;\n            } else if (spike.spikeType.equals(\"rsi_roc\")) {\n                pattern.rsiRocZScore = spike.statisticalZScore != null ? spike.statisticalZScore : 0.0;\n            } else if (spike.spikeType.equals(\"obv_roc\")) {\n                pattern.obvRocZScore = spike.statisticalZScore != null ? spike.statisticalZScore : 0.0;\n            } else if (spike.spikeType.equals(\"mfi_roc\")) {\n                pattern.mfiRocZScore = spike.statisticalZScore != null ? spike.statisticalZScore : 0.0;\n            } else if (spike.spikeType.equals(\"percent_b_roc\")) {\n                pattern.percentBRocZScore = spike.statisticalZScore != null ? spike.statisticalZScore : 0.0;\n            } else if (spike.spikeType.equals(\"vwap_roc\")) {\n                pattern.vwapRocZScore = spike.statisticalZScore != null ? spike.statisticalZScore : 0.0;\n            }\n        }\n        \n        if (priceHistory != null && !priceHistory.isEmpty()) {\n            double[] gainTargets = {0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 7.5, 10.0};\n            for (double targetGain : gainTargets) {\n                int minutesToTarget = calculateMinutesToTarget(priceHistory, entryPrice, targetGain, candlesPerMinute);\n                if (minutesToTarget > 0) {\n                    pattern.gainToTimeMinutes.put(targetGain, minutesToTarget);\n                }\n            }\n        }\n        \n            historicalPatterns.putIfAbsent(symbol, new ArrayList<>());\n            List<HistoricalPattern> patterns = historicalPatterns.get(symbol);\n            patterns.add(pattern);\n            \n            if (patterns.size() > maxPatternsPerSymbol) {\n                patterns.remove(0);\n            }\n        }\n    }\n    \n    private int calculateMinutesToTarget(List<Double> priceHistory, double entryPrice, \n                                        double targetGainPct, int candlesPerMinute) {\n        if (priceHistory == null || priceHistory.isEmpty() || entryPrice <= 0 || candlesPerMinute <= 0) {\n            return -1;\n        }\n        \n        double targetPrice = entryPrice * (1.0 + targetGainPct / 100.0);\n        \n        for (int i = 0; i < priceHistory.size(); i++) {\n            if (priceHistory.get(i) >= targetPrice) {\n                int minutes = i / candlesPerMinute;\n                return Math.max(1, minutes);\n            }\n        }\n        \n        return -1;\n    }\n    \n    public PredictionResult predictTimeToTarget(String symbol, BuySignal signal, double targetGainPct,\n                                               int priceRocPeriod, int rsiRocPeriod, int volumeRocPeriod) {\n        synchronized (lock) {\n            if (signal == null || signal.indicators == null) {\n                return new PredictionResult(targetGainPct, -1, 0.0, \"Insufficient signal data\");\n            }\n            \n            List<HistoricalPattern> patterns = historicalPatterns.get(symbol);\n            if (patterns == null || patterns.isEmpty()) {\n                return new PredictionResult(targetGainPct, \n                    estimateTimeBasedOnROC(signal, targetGainPct, priceRocPeriod, rsiRocPeriod, volumeRocPeriod), \n                    0.3, \"No historical data, using ROC-based estimate\");\n            }\n            \n            List<HistoricalPattern> patternsCopy = new ArrayList<>(patterns);\n            \n            List<PatternSimilarity> similarities = new ArrayList<>();\n            for (HistoricalPattern pattern : patternsCopy) {\n                double similarity = calculateSimilarity(signal, pattern);\n                if (similarity > 0.3) {\n                    similarities.add(new PatternSimilarity(pattern, similarity));\n                }\n            }\n        \n        if (similarities.isEmpty()) {\n            return new PredictionResult(targetGainPct, \n                estimateTimeBasedOnROC(signal, targetGainPct, priceRocPeriod, rsiRocPeriod, volumeRocPeriod), \n                0.4, \"No similar patterns, using ROC-based estimate\");\n        }\n        \n        similarities.sort((a, b) -> Double.compare(b.similarity, a.similarity));\n        \n        int topN = Math.min(10, similarities.size());\n        double weightedTimeSum = 0.0;\n        double weightSum = 0.0;\n        int patternsWithData = 0;\n        \n        for (int i = 0; i < topN; i++) {\n            PatternSimilarity ps = similarities.get(i);\n            Integer timeToTarget = ps.pattern.gainToTimeMinutes.get(targetGainPct);\n            \n            if (timeToTarget == null) {\n                timeToTarget = interpolateTime(ps.pattern.gainToTimeMinutes, targetGainPct);\n            }\n            \n            if (timeToTarget != null && timeToTarget > 0) {\n                double weight = ps.similarity;\n                weightedTimeSum += timeToTarget * weight;\n                weightSum += weight;\n                patternsWithData++;\n            }\n        }\n        \n        if (patternsWithData == 0) {\n            return new PredictionResult(targetGainPct, \n                estimateTimeBasedOnROC(signal, targetGainPct, priceRocPeriod, rsiRocPeriod, volumeRocPeriod), \n                0.5, \"Patterns found but no timeframe data, using ROC estimate\");\n        }\n        \n        int predictedMinutes = (int) Math.round(weightedTimeSum / weightSum);\n        double confidence = calculateConfidence(patternsWithData, similarities.size(), weightSum);\n        \n            String reason = String.format(\"Based on %d similar historical patterns (%.0f%% similarity)\", \n                                         patternsWithData, (weightSum / patternsWithData) * 100);\n            \n            return new PredictionResult(targetGainPct, predictedMinutes, confidence, reason);\n        }\n    }\n    \n    private double calculateSimilarity(BuySignal signal, HistoricalPattern pattern) {\n        double weights = 0.0;\n        double totalWeight = 0.0;\n        \n        // Compare ROC values (raw momentum indicators) - always available\n        double priceRocSim = 1.0 - Math.min(1.0, Math.abs(signal.indicators.priceRoc - pattern.priceRoc) / 10.0);\n        weights += priceRocSim * 0.15;\n        totalWeight += 0.15;\n        \n        double volumeRocSim = 1.0 - Math.min(1.0, Math.abs(signal.indicators.volumeRoc - pattern.volumeRoc) / 50.0);\n        weights += volumeRocSim * 0.08;\n        totalWeight += 0.08;\n        \n        double rsiRocSim = 1.0 - Math.min(1.0, Math.abs(signal.indicators.rsiRoc - pattern.rsiRoc) / 20.0);\n        weights += rsiRocSim * 0.08;\n        totalWeight += 0.08;\n        \n        double obvRocSim = 1.0 - Math.min(1.0, Math.abs(signal.indicators.obvRoc - pattern.obvRoc) / 50.0);\n        weights += obvRocSim * 0.08;\n        totalWeight += 0.08;\n        \n        double mfiRocSim = 1.0 - Math.min(1.0, Math.abs(signal.indicators.mfiRoc - pattern.mfiRoc) / 20.0);\n        weights += mfiRocSim * 0.06;\n        totalWeight += 0.06;\n        \n        double percentBRocSim = 1.0 - Math.min(1.0, Math.abs(signal.indicators.percentBRoc - pattern.percentBRoc) / 30.0);\n        weights += percentBRocSim * 0.05;\n        totalWeight += 0.05;\n        \n        double vwapRocSim = 1.0 - Math.min(1.0, Math.abs(signal.indicators.vwapRoc - pattern.vwapRoc) / 10.0);\n        weights += vwapRocSim * 0.05;\n        totalWeight += 0.05;\n        \n        // FIX: Only compare Z-scores when BOTH signal and pattern have actual spike data\n        // Skip spike dimensions entirely when either side lacks data - let ROC values determine similarity\n        boolean signalHasPriceSpike = hasSpikeType(signal, \"price_roc\");\n        boolean signalHasVolumeSpike = hasSpikeType(signal, \"volume_roc\");\n        boolean signalHasRsiSpike = hasSpikeType(signal, \"rsi_roc\");\n        \n        boolean patternHasPriceSpike = Math.abs(pattern.priceRocZScore) > 0.01;\n        boolean patternHasVolumeSpike = Math.abs(pattern.volumeRocZScore) > 0.01;\n        boolean patternHasRsiSpike = Math.abs(pattern.rsiRocZScore) > 0.01;\n        \n        // Price spike Z-score comparison (only if both have spike data)\n        if (signalHasPriceSpike && patternHasPriceSpike) {\n            double signalPriceZScore = getZScoreFromSignal(signal, \"price_roc\");\n            double priceZScoreSim = 1.0 - Math.min(1.0, Math.abs(signalPriceZScore - pattern.priceRocZScore) / 5.0);\n            weights += priceZScoreSim * 0.20;\n            totalWeight += 0.20;\n        }\n        // Skip this dimension entirely if spike data is missing - no fixed bonus, no penalty\n        \n        // Volume spike Z-score comparison (only if both have spike data)\n        if (signalHasVolumeSpike && patternHasVolumeSpike) {\n            double signalVolumeZScore = getZScoreFromSignal(signal, \"volume_roc\");\n            double volumeZScoreSim = 1.0 - Math.min(1.0, Math.abs(signalVolumeZScore - pattern.volumeRocZScore) / 5.0);\n            weights += volumeZScoreSim * 0.15;\n            totalWeight += 0.15;\n        }\n        \n        // RSI spike Z-score comparison (only if both have spike data)\n        if (signalHasRsiSpike && patternHasRsiSpike) {\n            double signalRsiZScore = getZScoreFromSignal(signal, \"rsi_roc\");\n            double rsiZScoreSim = 1.0 - Math.min(1.0, Math.abs(signalRsiZScore - pattern.rsiRocZScore) / 5.0);\n            weights += rsiZScoreSim * 0.10;\n            totalWeight += 0.10;\n        }\n        \n        return weights / totalWeight;\n    }\n    \n    private boolean hasSpikeType(BuySignal signal, String spikeType) {\n        if (signal.spikes == null) return false;\n        \n        for (SpikeRecord spike : signal.spikes) {\n            if (spike.spikeType.equals(spikeType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    private double getZScoreFromSignal(BuySignal signal, String spikeType) {\n        if (signal.spikes == null) return 0.0;\n        \n        for (SpikeRecord spike : signal.spikes) {\n            if (spike.spikeType.equals(spikeType)) {\n                return spike.statisticalZScore != null ? spike.statisticalZScore : 0.0;\n            }\n        }\n        return 0.0;\n    }\n    \n    private Integer interpolateTime(Map<Double, Integer> gainToTimeMinutes, double targetGain) {\n        if (gainToTimeMinutes.isEmpty()) {\n            return null;\n        }\n        \n        Double lowerGain = null;\n        Double higherGain = null;\n        \n        for (Double gain : gainToTimeMinutes.keySet()) {\n            if (gain < targetGain && (lowerGain == null || gain > lowerGain)) {\n                lowerGain = gain;\n            }\n            if (gain > targetGain && (higherGain == null || gain < higherGain)) {\n                higherGain = gain;\n            }\n        }\n        \n        if (lowerGain != null && higherGain != null) {\n            int lowerTime = gainToTimeMinutes.get(lowerGain);\n            int higherTime = gainToTimeMinutes.get(higherGain);\n            double ratio = (targetGain - lowerGain) / (higherGain - lowerGain);\n            return (int) Math.round(lowerTime + ratio * (higherTime - lowerTime));\n        } else if (lowerGain != null) {\n            double ratio = targetGain / lowerGain;\n            return (int) Math.round(gainToTimeMinutes.get(lowerGain) * ratio);\n        } else if (higherGain != null) {\n            double ratio = targetGain / higherGain;\n            return (int) Math.round(gainToTimeMinutes.get(higherGain) * ratio);\n        }\n        \n        return null;\n    }\n    \n    private int estimateTimeBasedOnROC(BuySignal signal, double targetGainPct, \n                                       int priceRocPeriod, int rsiRocPeriod, int volumeRocPeriod) {\n        // FIX: Convert ROC values to per-minute rates by dividing by their periods\n        // Before: assumed ROC was % per 60 minutes (WRONG)\n        // After: properly normalize ROC to % per minute based on actual calculation period\n        \n        // Defensive check: prevent division by zero if periods are misconfigured\n        if (priceRocPeriod <= 0 || rsiRocPeriod <= 0 || volumeRocPeriod <= 0) {\n            System.err.println(\"WARNING: Invalid ROC period configuration detected. Using defaults.\");\n            priceRocPeriod = Math.max(1, priceRocPeriod);\n            rsiRocPeriod = Math.max(1, rsiRocPeriod);\n            volumeRocPeriod = Math.max(1, volumeRocPeriod);\n        }\n        \n        double priceRocPerMinute = signal.indicators.priceRoc / priceRocPeriod;\n        double volumeRocPerMinute = signal.indicators.volumeRoc / volumeRocPeriod;\n        double rsiRocPerMinute = signal.indicators.rsiRoc / rsiRocPeriod;\n        \n        // Weighted average of per-minute ROC values (price weighted most heavily)\n        double avgRocPerMinute = (priceRocPerMinute * 1.0 + \n                                 volumeRocPerMinute * 0.1 + \n                                 rsiRocPerMinute * 0.2) / 1.3;\n        \n        if (avgRocPerMinute <= 0) {\n            return 480;  // Default to 8 hours if no positive momentum\n        }\n        \n        // Calculate minutes needed to achieve target gain at current rate\n        double minutesPerPercent = 1.0 / avgRocPerMinute;\n        int estimatedMinutes = (int) Math.round(minutesPerPercent * targetGainPct);\n        \n        // Reasonable bounds: 5 minutes to 24 hours\n        estimatedMinutes = Math.max(5, Math.min(estimatedMinutes, 1440));\n        \n        return estimatedMinutes;\n    }\n    \n    private double calculateConfidence(int patternsUsed, int totalPatterns, double avgSimilarity) {\n        double dataConfidence = Math.min(1.0, patternsUsed / 10.0);\n        double similarityConfidence = avgSimilarity / patternsUsed;\n        double volumeConfidence = Math.min(1.0, totalPatterns / 50.0);\n        \n        return (dataConfidence * 0.4 + similarityConfidence * 0.4 + volumeConfidence * 0.2);\n    }\n    \n    public int getHistoricalPatternCount(String symbol) {\n        synchronized (lock) {\n            List<HistoricalPattern> patterns = historicalPatterns.get(symbol);\n            return patterns != null ? patterns.size() : 0;\n        }\n    }\n    \n    public void clearHistory(String symbol) {\n        synchronized (lock) {\n            if (symbol == null) {\n                historicalPatterns.clear();\n            } else {\n                historicalPatterns.remove(symbol);\n            }\n        }\n    }\n    \n    private static class PatternSimilarity {\n        HistoricalPattern pattern;\n        double similarity;\n        \n        PatternSimilarity(HistoricalPattern pattern, double similarity) {\n            this.pattern = pattern;\n            this.similarity = similarity;\n        }\n    }\n    \n    public static class PredictionResult {\n        public double targetGainPercent;\n        public int predictedMinutes;\n        public double confidence;\n        public String reasoning;\n        \n        public PredictionResult(double targetGainPercent, int predictedMinutes, \n                               double confidence, String reasoning) {\n            this.targetGainPercent = targetGainPercent;\n            this.predictedMinutes = predictedMinutes;\n            this.confidence = confidence;\n            this.reasoning = reasoning;\n        }\n        \n        public String getFormattedTimeframe() {\n            if (predictedMinutes < 0) {\n                return \"Unknown\";\n            } else if (predictedMinutes < 60) {\n                return predictedMinutes + \" minutes\";\n            } else if (predictedMinutes < 1440) {\n                int hours = predictedMinutes / 60;\n                int mins = predictedMinutes % 60;\n                return hours + \"h \" + mins + \"m\";\n            } else {\n                int days = predictedMinutes / 1440;\n                int hours = (predictedMinutes % 1440) / 60;\n                return days + \"d \" + hours + \"h\";\n            }\n        }\n    }\n}\n","size_bytes":18747},"build/extracted-include-protos/test/google/cloud/extended_operations.proto":{"content":"// Copyright 2021 Google LLC.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// This file contains custom annotations that are used by GAPIC generators to\n// handle Long Running Operation methods (LRO) that are NOT compliant with\n// https://google.aip.dev/151. These annotations are public for technical\n// reasons only. Please DO NOT USE them in your protos.\nsyntax = \"proto3\";\n\npackage google.cloud;\n\nimport \"google/protobuf/descriptor.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/cloud/extendedops;extendedops\";\noption java_multiple_files = true;\noption java_outer_classname = \"ExtendedOperationsProto\";\noption java_package = \"com.google.cloud\";\noption objc_class_prefix = \"GAPI\";\n\n// FieldOptions to match corresponding fields in the initial request,\n// polling request and operation response messages.\n//\n// Example:\n//\n// In an API-specific operation message:\n//\n//     message MyOperation {\n//       string http_error_message = 1 [(operation_field) = ERROR_MESSAGE];\n//       int32 http_error_status_code = 2 [(operation_field) = ERROR_CODE];\n//       string id = 3 [(operation_field) = NAME];\n//       Status status = 4 [(operation_field) = STATUS];\n//     }\n//\n// In a polling request message (the one which is used to poll for an LRO\n// status):\n//\n//     message MyPollingRequest {\n//       string operation = 1 [(operation_response_field) = \"id\"];\n//       string project = 2;\n//       string region = 3;\n//     }\n//\n// In an initial request message (the one which starts an LRO):\n//\n//    message MyInitialRequest {\n//      string my_project = 2 [(operation_request_field) = \"project\"];\n//      string my_region = 3 [(operation_request_field) = \"region\"];\n//    }\n//\nextend google.protobuf.FieldOptions {\n  // A field annotation that maps fields in an API-specific Operation object to\n  // their standard counterparts in google.longrunning.Operation. See\n  // OperationResponseMapping enum definition.\n  OperationResponseMapping operation_field = 1149;\n\n  // A field annotation that maps fields in the initial request message\n  // (the one which started the LRO) to their counterparts in the polling\n  // request message. For non-standard LRO, the polling response may be missing\n  // some of the information needed to make a subsequent polling request. The\n  // missing information (for example, project or region ID) is contained in the\n  // fields of the initial request message that this annotation must be applied\n  // to. The string value of the annotation corresponds to the name of the\n  // counterpart field in the polling request message that the annotated field's\n  // value will be copied to.\n  string operation_request_field = 1150;\n\n  // A field annotation that maps fields in the polling request message to their\n  // counterparts in the initial and/or polling response message. The initial\n  // and the polling methods return an API-specific Operation object. Some of\n  // the fields from that response object must be reused in the subsequent\n  // request (like operation name/ID) to fully identify the polled operation.\n  // This annotation must be applied to the fields in the polling request\n  // message, the string value of the annotation must correspond to the name of\n  // the counterpart field in the Operation response object whose value will be\n  // copied to the annotated field.\n  string operation_response_field = 1151;\n}\n\n// MethodOptions to identify the actual service and method used for operation\n// status polling.\n//\n// Example:\n//\n// In a method, which starts an LRO:\n//\n//     service MyService {\n//       rpc Foo(MyInitialRequest) returns (MyOperation) {\n//         option (operation_service) = \"MyPollingService\";\n//       }\n//     }\n//\n// In a polling method:\n//\n//     service MyPollingService {\n//       rpc Get(MyPollingRequest) returns (MyOperation) {\n//         option (operation_polling_method) = true;\n//       }\n//     }\nextend google.protobuf.MethodOptions {\n  // A method annotation that maps an LRO method (the one which starts an LRO)\n  // to the service, which will be used to poll for the operation status. The\n  // annotation must be applied to the method which starts an LRO, the string\n  // value of the annotation must correspond to the name of the service used to\n  // poll for the operation status.\n  string operation_service = 1249;\n\n  // A method annotation that marks methods that can be used for polling\n  // operation status (e.g. the MyPollingService.Get(MyPollingRequest) method).\n  bool operation_polling_method = 1250;\n}\n\n// An enum to be used to mark the essential (for polling) fields in an\n// API-specific Operation object. A custom Operation object may contain many\n// different fields, but only few of them are essential to conduct a successful\n// polling process.\nenum OperationResponseMapping {\n  // Do not use.\n  UNDEFINED = 0;\n\n  // A field in an API-specific (custom) Operation object which carries the same\n  // meaning as google.longrunning.Operation.name.\n  NAME = 1;\n\n  // A field in an API-specific (custom) Operation object which carries the same\n  // meaning as google.longrunning.Operation.done. If the annotated field is of\n  // an enum type, `annotated_field_name == EnumType.DONE` semantics should be\n  // equivalent to `Operation.done == true`. If the annotated field is of type\n  // boolean, then it should follow the same semantics as Operation.done.\n  // Otherwise, a non-empty value should be treated as `Operation.done == true`.\n  STATUS = 2;\n\n  // A field in an API-specific (custom) Operation object which carries the same\n  // meaning as google.longrunning.Operation.error.code.\n  ERROR_CODE = 3;\n\n  // A field in an API-specific (custom) Operation object which carries the same\n  // meaning as google.longrunning.Operation.error.message.\n  ERROR_MESSAGE = 4;\n}","size_bytes":6308},"build/extracted-include-protos/main/google/type/date.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/date;date\";\noption java_multiple_files = true;\noption java_outer_classname = \"DateProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a whole or partial calendar date, such as a birthday. The time of\n// day and time zone are either specified elsewhere or are insignificant. The\n// date is relative to the Gregorian Calendar. This can represent one of the\n// following:\n//\n// * A full date, with non-zero year, month, and day values\n// * A month and day value, with a zero year, such as an anniversary\n// * A year on its own, with zero month and day values\n// * A year and month value, with a zero day, such as a credit card expiration\n// date\n//\n// Related types are [google.type.TimeOfDay][google.type.TimeOfDay] and\n// `google.protobuf.Timestamp`.\nmessage Date {\n  // Year of the date. Must be from 1 to 9999, or 0 to specify a date without\n  // a year.\n  int32 year = 1;\n\n  // Month of a year. Must be from 1 to 12, or 0 to specify a year without a\n  // month and day.\n  int32 month = 2;\n\n  // Day of a month. Must be from 1 to 31 and valid for the year and month, or 0\n  // to specify a year by itself or a year and month where the day isn't\n  // significant.\n  int32 day = 3;\n}\n","size_bytes":1955},"build/extracted-include-protos/test/google/api/field_behavior.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/descriptor.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/annotations;annotations\";\noption java_multiple_files = true;\noption java_outer_classname = \"FieldBehaviorProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\nextend google.protobuf.FieldOptions {\n  // A designation of a specific field behavior (required, output only, etc.)\n  // in protobuf messages.\n  //\n  // Examples:\n  //\n  //   string name = 1 [(google.api.field_behavior) = REQUIRED];\n  //   State state = 1 [(google.api.field_behavior) = OUTPUT_ONLY];\n  //   google.protobuf.Duration ttl = 1\n  //     [(google.api.field_behavior) = INPUT_ONLY];\n  //   google.protobuf.Timestamp expire_time = 1\n  //     [(google.api.field_behavior) = OUTPUT_ONLY,\n  //      (google.api.field_behavior) = IMMUTABLE];\n  repeated google.api.FieldBehavior field_behavior = 1052;\n}\n\n// An indicator of the behavior of a given field (for example, that a field\n// is required in requests, or given as output but ignored as input).\n// This **does not** change the behavior in protocol buffers itself; it only\n// denotes the behavior and may affect how API tooling handles the field.\n//\n// Note: This enum **may** receive new values in the future.\nenum FieldBehavior {\n  // Conventional default for enums. Do not use this.\n  FIELD_BEHAVIOR_UNSPECIFIED = 0;\n\n  // Specifically denotes a field as optional.\n  // While all fields in protocol buffers are optional, this may be specified\n  // for emphasis if appropriate.\n  OPTIONAL = 1;\n\n  // Denotes a field as required.\n  // This indicates that the field **must** be provided as part of the request,\n  // and failure to do so will cause an error (usually `INVALID_ARGUMENT`).\n  REQUIRED = 2;\n\n  // Denotes a field as output only.\n  // This indicates that the field is provided in responses, but including the\n  // field in a request does nothing (the server *must* ignore it and\n  // *must not* throw an error as a result of the field's presence).\n  OUTPUT_ONLY = 3;\n\n  // Denotes a field as input only.\n  // This indicates that the field is provided in requests, and the\n  // corresponding field is not included in output.\n  INPUT_ONLY = 4;\n\n  // Denotes a field as immutable.\n  // This indicates that the field may be set once in a request to create a\n  // resource, but may not be changed thereafter.\n  IMMUTABLE = 5;\n\n  // Denotes that a (repeated) field is an unordered list.\n  // This indicates that the service may provide the elements of the list\n  // in any arbitrary  order, rather than the order the user originally\n  // provided. Additionally, the list's order may or may not be stable.\n  UNORDERED_LIST = 6;\n\n  // Denotes that this field returns a non-empty default value if not set.\n  // This indicates that if the user provides the empty value in a request,\n  // a non-empty value will be returned. The user will not be aware of what\n  // non-empty value to expect.\n  NON_EMPTY_DEFAULT = 7;\n}\n","size_bytes":3604},"src/main/proto/trading_service.proto":{"content":"syntax = \"proto3\";\n\npackage spiketrade.proto;\n\nimport \"market_data.proto\";\nimport \"spike_signals.proto\";\nimport \"config.proto\";\n\noption java_package = \"com.spiketrade.proto\";\noption java_outer_classname = \"TradingServiceProto\";\n\n// Trading service definition\nservice TradingService {\n  // Connection management\n  rpc Connect(ConnectRequest) returns (ConnectResponse);\n  rpc GetStatus(StatusRequest) returns (StatusResponse);\n  \n  // Market data\n  rpc GetHistoricalData(HistoricalDataRequest) returns (HistoricalDataResponse);\n  rpc StreamQuotes(QuoteStreamRequest) returns (stream Quote);\n  \n  // Signals and analysis\n  rpc StreamSignals(SignalStreamRequest) returns (stream BuySignal);\n  rpc GetAnalysisStatus(AnalysisStatusRequest) returns (AnalysisStatus);\n  rpc GetSellWarning(SellWarningRequest) returns (SellWarning);\n  \n  // Configuration\n  rpc UpdateConfig(ConfigUpdateRequest) returns (ConfigResponse);\n  rpc GetConfig(ConfigRequest) returns (ConfigResponse);\n  \n  // Trading control\n  rpc StartTrading(StartTradingRequest) returns (TradingControlResponse);\n  rpc StopTrading(StopTradingRequest) returns (TradingControlResponse);\n  \n  // Backtesting\n  rpc RunBacktest(BacktestRequest) returns (BacktestResponse);\n  rpc StreamIndicators(IndicatorStreamRequest) returns (stream IndicatorUpdate);\n  \n  // Trade Tracking\n  rpc GetOpenTrades(GetOpenTradesRequest) returns (GetOpenTradesResponse);\n  rpc GetClosedTrades(GetClosedTradesRequest) returns (GetClosedTradesResponse);\n}\n\n// Request/Response messages\nmessage ConnectRequest {\n  string questrade_token = 1;\n}\n\nmessage ConnectResponse {\n  bool success = 1;\n  string message = 2;\n  ConnectionStatus status = 3;\n}\n\nmessage StatusRequest {}\n\nmessage StatusResponse {\n  bool is_trading = 1;\n  ConnectionStatus connection_status = 2;\n  int32 total_signals = 3;\n  int32 active_positions = 4;\n}\n\nmessage AnalysisStatusRequest {\n  string symbol = 1;\n}\n\nmessage ConfigRequest {}\n\nmessage StartTradingRequest {\n  repeated string symbols = 1;\n}\n\nmessage StopTradingRequest {}\n\nmessage TradingControlResponse {\n  bool success = 1;\n  string message = 2;\n}\n\nmessage BacktestRequest {\n  string symbol = 1;\n  string start_date = 2;  // Format: YYYY-MM-DD\n  string end_date = 3;    // Format: YYYY-MM-DD\n  double initial_capital = 4;\n  int32 interval_minutes = 5;\n}\n\nmessage BacktestTrade {\n  string timestamp = 1;\n  string action = 2;  // \"BUY\" or \"SELL\"\n  double price = 3;\n  int32 shares = 4;\n  double total = 5;\n  double balance = 6;\n  double signal_probability = 7;\n}\n\nmessage BacktestResponse {\n  bool success = 1;\n  string message = 2;\n  repeated BacktestTrade trades = 3;\n  double final_balance = 4;\n  double total_return = 5;\n  int32 total_trades = 6;\n  int32 winning_trades = 7;\n  int32 losing_trades = 8;\n  double win_rate = 9;\n}\n\n// Trade tracking messages\nmessage Trade {\n  string symbol = 1;\n  double entry_price = 2;\n  double exit_price = 3;\n  int32 shares = 4;\n  int64 entry_time_ms = 5;\n  int64 exit_time_ms = 6;\n  double profit_loss = 7;\n  double profit_loss_pct = 8;\n  bool is_open = 9;\n}\n\nmessage GetOpenTradesRequest {}\n\nmessage GetOpenTradesResponse {\n  repeated Trade trades = 1;\n}\n\nmessage GetClosedTradesRequest {}\n\nmessage GetClosedTradesResponse {\n  repeated Trade trades = 1;\n  double total_profit_loss = 2;\n  int32 total_trades = 3;\n  int32 winning_trades = 4;\n  double win_rate = 5;\n}\n","size_bytes":3359},"build/extracted-include-protos/main/google/type/color.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\nimport \"google/protobuf/wrappers.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/color;color\";\noption java_multiple_files = true;\noption java_outer_classname = \"ColorProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a color in the RGBA color space. This representation is designed\n// for simplicity of conversion to/from color representations in various\n// languages over compactness. For example, the fields of this representation\n// can be trivially provided to the constructor of `java.awt.Color` in Java; it\n// can also be trivially provided to UIColor's `+colorWithRed:green:blue:alpha`\n// method in iOS; and, with just a little work, it can be easily formatted into\n// a CSS `rgba()` string in JavaScript.\n//\n// This reference page doesn't carry information about the absolute color\n// space\n// that should be used to interpret the RGB value (e.g. sRGB, Adobe RGB,\n// DCI-P3, BT.2020, etc.). By default, applications should assume the sRGB color\n// space.\n//\n// When color equality needs to be decided, implementations, unless\n// documented otherwise, treat two colors as equal if all their red,\n// green, blue, and alpha values each differ by at most 1e-5.\n//\n// Example (Java):\n//\n//      import com.google.type.Color;\n//\n//      // ...\n//      public static java.awt.Color fromProto(Color protocolor) {\n//        float alpha = protocolor.hasAlpha()\n//            ? protocolor.getAlpha().getValue()\n//            : 1.0;\n//\n//        return new java.awt.Color(\n//            protocolor.getRed(),\n//            protocolor.getGreen(),\n//            protocolor.getBlue(),\n//            alpha);\n//      }\n//\n//      public static Color toProto(java.awt.Color color) {\n//        float red = (float) color.getRed();\n//        float green = (float) color.getGreen();\n//        float blue = (float) color.getBlue();\n//        float denominator = 255.0;\n//        Color.Builder resultBuilder =\n//            Color\n//                .newBuilder()\n//                .setRed(red / denominator)\n//                .setGreen(green / denominator)\n//                .setBlue(blue / denominator);\n//        int alpha = color.getAlpha();\n//        if (alpha != 255) {\n//          result.setAlpha(\n//              FloatValue\n//                  .newBuilder()\n//                  .setValue(((float) alpha) / denominator)\n//                  .build());\n//        }\n//        return resultBuilder.build();\n//      }\n//      // ...\n//\n// Example (iOS / Obj-C):\n//\n//      // ...\n//      static UIColor* fromProto(Color* protocolor) {\n//         float red = [protocolor red];\n//         float green = [protocolor green];\n//         float blue = [protocolor blue];\n//         FloatValue* alpha_wrapper = [protocolor alpha];\n//         float alpha = 1.0;\n//         if (alpha_wrapper != nil) {\n//           alpha = [alpha_wrapper value];\n//         }\n//         return [UIColor colorWithRed:red green:green blue:blue alpha:alpha];\n//      }\n//\n//      static Color* toProto(UIColor* color) {\n//          CGFloat red, green, blue, alpha;\n//          if (![color getRed:&red green:&green blue:&blue alpha:&alpha]) {\n//            return nil;\n//          }\n//          Color* result = [[Color alloc] init];\n//          [result setRed:red];\n//          [result setGreen:green];\n//          [result setBlue:blue];\n//          if (alpha <= 0.9999) {\n//            [result setAlpha:floatWrapperWithValue(alpha)];\n//          }\n//          [result autorelease];\n//          return result;\n//     }\n//     // ...\n//\n//  Example (JavaScript):\n//\n//     // ...\n//\n//     var protoToCssColor = function(rgb_color) {\n//        var redFrac = rgb_color.red || 0.0;\n//        var greenFrac = rgb_color.green || 0.0;\n//        var blueFrac = rgb_color.blue || 0.0;\n//        var red = Math.floor(redFrac * 255);\n//        var green = Math.floor(greenFrac * 255);\n//        var blue = Math.floor(blueFrac * 255);\n//\n//        if (!('alpha' in rgb_color)) {\n//           return rgbToCssColor(red, green, blue);\n//        }\n//\n//        var alphaFrac = rgb_color.alpha.value || 0.0;\n//        var rgbParams = [red, green, blue].join(',');\n//        return ['rgba(', rgbParams, ',', alphaFrac, ')'].join('');\n//     };\n//\n//     var rgbToCssColor = function(red, green, blue) {\n//       var rgbNumber = new Number((red << 16) | (green << 8) | blue);\n//       var hexString = rgbNumber.toString(16);\n//       var missingZeros = 6 - hexString.length;\n//       var resultBuilder = ['#'];\n//       for (var i = 0; i < missingZeros; i++) {\n//          resultBuilder.push('0');\n//       }\n//       resultBuilder.push(hexString);\n//       return resultBuilder.join('');\n//     };\n//\n//     // ...\nmessage Color {\n  // The amount of red in the color as a value in the interval [0, 1].\n  float red = 1;\n\n  // The amount of green in the color as a value in the interval [0, 1].\n  float green = 2;\n\n  // The amount of blue in the color as a value in the interval [0, 1].\n  float blue = 3;\n\n  // The fraction of this color that should be applied to the pixel. That is,\n  // the final pixel color is defined by the equation:\n  //\n  //   `pixel color = alpha * (this color) + (1.0 - alpha) * (background color)`\n  //\n  // This means that a value of 1.0 corresponds to a solid color, whereas\n  // a value of 0.0 corresponds to a completely transparent color. This\n  // uses a wrapper message rather than a simple float scalar so that it is\n  // possible to distinguish between a default value and the value being unset.\n  // If omitted, this color object is rendered as a solid color\n  // (as if the alpha value had been explicitly given a value of 1.0).\n  google.protobuf.FloatValue alpha = 4;\n}\n","size_bytes":6376},"build/extracted-include-protos/test/google/protobuf/empty.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption go_package = \"google.golang.org/protobuf/types/known/emptypb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"EmptyProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\noption cc_enable_arenas = true;\n\n// A generic empty message that you can re-use to avoid defining duplicated\n// empty messages in your APIs. A typical example is to use it as the request\n// or the response type of an API method. For instance:\n//\n//     service Foo {\n//       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);\n//     }\n//\nmessage Empty {}\n","size_bytes":2363},"build/extracted-include-protos/main/google/protobuf/timestamp.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/protobuf/types/known/timestamppb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"TimestampProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\n\n// A Timestamp represents a point in time independent of any time zone or local\n// calendar, encoded as a count of seconds and fractions of seconds at\n// nanosecond resolution. The count is relative to an epoch at UTC midnight on\n// January 1, 1970, in the proleptic Gregorian calendar which extends the\n// Gregorian calendar backwards to year one.\n//\n// All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n// second table is needed for interpretation, using a [24-hour linear\n// smear](https://developers.google.com/time/smear).\n//\n// The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n// restricting to that range, we ensure that we can convert to and from [RFC\n// 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n//\n// # Examples\n//\n// Example 1: Compute Timestamp from POSIX `time()`.\n//\n//     Timestamp timestamp;\n//     timestamp.set_seconds(time(NULL));\n//     timestamp.set_nanos(0);\n//\n// Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n//\n//     struct timeval tv;\n//     gettimeofday(&tv, NULL);\n//\n//     Timestamp timestamp;\n//     timestamp.set_seconds(tv.tv_sec);\n//     timestamp.set_nanos(tv.tv_usec * 1000);\n//\n// Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n//\n//     FILETIME ft;\n//     GetSystemTimeAsFileTime(&ft);\n//     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n//\n//     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n//     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n//     Timestamp timestamp;\n//     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n//     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n//\n// Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n//\n//     long millis = System.currentTimeMillis();\n//\n//     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n//         .setNanos((int) ((millis % 1000) * 1000000)).build();\n//\n// Example 5: Compute Timestamp from Java `Instant.now()`.\n//\n//     Instant now = Instant.now();\n//\n//     Timestamp timestamp =\n//         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n//             .setNanos(now.getNano()).build();\n//\n// Example 6: Compute Timestamp from current time in Python.\n//\n//     timestamp = Timestamp()\n//     timestamp.GetCurrentTime()\n//\n// # JSON Mapping\n//\n// In JSON format, the Timestamp type is encoded as a string in the\n// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n// format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n// where {year} is always expressed using four digits while {month}, {day},\n// {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n// seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n// are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n// is required. A proto3 JSON serializer should always use UTC (as indicated by\n// \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n// able to accept both UTC and other timezones (as indicated by an offset).\n//\n// For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n// 01:30 UTC on January 15, 2017.\n//\n// In JavaScript, one can convert a Date object to this format using the\n// standard\n// [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n// method. In Python, a standard `datetime.datetime` object can be converted\n// to this format using\n// [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n// the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n// the Joda Time's [`ISODateTimeFormat.dateTime()`](\n// http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n// ) to obtain a formatter capable of generating timestamps in this format.\n//\nmessage Timestamp {\n  // Represents seconds of UTC time since Unix epoch\n  // 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n  // 9999-12-31T23:59:59Z inclusive.\n  int64 seconds = 1;\n\n  // Non-negative fractions of a second at nanosecond resolution. Negative\n  // second values with fractions must still have non-negative nanos values\n  // that count forward in time. Must be from 0 to 999,999,999\n  // inclusive.\n  int32 nanos = 2;\n}\n","size_bytes":6449},"build/extracted-include-protos/main/google/api/resource.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/descriptor.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/api/annotations;annotations\";\noption java_multiple_files = true;\noption java_outer_classname = \"ResourceProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\nextend google.protobuf.FieldOptions {\n  // An annotation that describes a resource reference, see\n  // [ResourceReference][].\n  google.api.ResourceReference resource_reference = 1055;\n}\n\nextend google.protobuf.FileOptions {\n  // An annotation that describes a resource definition without a corresponding\n  // message; see [ResourceDescriptor][].\n  repeated google.api.ResourceDescriptor resource_definition = 1053;\n}\n\nextend google.protobuf.MessageOptions {\n  // An annotation that describes a resource definition, see\n  // [ResourceDescriptor][].\n  google.api.ResourceDescriptor resource = 1053;\n}\n\n// A simple descriptor of a resource type.\n//\n// ResourceDescriptor annotates a resource message (either by means of a\n// protobuf annotation or use in the service config), and associates the\n// resource's schema, the resource type, and the pattern of the resource name.\n//\n// Example:\n//\n//     message Topic {\n//       // Indicates this message defines a resource schema.\n//       // Declares the resource type in the format of {service}/{kind}.\n//       // For Kubernetes resources, the format is {api group}/{kind}.\n//       option (google.api.resource) = {\n//         type: \"pubsub.googleapis.com/Topic\"\n//         pattern: \"projects/{project}/topics/{topic}\"\n//       };\n//     }\n//\n// The ResourceDescriptor Yaml config will look like:\n//\n//     resources:\n//     - type: \"pubsub.googleapis.com/Topic\"\n//       pattern: \"projects/{project}/topics/{topic}\"\n//\n// Sometimes, resources have multiple patterns, typically because they can\n// live under multiple parents.\n//\n// Example:\n//\n//     message LogEntry {\n//       option (google.api.resource) = {\n//         type: \"logging.googleapis.com/LogEntry\"\n//         pattern: \"projects/{project}/logs/{log}\"\n//         pattern: \"folders/{folder}/logs/{log}\"\n//         pattern: \"organizations/{organization}/logs/{log}\"\n//         pattern: \"billingAccounts/{billing_account}/logs/{log}\"\n//       };\n//     }\n//\n// The ResourceDescriptor Yaml config will look like:\n//\n//     resources:\n//     - type: 'logging.googleapis.com/LogEntry'\n//       pattern: \"projects/{project}/logs/{log}\"\n//       pattern: \"folders/{folder}/logs/{log}\"\n//       pattern: \"organizations/{organization}/logs/{log}\"\n//       pattern: \"billingAccounts/{billing_account}/logs/{log}\"\nmessage ResourceDescriptor {\n  // A description of the historical or future-looking state of the\n  // resource pattern.\n  enum History {\n    // The \"unset\" value.\n    HISTORY_UNSPECIFIED = 0;\n\n    // The resource originally had one pattern and launched as such, and\n    // additional patterns were added later.\n    ORIGINALLY_SINGLE_PATTERN = 1;\n\n    // The resource has one pattern, but the API owner expects to add more\n    // later. (This is the inverse of ORIGINALLY_SINGLE_PATTERN, and prevents\n    // that from being necessary once there are multiple patterns.)\n    FUTURE_MULTI_PATTERN = 2;\n  }\n\n  // A flag representing a specific style that a resource claims to conform to.\n  enum Style {\n    // The unspecified value. Do not use.\n    STYLE_UNSPECIFIED = 0;\n\n    // This resource is intended to be \"declarative-friendly\".\n    //\n    // Declarative-friendly resources must be more strictly consistent, and\n    // setting this to true communicates to tools that this resource should\n    // adhere to declarative-friendly expectations.\n    //\n    // Note: This is used by the API linter (linter.aip.dev) to enable\n    // additional checks.\n    DECLARATIVE_FRIENDLY = 1;\n  }\n\n  // The resource type. It must be in the format of\n  // {service_name}/{resource_type_kind}. The `resource_type_kind` must be\n  // singular and must not include version numbers.\n  //\n  // Example: `storage.googleapis.com/Bucket`\n  //\n  // The value of the resource_type_kind must follow the regular expression\n  // /[A-Za-z][a-zA-Z0-9]+/. It should start with an upper case character and\n  // should use PascalCase (UpperCamelCase). The maximum number of\n  // characters allowed for the `resource_type_kind` is 100.\n  string type = 1;\n\n  // Optional. The relative resource name pattern associated with this resource\n  // type. The DNS prefix of the full resource name shouldn't be specified here.\n  //\n  // The path pattern must follow the syntax, which aligns with HTTP binding\n  // syntax:\n  //\n  //     Template = Segment { \"/\" Segment } ;\n  //     Segment = LITERAL | Variable ;\n  //     Variable = \"{\" LITERAL \"}\" ;\n  //\n  // Examples:\n  //\n  //     - \"projects/{project}/topics/{topic}\"\n  //     - \"projects/{project}/knowledgeBases/{knowledge_base}\"\n  //\n  // The components in braces correspond to the IDs for each resource in the\n  // hierarchy. It is expected that, if multiple patterns are provided,\n  // the same component name (e.g. \"project\") refers to IDs of the same\n  // type of resource.\n  repeated string pattern = 2;\n\n  // Optional. The field on the resource that designates the resource name\n  // field. If omitted, this is assumed to be \"name\".\n  string name_field = 3;\n\n  // Optional. The historical or future-looking state of the resource pattern.\n  //\n  // Example:\n  //\n  //     // The InspectTemplate message originally only supported resource\n  //     // names with organization, and project was added later.\n  //     message InspectTemplate {\n  //       option (google.api.resource) = {\n  //         type: \"dlp.googleapis.com/InspectTemplate\"\n  //         pattern:\n  //         \"organizations/{organization}/inspectTemplates/{inspect_template}\"\n  //         pattern: \"projects/{project}/inspectTemplates/{inspect_template}\"\n  //         history: ORIGINALLY_SINGLE_PATTERN\n  //       };\n  //     }\n  History history = 4;\n\n  // The plural name used in the resource name and permission names, such as\n  // 'projects' for the resource name of 'projects/{project}' and the permission\n  // name of 'cloudresourcemanager.googleapis.com/projects.get'. It is the same\n  // concept of the `plural` field in k8s CRD spec\n  // https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/\n  //\n  // Note: The plural form is required even for singleton resources. See\n  // https://aip.dev/156\n  string plural = 5;\n\n  // The same concept of the `singular` field in k8s CRD spec\n  // https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/\n  // Such as \"project\" for the `resourcemanager.googleapis.com/Project` type.\n  string singular = 6;\n\n  // Style flag(s) for this resource.\n  // These indicate that a resource is expected to conform to a given\n  // style. See the specific style flags for additional information.\n  repeated Style style = 10;\n}\n\n// Defines a proto annotation that describes a string field that refers to\n// an API resource.\nmessage ResourceReference {\n  // The resource type that the annotated field references.\n  //\n  // Example:\n  //\n  //     message Subscription {\n  //       string topic = 2 [(google.api.resource_reference) = {\n  //         type: \"pubsub.googleapis.com/Topic\"\n  //       }];\n  //     }\n  //\n  // Occasionally, a field may reference an arbitrary resource. In this case,\n  // APIs use the special value * in their resource reference.\n  //\n  // Example:\n  //\n  //     message GetIamPolicyRequest {\n  //       string resource = 2 [(google.api.resource_reference) = {\n  //         type: \"*\"\n  //       }];\n  //     }\n  string type = 1;\n\n  // The resource type of a child collection that the annotated field\n  // references. This is useful for annotating the `parent` field that\n  // doesn't have a fixed resource type.\n  //\n  // Example:\n  //\n  //     message ListLogEntriesRequest {\n  //       string parent = 1 [(google.api.resource_reference) = {\n  //         child_type: \"logging.googleapis.com/LogEntry\"\n  //       };\n  //     }\n  string child_type = 2;\n}\n","size_bytes":8744},"build/extracted-include-protos/main/google/api/billing.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"BillingProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Billing related configuration of the service.\n//\n// The following example shows how to configure monitored resources and metrics\n// for billing, `consumer_destinations` is the only supported destination and\n// the monitored resources need at least one label key\n// `cloud.googleapis.com/location` to indicate the location of the billing\n// usage, using different monitored resources between monitoring and billing is\n// recommended so they can be evolved independently:\n//\n//\n//     monitored_resources:\n//     - type: library.googleapis.com/billing_branch\n//       labels:\n//       - key: cloud.googleapis.com/location\n//         description: |\n//           Predefined label to support billing location restriction.\n//       - key: city\n//         description: |\n//           Custom label to define the city where the library branch is located\n//           in.\n//       - key: name\n//         description: Custom label to define the name of the library branch.\n//     metrics:\n//     - name: library.googleapis.com/book/borrowed_count\n//       metric_kind: DELTA\n//       value_type: INT64\n//       unit: \"1\"\n//     billing:\n//       consumer_destinations:\n//       - monitored_resource: library.googleapis.com/billing_branch\n//         metrics:\n//         - library.googleapis.com/book/borrowed_count\nmessage Billing {\n  // Configuration of a specific billing destination (Currently only support\n  // bill against consumer project).\n  message BillingDestination {\n    // The monitored resource type. The type must be defined in\n    // [Service.monitored_resources][google.api.Service.monitored_resources]\n    // section.\n    string monitored_resource = 1;\n\n    // Names of the metrics to report to this billing destination.\n    // Each name must be defined in\n    // [Service.metrics][google.api.Service.metrics] section.\n    repeated string metrics = 2;\n  }\n\n  // Billing configurations for sending metrics to the consumer project.\n  // There can be multiple consumer destinations per service, each one must have\n  // a different monitored resource type. A metric can be used in at most\n  // one consumer destination.\n  repeated BillingDestination consumer_destinations = 8;\n}\n","size_bytes":3062},"build/extracted-include-protos/main/google/protobuf/type.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\nimport \"google/protobuf/any.proto\";\nimport \"google/protobuf/source_context.proto\";\n\noption cc_enable_arenas = true;\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"TypeProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\noption go_package = \"google.golang.org/protobuf/types/known/typepb\";\n\n// A protocol buffer message type.\nmessage Type {\n  // The fully qualified message name.\n  string name = 1;\n  // The list of fields.\n  repeated Field fields = 2;\n  // The list of types appearing in `oneof` definitions in this type.\n  repeated string oneofs = 3;\n  // The protocol buffer options.\n  repeated Option options = 4;\n  // The source context.\n  SourceContext source_context = 5;\n  // The source syntax.\n  Syntax syntax = 6;\n  // The source edition string, only valid when syntax is SYNTAX_EDITIONS.\n  string edition = 7;\n}\n\n// A single field of a message type.\nmessage Field {\n  // Basic field types.\n  enum Kind {\n    // Field type unknown.\n    TYPE_UNKNOWN = 0;\n    // Field type double.\n    TYPE_DOUBLE = 1;\n    // Field type float.\n    TYPE_FLOAT = 2;\n    // Field type int64.\n    TYPE_INT64 = 3;\n    // Field type uint64.\n    TYPE_UINT64 = 4;\n    // Field type int32.\n    TYPE_INT32 = 5;\n    // Field type fixed64.\n    TYPE_FIXED64 = 6;\n    // Field type fixed32.\n    TYPE_FIXED32 = 7;\n    // Field type bool.\n    TYPE_BOOL = 8;\n    // Field type string.\n    TYPE_STRING = 9;\n    // Field type group. Proto2 syntax only, and deprecated.\n    TYPE_GROUP = 10;\n    // Field type message.\n    TYPE_MESSAGE = 11;\n    // Field type bytes.\n    TYPE_BYTES = 12;\n    // Field type uint32.\n    TYPE_UINT32 = 13;\n    // Field type enum.\n    TYPE_ENUM = 14;\n    // Field type sfixed32.\n    TYPE_SFIXED32 = 15;\n    // Field type sfixed64.\n    TYPE_SFIXED64 = 16;\n    // Field type sint32.\n    TYPE_SINT32 = 17;\n    // Field type sint64.\n    TYPE_SINT64 = 18;\n  }\n\n  // Whether a field is optional, required, or repeated.\n  enum Cardinality {\n    // For fields with unknown cardinality.\n    CARDINALITY_UNKNOWN = 0;\n    // For optional fields.\n    CARDINALITY_OPTIONAL = 1;\n    // For required fields. Proto2 syntax only.\n    CARDINALITY_REQUIRED = 2;\n    // For repeated fields.\n    CARDINALITY_REPEATED = 3;\n  }\n\n  // The field type.\n  Kind kind = 1;\n  // The field cardinality.\n  Cardinality cardinality = 2;\n  // The field number.\n  int32 number = 3;\n  // The field name.\n  string name = 4;\n  // The field type URL, without the scheme, for message or enumeration\n  // types. Example: `\"type.googleapis.com/google.protobuf.Timestamp\"`.\n  string type_url = 6;\n  // The index of the field type in `Type.oneofs`, for message or enumeration\n  // types. The first type has index 1; zero means the type is not in the list.\n  int32 oneof_index = 7;\n  // Whether to use alternative packed wire representation.\n  bool packed = 8;\n  // The protocol buffer options.\n  repeated Option options = 9;\n  // The field JSON name.\n  string json_name = 10;\n  // The string value of the default value of this field. Proto2 syntax only.\n  string default_value = 11;\n}\n\n// Enum type definition.\nmessage Enum {\n  // Enum type name.\n  string name = 1;\n  // Enum value definitions.\n  repeated EnumValue enumvalue = 2;\n  // Protocol buffer options.\n  repeated Option options = 3;\n  // The source context.\n  SourceContext source_context = 4;\n  // The source syntax.\n  Syntax syntax = 5;\n  // The source edition string, only valid when syntax is SYNTAX_EDITIONS.\n  string edition = 6;\n}\n\n// Enum value definition.\nmessage EnumValue {\n  // Enum value name.\n  string name = 1;\n  // Enum value number.\n  int32 number = 2;\n  // Protocol buffer options.\n  repeated Option options = 3;\n}\n\n// A protocol buffer option, which can be attached to a message, field,\n// enumeration, etc.\nmessage Option {\n  // The option's name. For protobuf built-in options (options defined in\n  // descriptor.proto), this is the short name. For example, `\"map_entry\"`.\n  // For custom options, it should be the fully-qualified name. For example,\n  // `\"google.api.http\"`.\n  string name = 1;\n  // The option's value packed in an Any message. If the value is a primitive,\n  // the corresponding wrapper type defined in google/protobuf/wrappers.proto\n  // should be used. If the value is an enum, it should be stored as an int32\n  // value using the google.protobuf.Int32Value type.\n  Any value = 2;\n}\n\n// The syntax in which a protocol buffer element is defined.\nenum Syntax {\n  // Syntax `proto2`.\n  SYNTAX_PROTO2 = 0;\n  // Syntax `proto3`.\n  SYNTAX_PROTO3 = 1;\n  // Syntax `editions`.\n  SYNTAX_EDITIONS = 2;\n}\n","size_bytes":6367},"src/main/java/com/spiketrade/service/IndicatorCalibrationService.java":{"content":"package com.spiketrade.service;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class IndicatorCalibrationService {\n    private Map<String, IndicatorStats> stats = new ConcurrentHashMap<>();\n    \n    public static class IndicatorStats {\n        public int totalSignals = 0;\n        public int winningTrades = 0;\n        public double actualWinRate = 0.0;\n        public double calibratedWeight = 0.0;\n    }\n    \n    public void recordTradeOutcome(java.util.Set<String> activeIndicators, boolean wasWinner) {\n        for (String indicator : activeIndicators) {\n            IndicatorStats stat = stats.computeIfAbsent(indicator, k -> new IndicatorStats());\n            stat.totalSignals++;\n            if (wasWinner) stat.winningTrades++;\n            \n            stat.actualWinRate = (double) stat.winningTrades / stat.totalSignals;\n            stat.calibratedWeight = stat.actualWinRate;\n        }\n    }\n    \n    public double getWeight(String indicator) {\n        IndicatorStats stat = stats.get(indicator);\n        \n        if (stat == null || stat.totalSignals < 30) {\n            switch (indicator) {\n                case \"spike_quality\": return 0.55;\n                case \"price_roc\": return 0.52;\n                case \"rsi_oversold\": return 0.48;\n                case \"obv_roc\": return 0.51;\n                case \"mfi\": return 0.51;\n                case \"bollinger\": return 0.53;\n                case \"vwap\": return 0.50;\n                case \"volume_spike\": return 0.52;\n                default: return 0.50;\n            }\n        }\n        \n        double standardError = Math.sqrt(0.25 / stat.totalSignals);\n        double zScore = (stat.actualWinRate - 0.5) / standardError;\n        \n        if (Math.abs(zScore) < 1.96) {\n            return 0.50;\n        }\n        \n        return stat.calibratedWeight;\n    }\n    \n    public IndicatorStats getStats(String indicator) {\n        return stats.get(indicator);\n    }\n    \n    public void printCalibration() {\n        System.out.println(\"\\n CALIBRATION RESULTS:\");\n        for (Map.Entry<String, IndicatorStats> entry : stats.entrySet()) {\n            IndicatorStats stat = entry.getValue();\n            System.out.println(String.format(\"  %s: %.1f%% win rate (%d/%d trades)\",\n                entry.getKey(), stat.actualWinRate * 100, stat.winningTrades, stat.totalSignals));\n        }\n    }\n}\n","size_bytes":2384},"build/extracted-include-protos/main/google/longrunning/operations.proto":{"content":"// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.longrunning;\n\nimport \"google/api/annotations.proto\";\nimport \"google/api/client.proto\";\nimport \"google/protobuf/any.proto\";\nimport \"google/protobuf/duration.proto\";\nimport \"google/protobuf/empty.proto\";\nimport \"google/rpc/status.proto\";\nimport \"google/protobuf/descriptor.proto\";\n\noption cc_enable_arenas = true;\noption csharp_namespace = \"Google.LongRunning\";\noption go_package = \"cloud.google.com/go/longrunning/autogen/longrunningpb;longrunningpb\";\noption java_multiple_files = true;\noption java_outer_classname = \"OperationsProto\";\noption java_package = \"com.google.longrunning\";\noption php_namespace = \"Google\\\\LongRunning\";\n\nextend google.protobuf.MethodOptions {\n  // Additional information regarding long-running operations.\n  // In particular, this specifies the types that are returned from\n  // long-running operations.\n  //\n  // Required for methods that return `google.longrunning.Operation`; invalid\n  // otherwise.\n  google.longrunning.OperationInfo operation_info = 1049;\n}\n\n// Manages long-running operations with an API service.\n//\n// When an API method normally takes long time to complete, it can be designed\n// to return [Operation][google.longrunning.Operation] to the client, and the client can use this\n// interface to receive the real response asynchronously by polling the\n// operation resource, or pass the operation resource to another API (such as\n// Google Cloud Pub/Sub API) to receive the response.  Any API service that\n// returns long-running operations should implement the `Operations` interface\n// so developers can have a consistent client experience.\nservice Operations {\n  option (google.api.default_host) = \"longrunning.googleapis.com\";\n\n  // Lists operations that match the specified filter in the request. If the\n  // server doesn't support this method, it returns `UNIMPLEMENTED`.\n  //\n  // NOTE: the `name` binding allows API services to override the binding\n  // to use different resource name schemes, such as `users/*/operations`. To\n  // override the binding, API services can add a binding such as\n  // `\"/v1/{name=users/*}/operations\"` to their service configuration.\n  // For backwards compatibility, the default name includes the operations\n  // collection id, however overriding users must ensure the name binding\n  // is the parent resource, without the operations collection id.\n  rpc ListOperations(ListOperationsRequest) returns (ListOperationsResponse) {\n    option (google.api.http) = {\n      get: \"/v1/{name=operations}\"\n    };\n    option (google.api.method_signature) = \"name,filter\";\n  }\n\n  // Gets the latest state of a long-running operation.  Clients can use this\n  // method to poll the operation result at intervals as recommended by the API\n  // service.\n  rpc GetOperation(GetOperationRequest) returns (Operation) {\n    option (google.api.http) = {\n      get: \"/v1/{name=operations/**}\"\n    };\n    option (google.api.method_signature) = \"name\";\n  }\n\n  // Deletes a long-running operation. This method indicates that the client is\n  // no longer interested in the operation result. It does not cancel the\n  // operation. If the server doesn't support this method, it returns\n  // `google.rpc.Code.UNIMPLEMENTED`.\n  rpc DeleteOperation(DeleteOperationRequest) returns (google.protobuf.Empty) {\n    option (google.api.http) = {\n      delete: \"/v1/{name=operations/**}\"\n    };\n    option (google.api.method_signature) = \"name\";\n  }\n\n  // Starts asynchronous cancellation on a long-running operation.  The server\n  // makes a best effort to cancel the operation, but success is not\n  // guaranteed.  If the server doesn't support this method, it returns\n  // `google.rpc.Code.UNIMPLEMENTED`.  Clients can use\n  // [Operations.GetOperation][google.longrunning.Operations.GetOperation] or\n  // other methods to check whether the cancellation succeeded or whether the\n  // operation completed despite cancellation. On successful cancellation,\n  // the operation is not deleted; instead, it becomes an operation with\n  // an [Operation.error][google.longrunning.Operation.error] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,\n  // corresponding to `Code.CANCELLED`.\n  rpc CancelOperation(CancelOperationRequest) returns (google.protobuf.Empty) {\n    option (google.api.http) = {\n      post: \"/v1/{name=operations/**}:cancel\"\n      body: \"*\"\n    };\n    option (google.api.method_signature) = \"name\";\n  }\n\n  // Waits until the specified long-running operation is done or reaches at most\n  // a specified timeout, returning the latest state.  If the operation is\n  // already done, the latest state is immediately returned.  If the timeout\n  // specified is greater than the default HTTP/RPC timeout, the HTTP/RPC\n  // timeout is used.  If the server does not support this method, it returns\n  // `google.rpc.Code.UNIMPLEMENTED`.\n  // Note that this method is on a best-effort basis.  It may return the latest\n  // state before the specified timeout (including immediately), meaning even an\n  // immediate response is no guarantee that the operation is done.\n  rpc WaitOperation(WaitOperationRequest) returns (Operation) {\n  }\n}\n\n// This resource represents a long-running operation that is the result of a\n// network API call.\nmessage Operation {\n  // The server-assigned name, which is only unique within the same service that\n  // originally returns it. If you use the default HTTP mapping, the\n  // `name` should be a resource name ending with `operations/{unique_id}`.\n  string name = 1;\n\n  // Service-specific metadata associated with the operation.  It typically\n  // contains progress information and common metadata such as create time.\n  // Some services might not provide such metadata.  Any method that returns a\n  // long-running operation should document the metadata type, if any.\n  google.protobuf.Any metadata = 2;\n\n  // If the value is `false`, it means the operation is still in progress.\n  // If `true`, the operation is completed, and either `error` or `response` is\n  // available.\n  bool done = 3;\n\n  // The operation result, which can be either an `error` or a valid `response`.\n  // If `done` == `false`, neither `error` nor `response` is set.\n  // If `done` == `true`, exactly one of `error` or `response` is set.\n  oneof result {\n    // The error result of the operation in case of failure or cancellation.\n    google.rpc.Status error = 4;\n\n    // The normal response of the operation in case of success.  If the original\n    // method returns no data on success, such as `Delete`, the response is\n    // `google.protobuf.Empty`.  If the original method is standard\n    // `Get`/`Create`/`Update`, the response should be the resource.  For other\n    // methods, the response should have the type `XxxResponse`, where `Xxx`\n    // is the original method name.  For example, if the original method name\n    // is `TakeSnapshot()`, the inferred response type is\n    // `TakeSnapshotResponse`.\n    google.protobuf.Any response = 5;\n  }\n}\n\n// The request message for [Operations.GetOperation][google.longrunning.Operations.GetOperation].\nmessage GetOperationRequest {\n  // The name of the operation resource.\n  string name = 1;\n}\n\n// The request message for [Operations.ListOperations][google.longrunning.Operations.ListOperations].\nmessage ListOperationsRequest {\n  // The name of the operation's parent resource.\n  string name = 4;\n\n  // The standard list filter.\n  string filter = 1;\n\n  // The standard list page size.\n  int32 page_size = 2;\n\n  // The standard list page token.\n  string page_token = 3;\n}\n\n// The response message for [Operations.ListOperations][google.longrunning.Operations.ListOperations].\nmessage ListOperationsResponse {\n  // A list of operations that matches the specified filter in the request.\n  repeated Operation operations = 1;\n\n  // The standard List next-page token.\n  string next_page_token = 2;\n}\n\n// The request message for [Operations.CancelOperation][google.longrunning.Operations.CancelOperation].\nmessage CancelOperationRequest {\n  // The name of the operation resource to be cancelled.\n  string name = 1;\n}\n\n// The request message for [Operations.DeleteOperation][google.longrunning.Operations.DeleteOperation].\nmessage DeleteOperationRequest {\n  // The name of the operation resource to be deleted.\n  string name = 1;\n}\n\n// The request message for [Operations.WaitOperation][google.longrunning.Operations.WaitOperation].\nmessage WaitOperationRequest {\n  // The name of the operation resource to wait on.\n  string name = 1;\n\n  // The maximum duration to wait before timing out. If left blank, the wait\n  // will be at most the time permitted by the underlying HTTP/RPC protocol.\n  // If RPC context deadline is also specified, the shorter one will be used.\n  google.protobuf.Duration timeout = 2;\n}\n\n// A message representing the message types used by a long-running operation.\n//\n// Example:\n//\n//   rpc LongRunningRecognize(LongRunningRecognizeRequest)\n//       returns (google.longrunning.Operation) {\n//     option (google.longrunning.operation_info) = {\n//       response_type: \"LongRunningRecognizeResponse\"\n//       metadata_type: \"LongRunningRecognizeMetadata\"\n//     };\n//   }\nmessage OperationInfo {\n  // Required. The message name of the primary return type for this\n  // long-running operation.\n  // This type will be used to deserialize the LRO's response.\n  //\n  // If the response is in a different package from the rpc, a fully-qualified\n  // message name must be used (e.g. `google.protobuf.Struct`).\n  //\n  // Note: Altering this value constitutes a breaking change.\n  string response_type = 1;\n\n  // Required. The message name of the metadata type for this long-running\n  // operation.\n  //\n  // If the response is in a different package from the rpc, a fully-qualified\n  // message name must be used (e.g. `google.protobuf.Struct`).\n  //\n  // Note: Altering this value constitutes a breaking change.\n  string metadata_type = 2;\n}\n","size_bytes":10513},"build/extracted-include-protos/test/google/type/dayofweek.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption go_package = \"google.golang.org/genproto/googleapis/type/dayofweek;dayofweek\";\noption java_multiple_files = true;\noption java_outer_classname = \"DayOfWeekProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a day of the week.\nenum DayOfWeek {\n  // The day of the week is unspecified.\n  DAY_OF_WEEK_UNSPECIFIED = 0;\n\n  // Monday\n  MONDAY = 1;\n\n  // Tuesday\n  TUESDAY = 2;\n\n  // Wednesday\n  WEDNESDAY = 3;\n\n  // Thursday\n  THURSDAY = 4;\n\n  // Friday\n  FRIDAY = 5;\n\n  // Saturday\n  SATURDAY = 6;\n\n  // Sunday\n  SUNDAY = 7;\n}\n","size_bytes":1204},"build/extracted-include-protos/test/google/type/phone_number.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/phone_number;phone_number\";\noption java_multiple_files = true;\noption java_outer_classname = \"PhoneNumberProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// An object representing a phone number, suitable as an API wire format.\n//\n// This representation:\n//\n//  - should not be used for locale-specific formatting of a phone number, such\n//    as \"+1 (650) 253-0000 ext. 123\"\n//\n//  - is not designed for efficient storage\n//  - may not be suitable for dialing - specialized libraries (see references)\n//    should be used to parse the number for that purpose\n//\n// To do something meaningful with this number, such as format it for various\n// use-cases, convert it to an `i18n.phonenumbers.PhoneNumber` object first.\n//\n// For instance, in Java this would be:\n//\n//    com.google.type.PhoneNumber wireProto =\n//        com.google.type.PhoneNumber.newBuilder().build();\n//    com.google.i18n.phonenumbers.Phonenumber.PhoneNumber phoneNumber =\n//        PhoneNumberUtil.getInstance().parse(wireProto.getE164Number(), \"ZZ\");\n//    if (!wireProto.getExtension().isEmpty()) {\n//      phoneNumber.setExtension(wireProto.getExtension());\n//    }\n//\n//  Reference(s):\n//   - https://github.com/google/libphonenumber\nmessage PhoneNumber {\n  // An object representing a short code, which is a phone number that is\n  // typically much shorter than regular phone numbers and can be used to\n  // address messages in MMS and SMS systems, as well as for abbreviated dialing\n  // (e.g. \"Text 611 to see how many minutes you have remaining on your plan.\").\n  //\n  // Short codes are restricted to a region and are not internationally\n  // dialable, which means the same short code can exist in different regions,\n  // with different usage and pricing, even if those regions share the same\n  // country calling code (e.g. US and CA).\n  message ShortCode {\n    // Required. The BCP-47 region code of the location where calls to this\n    // short code can be made, such as \"US\" and \"BB\".\n    //\n    // Reference(s):\n    //  - http://www.unicode.org/reports/tr35/#unicode_region_subtag\n    string region_code = 1;\n\n    // Required. The short code digits, without a leading plus ('+') or country\n    // calling code, e.g. \"611\".\n    string number = 2;\n  }\n\n  // Required.  Either a regular number, or a short code.  New fields may be\n  // added to the oneof below in the future, so clients should ignore phone\n  // numbers for which none of the fields they coded against are set.\n  oneof kind {\n    // The phone number, represented as a leading plus sign ('+'), followed by a\n    // phone number that uses a relaxed ITU E.164 format consisting of the\n    // country calling code (1 to 3 digits) and the subscriber number, with no\n    // additional spaces or formatting, e.g.:\n    //  - correct: \"+15552220123\"\n    //  - incorrect: \"+1 (555) 222-01234 x123\".\n    //\n    // The ITU E.164 format limits the latter to 12 digits, but in practice not\n    // all countries respect that, so we relax that restriction here.\n    // National-only numbers are not allowed.\n    //\n    // References:\n    //  - https://www.itu.int/rec/T-REC-E.164-201011-I\n    //  - https://en.wikipedia.org/wiki/E.164.\n    //  - https://en.wikipedia.org/wiki/List_of_country_calling_codes\n    string e164_number = 1;\n\n    // A short code.\n    //\n    // Reference(s):\n    //  - https://en.wikipedia.org/wiki/Short_code\n    ShortCode short_code = 2;\n  }\n\n  // The phone number's extension. The extension is not standardized in ITU\n  // recommendations, except for being defined as a series of numbers with a\n  // maximum length of 40 digits. Other than digits, some other dialing\n  // characters such as ',' (indicating a wait) or '#' may be stored here.\n  //\n  // Note that no regions currently use extensions with short codes, so this\n  // field is normally only set in conjunction with an E.164 number. It is held\n  // separately from the E.164 number to allow for short code extensions in the\n  // future.\n  string extension = 3;\n}\n","size_bytes":4744},"src/main/java/com/spiketrade/service/SettingsManager.java":{"content":"package com.spiketrade.service;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport javafx.scene.control.*;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.Map;\n\npublic class SettingsManager {\n    private static final String SETTINGS_FILE = \"trading_settings.json\";\n    private final ObjectMapper objectMapper;\n    \n    public SettingsManager() {\n        this.objectMapper = new ObjectMapper();\n    }\n    \n    public JsonNode loadSettingsJson() throws IOException {\n        File file = new File(SETTINGS_FILE);\n        if (!file.exists()) {\n            return objectMapper.createObjectNode();\n        }\n        return objectMapper.readTree(file);\n    }\n    \n    public void saveSettingsToFile(JsonNode settings) throws IOException {\n        objectMapper.writerWithDefaultPrettyPrinter()\n                .writeValue(new File(SETTINGS_FILE), settings);\n    }\n    \n    public static class SettingsBuilder {\n        private final ObjectNode settings;\n        private final ObjectNode params;\n        \n        public SettingsBuilder(JsonNode existingSettings, ObjectMapper mapper) {\n            if (existingSettings == null || !existingSettings.isObject()) {\n                this.settings = mapper.createObjectNode();\n            } else {\n                this.settings = (ObjectNode) existingSettings;\n            }\n            \n            if (!settings.has(\"params\") || settings.get(\"params\") == null) {\n                settings.set(\"params\", mapper.createObjectNode());\n            }\n            this.params = (ObjectNode) settings.get(\"params\");\n        }\n        \n        public SettingsBuilder putDouble(String key, double value) {\n            params.put(key, value);\n            return this;\n        }\n        \n        public SettingsBuilder putInt(String key, int value) {\n            params.put(key, value);\n            return this;\n        }\n        \n        public SettingsBuilder putBoolean(String key, boolean value) {\n            params.put(key, value);\n            return this;\n        }\n        \n        public SettingsBuilder putString(String key, String value) {\n            params.put(key, value);\n            return this;\n        }\n        \n        public SettingsBuilder setTimestamp() {\n            settings.put(\"timestamp\", LocalDateTime.now().toString());\n            return this;\n        }\n        \n        public JsonNode build() {\n            return settings;\n        }\n    }\n}\n","size_bytes":2585},"src/main/resources/styles.css":{"content":"/* ============================================================================\n   SPIKETRADE - APPLE-INSPIRED PROFESSIONAL DESIGN\n   Minimalist greyscale palette with single accent color\n   ============================================================================ */\n\n/* PROFESSIONAL GREYSCALE PALETTE (Apple-inspired)\n   Background:      #0B0D0F  (Deepest charcoal)\n   Panels:          #15181D  (Panel background)\n   Elevated Cards:  #1F232A  (Card surfaces)\n   Dividers:        #262A32  (Subtle borders)\n   Primary Text:    #F5F5F7  (High contrast white)\n   Secondary Text:  #9DA3AD  (Medium grey)\n   Muted Text:      #6F7680  (Low emphasis)\n   Accent Blue:     #5AC8FA  (Active controls - use sparingly)\n   Highlight:       #3A3F47  (Hover/focus states)\n*/\n\n.root {\n    -fx-background-color: #0B0D0F;\n    -fx-font-family: \"SF Pro Display\", \"Segoe UI\", \"Inter\", \"Helvetica Neue\", Arial, sans-serif;\n}\n\n/* ============================================================================\n   HEADER - Clean and minimal\n   ============================================================================ */\n.header {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-width: 0 0 1 0;\n    -fx-padding: 20;\n}\n\n/* ============================================================================\n   STATUS INDICATORS - Subtle state communication\n   ============================================================================ */\n.status-online {\n    -fx-text-fill: #F5F5F7;\n    -fx-font-weight: 600;\n}\n\n.status-offline {\n    -fx-text-fill: #6F7680;\n    -fx-font-weight: 600;\n}\n\n.status-trading {\n    -fx-text-fill: #5AC8FA;\n    -fx-font-weight: 600;\n}\n\n/* ============================================================================\n   BUTTONS - Minimal with subtle depth\n   ============================================================================ */\n.rounded-button {\n    -fx-background-color: #3A3F47;\n    -fx-text-fill: #F5F5F7;\n    -fx-background-radius: 8;\n    -fx-border-radius: 8;\n    -fx-padding: 10 20;\n    -fx-font-size: 13px;\n    -fx-font-weight: 500;\n    -fx-cursor: hand;\n}\n\n.rounded-button:hover {\n    -fx-background-color: #4A4F57;\n}\n\n.rounded-button:pressed {\n    -fx-background-color: #2A2F37;\n}\n\n/* Active/Success Button */\n.button-green {\n    -fx-background-color: #5AC8FA;\n    -fx-text-fill: #0B0D0F;\n    -fx-background-radius: 8;\n    -fx-border-radius: 8;\n    -fx-padding: 10 20;\n    -fx-font-weight: 600;\n    -fx-font-size: 13px;\n    -fx-cursor: hand;\n}\n\n.button-green:hover {\n    -fx-background-color: #6CCEFF;\n}\n\n/* Danger/Stop Button */\n.button-red {\n    -fx-background-color: #3A3F47;\n    -fx-text-fill: #9DA3AD;\n    -fx-background-radius: 8;\n    -fx-border-radius: 8;\n    -fx-border-color: #262A32;\n    -fx-border-width: 1;\n    -fx-padding: 10 20;\n    -fx-font-weight: 600;\n    -fx-font-size: 13px;\n    -fx-cursor: hand;\n}\n\n.button-red:hover {\n    -fx-background-color: #4A4F57;\n    -fx-text-fill: #F5F5F7;\n}\n\n/* ============================================================================\n   TAB PANE - Clean interface\n   ============================================================================ */\n.tab-pane {\n    -fx-background-color: transparent;\n    -fx-border-color: transparent;\n}\n\n.tab-pane .tab-header-area {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-width: 0 0 1 0;\n}\n\n.tab-pane .tab-header-area .tab-header-background {\n    -fx-background-color: #15181D;\n}\n\n.tab-pane .tab {\n    -fx-background-color: transparent;\n    -fx-background-radius: 0;\n    -fx-padding: 14 24;\n    -fx-font-size: 13px;\n    -fx-font-weight: 500;\n    -fx-border-width: 0 0 2 0;\n    -fx-border-color: transparent;\n}\n\n.tab-pane .tab:hover {\n    -fx-background-color: rgba(58, 63, 71, 0.3);\n}\n\n.tab-pane .tab:selected {\n    -fx-background-color: rgba(58, 63, 71, 0.4);\n    -fx-border-color: #5AC8FA;\n    -fx-border-width: 0 0 2 0;\n}\n\n.tab-pane .tab-label {\n    -fx-text-fill: #9DA3AD;\n    -fx-font-size: 13px;\n}\n\n.tab-pane .tab:selected .tab-label {\n    -fx-text-fill: #F5F5F7;\n    -fx-font-weight: 600;\n}\n\n/* ============================================================================\n   CARDS & PANELS - Elevated surfaces\n   ============================================================================ */\n.section-card {\n    -fx-background-color: #1F232A;\n    -fx-background-radius: 12;\n    -fx-border-color: #262A32;\n    -fx-border-radius: 12;\n    -fx-border-width: 1;\n    -fx-padding: 20;\n}\n\n.section-card:hover {\n    -fx-border-color: #3A3F47;\n}\n\n/* ============================================================================\n   TITLED PANE - Collapsible sections\n   ============================================================================ */\n.titled-pane {\n    -fx-background-color: #1F232A;\n    -fx-border-color: #262A32;\n    -fx-border-width: 1;\n    -fx-border-radius: 8;\n}\n\n.titled-pane > .title {\n    -fx-background-color: #3A3F47;\n    -fx-text-fill: #F5F5F7;\n    -fx-font-size: 13px;\n    -fx-font-weight: 600;\n    -fx-background-radius: 8 8 0 0;\n    -fx-padding: 12 16;\n}\n\n.titled-pane > .title:hover {\n    -fx-background-color: #4A4F57;\n}\n\n.titled-pane > .content {\n    -fx-background-color: #1F232A;\n    -fx-border-color: transparent;\n    -fx-padding: 16;\n}\n\n/* ============================================================================\n   LABELS - Typography hierarchy\n   ============================================================================ */\n.label-header {\n    -fx-font-size: 22px;\n    -fx-font-weight: 600;\n    -fx-text-fill: #F5F5F7;\n}\n\n.label-subheader {\n    -fx-font-size: 15px;\n    -fx-font-weight: 600;\n    -fx-text-fill: #F5F5F7;\n}\n\n.label-normal {\n    -fx-font-size: 13px;\n    -fx-text-fill: #9DA3AD;\n}\n\n.label-muted {\n    -fx-font-size: 12px;\n    -fx-text-fill: #6F7680;\n}\n\n/* ============================================================================\n   TEXT FIELDS - Clean input controls\n   ============================================================================ */\n.text-field {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-radius: 6;\n    -fx-background-radius: 6;\n    -fx-padding: 8 12;\n    -fx-font-size: 13px;\n    -fx-text-fill: #F5F5F7;\n    -fx-prompt-text-fill: #6F7680;\n}\n\n.text-field:focused {\n    -fx-border-color: #5AC8FA;\n    -fx-border-width: 1;\n}\n\n/* ============================================================================\n   TABLES - Professional data display\n   ============================================================================ */\n.table-view {\n    -fx-background-color: #1F232A;\n    -fx-border-color: #262A32;\n    -fx-border-width: 1;\n    -fx-border-radius: 8;\n    -fx-background-radius: 8;\n}\n\n.table-view .column-header {\n    -fx-background-color: #15181D;\n    -fx-text-fill: #9DA3AD;\n    -fx-font-weight: 600;\n    -fx-font-size: 12px;\n    -fx-padding: 10;\n    -fx-border-color: #262A32;\n}\n\n.table-view .column-header-background {\n    -fx-background-color: #15181D;\n}\n\n.table-view .table-cell {\n    -fx-text-fill: #F5F5F7;\n    -fx-font-size: 12px;\n    -fx-padding: 8 10;\n    -fx-border-color: #262A32;\n    -fx-font-family: \"SF Mono\", \"Consolas\", \"Monaco\", monospace;\n}\n\n.table-row-cell {\n    -fx-background-color: transparent;\n}\n\n.table-row-cell:odd {\n    -fx-background-color: rgba(38, 42, 50, 0.3);\n}\n\n.table-row-cell:selected {\n    -fx-background-color: rgba(90, 200, 250, 0.15);\n    -fx-text-fill: #F5F5F7;\n}\n\n.table-row-cell:hover {\n    -fx-background-color: rgba(58, 63, 71, 0.4);\n}\n\n/* ============================================================================\n   SCROLL BARS - Minimal design\n   ============================================================================ */\n.scroll-bar {\n    -fx-background-color: transparent;\n}\n\n.scroll-bar .thumb {\n    -fx-background-color: #3A3F47;\n    -fx-background-radius: 4;\n}\n\n.scroll-bar .thumb:hover {\n    -fx-background-color: #4A4F57;\n}\n\n.scroll-bar .increment-button,\n.scroll-bar .decrement-button {\n    -fx-background-color: transparent;\n    -fx-padding: 0;\n}\n\n/* ============================================================================\n   CHECKBOXES - Modern toggle style\n   ============================================================================ */\n.check-box {\n    -fx-text-fill: #9DA3AD;\n    -fx-font-size: 13px;\n}\n\n.check-box .box {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-radius: 4;\n    -fx-border-width: 1;\n}\n\n.check-box:hover .box {\n    -fx-border-color: #3A3F47;\n}\n\n.check-box:selected .box {\n    -fx-background-color: #5AC8FA;\n    -fx-border-color: #5AC8FA;\n}\n\n.check-box:selected .mark {\n    -fx-background-color: #0B0D0F;\n    -fx-shape: \"M 0 4 L 4 8 L 10 0\";\n}\n\n/* ============================================================================\n   SLIDERS - Clean track design\n   ============================================================================ */\n.slider .track {\n    -fx-background-color: #262A32;\n    -fx-background-radius: 4;\n    -fx-pref-height: 4;\n}\n\n.slider .thumb {\n    -fx-background-color: #F5F5F7;\n    -fx-background-radius: 10;\n    -fx-pref-width: 18;\n    -fx-pref-height: 18;\n}\n\n.slider .thumb:hover {\n    -fx-background-color: #5AC8FA;\n    -fx-scale-x: 1.1;\n    -fx-scale-y: 1.1;\n}\n\n.slider .thumb:pressed {\n    -fx-scale-x: 1.15;\n    -fx-scale-y: 1.15;\n}\n\n/* ============================================================================\n   COMBO BOX - Dropdown styling\n   ============================================================================ */\n.combo-box {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-radius: 6;\n    -fx-background-radius: 6;\n}\n\n.combo-box:hover {\n    -fx-border-color: #3A3F47;\n}\n\n.combo-box .list-cell {\n    -fx-background-color: #1F232A;\n    -fx-text-fill: #9DA3AD;\n}\n\n.combo-box .list-cell:hover {\n    -fx-background-color: #3A3F47;\n    -fx-text-fill: #F5F5F7;\n}\n\n/* ============================================================================\n   STATUS BAR - Bottom info strip\n   ============================================================================ */\n.status-bar {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-width: 1 0 0 0;\n    -fx-padding: 8 20;\n}\n\n/* ============================================================================\n   FINANCIAL DATA - Subtle state indication with typography\n   ============================================================================ */\n.profit-positive {\n    -fx-text-fill: #F5F5F7;\n    -fx-font-weight: 600;\n    -fx-font-family: \"SF Mono\", \"Consolas\", \"Monaco\", monospace;\n}\n\n.profit-negative {\n    -fx-text-fill: #9DA3AD;\n    -fx-font-weight: 600;\n    -fx-font-family: \"SF Mono\", \"Consolas\", \"Monaco\", monospace;\n}\n\n/* ============================================================================\n   WARNING & INFO - Single accent color for alerts\n   ============================================================================ */\n.warning-text {\n    -fx-text-fill: #9DA3AD;\n    -fx-font-weight: 500;\n}\n\n.info-text {\n    -fx-text-fill: #F5F5F7;\n    -fx-font-weight: 500;\n}\n\n/* ============================================================================\n   SEPARATORS\n   ============================================================================ */\n.separator {\n    -fx-background-color: #262A32;\n}\n\n.separator .line {\n    -fx-border-color: #262A32;\n}\n\n/* ============================================================================\n   SPINNER CONTROLS\n   ============================================================================ */\n.spinner {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-radius: 6;\n}\n\n.spinner .text-field {\n    -fx-background-color: #15181D;\n    -fx-text-fill: #F5F5F7;\n}\n\n.spinner .increment-arrow-button,\n.spinner .decrement-arrow-button {\n    -fx-background-color: #262A32;\n}\n\n.spinner .increment-arrow-button:hover,\n.spinner .decrement-arrow-button:hover {\n    -fx-background-color: #3A3F47;\n}\n\n/* ============================================================================\n   TOOLTIP - Hover information\n   ============================================================================ */\n.tooltip {\n    -fx-background-color: #1F232A;\n    -fx-text-fill: #F5F5F7;\n    -fx-border-color: #262A32;\n    -fx-border-width: 1;\n    -fx-border-radius: 6;\n    -fx-background-radius: 6;\n    -fx-padding: 6 10;\n    -fx-font-size: 12px;\n}\n","size_bytes":12373},"build/extracted-include-protos/test/google/api/endpoint.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"EndpointProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Endpoint` describes a network address of a service that serves a set of\n// APIs. It is commonly known as a service endpoint. A service may expose\n// any number of service endpoints, and all service endpoints share the same\n// service definition, such as quota limits and monitoring metrics.\n//\n// Example:\n//\n//     type: google.api.Service\n//     name: library-example.googleapis.com\n//     endpoints:\n//       # Declares network address `https://library-example.googleapis.com`\n//       # for service `library-example.googleapis.com`. The `https` scheme\n//       # is implicit for all service endpoints. Other schemes may be\n//       # supported in the future.\n//     - name: library-example.googleapis.com\n//       allow_cors: false\n//     - name: content-staging-library-example.googleapis.com\n//       # Allows HTTP OPTIONS calls to be passed to the API frontend, for it\n//       # to decide whether the subsequent cross-origin request is allowed\n//       # to proceed.\n//       allow_cors: true\nmessage Endpoint {\n  // The canonical name of this endpoint.\n  string name = 1;\n\n  // Unimplemented. Dot not use.\n  //\n  // DEPRECATED: This field is no longer supported. Instead of using aliases,\n  // please specify multiple [google.api.Endpoint][google.api.Endpoint] for each\n  // of the intended aliases.\n  //\n  // Additional names that this endpoint will be hosted on.\n  repeated string aliases = 2 [deprecated = true];\n\n  // The specification of an Internet routable address of API frontend that will\n  // handle requests to this [API\n  // Endpoint](https://cloud.google.com/apis/design/glossary). It should be\n  // either a valid IPv4 address or a fully-qualified domain name. For example,\n  // \"8.8.8.8\" or \"myservice.appspot.com\".\n  string target = 101;\n\n  // Allowing\n  // [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing), aka\n  // cross-domain traffic, would allow the backends served from this endpoint to\n  // receive and respond to HTTP OPTIONS requests. The response will be used by\n  // the browser to determine whether the subsequent cross-origin request is\n  // allowed to proceed.\n  bool allow_cors = 5;\n}\n","size_bytes":3028},"src/main/java/com/spiketrade/TradingServiceClient.java":{"content":"package com.spiketrade;\n\nimport com.spiketrade.proto.*;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.StatusRuntimeException;\nimport io.grpc.stub.StreamObserver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\n\npublic class TradingServiceClient {\n    private static final Logger logger = LoggerFactory.getLogger(TradingServiceClient.class);\n    private static TradingServiceClient instance;\n    \n    private ManagedChannel channel;\n    private TradingServiceGrpc.TradingServiceBlockingStub blockingStub;\n    private TradingServiceGrpc.TradingServiceStub asyncStub;\n    \n    private boolean connected = false;\n    private String serverHost = \"localhost\";\n    private int serverPort = 50051;\n    \n    private Map<String, StreamObserver<?>> activeQuoteStreams = new ConcurrentHashMap<>();\n    private Map<String, StreamObserver<?>> activeSignalStreams = new ConcurrentHashMap<>();\n    \n    private TradingServiceClient() {\n        connect();\n    }\n    \n    public static synchronized TradingServiceClient getInstance() {\n        if (instance == null) {\n            instance = new TradingServiceClient();\n        }\n        return instance;\n    }\n    \n    private void connect() {\n        try {\n            if (channel != null && !channel.isShutdown()) {\n                channel.shutdown();\n            }\n            \n            channel = ManagedChannelBuilder\n                .forAddress(serverHost, serverPort)\n                .usePlaintext()\n                .build();\n            \n            blockingStub = TradingServiceGrpc.newBlockingStub(channel);\n            asyncStub = TradingServiceGrpc.newStub(channel);\n            \n            connected = true;\n            logger.info(\"Connected to gRPC server at {}:{}\", serverHost, serverPort);\n            \n        } catch (Exception e) {\n            logger.error(\"Failed to connect to gRPC server\", e);\n            connected = false;\n        }\n    }\n    \n    public boolean isConnected() {\n        return connected && channel != null && !channel.isShutdown();\n    }\n    \n    public void reconnect() {\n        logger.info(\"Reconnecting to server...\");\n        connect();\n    }\n    \n    public void stopStreaming(List<String> symbols) {\n        if (symbols == null || symbols.isEmpty()) {\n            return;\n        }\n        \n        int stoppedCount = 0;\n        \n        for (String symbol : symbols) {\n            StreamObserver<?> quoteStream = activeQuoteStreams.remove(symbol);\n            if (quoteStream != null) {\n                try {\n                    quoteStream.onCompleted();\n                    stoppedCount++;\n                    logger.info(\"Stopped quote stream for {}\", symbol);\n                } catch (Exception e) {\n                    logger.warn(\"Error stopping quote stream for {}: {}\", symbol, e.getMessage());\n                }\n            }\n            \n            StreamObserver<?> signalStream = activeSignalStreams.remove(symbol);\n            if (signalStream != null) {\n                try {\n                    signalStream.onCompleted();\n                    stoppedCount++;\n                    logger.info(\"Stopped signal stream for {}\", symbol);\n                } catch (Exception e) {\n                    logger.warn(\"Error stopping signal stream for {}: {}\", symbol, e.getMessage());\n                }\n            }\n        }\n        \n        if (stoppedCount > 0) {\n            logger.info(\"Successfully stopped {} stream(s) for {} symbol(s)\", stoppedCount, symbols.size());\n        }\n    }\n    \n    public void stopAllStreams() {\n        List<String> allSymbols = new ArrayList<>();\n        allSymbols.addAll(activeQuoteStreams.keySet());\n        allSymbols.addAll(activeSignalStreams.keySet());\n        \n        if (!allSymbols.isEmpty()) {\n            logger.info(\"Stopping all active streams for {} symbols\", allSymbols.size());\n            stopStreaming(allSymbols);\n        }\n    }\n    \n    public void shutdown() {\n        stopAllStreams();\n        \n        try {\n            if (channel != null) {\n                channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n            }\n        } catch (InterruptedException e) {\n            logger.error(\"Error shutting down channel\", e);\n            Thread.currentThread().interrupt();\n        }\n    }\n    \n    public interface ConnectionCallback {\n        void onSuccess(String message, MarketDataProto.ConnectionStatus status);\n        void onError(String error);\n    }\n    \n    public void connectQuestrade(String token, ConnectionCallback callback) {\n        if (!isConnected()) {\n            reconnect();\n        }\n        \n        try {\n            TradingServiceProto.ConnectRequest request = TradingServiceProto.ConnectRequest.newBuilder()\n                .setQuestradeToken(token != null ? token : \"\")\n                .build();\n            \n            TradingServiceProto.ConnectResponse response = blockingStub.connect(request);\n            \n            logger.info(\"Connect response: success={}, message={}\", response.getSuccess(), response.getMessage());\n            \n            callback.onSuccess(response.getMessage(), response.getStatus());\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"Connect RPC failed\", e);\n            callback.onError(\"Failed to connect to backend: \" + e.getStatus());\n        }\n    }\n    \n    public interface StatusCallback {\n        void onStatus(boolean isTrading, MarketDataProto.ConnectionStatus connectionStatus, \n                     int totalSignals, int activePositions);\n        void onError(String error);\n    }\n    \n    public void getStatus(StatusCallback callback) {\n        if (!isConnected()) {\n            callback.onError(\"Not connected to backend\");\n            return;\n        }\n        \n        try {\n            TradingServiceProto.StatusRequest request = TradingServiceProto.StatusRequest.newBuilder().build();\n            TradingServiceProto.StatusResponse response = blockingStub.getStatus(request);\n            \n            callback.onStatus(\n                response.getIsTrading(),\n                response.getConnectionStatus(),\n                response.getTotalSignals(),\n                response.getActivePositions()\n            );\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"GetStatus RPC failed\", e);\n            callback.onError(\"Failed to get status: \" + e.getStatus());\n        }\n    }\n    \n    public interface HistoricalDataCallback {\n        void onData(List<MarketDataProto.Candle> candles);\n        void onError(String error);\n    }\n    \n    public void getHistoricalData(String symbol, int intervalMinutes, int numBars, \n                                  HistoricalDataCallback callback) {\n        if (!isConnected()) {\n            callback.onError(\"Not connected to backend\");\n            return;\n        }\n        \n        try {\n            MarketDataProto.HistoricalDataRequest request = MarketDataProto.HistoricalDataRequest.newBuilder()\n                .setSymbol(symbol)\n                .setIntervalMinutes(intervalMinutes)\n                .setNumBars(numBars)\n                .build();\n            \n            MarketDataProto.HistoricalDataResponse response = blockingStub.getHistoricalData(request);\n            \n            if (!response.getErrorMessage().isEmpty()) {\n                callback.onError(response.getErrorMessage());\n            } else {\n                callback.onData(response.getCandlesList());\n                logger.info(\"Received {} candles for {}\", response.getCandlesCount(), symbol);\n            }\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"GetHistoricalData RPC failed for {}\", symbol, e);\n            callback.onError(\"Failed to get historical data: \" + e.getStatus());\n        }\n    }\n    \n    public interface QuoteCallback {\n        void onQuote(MarketDataProto.Quote quote);\n        void onError(String error);\n        void onCompleted();\n    }\n    \n    public StreamObserver<MarketDataProto.Quote> streamQuotes(List<String> symbols, QuoteCallback callback) {\n        if (!isConnected()) {\n            callback.onError(\"Not connected to backend\");\n            return null;\n        }\n        \n        try {\n            MarketDataProto.QuoteStreamRequest request = MarketDataProto.QuoteStreamRequest.newBuilder()\n                .addAllSymbols(symbols)\n                .build();\n            \n            StreamObserver<MarketDataProto.Quote> responseObserver = new StreamObserver<MarketDataProto.Quote>() {\n                @Override\n                public void onNext(MarketDataProto.Quote quote) {\n                    callback.onQuote(quote);\n                }\n                \n                @Override\n                public void onError(Throwable t) {\n                    logger.error(\"StreamQuotes error\", t);\n                    for (String symbol : symbols) {\n                        activeQuoteStreams.remove(symbol);\n                    }\n                    callback.onError(\"Stream error: \" + t.getMessage());\n                }\n                \n                @Override\n                public void onCompleted() {\n                    logger.info(\"StreamQuotes completed\");\n                    for (String symbol : symbols) {\n                        activeQuoteStreams.remove(symbol);\n                    }\n                    callback.onCompleted();\n                }\n            };\n            \n            asyncStub.streamQuotes(request, responseObserver);\n            \n            for (String symbol : symbols) {\n                activeQuoteStreams.put(symbol, responseObserver);\n            }\n            \n            logger.info(\"Started streaming quotes for {} symbols\", symbols.size());\n            \n            return responseObserver;\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"StreamQuotes RPC failed\", e);\n            callback.onError(\"Failed to start quote stream: \" + e.getStatus());\n            return null;\n        }\n    }\n    \n    public interface SignalCallback {\n        void onSignal(SpikeSignalsProto.BuySignal signal);\n        void onError(String error);\n        void onCompleted();\n    }\n    \n    public StreamObserver<SpikeSignalsProto.BuySignal> streamSignals(\n            List<String> symbols, double minProbability, SignalCallback callback) {\n        if (!isConnected()) {\n            callback.onError(\"Not connected to backend\");\n            return null;\n        }\n        \n        try {\n            SpikeSignalsProto.SignalStreamRequest request = SpikeSignalsProto.SignalStreamRequest.newBuilder()\n                .addAllSymbols(symbols)\n                .setMinProbability(minProbability)\n                .build();\n            \n            StreamObserver<SpikeSignalsProto.BuySignal> responseObserver = new StreamObserver<SpikeSignalsProto.BuySignal>() {\n                @Override\n                public void onNext(SpikeSignalsProto.BuySignal signal) {\n                    callback.onSignal(signal);\n                }\n                \n                @Override\n                public void onError(Throwable t) {\n                    logger.error(\"StreamSignals error\", t);\n                    for (String symbol : symbols) {\n                        activeSignalStreams.remove(symbol);\n                    }\n                    callback.onError(\"Signal stream error: \" + t.getMessage());\n                }\n                \n                @Override\n                public void onCompleted() {\n                    logger.info(\"StreamSignals completed\");\n                    for (String symbol : symbols) {\n                        activeSignalStreams.remove(symbol);\n                    }\n                    callback.onCompleted();\n                }\n            };\n            \n            asyncStub.streamSignals(request, responseObserver);\n            \n            for (String symbol : symbols) {\n                activeSignalStreams.put(symbol, responseObserver);\n            }\n            \n            logger.info(\"Started streaming signals for {} symbols\", symbols.size());\n            \n            return responseObserver;\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"StreamSignals RPC failed\", e);\n            callback.onError(\"Failed to start signal stream: \" + e.getStatus());\n            return null;\n        }\n    }\n    \n    public interface AnalysisStatusCallback {\n        void onStatus(SpikeSignalsProto.AnalysisStatus status);\n        void onError(String error);\n    }\n    \n    public void getAnalysisStatus(String symbol, AnalysisStatusCallback callback) {\n        if (!isConnected()) {\n            callback.onError(\"Not connected to backend\");\n            return;\n        }\n        \n        try {\n            TradingServiceProto.AnalysisStatusRequest request = \n                TradingServiceProto.AnalysisStatusRequest.newBuilder()\n                    .setSymbol(symbol)\n                    .build();\n            \n            SpikeSignalsProto.AnalysisStatus response = blockingStub.getAnalysisStatus(request);\n            callback.onStatus(response);\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"GetAnalysisStatus RPC failed for {}\", symbol, e);\n            callback.onError(\"Failed to get analysis status: \" + e.getStatus());\n        }\n    }\n    \n    public interface TradingControlCallback {\n        void onSuccess(String message);\n        void onError(String error);\n    }\n    \n    public interface StartTradingCallback {\n        void onSuccess(String message);\n        void onError(String error);\n    }\n    \n    public interface StopTradingCallback {\n        void onSuccess(String message);\n        void onError(String error);\n    }\n    \n    public void startTrading(List<String> symbols, ConfigProto.TradingConfig config, StartTradingCallback callback) {\n        if (!isConnected()) {\n            callback.onError(\"Not connected to backend\");\n            return;\n        }\n        \n        try {\n            TradingServiceProto.StartTradingRequest request = \n                TradingServiceProto.StartTradingRequest.newBuilder()\n                    .addAllSymbols(symbols)\n                    .build();\n            \n            TradingServiceProto.TradingControlResponse response = blockingStub.startTrading(request);\n            \n            if (response.getSuccess()) {\n                callback.onSuccess(response.getMessage());\n                logger.info(\"Trading started: {}\", response.getMessage());\n            } else {\n                callback.onError(response.getMessage());\n            }\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"StartTrading RPC failed\", e);\n            callback.onError(\"Failed to start trading: \" + e.getStatus());\n        }\n    }\n    \n    public void startTrading(List<String> symbols, TradingControlCallback callback) {\n        if (!isConnected()) {\n            callback.onError(\"Not connected to backend\");\n            return;\n        }\n        \n        try {\n            TradingServiceProto.StartTradingRequest request = \n                TradingServiceProto.StartTradingRequest.newBuilder()\n                    .addAllSymbols(symbols)\n                    .build();\n            \n            TradingServiceProto.TradingControlResponse response = blockingStub.startTrading(request);\n            \n            if (response.getSuccess()) {\n                callback.onSuccess(response.getMessage());\n                logger.info(\"Trading started: {}\", response.getMessage());\n            } else {\n                callback.onError(response.getMessage());\n            }\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"StartTrading RPC failed\", e);\n            callback.onError(\"Failed to start trading: \" + e.getStatus());\n        }\n    }\n    \n    public void stopTrading(StopTradingCallback callback) {\n        if (!isConnected()) {\n            callback.onError(\"Not connected to backend\");\n            return;\n        }\n        \n        try {\n            TradingServiceProto.StopTradingRequest request = \n                TradingServiceProto.StopTradingRequest.newBuilder().build();\n            \n            TradingServiceProto.TradingControlResponse response = blockingStub.stopTrading(request);\n            \n            if (response.getSuccess()) {\n                callback.onSuccess(response.getMessage());\n                logger.info(\"Trading stopped: {}\", response.getMessage());\n            } else {\n                callback.onError(response.getMessage());\n            }\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"StopTrading RPC failed\", e);\n            callback.onError(\"Failed to stop trading: \" + e.getStatus());\n        }\n    }\n    \n    public void stopTrading(TradingControlCallback callback) {\n        stopTrading((StopTradingCallback) callback);\n    }\n    \n    public interface ConfigCallback {\n        void onConfig(ConfigProto.TradingConfig config);\n        void onError(String error);\n    }\n    \n    public void getConfig(ConfigCallback callback) {\n        if (!isConnected()) {\n            callback.onError(\"Not connected to backend\");\n            return;\n        }\n        \n        try {\n            TradingServiceProto.ConfigRequest request = \n                TradingServiceProto.ConfigRequest.newBuilder().build();\n            \n            ConfigProto.ConfigResponse response = blockingStub.getConfig(request);\n            \n            if (response.getSuccess()) {\n                callback.onConfig(response.getCurrentConfig());\n            } else {\n                callback.onError(response.getMessage());\n            }\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"GetConfig RPC failed\", e);\n            callback.onError(\"Failed to get config: \" + e.getStatus());\n        }\n    }\n    \n    public void updateConfig(ConfigProto.TradingConfig config, ConfigCallback callback) {\n        if (!isConnected()) {\n            callback.onError(\"Not connected to backend\");\n            return;\n        }\n        \n        try {\n            ConfigProto.ConfigUpdateRequest request = ConfigProto.ConfigUpdateRequest.newBuilder()\n                .setConfig(config)\n                .build();\n            \n            ConfigProto.ConfigResponse response = blockingStub.updateConfig(request);\n            \n            if (response.getSuccess()) {\n                callback.onConfig(response.getCurrentConfig());\n                logger.info(\"Config updated: {}\", response.getMessage());\n            } else {\n                callback.onError(response.getMessage());\n            }\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"UpdateConfig RPC failed\", e);\n            callback.onError(\"Failed to update config: \" + e.getStatus());\n        }\n    }\n    \n    public interface SellWarningCallback {\n        void onWarning(com.spiketrade.backend.SellWarning warning);\n        void onNoWarning();\n        void onError(String error);\n    }\n    \n    public void getSellWarning(String symbol, SellWarningCallback callback) {\n        if (!isConnected()) {\n            callback.onError(\"Not connected to backend\");\n            return;\n        }\n        \n        try {\n            SpikeSignalsProto.SellWarningRequest request = \n                SpikeSignalsProto.SellWarningRequest.newBuilder()\n                    .setSymbol(symbol)\n                    .build();\n            \n            SpikeSignalsProto.SellWarning response = blockingStub.getSellWarning(request);\n            \n            // Check if warning probability is significant\n            if (response.getWarningProbability() >= 0.5) {\n                // Convert proto to SellWarning object\n                com.spiketrade.backend.SellWarning warning = new com.spiketrade.backend.SellWarning();\n                warning.timestamp = java.time.Instant.ofEpochMilli(response.getTimestampMs());\n                warning.symbol = response.getSymbol();\n                warning.price = response.getPrice();\n                warning.warningProbability = response.getWarningProbability();\n                warning.reason = response.getReason();\n                \n                // Add indicators if present\n                if (response.hasIndicators()) {\n                    com.spiketrade.backend.IndicatorsData indicators = \n                        new com.spiketrade.backend.IndicatorsData();\n                    indicators.rsi = response.getIndicators().getRsi();\n                    indicators.priceRoc = response.getIndicators().getPriceRoc();\n                    indicators.volumeRoc = response.getIndicators().getVolumeRoc();\n                    indicators.obv = response.getIndicators().getObv();\n                    indicators.mfi = response.getIndicators().getMfi();\n                    warning.indicators = indicators;\n                }\n                \n                callback.onWarning(warning);\n            } else {\n                callback.onNoWarning();\n            }\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"GetSellWarning RPC failed\", e);\n            callback.onError(\"Failed to get sell warning: \" + e.getStatus());\n        }\n    }\n    \n    public interface OpenTradesCallback {\n        void onTrades(List<TradingServiceProto.Trade> trades);\n        void onError(String error);\n    }\n    \n    public void getOpenTrades(OpenTradesCallback callback) {\n        if (!isConnected()) {\n            callback.onError(\"Not connected to backend\");\n            return;\n        }\n        \n        try {\n            TradingServiceProto.GetOpenTradesRequest request = \n                TradingServiceProto.GetOpenTradesRequest.newBuilder().build();\n            \n            TradingServiceProto.GetOpenTradesResponse response = blockingStub.getOpenTrades(request);\n            callback.onTrades(response.getTradesList());\n            logger.info(\"Retrieved {} open trades\", response.getTradesCount());\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"GetOpenTrades RPC failed\", e);\n            callback.onError(\"Failed to get open trades: \" + e.getStatus());\n        }\n    }\n    \n    public interface ClosedTradesCallback {\n        void onTrades(List<TradingServiceProto.Trade> trades, double totalProfitLoss, \n                     int totalTrades, int winningTrades, double winRate);\n        void onError(String error);\n    }\n    \n    public void getClosedTrades(ClosedTradesCallback callback) {\n        if (!isConnected()) {\n            callback.onError(\"Not connected to backend\");\n            return;\n        }\n        \n        try {\n            TradingServiceProto.GetClosedTradesRequest request = \n                TradingServiceProto.GetClosedTradesRequest.newBuilder().build();\n            \n            TradingServiceProto.GetClosedTradesResponse response = blockingStub.getClosedTrades(request);\n            callback.onTrades(\n                response.getTradesList(),\n                response.getTotalProfitLoss(),\n                response.getTotalTrades(),\n                response.getWinningTrades(),\n                response.getWinRate()\n            );\n            logger.info(\"Retrieved {} closed trades\", response.getTotalTrades());\n            \n        } catch (StatusRuntimeException e) {\n            logger.error(\"GetClosedTrades RPC failed\", e);\n            callback.onError(\"Failed to get closed trades: \" + e.getStatus());\n        }\n    }\n}\n","size_bytes":23737},"build/generated/source/proto/main/grpc/com/spiketrade/proto/TradingServiceGrpc.java":{"content":"package com.spiketrade.proto;\n\nimport static io.grpc.MethodDescriptor.generateFullMethodName;\n\n/**\n * <pre>\n * Trading service definition\n * </pre>\n */\n@javax.annotation.Generated(\n    value = \"by gRPC proto compiler (version 1.60.0)\",\n    comments = \"Source: trading_service.proto\")\n@io.grpc.stub.annotations.GrpcGenerated\npublic final class TradingServiceGrpc {\n\n  private TradingServiceGrpc() {}\n\n  public static final java.lang.String SERVICE_NAME = \"spiketrade.proto.TradingService\";\n\n  // Static method descriptors that strictly reflect the proto.\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.ConnectRequest,\n      com.spiketrade.proto.TradingServiceProto.ConnectResponse> getConnectMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"Connect\",\n      requestType = com.spiketrade.proto.TradingServiceProto.ConnectRequest.class,\n      responseType = com.spiketrade.proto.TradingServiceProto.ConnectResponse.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.ConnectRequest,\n      com.spiketrade.proto.TradingServiceProto.ConnectResponse> getConnectMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.ConnectRequest, com.spiketrade.proto.TradingServiceProto.ConnectResponse> getConnectMethod;\n    if ((getConnectMethod = TradingServiceGrpc.getConnectMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getConnectMethod = TradingServiceGrpc.getConnectMethod) == null) {\n          TradingServiceGrpc.getConnectMethod = getConnectMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.TradingServiceProto.ConnectRequest, com.spiketrade.proto.TradingServiceProto.ConnectResponse>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"Connect\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.ConnectRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.ConnectResponse.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"Connect\"))\n              .build();\n        }\n      }\n    }\n    return getConnectMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.StatusRequest,\n      com.spiketrade.proto.TradingServiceProto.StatusResponse> getGetStatusMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"GetStatus\",\n      requestType = com.spiketrade.proto.TradingServiceProto.StatusRequest.class,\n      responseType = com.spiketrade.proto.TradingServiceProto.StatusResponse.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.StatusRequest,\n      com.spiketrade.proto.TradingServiceProto.StatusResponse> getGetStatusMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.StatusRequest, com.spiketrade.proto.TradingServiceProto.StatusResponse> getGetStatusMethod;\n    if ((getGetStatusMethod = TradingServiceGrpc.getGetStatusMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getGetStatusMethod = TradingServiceGrpc.getGetStatusMethod) == null) {\n          TradingServiceGrpc.getGetStatusMethod = getGetStatusMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.TradingServiceProto.StatusRequest, com.spiketrade.proto.TradingServiceProto.StatusResponse>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"GetStatus\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.StatusRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.StatusResponse.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"GetStatus\"))\n              .build();\n        }\n      }\n    }\n    return getGetStatusMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.MarketDataProto.HistoricalDataRequest,\n      com.spiketrade.proto.MarketDataProto.HistoricalDataResponse> getGetHistoricalDataMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"GetHistoricalData\",\n      requestType = com.spiketrade.proto.MarketDataProto.HistoricalDataRequest.class,\n      responseType = com.spiketrade.proto.MarketDataProto.HistoricalDataResponse.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.MarketDataProto.HistoricalDataRequest,\n      com.spiketrade.proto.MarketDataProto.HistoricalDataResponse> getGetHistoricalDataMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.MarketDataProto.HistoricalDataRequest, com.spiketrade.proto.MarketDataProto.HistoricalDataResponse> getGetHistoricalDataMethod;\n    if ((getGetHistoricalDataMethod = TradingServiceGrpc.getGetHistoricalDataMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getGetHistoricalDataMethod = TradingServiceGrpc.getGetHistoricalDataMethod) == null) {\n          TradingServiceGrpc.getGetHistoricalDataMethod = getGetHistoricalDataMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.MarketDataProto.HistoricalDataRequest, com.spiketrade.proto.MarketDataProto.HistoricalDataResponse>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"GetHistoricalData\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.MarketDataProto.HistoricalDataRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.MarketDataProto.HistoricalDataResponse.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"GetHistoricalData\"))\n              .build();\n        }\n      }\n    }\n    return getGetHistoricalDataMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.MarketDataProto.QuoteStreamRequest,\n      com.spiketrade.proto.MarketDataProto.Quote> getStreamQuotesMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"StreamQuotes\",\n      requestType = com.spiketrade.proto.MarketDataProto.QuoteStreamRequest.class,\n      responseType = com.spiketrade.proto.MarketDataProto.Quote.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.MarketDataProto.QuoteStreamRequest,\n      com.spiketrade.proto.MarketDataProto.Quote> getStreamQuotesMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.MarketDataProto.QuoteStreamRequest, com.spiketrade.proto.MarketDataProto.Quote> getStreamQuotesMethod;\n    if ((getStreamQuotesMethod = TradingServiceGrpc.getStreamQuotesMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getStreamQuotesMethod = TradingServiceGrpc.getStreamQuotesMethod) == null) {\n          TradingServiceGrpc.getStreamQuotesMethod = getStreamQuotesMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.MarketDataProto.QuoteStreamRequest, com.spiketrade.proto.MarketDataProto.Quote>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"StreamQuotes\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.MarketDataProto.QuoteStreamRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.MarketDataProto.Quote.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"StreamQuotes\"))\n              .build();\n        }\n      }\n    }\n    return getStreamQuotesMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.SpikeSignalsProto.SignalStreamRequest,\n      com.spiketrade.proto.SpikeSignalsProto.BuySignal> getStreamSignalsMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"StreamSignals\",\n      requestType = com.spiketrade.proto.SpikeSignalsProto.SignalStreamRequest.class,\n      responseType = com.spiketrade.proto.SpikeSignalsProto.BuySignal.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.SpikeSignalsProto.SignalStreamRequest,\n      com.spiketrade.proto.SpikeSignalsProto.BuySignal> getStreamSignalsMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.SpikeSignalsProto.SignalStreamRequest, com.spiketrade.proto.SpikeSignalsProto.BuySignal> getStreamSignalsMethod;\n    if ((getStreamSignalsMethod = TradingServiceGrpc.getStreamSignalsMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getStreamSignalsMethod = TradingServiceGrpc.getStreamSignalsMethod) == null) {\n          TradingServiceGrpc.getStreamSignalsMethod = getStreamSignalsMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.SpikeSignalsProto.SignalStreamRequest, com.spiketrade.proto.SpikeSignalsProto.BuySignal>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"StreamSignals\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.SpikeSignalsProto.SignalStreamRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.SpikeSignalsProto.BuySignal.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"StreamSignals\"))\n              .build();\n        }\n      }\n    }\n    return getStreamSignalsMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest,\n      com.spiketrade.proto.SpikeSignalsProto.AnalysisStatus> getGetAnalysisStatusMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"GetAnalysisStatus\",\n      requestType = com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest.class,\n      responseType = com.spiketrade.proto.SpikeSignalsProto.AnalysisStatus.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest,\n      com.spiketrade.proto.SpikeSignalsProto.AnalysisStatus> getGetAnalysisStatusMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest, com.spiketrade.proto.SpikeSignalsProto.AnalysisStatus> getGetAnalysisStatusMethod;\n    if ((getGetAnalysisStatusMethod = TradingServiceGrpc.getGetAnalysisStatusMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getGetAnalysisStatusMethod = TradingServiceGrpc.getGetAnalysisStatusMethod) == null) {\n          TradingServiceGrpc.getGetAnalysisStatusMethod = getGetAnalysisStatusMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest, com.spiketrade.proto.SpikeSignalsProto.AnalysisStatus>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"GetAnalysisStatus\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.SpikeSignalsProto.AnalysisStatus.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"GetAnalysisStatus\"))\n              .build();\n        }\n      }\n    }\n    return getGetAnalysisStatusMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.SpikeSignalsProto.SellWarningRequest,\n      com.spiketrade.proto.SpikeSignalsProto.SellWarning> getGetSellWarningMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"GetSellWarning\",\n      requestType = com.spiketrade.proto.SpikeSignalsProto.SellWarningRequest.class,\n      responseType = com.spiketrade.proto.SpikeSignalsProto.SellWarning.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.SpikeSignalsProto.SellWarningRequest,\n      com.spiketrade.proto.SpikeSignalsProto.SellWarning> getGetSellWarningMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.SpikeSignalsProto.SellWarningRequest, com.spiketrade.proto.SpikeSignalsProto.SellWarning> getGetSellWarningMethod;\n    if ((getGetSellWarningMethod = TradingServiceGrpc.getGetSellWarningMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getGetSellWarningMethod = TradingServiceGrpc.getGetSellWarningMethod) == null) {\n          TradingServiceGrpc.getGetSellWarningMethod = getGetSellWarningMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.SpikeSignalsProto.SellWarningRequest, com.spiketrade.proto.SpikeSignalsProto.SellWarning>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"GetSellWarning\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.SpikeSignalsProto.SellWarningRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.SpikeSignalsProto.SellWarning.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"GetSellWarning\"))\n              .build();\n        }\n      }\n    }\n    return getGetSellWarningMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.ConfigProto.ConfigUpdateRequest,\n      com.spiketrade.proto.ConfigProto.ConfigResponse> getUpdateConfigMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"UpdateConfig\",\n      requestType = com.spiketrade.proto.ConfigProto.ConfigUpdateRequest.class,\n      responseType = com.spiketrade.proto.ConfigProto.ConfigResponse.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.ConfigProto.ConfigUpdateRequest,\n      com.spiketrade.proto.ConfigProto.ConfigResponse> getUpdateConfigMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.ConfigProto.ConfigUpdateRequest, com.spiketrade.proto.ConfigProto.ConfigResponse> getUpdateConfigMethod;\n    if ((getUpdateConfigMethod = TradingServiceGrpc.getUpdateConfigMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getUpdateConfigMethod = TradingServiceGrpc.getUpdateConfigMethod) == null) {\n          TradingServiceGrpc.getUpdateConfigMethod = getUpdateConfigMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.ConfigProto.ConfigUpdateRequest, com.spiketrade.proto.ConfigProto.ConfigResponse>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"UpdateConfig\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.ConfigProto.ConfigUpdateRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.ConfigProto.ConfigResponse.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"UpdateConfig\"))\n              .build();\n        }\n      }\n    }\n    return getUpdateConfigMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.ConfigRequest,\n      com.spiketrade.proto.ConfigProto.ConfigResponse> getGetConfigMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"GetConfig\",\n      requestType = com.spiketrade.proto.TradingServiceProto.ConfigRequest.class,\n      responseType = com.spiketrade.proto.ConfigProto.ConfigResponse.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.ConfigRequest,\n      com.spiketrade.proto.ConfigProto.ConfigResponse> getGetConfigMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.ConfigRequest, com.spiketrade.proto.ConfigProto.ConfigResponse> getGetConfigMethod;\n    if ((getGetConfigMethod = TradingServiceGrpc.getGetConfigMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getGetConfigMethod = TradingServiceGrpc.getGetConfigMethod) == null) {\n          TradingServiceGrpc.getGetConfigMethod = getGetConfigMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.TradingServiceProto.ConfigRequest, com.spiketrade.proto.ConfigProto.ConfigResponse>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"GetConfig\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.ConfigRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.ConfigProto.ConfigResponse.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"GetConfig\"))\n              .build();\n        }\n      }\n    }\n    return getGetConfigMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.StartTradingRequest,\n      com.spiketrade.proto.TradingServiceProto.TradingControlResponse> getStartTradingMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"StartTrading\",\n      requestType = com.spiketrade.proto.TradingServiceProto.StartTradingRequest.class,\n      responseType = com.spiketrade.proto.TradingServiceProto.TradingControlResponse.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.StartTradingRequest,\n      com.spiketrade.proto.TradingServiceProto.TradingControlResponse> getStartTradingMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.StartTradingRequest, com.spiketrade.proto.TradingServiceProto.TradingControlResponse> getStartTradingMethod;\n    if ((getStartTradingMethod = TradingServiceGrpc.getStartTradingMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getStartTradingMethod = TradingServiceGrpc.getStartTradingMethod) == null) {\n          TradingServiceGrpc.getStartTradingMethod = getStartTradingMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.TradingServiceProto.StartTradingRequest, com.spiketrade.proto.TradingServiceProto.TradingControlResponse>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"StartTrading\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.StartTradingRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.TradingControlResponse.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"StartTrading\"))\n              .build();\n        }\n      }\n    }\n    return getStartTradingMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.StopTradingRequest,\n      com.spiketrade.proto.TradingServiceProto.TradingControlResponse> getStopTradingMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"StopTrading\",\n      requestType = com.spiketrade.proto.TradingServiceProto.StopTradingRequest.class,\n      responseType = com.spiketrade.proto.TradingServiceProto.TradingControlResponse.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.StopTradingRequest,\n      com.spiketrade.proto.TradingServiceProto.TradingControlResponse> getStopTradingMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.StopTradingRequest, com.spiketrade.proto.TradingServiceProto.TradingControlResponse> getStopTradingMethod;\n    if ((getStopTradingMethod = TradingServiceGrpc.getStopTradingMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getStopTradingMethod = TradingServiceGrpc.getStopTradingMethod) == null) {\n          TradingServiceGrpc.getStopTradingMethod = getStopTradingMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.TradingServiceProto.StopTradingRequest, com.spiketrade.proto.TradingServiceProto.TradingControlResponse>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"StopTrading\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.StopTradingRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.TradingControlResponse.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"StopTrading\"))\n              .build();\n        }\n      }\n    }\n    return getStopTradingMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.BacktestRequest,\n      com.spiketrade.proto.TradingServiceProto.BacktestResponse> getRunBacktestMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"RunBacktest\",\n      requestType = com.spiketrade.proto.TradingServiceProto.BacktestRequest.class,\n      responseType = com.spiketrade.proto.TradingServiceProto.BacktestResponse.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.BacktestRequest,\n      com.spiketrade.proto.TradingServiceProto.BacktestResponse> getRunBacktestMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.BacktestRequest, com.spiketrade.proto.TradingServiceProto.BacktestResponse> getRunBacktestMethod;\n    if ((getRunBacktestMethod = TradingServiceGrpc.getRunBacktestMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getRunBacktestMethod = TradingServiceGrpc.getRunBacktestMethod) == null) {\n          TradingServiceGrpc.getRunBacktestMethod = getRunBacktestMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.TradingServiceProto.BacktestRequest, com.spiketrade.proto.TradingServiceProto.BacktestResponse>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"RunBacktest\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.BacktestRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.BacktestResponse.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"RunBacktest\"))\n              .build();\n        }\n      }\n    }\n    return getRunBacktestMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest,\n      com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate> getStreamIndicatorsMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"StreamIndicators\",\n      requestType = com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest.class,\n      responseType = com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest,\n      com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate> getStreamIndicatorsMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest, com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate> getStreamIndicatorsMethod;\n    if ((getStreamIndicatorsMethod = TradingServiceGrpc.getStreamIndicatorsMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getStreamIndicatorsMethod = TradingServiceGrpc.getStreamIndicatorsMethod) == null) {\n          TradingServiceGrpc.getStreamIndicatorsMethod = getStreamIndicatorsMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest, com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"StreamIndicators\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"StreamIndicators\"))\n              .build();\n        }\n      }\n    }\n    return getStreamIndicatorsMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest,\n      com.spiketrade.proto.TradingServiceProto.GetOpenTradesResponse> getGetOpenTradesMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"GetOpenTrades\",\n      requestType = com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest.class,\n      responseType = com.spiketrade.proto.TradingServiceProto.GetOpenTradesResponse.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest,\n      com.spiketrade.proto.TradingServiceProto.GetOpenTradesResponse> getGetOpenTradesMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest, com.spiketrade.proto.TradingServiceProto.GetOpenTradesResponse> getGetOpenTradesMethod;\n    if ((getGetOpenTradesMethod = TradingServiceGrpc.getGetOpenTradesMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getGetOpenTradesMethod = TradingServiceGrpc.getGetOpenTradesMethod) == null) {\n          TradingServiceGrpc.getGetOpenTradesMethod = getGetOpenTradesMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest, com.spiketrade.proto.TradingServiceProto.GetOpenTradesResponse>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"GetOpenTrades\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.GetOpenTradesResponse.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"GetOpenTrades\"))\n              .build();\n        }\n      }\n    }\n    return getGetOpenTradesMethod;\n  }\n\n  private static volatile io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.GetClosedTradesRequest,\n      com.spiketrade.proto.TradingServiceProto.GetClosedTradesResponse> getGetClosedTradesMethod;\n\n  @io.grpc.stub.annotations.RpcMethod(\n      fullMethodName = SERVICE_NAME + '/' + \"GetClosedTrades\",\n      requestType = com.spiketrade.proto.TradingServiceProto.GetClosedTradesRequest.class,\n      responseType = com.spiketrade.proto.TradingServiceProto.GetClosedTradesResponse.class,\n      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)\n  public static io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.GetClosedTradesRequest,\n      com.spiketrade.proto.TradingServiceProto.GetClosedTradesResponse> getGetClosedTradesMethod() {\n    io.grpc.MethodDescriptor<com.spiketrade.proto.TradingServiceProto.GetClosedTradesRequest, com.spiketrade.proto.TradingServiceProto.GetClosedTradesResponse> getGetClosedTradesMethod;\n    if ((getGetClosedTradesMethod = TradingServiceGrpc.getGetClosedTradesMethod) == null) {\n      synchronized (TradingServiceGrpc.class) {\n        if ((getGetClosedTradesMethod = TradingServiceGrpc.getGetClosedTradesMethod) == null) {\n          TradingServiceGrpc.getGetClosedTradesMethod = getGetClosedTradesMethod =\n              io.grpc.MethodDescriptor.<com.spiketrade.proto.TradingServiceProto.GetClosedTradesRequest, com.spiketrade.proto.TradingServiceProto.GetClosedTradesResponse>newBuilder()\n              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)\n              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"GetClosedTrades\"))\n              .setSampledToLocalTracing(true)\n              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.GetClosedTradesRequest.getDefaultInstance()))\n              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n                  com.spiketrade.proto.TradingServiceProto.GetClosedTradesResponse.getDefaultInstance()))\n              .setSchemaDescriptor(new TradingServiceMethodDescriptorSupplier(\"GetClosedTrades\"))\n              .build();\n        }\n      }\n    }\n    return getGetClosedTradesMethod;\n  }\n\n  /**\n   * Creates a new async stub that supports all call types for the service\n   */\n  public static TradingServiceStub newStub(io.grpc.Channel channel) {\n    io.grpc.stub.AbstractStub.StubFactory<TradingServiceStub> factory =\n      new io.grpc.stub.AbstractStub.StubFactory<TradingServiceStub>() {\n        @java.lang.Override\n        public TradingServiceStub newStub(io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n          return new TradingServiceStub(channel, callOptions);\n        }\n      };\n    return TradingServiceStub.newStub(factory, channel);\n  }\n\n  /**\n   * Creates a new blocking-style stub that supports unary and streaming output calls on the service\n   */\n  public static TradingServiceBlockingStub newBlockingStub(\n      io.grpc.Channel channel) {\n    io.grpc.stub.AbstractStub.StubFactory<TradingServiceBlockingStub> factory =\n      new io.grpc.stub.AbstractStub.StubFactory<TradingServiceBlockingStub>() {\n        @java.lang.Override\n        public TradingServiceBlockingStub newStub(io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n          return new TradingServiceBlockingStub(channel, callOptions);\n        }\n      };\n    return TradingServiceBlockingStub.newStub(factory, channel);\n  }\n\n  /**\n   * Creates a new ListenableFuture-style stub that supports unary calls on the service\n   */\n  public static TradingServiceFutureStub newFutureStub(\n      io.grpc.Channel channel) {\n    io.grpc.stub.AbstractStub.StubFactory<TradingServiceFutureStub> factory =\n      new io.grpc.stub.AbstractStub.StubFactory<TradingServiceFutureStub>() {\n        @java.lang.Override\n        public TradingServiceFutureStub newStub(io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n          return new TradingServiceFutureStub(channel, callOptions);\n        }\n      };\n    return TradingServiceFutureStub.newStub(factory, channel);\n  }\n\n  /**\n   * <pre>\n   * Trading service definition\n   * </pre>\n   */\n  public interface AsyncService {\n\n    /**\n     * <pre>\n     * Connection management\n     * </pre>\n     */\n    default void connect(com.spiketrade.proto.TradingServiceProto.ConnectRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.ConnectResponse> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getConnectMethod(), responseObserver);\n    }\n\n    /**\n     */\n    default void getStatus(com.spiketrade.proto.TradingServiceProto.StatusRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.StatusResponse> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getGetStatusMethod(), responseObserver);\n    }\n\n    /**\n     * <pre>\n     * Market data\n     * </pre>\n     */\n    default void getHistoricalData(com.spiketrade.proto.MarketDataProto.HistoricalDataRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.MarketDataProto.HistoricalDataResponse> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getGetHistoricalDataMethod(), responseObserver);\n    }\n\n    /**\n     */\n    default void streamQuotes(com.spiketrade.proto.MarketDataProto.QuoteStreamRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.MarketDataProto.Quote> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getStreamQuotesMethod(), responseObserver);\n    }\n\n    /**\n     * <pre>\n     * Signals and analysis\n     * </pre>\n     */\n    default void streamSignals(com.spiketrade.proto.SpikeSignalsProto.SignalStreamRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.SpikeSignalsProto.BuySignal> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getStreamSignalsMethod(), responseObserver);\n    }\n\n    /**\n     */\n    default void getAnalysisStatus(com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.SpikeSignalsProto.AnalysisStatus> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getGetAnalysisStatusMethod(), responseObserver);\n    }\n\n    /**\n     */\n    default void getSellWarning(com.spiketrade.proto.SpikeSignalsProto.SellWarningRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.SpikeSignalsProto.SellWarning> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getGetSellWarningMethod(), responseObserver);\n    }\n\n    /**\n     * <pre>\n     * Configuration\n     * </pre>\n     */\n    default void updateConfig(com.spiketrade.proto.ConfigProto.ConfigUpdateRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.ConfigProto.ConfigResponse> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getUpdateConfigMethod(), responseObserver);\n    }\n\n    /**\n     */\n    default void getConfig(com.spiketrade.proto.TradingServiceProto.ConfigRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.ConfigProto.ConfigResponse> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getGetConfigMethod(), responseObserver);\n    }\n\n    /**\n     * <pre>\n     * Trading control\n     * </pre>\n     */\n    default void startTrading(com.spiketrade.proto.TradingServiceProto.StartTradingRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.TradingControlResponse> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getStartTradingMethod(), responseObserver);\n    }\n\n    /**\n     */\n    default void stopTrading(com.spiketrade.proto.TradingServiceProto.StopTradingRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.TradingControlResponse> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getStopTradingMethod(), responseObserver);\n    }\n\n    /**\n     * <pre>\n     * Backtesting\n     * </pre>\n     */\n    default void runBacktest(com.spiketrade.proto.TradingServiceProto.BacktestRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.BacktestResponse> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getRunBacktestMethod(), responseObserver);\n    }\n\n    /**\n     */\n    default void streamIndicators(com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getStreamIndicatorsMethod(), responseObserver);\n    }\n\n    /**\n     * <pre>\n     * Trade Tracking\n     * </pre>\n     */\n    default void getOpenTrades(com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.GetOpenTradesResponse> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getGetOpenTradesMethod(), responseObserver);\n    }\n\n    /**\n     */\n    default void getClosedTrades(com.spiketrade.proto.TradingServiceProto.GetClosedTradesRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.GetClosedTradesResponse> responseObserver) {\n      io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getGetClosedTradesMethod(), responseObserver);\n    }\n  }\n\n  /**\n   * Base class for the server implementation of the service TradingService.\n   * <pre>\n   * Trading service definition\n   * </pre>\n   */\n  public static abstract class TradingServiceImplBase\n      implements io.grpc.BindableService, AsyncService {\n\n    @java.lang.Override public final io.grpc.ServerServiceDefinition bindService() {\n      return TradingServiceGrpc.bindService(this);\n    }\n  }\n\n  /**\n   * A stub to allow clients to do asynchronous rpc calls to service TradingService.\n   * <pre>\n   * Trading service definition\n   * </pre>\n   */\n  public static final class TradingServiceStub\n      extends io.grpc.stub.AbstractAsyncStub<TradingServiceStub> {\n    private TradingServiceStub(\n        io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n      super(channel, callOptions);\n    }\n\n    @java.lang.Override\n    protected TradingServiceStub build(\n        io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n      return new TradingServiceStub(channel, callOptions);\n    }\n\n    /**\n     * <pre>\n     * Connection management\n     * </pre>\n     */\n    public void connect(com.spiketrade.proto.TradingServiceProto.ConnectRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.ConnectResponse> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncUnaryCall(\n          getChannel().newCall(getConnectMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     */\n    public void getStatus(com.spiketrade.proto.TradingServiceProto.StatusRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.StatusResponse> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncUnaryCall(\n          getChannel().newCall(getGetStatusMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     * <pre>\n     * Market data\n     * </pre>\n     */\n    public void getHistoricalData(com.spiketrade.proto.MarketDataProto.HistoricalDataRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.MarketDataProto.HistoricalDataResponse> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncUnaryCall(\n          getChannel().newCall(getGetHistoricalDataMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     */\n    public void streamQuotes(com.spiketrade.proto.MarketDataProto.QuoteStreamRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.MarketDataProto.Quote> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncServerStreamingCall(\n          getChannel().newCall(getStreamQuotesMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     * <pre>\n     * Signals and analysis\n     * </pre>\n     */\n    public void streamSignals(com.spiketrade.proto.SpikeSignalsProto.SignalStreamRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.SpikeSignalsProto.BuySignal> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncServerStreamingCall(\n          getChannel().newCall(getStreamSignalsMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     */\n    public void getAnalysisStatus(com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.SpikeSignalsProto.AnalysisStatus> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncUnaryCall(\n          getChannel().newCall(getGetAnalysisStatusMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     */\n    public void getSellWarning(com.spiketrade.proto.SpikeSignalsProto.SellWarningRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.SpikeSignalsProto.SellWarning> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncUnaryCall(\n          getChannel().newCall(getGetSellWarningMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     * <pre>\n     * Configuration\n     * </pre>\n     */\n    public void updateConfig(com.spiketrade.proto.ConfigProto.ConfigUpdateRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.ConfigProto.ConfigResponse> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncUnaryCall(\n          getChannel().newCall(getUpdateConfigMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     */\n    public void getConfig(com.spiketrade.proto.TradingServiceProto.ConfigRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.ConfigProto.ConfigResponse> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncUnaryCall(\n          getChannel().newCall(getGetConfigMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     * <pre>\n     * Trading control\n     * </pre>\n     */\n    public void startTrading(com.spiketrade.proto.TradingServiceProto.StartTradingRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.TradingControlResponse> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncUnaryCall(\n          getChannel().newCall(getStartTradingMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     */\n    public void stopTrading(com.spiketrade.proto.TradingServiceProto.StopTradingRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.TradingControlResponse> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncUnaryCall(\n          getChannel().newCall(getStopTradingMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     * <pre>\n     * Backtesting\n     * </pre>\n     */\n    public void runBacktest(com.spiketrade.proto.TradingServiceProto.BacktestRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.BacktestResponse> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncUnaryCall(\n          getChannel().newCall(getRunBacktestMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     */\n    public void streamIndicators(com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncServerStreamingCall(\n          getChannel().newCall(getStreamIndicatorsMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     * <pre>\n     * Trade Tracking\n     * </pre>\n     */\n    public void getOpenTrades(com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.GetOpenTradesResponse> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncUnaryCall(\n          getChannel().newCall(getGetOpenTradesMethod(), getCallOptions()), request, responseObserver);\n    }\n\n    /**\n     */\n    public void getClosedTrades(com.spiketrade.proto.TradingServiceProto.GetClosedTradesRequest request,\n        io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.GetClosedTradesResponse> responseObserver) {\n      io.grpc.stub.ClientCalls.asyncUnaryCall(\n          getChannel().newCall(getGetClosedTradesMethod(), getCallOptions()), request, responseObserver);\n    }\n  }\n\n  /**\n   * A stub to allow clients to do synchronous rpc calls to service TradingService.\n   * <pre>\n   * Trading service definition\n   * </pre>\n   */\n  public static final class TradingServiceBlockingStub\n      extends io.grpc.stub.AbstractBlockingStub<TradingServiceBlockingStub> {\n    private TradingServiceBlockingStub(\n        io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n      super(channel, callOptions);\n    }\n\n    @java.lang.Override\n    protected TradingServiceBlockingStub build(\n        io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n      return new TradingServiceBlockingStub(channel, callOptions);\n    }\n\n    /**\n     * <pre>\n     * Connection management\n     * </pre>\n     */\n    public com.spiketrade.proto.TradingServiceProto.ConnectResponse connect(com.spiketrade.proto.TradingServiceProto.ConnectRequest request) {\n      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n          getChannel(), getConnectMethod(), getCallOptions(), request);\n    }\n\n    /**\n     */\n    public com.spiketrade.proto.TradingServiceProto.StatusResponse getStatus(com.spiketrade.proto.TradingServiceProto.StatusRequest request) {\n      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n          getChannel(), getGetStatusMethod(), getCallOptions(), request);\n    }\n\n    /**\n     * <pre>\n     * Market data\n     * </pre>\n     */\n    public com.spiketrade.proto.MarketDataProto.HistoricalDataResponse getHistoricalData(com.spiketrade.proto.MarketDataProto.HistoricalDataRequest request) {\n      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n          getChannel(), getGetHistoricalDataMethod(), getCallOptions(), request);\n    }\n\n    /**\n     */\n    public java.util.Iterator<com.spiketrade.proto.MarketDataProto.Quote> streamQuotes(\n        com.spiketrade.proto.MarketDataProto.QuoteStreamRequest request) {\n      return io.grpc.stub.ClientCalls.blockingServerStreamingCall(\n          getChannel(), getStreamQuotesMethod(), getCallOptions(), request);\n    }\n\n    /**\n     * <pre>\n     * Signals and analysis\n     * </pre>\n     */\n    public java.util.Iterator<com.spiketrade.proto.SpikeSignalsProto.BuySignal> streamSignals(\n        com.spiketrade.proto.SpikeSignalsProto.SignalStreamRequest request) {\n      return io.grpc.stub.ClientCalls.blockingServerStreamingCall(\n          getChannel(), getStreamSignalsMethod(), getCallOptions(), request);\n    }\n\n    /**\n     */\n    public com.spiketrade.proto.SpikeSignalsProto.AnalysisStatus getAnalysisStatus(com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest request) {\n      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n          getChannel(), getGetAnalysisStatusMethod(), getCallOptions(), request);\n    }\n\n    /**\n     */\n    public com.spiketrade.proto.SpikeSignalsProto.SellWarning getSellWarning(com.spiketrade.proto.SpikeSignalsProto.SellWarningRequest request) {\n      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n          getChannel(), getGetSellWarningMethod(), getCallOptions(), request);\n    }\n\n    /**\n     * <pre>\n     * Configuration\n     * </pre>\n     */\n    public com.spiketrade.proto.ConfigProto.ConfigResponse updateConfig(com.spiketrade.proto.ConfigProto.ConfigUpdateRequest request) {\n      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n          getChannel(), getUpdateConfigMethod(), getCallOptions(), request);\n    }\n\n    /**\n     */\n    public com.spiketrade.proto.ConfigProto.ConfigResponse getConfig(com.spiketrade.proto.TradingServiceProto.ConfigRequest request) {\n      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n          getChannel(), getGetConfigMethod(), getCallOptions(), request);\n    }\n\n    /**\n     * <pre>\n     * Trading control\n     * </pre>\n     */\n    public com.spiketrade.proto.TradingServiceProto.TradingControlResponse startTrading(com.spiketrade.proto.TradingServiceProto.StartTradingRequest request) {\n      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n          getChannel(), getStartTradingMethod(), getCallOptions(), request);\n    }\n\n    /**\n     */\n    public com.spiketrade.proto.TradingServiceProto.TradingControlResponse stopTrading(com.spiketrade.proto.TradingServiceProto.StopTradingRequest request) {\n      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n          getChannel(), getStopTradingMethod(), getCallOptions(), request);\n    }\n\n    /**\n     * <pre>\n     * Backtesting\n     * </pre>\n     */\n    public com.spiketrade.proto.TradingServiceProto.BacktestResponse runBacktest(com.spiketrade.proto.TradingServiceProto.BacktestRequest request) {\n      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n          getChannel(), getRunBacktestMethod(), getCallOptions(), request);\n    }\n\n    /**\n     */\n    public java.util.Iterator<com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate> streamIndicators(\n        com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest request) {\n      return io.grpc.stub.ClientCalls.blockingServerStreamingCall(\n          getChannel(), getStreamIndicatorsMethod(), getCallOptions(), request);\n    }\n\n    /**\n     * <pre>\n     * Trade Tracking\n     * </pre>\n     */\n    public com.spiketrade.proto.TradingServiceProto.GetOpenTradesResponse getOpenTrades(com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest request) {\n      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n          getChannel(), getGetOpenTradesMethod(), getCallOptions(), request);\n    }\n\n    /**\n     */\n    public com.spiketrade.proto.TradingServiceProto.GetClosedTradesResponse getClosedTrades(com.spiketrade.proto.TradingServiceProto.GetClosedTradesRequest request) {\n      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n          getChannel(), getGetClosedTradesMethod(), getCallOptions(), request);\n    }\n  }\n\n  /**\n   * A stub to allow clients to do ListenableFuture-style rpc calls to service TradingService.\n   * <pre>\n   * Trading service definition\n   * </pre>\n   */\n  public static final class TradingServiceFutureStub\n      extends io.grpc.stub.AbstractFutureStub<TradingServiceFutureStub> {\n    private TradingServiceFutureStub(\n        io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n      super(channel, callOptions);\n    }\n\n    @java.lang.Override\n    protected TradingServiceFutureStub build(\n        io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n      return new TradingServiceFutureStub(channel, callOptions);\n    }\n\n    /**\n     * <pre>\n     * Connection management\n     * </pre>\n     */\n    public com.google.common.util.concurrent.ListenableFuture<com.spiketrade.proto.TradingServiceProto.ConnectResponse> connect(\n        com.spiketrade.proto.TradingServiceProto.ConnectRequest request) {\n      return io.grpc.stub.ClientCalls.futureUnaryCall(\n          getChannel().newCall(getConnectMethod(), getCallOptions()), request);\n    }\n\n    /**\n     */\n    public com.google.common.util.concurrent.ListenableFuture<com.spiketrade.proto.TradingServiceProto.StatusResponse> getStatus(\n        com.spiketrade.proto.TradingServiceProto.StatusRequest request) {\n      return io.grpc.stub.ClientCalls.futureUnaryCall(\n          getChannel().newCall(getGetStatusMethod(), getCallOptions()), request);\n    }\n\n    /**\n     * <pre>\n     * Market data\n     * </pre>\n     */\n    public com.google.common.util.concurrent.ListenableFuture<com.spiketrade.proto.MarketDataProto.HistoricalDataResponse> getHistoricalData(\n        com.spiketrade.proto.MarketDataProto.HistoricalDataRequest request) {\n      return io.grpc.stub.ClientCalls.futureUnaryCall(\n          getChannel().newCall(getGetHistoricalDataMethod(), getCallOptions()), request);\n    }\n\n    /**\n     */\n    public com.google.common.util.concurrent.ListenableFuture<com.spiketrade.proto.SpikeSignalsProto.AnalysisStatus> getAnalysisStatus(\n        com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest request) {\n      return io.grpc.stub.ClientCalls.futureUnaryCall(\n          getChannel().newCall(getGetAnalysisStatusMethod(), getCallOptions()), request);\n    }\n\n    /**\n     */\n    public com.google.common.util.concurrent.ListenableFuture<com.spiketrade.proto.SpikeSignalsProto.SellWarning> getSellWarning(\n        com.spiketrade.proto.SpikeSignalsProto.SellWarningRequest request) {\n      return io.grpc.stub.ClientCalls.futureUnaryCall(\n          getChannel().newCall(getGetSellWarningMethod(), getCallOptions()), request);\n    }\n\n    /**\n     * <pre>\n     * Configuration\n     * </pre>\n     */\n    public com.google.common.util.concurrent.ListenableFuture<com.spiketrade.proto.ConfigProto.ConfigResponse> updateConfig(\n        com.spiketrade.proto.ConfigProto.ConfigUpdateRequest request) {\n      return io.grpc.stub.ClientCalls.futureUnaryCall(\n          getChannel().newCall(getUpdateConfigMethod(), getCallOptions()), request);\n    }\n\n    /**\n     */\n    public com.google.common.util.concurrent.ListenableFuture<com.spiketrade.proto.ConfigProto.ConfigResponse> getConfig(\n        com.spiketrade.proto.TradingServiceProto.ConfigRequest request) {\n      return io.grpc.stub.ClientCalls.futureUnaryCall(\n          getChannel().newCall(getGetConfigMethod(), getCallOptions()), request);\n    }\n\n    /**\n     * <pre>\n     * Trading control\n     * </pre>\n     */\n    public com.google.common.util.concurrent.ListenableFuture<com.spiketrade.proto.TradingServiceProto.TradingControlResponse> startTrading(\n        com.spiketrade.proto.TradingServiceProto.StartTradingRequest request) {\n      return io.grpc.stub.ClientCalls.futureUnaryCall(\n          getChannel().newCall(getStartTradingMethod(), getCallOptions()), request);\n    }\n\n    /**\n     */\n    public com.google.common.util.concurrent.ListenableFuture<com.spiketrade.proto.TradingServiceProto.TradingControlResponse> stopTrading(\n        com.spiketrade.proto.TradingServiceProto.StopTradingRequest request) {\n      return io.grpc.stub.ClientCalls.futureUnaryCall(\n          getChannel().newCall(getStopTradingMethod(), getCallOptions()), request);\n    }\n\n    /**\n     * <pre>\n     * Backtesting\n     * </pre>\n     */\n    public com.google.common.util.concurrent.ListenableFuture<com.spiketrade.proto.TradingServiceProto.BacktestResponse> runBacktest(\n        com.spiketrade.proto.TradingServiceProto.BacktestRequest request) {\n      return io.grpc.stub.ClientCalls.futureUnaryCall(\n          getChannel().newCall(getRunBacktestMethod(), getCallOptions()), request);\n    }\n\n    /**\n     * <pre>\n     * Trade Tracking\n     * </pre>\n     */\n    public com.google.common.util.concurrent.ListenableFuture<com.spiketrade.proto.TradingServiceProto.GetOpenTradesResponse> getOpenTrades(\n        com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest request) {\n      return io.grpc.stub.ClientCalls.futureUnaryCall(\n          getChannel().newCall(getGetOpenTradesMethod(), getCallOptions()), request);\n    }\n\n    /**\n     */\n    public com.google.common.util.concurrent.ListenableFuture<com.spiketrade.proto.TradingServiceProto.GetClosedTradesResponse> getClosedTrades(\n        com.spiketrade.proto.TradingServiceProto.GetClosedTradesRequest request) {\n      return io.grpc.stub.ClientCalls.futureUnaryCall(\n          getChannel().newCall(getGetClosedTradesMethod(), getCallOptions()), request);\n    }\n  }\n\n  private static final int METHODID_CONNECT = 0;\n  private static final int METHODID_GET_STATUS = 1;\n  private static final int METHODID_GET_HISTORICAL_DATA = 2;\n  private static final int METHODID_STREAM_QUOTES = 3;\n  private static final int METHODID_STREAM_SIGNALS = 4;\n  private static final int METHODID_GET_ANALYSIS_STATUS = 5;\n  private static final int METHODID_GET_SELL_WARNING = 6;\n  private static final int METHODID_UPDATE_CONFIG = 7;\n  private static final int METHODID_GET_CONFIG = 8;\n  private static final int METHODID_START_TRADING = 9;\n  private static final int METHODID_STOP_TRADING = 10;\n  private static final int METHODID_RUN_BACKTEST = 11;\n  private static final int METHODID_STREAM_INDICATORS = 12;\n  private static final int METHODID_GET_OPEN_TRADES = 13;\n  private static final int METHODID_GET_CLOSED_TRADES = 14;\n\n  private static final class MethodHandlers<Req, Resp> implements\n      io.grpc.stub.ServerCalls.UnaryMethod<Req, Resp>,\n      io.grpc.stub.ServerCalls.ServerStreamingMethod<Req, Resp>,\n      io.grpc.stub.ServerCalls.ClientStreamingMethod<Req, Resp>,\n      io.grpc.stub.ServerCalls.BidiStreamingMethod<Req, Resp> {\n    private final AsyncService serviceImpl;\n    private final int methodId;\n\n    MethodHandlers(AsyncService serviceImpl, int methodId) {\n      this.serviceImpl = serviceImpl;\n      this.methodId = methodId;\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public void invoke(Req request, io.grpc.stub.StreamObserver<Resp> responseObserver) {\n      switch (methodId) {\n        case METHODID_CONNECT:\n          serviceImpl.connect((com.spiketrade.proto.TradingServiceProto.ConnectRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.ConnectResponse>) responseObserver);\n          break;\n        case METHODID_GET_STATUS:\n          serviceImpl.getStatus((com.spiketrade.proto.TradingServiceProto.StatusRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.StatusResponse>) responseObserver);\n          break;\n        case METHODID_GET_HISTORICAL_DATA:\n          serviceImpl.getHistoricalData((com.spiketrade.proto.MarketDataProto.HistoricalDataRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.MarketDataProto.HistoricalDataResponse>) responseObserver);\n          break;\n        case METHODID_STREAM_QUOTES:\n          serviceImpl.streamQuotes((com.spiketrade.proto.MarketDataProto.QuoteStreamRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.MarketDataProto.Quote>) responseObserver);\n          break;\n        case METHODID_STREAM_SIGNALS:\n          serviceImpl.streamSignals((com.spiketrade.proto.SpikeSignalsProto.SignalStreamRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.SpikeSignalsProto.BuySignal>) responseObserver);\n          break;\n        case METHODID_GET_ANALYSIS_STATUS:\n          serviceImpl.getAnalysisStatus((com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.SpikeSignalsProto.AnalysisStatus>) responseObserver);\n          break;\n        case METHODID_GET_SELL_WARNING:\n          serviceImpl.getSellWarning((com.spiketrade.proto.SpikeSignalsProto.SellWarningRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.SpikeSignalsProto.SellWarning>) responseObserver);\n          break;\n        case METHODID_UPDATE_CONFIG:\n          serviceImpl.updateConfig((com.spiketrade.proto.ConfigProto.ConfigUpdateRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.ConfigProto.ConfigResponse>) responseObserver);\n          break;\n        case METHODID_GET_CONFIG:\n          serviceImpl.getConfig((com.spiketrade.proto.TradingServiceProto.ConfigRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.ConfigProto.ConfigResponse>) responseObserver);\n          break;\n        case METHODID_START_TRADING:\n          serviceImpl.startTrading((com.spiketrade.proto.TradingServiceProto.StartTradingRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.TradingControlResponse>) responseObserver);\n          break;\n        case METHODID_STOP_TRADING:\n          serviceImpl.stopTrading((com.spiketrade.proto.TradingServiceProto.StopTradingRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.TradingControlResponse>) responseObserver);\n          break;\n        case METHODID_RUN_BACKTEST:\n          serviceImpl.runBacktest((com.spiketrade.proto.TradingServiceProto.BacktestRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.BacktestResponse>) responseObserver);\n          break;\n        case METHODID_STREAM_INDICATORS:\n          serviceImpl.streamIndicators((com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate>) responseObserver);\n          break;\n        case METHODID_GET_OPEN_TRADES:\n          serviceImpl.getOpenTrades((com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.GetOpenTradesResponse>) responseObserver);\n          break;\n        case METHODID_GET_CLOSED_TRADES:\n          serviceImpl.getClosedTrades((com.spiketrade.proto.TradingServiceProto.GetClosedTradesRequest) request,\n              (io.grpc.stub.StreamObserver<com.spiketrade.proto.TradingServiceProto.GetClosedTradesResponse>) responseObserver);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public io.grpc.stub.StreamObserver<Req> invoke(\n        io.grpc.stub.StreamObserver<Resp> responseObserver) {\n      switch (methodId) {\n        default:\n          throw new AssertionError();\n      }\n    }\n  }\n\n  public static final io.grpc.ServerServiceDefinition bindService(AsyncService service) {\n    return io.grpc.ServerServiceDefinition.builder(getServiceDescriptor())\n        .addMethod(\n          getConnectMethod(),\n          io.grpc.stub.ServerCalls.asyncUnaryCall(\n            new MethodHandlers<\n              com.spiketrade.proto.TradingServiceProto.ConnectRequest,\n              com.spiketrade.proto.TradingServiceProto.ConnectResponse>(\n                service, METHODID_CONNECT)))\n        .addMethod(\n          getGetStatusMethod(),\n          io.grpc.stub.ServerCalls.asyncUnaryCall(\n            new MethodHandlers<\n              com.spiketrade.proto.TradingServiceProto.StatusRequest,\n              com.spiketrade.proto.TradingServiceProto.StatusResponse>(\n                service, METHODID_GET_STATUS)))\n        .addMethod(\n          getGetHistoricalDataMethod(),\n          io.grpc.stub.ServerCalls.asyncUnaryCall(\n            new MethodHandlers<\n              com.spiketrade.proto.MarketDataProto.HistoricalDataRequest,\n              com.spiketrade.proto.MarketDataProto.HistoricalDataResponse>(\n                service, METHODID_GET_HISTORICAL_DATA)))\n        .addMethod(\n          getStreamQuotesMethod(),\n          io.grpc.stub.ServerCalls.asyncServerStreamingCall(\n            new MethodHandlers<\n              com.spiketrade.proto.MarketDataProto.QuoteStreamRequest,\n              com.spiketrade.proto.MarketDataProto.Quote>(\n                service, METHODID_STREAM_QUOTES)))\n        .addMethod(\n          getStreamSignalsMethod(),\n          io.grpc.stub.ServerCalls.asyncServerStreamingCall(\n            new MethodHandlers<\n              com.spiketrade.proto.SpikeSignalsProto.SignalStreamRequest,\n              com.spiketrade.proto.SpikeSignalsProto.BuySignal>(\n                service, METHODID_STREAM_SIGNALS)))\n        .addMethod(\n          getGetAnalysisStatusMethod(),\n          io.grpc.stub.ServerCalls.asyncUnaryCall(\n            new MethodHandlers<\n              com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest,\n              com.spiketrade.proto.SpikeSignalsProto.AnalysisStatus>(\n                service, METHODID_GET_ANALYSIS_STATUS)))\n        .addMethod(\n          getGetSellWarningMethod(),\n          io.grpc.stub.ServerCalls.asyncUnaryCall(\n            new MethodHandlers<\n              com.spiketrade.proto.SpikeSignalsProto.SellWarningRequest,\n              com.spiketrade.proto.SpikeSignalsProto.SellWarning>(\n                service, METHODID_GET_SELL_WARNING)))\n        .addMethod(\n          getUpdateConfigMethod(),\n          io.grpc.stub.ServerCalls.asyncUnaryCall(\n            new MethodHandlers<\n              com.spiketrade.proto.ConfigProto.ConfigUpdateRequest,\n              com.spiketrade.proto.ConfigProto.ConfigResponse>(\n                service, METHODID_UPDATE_CONFIG)))\n        .addMethod(\n          getGetConfigMethod(),\n          io.grpc.stub.ServerCalls.asyncUnaryCall(\n            new MethodHandlers<\n              com.spiketrade.proto.TradingServiceProto.ConfigRequest,\n              com.spiketrade.proto.ConfigProto.ConfigResponse>(\n                service, METHODID_GET_CONFIG)))\n        .addMethod(\n          getStartTradingMethod(),\n          io.grpc.stub.ServerCalls.asyncUnaryCall(\n            new MethodHandlers<\n              com.spiketrade.proto.TradingServiceProto.StartTradingRequest,\n              com.spiketrade.proto.TradingServiceProto.TradingControlResponse>(\n                service, METHODID_START_TRADING)))\n        .addMethod(\n          getStopTradingMethod(),\n          io.grpc.stub.ServerCalls.asyncUnaryCall(\n            new MethodHandlers<\n              com.spiketrade.proto.TradingServiceProto.StopTradingRequest,\n              com.spiketrade.proto.TradingServiceProto.TradingControlResponse>(\n                service, METHODID_STOP_TRADING)))\n        .addMethod(\n          getRunBacktestMethod(),\n          io.grpc.stub.ServerCalls.asyncUnaryCall(\n            new MethodHandlers<\n              com.spiketrade.proto.TradingServiceProto.BacktestRequest,\n              com.spiketrade.proto.TradingServiceProto.BacktestResponse>(\n                service, METHODID_RUN_BACKTEST)))\n        .addMethod(\n          getStreamIndicatorsMethod(),\n          io.grpc.stub.ServerCalls.asyncServerStreamingCall(\n            new MethodHandlers<\n              com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest,\n              com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate>(\n                service, METHODID_STREAM_INDICATORS)))\n        .addMethod(\n          getGetOpenTradesMethod(),\n          io.grpc.stub.ServerCalls.asyncUnaryCall(\n            new MethodHandlers<\n              com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest,\n              com.spiketrade.proto.TradingServiceProto.GetOpenTradesResponse>(\n                service, METHODID_GET_OPEN_TRADES)))\n        .addMethod(\n          getGetClosedTradesMethod(),\n          io.grpc.stub.ServerCalls.asyncUnaryCall(\n            new MethodHandlers<\n              com.spiketrade.proto.TradingServiceProto.GetClosedTradesRequest,\n              com.spiketrade.proto.TradingServiceProto.GetClosedTradesResponse>(\n                service, METHODID_GET_CLOSED_TRADES)))\n        .build();\n  }\n\n  private static abstract class TradingServiceBaseDescriptorSupplier\n      implements io.grpc.protobuf.ProtoFileDescriptorSupplier, io.grpc.protobuf.ProtoServiceDescriptorSupplier {\n    TradingServiceBaseDescriptorSupplier() {}\n\n    @java.lang.Override\n    public com.google.protobuf.Descriptors.FileDescriptor getFileDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.getDescriptor();\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Descriptors.ServiceDescriptor getServiceDescriptor() {\n      return getFileDescriptor().findServiceByName(\"TradingService\");\n    }\n  }\n\n  private static final class TradingServiceFileDescriptorSupplier\n      extends TradingServiceBaseDescriptorSupplier {\n    TradingServiceFileDescriptorSupplier() {}\n  }\n\n  private static final class TradingServiceMethodDescriptorSupplier\n      extends TradingServiceBaseDescriptorSupplier\n      implements io.grpc.protobuf.ProtoMethodDescriptorSupplier {\n    private final java.lang.String methodName;\n\n    TradingServiceMethodDescriptorSupplier(java.lang.String methodName) {\n      this.methodName = methodName;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Descriptors.MethodDescriptor getMethodDescriptor() {\n      return getServiceDescriptor().findMethodByName(methodName);\n    }\n  }\n\n  private static volatile io.grpc.ServiceDescriptor serviceDescriptor;\n\n  public static io.grpc.ServiceDescriptor getServiceDescriptor() {\n    io.grpc.ServiceDescriptor result = serviceDescriptor;\n    if (result == null) {\n      synchronized (TradingServiceGrpc.class) {\n        result = serviceDescriptor;\n        if (result == null) {\n          serviceDescriptor = result = io.grpc.ServiceDescriptor.newBuilder(SERVICE_NAME)\n              .setSchemaDescriptor(new TradingServiceFileDescriptorSupplier())\n              .addMethod(getConnectMethod())\n              .addMethod(getGetStatusMethod())\n              .addMethod(getGetHistoricalDataMethod())\n              .addMethod(getStreamQuotesMethod())\n              .addMethod(getStreamSignalsMethod())\n              .addMethod(getGetAnalysisStatusMethod())\n              .addMethod(getGetSellWarningMethod())\n              .addMethod(getUpdateConfigMethod())\n              .addMethod(getGetConfigMethod())\n              .addMethod(getStartTradingMethod())\n              .addMethod(getStopTradingMethod())\n              .addMethod(getRunBacktestMethod())\n              .addMethod(getStreamIndicatorsMethod())\n              .addMethod(getGetOpenTradesMethod())\n              .addMethod(getGetClosedTradesMethod())\n              .build();\n        }\n      }\n    }\n    return result;\n  }\n}\n","size_bytes":71720},"build/extracted-include-protos/main/google/api/backend.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"BackendProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Backend` defines the backend configuration for a service.\nmessage Backend {\n  // A list of API backend rules that apply to individual API methods.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated BackendRule rules = 1;\n}\n\n// A backend rule provides configuration for an individual API element.\nmessage BackendRule {\n  // Path Translation specifies how to combine the backend address with the\n  // request path in order to produce the appropriate forwarding URL for the\n  // request.\n  //\n  // Path Translation is applicable only to HTTP-based backends. Backends which\n  // do not accept requests over HTTP/HTTPS should leave `path_translation`\n  // unspecified.\n  enum PathTranslation {\n    PATH_TRANSLATION_UNSPECIFIED = 0;\n\n    // Use the backend address as-is, with no modification to the path. If the\n    // URL pattern contains variables, the variable names and values will be\n    // appended to the query string. If a query string parameter and a URL\n    // pattern variable have the same name, this may result in duplicate keys in\n    // the query string.\n    //\n    // # Examples\n    //\n    // Given the following operation config:\n    //\n    //     Method path:        /api/company/{cid}/user/{uid}\n    //     Backend address:    https://example.cloudfunctions.net/getUser\n    //\n    // Requests to the following request paths will call the backend at the\n    // translated path:\n    //\n    //     Request path: /api/company/widgetworks/user/johndoe\n    //     Translated:\n    //     https://example.cloudfunctions.net/getUser?cid=widgetworks&uid=johndoe\n    //\n    //     Request path: /api/company/widgetworks/user/johndoe?timezone=EST\n    //     Translated:\n    //     https://example.cloudfunctions.net/getUser?timezone=EST&cid=widgetworks&uid=johndoe\n    CONSTANT_ADDRESS = 1;\n\n    // The request path will be appended to the backend address.\n    //\n    // # Examples\n    //\n    // Given the following operation config:\n    //\n    //     Method path:        /api/company/{cid}/user/{uid}\n    //     Backend address:    https://example.appspot.com\n    //\n    // Requests to the following request paths will call the backend at the\n    // translated path:\n    //\n    //     Request path: /api/company/widgetworks/user/johndoe\n    //     Translated:\n    //     https://example.appspot.com/api/company/widgetworks/user/johndoe\n    //\n    //     Request path: /api/company/widgetworks/user/johndoe?timezone=EST\n    //     Translated:\n    //     https://example.appspot.com/api/company/widgetworks/user/johndoe?timezone=EST\n    APPEND_PATH_TO_ADDRESS = 2;\n  }\n\n  // Selects the methods to which this rule applies.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // The address of the API backend.\n  //\n  // The scheme is used to determine the backend protocol and security.\n  // The following schemes are accepted:\n  //\n  //    SCHEME        PROTOCOL    SECURITY\n  //    http://       HTTP        None\n  //    https://      HTTP        TLS\n  //    grpc://       gRPC        None\n  //    grpcs://      gRPC        TLS\n  //\n  // It is recommended to explicitly include a scheme. Leaving out the scheme\n  // may cause constrasting behaviors across platforms.\n  //\n  // If the port is unspecified, the default is:\n  // - 80 for schemes without TLS\n  // - 443 for schemes with TLS\n  //\n  // For HTTP backends, use [protocol][google.api.BackendRule.protocol]\n  // to specify the protocol version.\n  string address = 2;\n\n  // The number of seconds to wait for a response from a request. The default\n  // varies based on the request protocol and deployment environment.\n  double deadline = 3;\n\n  // Deprecated, do not use.\n  double min_deadline = 4 [deprecated = true];\n\n  // The number of seconds to wait for the completion of a long running\n  // operation. The default is no deadline.\n  double operation_deadline = 5;\n\n  PathTranslation path_translation = 6;\n\n  // Authentication settings used by the backend.\n  //\n  // These are typically used to provide service management functionality to\n  // a backend served on a publicly-routable URL. The `authentication`\n  // details should match the authentication behavior used by the backend.\n  //\n  // For example, specifying `jwt_audience` implies that the backend expects\n  // authentication via a JWT.\n  //\n  // When authentication is unspecified, the resulting behavior is the same\n  // as `disable_auth` set to `true`.\n  //\n  // Refer to https://developers.google.com/identity/protocols/OpenIDConnect for\n  // JWT ID token.\n  oneof authentication {\n    // The JWT audience is used when generating a JWT ID token for the backend.\n    // This ID token will be added in the HTTP \"authorization\" header, and sent\n    // to the backend.\n    string jwt_audience = 7;\n\n    // When disable_auth is true, a JWT ID token won't be generated and the\n    // original \"Authorization\" HTTP header will be preserved. If the header is\n    // used to carry the original token and is expected by the backend, this\n    // field must be set to true to preserve the header.\n    bool disable_auth = 8;\n  }\n\n  // The protocol used for sending a request to the backend.\n  // The supported values are \"http/1.1\" and \"h2\".\n  //\n  // The default value is inferred from the scheme in the\n  // [address][google.api.BackendRule.address] field:\n  //\n  //    SCHEME        PROTOCOL\n  //    http://       http/1.1\n  //    https://      http/1.1\n  //    grpc://       h2\n  //    grpcs://      h2\n  //\n  // For secure HTTP backends (https://) that support HTTP/2, set this field\n  // to \"h2\" for improved performance.\n  //\n  // Configuring this field to non-default values is only supported for secure\n  // HTTP backends. This field will be ignored for all other backends.\n  //\n  // See\n  // https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids\n  // for more details on the supported values.\n  string protocol = 9;\n\n  // The map between request protocol and the backend address.\n  map<string, BackendRule> overrides_by_request_protocol = 10;\n}\n","size_bytes":7014},"build/extracted-include-protos/test/google/api/consumer.proto":{"content":"// Copyright 2016 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"ConsumerProto\";\noption java_package = \"com.google.api\";\n\n// A descriptor for defining project properties for a service. One service may\n// have many consumer projects, and the service may want to behave differently\n// depending on some properties on the project. For example, a project may be\n// associated with a school, or a business, or a government agency, a business\n// type property on the project may affect how a service responds to the client.\n// This descriptor defines which properties are allowed to be set on a project.\n//\n// Example:\n//\n//    project_properties:\n//      properties:\n//      - name: NO_WATERMARK\n//        type: BOOL\n//        description: Allows usage of the API without watermarks.\n//      - name: EXTENDED_TILE_CACHE_PERIOD\n//        type: INT64\nmessage ProjectProperties {\n  // List of per consumer project-specific properties.\n  repeated Property properties = 1;\n}\n\n// Defines project properties.\n//\n// API services can define properties that can be assigned to consumer projects\n// so that backends can perform response customization without having to make\n// additional calls or maintain additional storage. For example, Maps API\n// defines properties that controls map tile cache period, or whether to embed a\n// watermark in a result.\n//\n// These values can be set via API producer console. Only API providers can\n// define and set these properties.\nmessage Property {\n  // Supported data type of the property values\n  enum PropertyType {\n    // The type is unspecified, and will result in an error.\n    UNSPECIFIED = 0;\n\n    // The type is `int64`.\n    INT64 = 1;\n\n    // The type is `bool`.\n    BOOL = 2;\n\n    // The type is `string`.\n    STRING = 3;\n\n    // The type is 'double'.\n    DOUBLE = 4;\n  }\n\n  // The name of the property (a.k.a key).\n  string name = 1;\n\n  // The type of this property.\n  PropertyType type = 2;\n\n  // The description of the property\n  string description = 3;\n}\n","size_bytes":2717},"build/extracted-include-protos/main/google/type/latlng.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/latlng;latlng\";\noption java_multiple_files = true;\noption java_outer_classname = \"LatLngProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// An object that represents a latitude/longitude pair. This is expressed as a\n// pair of doubles to represent degrees latitude and degrees longitude. Unless\n// specified otherwise, this must conform to the\n// <a href=\"http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf\">WGS84\n// standard</a>. Values must be within normalized ranges.\nmessage LatLng {\n  // The latitude in degrees. It must be in the range [-90.0, +90.0].\n  double latitude = 1;\n\n  // The longitude in degrees. It must be in the range [-180.0, +180.0].\n  double longitude = 2;\n}\n","size_bytes":1447},"build/extracted-include-protos/test/google/api/error_reason.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/error_reason;error_reason\";\noption java_multiple_files = true;\noption java_outer_classname = \"ErrorReasonProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Defines the supported values for `google.rpc.ErrorInfo.reason` for the\n// `googleapis.com` error domain. This error domain is reserved for [Service\n// Infrastructure](https://cloud.google.com/service-infrastructure/docs/overview).\n// For each error info of this domain, the metadata key \"service\" refers to the\n// logical identifier of an API service, such as \"pubsub.googleapis.com\". The\n// \"consumer\" refers to the entity that consumes an API Service. It typically is\n// a Google project that owns the client application or the server resource,\n// such as \"projects/123\". Other metadata keys are specific to each error\n// reason. For more information, see the definition of the specific error\n// reason.\nenum ErrorReason {\n  // Do not use this default value.\n  ERROR_REASON_UNSPECIFIED = 0;\n\n  // The request is calling a disabled service for a consumer.\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" contacting\n  // \"pubsub.googleapis.com\" service which is disabled:\n  //\n  //     { \"reason\": \"SERVICE_DISABLED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"pubsub.googleapis.com\"\n  //       }\n  //     }\n  //\n  // This response indicates the \"pubsub.googleapis.com\" has been disabled in\n  // \"projects/123\".\n  SERVICE_DISABLED = 1;\n\n  // The request whose associated billing account is disabled.\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to contact\n  // \"pubsub.googleapis.com\" service because the associated billing account is\n  // disabled:\n  //\n  //     { \"reason\": \"BILLING_DISABLED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"pubsub.googleapis.com\"\n  //       }\n  //     }\n  //\n  // This response indicates the billing account associated has been disabled.\n  BILLING_DISABLED = 2;\n\n  // The request is denied because the provided [API\n  // key](https://cloud.google.com/docs/authentication/api-keys) is invalid. It\n  // may be in a bad format, cannot be found, or has been expired).\n  //\n  // Example of an ErrorInfo when the request is contacting\n  // \"storage.googleapis.com\" service with an invalid API key:\n  //\n  //     { \"reason\": \"API_KEY_INVALID\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //       }\n  //     }\n  API_KEY_INVALID = 3;\n\n  // The request is denied because it violates [API key API\n  // restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_api_restrictions).\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to call the\n  // \"storage.googleapis.com\" service because this service is restricted in the\n  // API key:\n  //\n  //     { \"reason\": \"API_KEY_SERVICE_BLOCKED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  API_KEY_SERVICE_BLOCKED = 4;\n\n  // The request is denied because it violates [API key HTTP\n  // restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_http_restrictions).\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to call\n  // \"storage.googleapis.com\" service because the http referrer of the request\n  // violates API key HTTP restrictions:\n  //\n  //     { \"reason\": \"API_KEY_HTTP_REFERRER_BLOCKED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\",\n  //       }\n  //     }\n  API_KEY_HTTP_REFERRER_BLOCKED = 7;\n\n  // The request is denied because it violates [API key IP address\n  // restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_application_restrictions).\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to call\n  // \"storage.googleapis.com\" service because the caller IP of the request\n  // violates API key IP address restrictions:\n  //\n  //     { \"reason\": \"API_KEY_IP_ADDRESS_BLOCKED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\",\n  //       }\n  //     }\n  API_KEY_IP_ADDRESS_BLOCKED = 8;\n\n  // The request is denied because it violates [API key Android application\n  // restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_application_restrictions).\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to call\n  // \"storage.googleapis.com\" service because the request from the Android apps\n  // violates the API key Android application restrictions:\n  //\n  //     { \"reason\": \"API_KEY_ANDROID_APP_BLOCKED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  API_KEY_ANDROID_APP_BLOCKED = 9;\n\n  // The request is denied because it violates [API key iOS application\n  // restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_application_restrictions).\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to call\n  // \"storage.googleapis.com\" service because the request from the iOS apps\n  // violates the API key iOS application restrictions:\n  //\n  //     { \"reason\": \"API_KEY_IOS_APP_BLOCKED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  API_KEY_IOS_APP_BLOCKED = 13;\n\n  // The request is denied because there is not enough rate quota for the\n  // consumer.\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to contact\n  // \"pubsub.googleapis.com\" service because consumer's rate quota usage has\n  // reached the maximum value set for the quota limit\n  // \"ReadsPerMinutePerProject\" on the quota metric\n  // \"pubsub.googleapis.com/read_requests\":\n  //\n  //     { \"reason\": \"RATE_LIMIT_EXCEEDED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"pubsub.googleapis.com\",\n  //         \"quota_metric\": \"pubsub.googleapis.com/read_requests\",\n  //         \"quota_limit\": \"ReadsPerMinutePerProject\"\n  //       }\n  //     }\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" checks quota on\n  // the service \"dataflow.googleapis.com\" and hits the organization quota\n  // limit \"DefaultRequestsPerMinutePerOrganization\" on the metric\n  // \"dataflow.googleapis.com/default_requests\".\n  //\n  //     { \"reason\": \"RATE_LIMIT_EXCEEDED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"dataflow.googleapis.com\",\n  //         \"quota_metric\": \"dataflow.googleapis.com/default_requests\",\n  //         \"quota_limit\": \"DefaultRequestsPerMinutePerOrganization\"\n  //       }\n  //     }\n  RATE_LIMIT_EXCEEDED = 5;\n\n  // The request is denied because there is not enough resource quota for the\n  // consumer.\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to contact\n  // \"compute.googleapis.com\" service because consumer's resource quota usage\n  // has reached the maximum value set for the quota limit \"VMsPerProject\"\n  // on the quota metric \"compute.googleapis.com/vms\":\n  //\n  //     { \"reason\": \"RESOURCE_QUOTA_EXCEEDED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"compute.googleapis.com\",\n  //         \"quota_metric\": \"compute.googleapis.com/vms\",\n  //         \"quota_limit\": \"VMsPerProject\"\n  //       }\n  //     }\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" checks resource\n  // quota on the service \"dataflow.googleapis.com\" and hits the organization\n  // quota limit \"jobs-per-organization\" on the metric\n  // \"dataflow.googleapis.com/job_count\".\n  //\n  //     { \"reason\": \"RESOURCE_QUOTA_EXCEEDED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"dataflow.googleapis.com\",\n  //         \"quota_metric\": \"dataflow.googleapis.com/job_count\",\n  //         \"quota_limit\": \"jobs-per-organization\"\n  //       }\n  //     }\n  RESOURCE_QUOTA_EXCEEDED = 6;\n\n  // The request whose associated billing account address is in a tax restricted\n  // location, violates the local tax restrictions when creating resources in\n  // the restricted region.\n  //\n  // Example of an ErrorInfo when creating the Cloud Storage Bucket in the\n  // container \"projects/123\" under a tax restricted region\n  // \"locations/asia-northeast3\":\n  //\n  //     { \"reason\": \"LOCATION_TAX_POLICY_VIOLATED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"location\": \"locations/asia-northeast3\"\n  //       }\n  //     }\n  //\n  // This response indicates creating the Cloud Storage Bucket in\n  // \"locations/asia-northeast3\" violates the location tax restriction.\n  LOCATION_TAX_POLICY_VIOLATED = 10;\n\n  // The request is denied because the caller does not have required permission\n  // on the user project \"projects/123\" or the user project is invalid. For more\n  // information, check the [userProject System\n  // Parameters](https://cloud.google.com/apis/docs/system-parameters).\n  //\n  // Example of an ErrorInfo when the caller is calling Cloud Storage service\n  // with insufficient permissions on the user project:\n  //\n  //     { \"reason\": \"USER_PROJECT_DENIED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  USER_PROJECT_DENIED = 11;\n\n  // The request is denied because the consumer \"projects/123\" is suspended due\n  // to Terms of Service(Tos) violations. Check [Project suspension\n  // guidelines](https://cloud.google.com/resource-manager/docs/project-suspension-guidelines)\n  // for more information.\n  //\n  // Example of an ErrorInfo when calling Cloud Storage service with the\n  // suspended consumer \"projects/123\":\n  //\n  //     { \"reason\": \"CONSUMER_SUSPENDED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  CONSUMER_SUSPENDED = 12;\n\n  // The request is denied because the associated consumer is invalid. It may be\n  // in a bad format, cannot be found, or have been deleted.\n  //\n  // Example of an ErrorInfo when calling Cloud Storage service with the\n  // invalid consumer \"projects/123\":\n  //\n  //     { \"reason\": \"CONSUMER_INVALID\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  CONSUMER_INVALID = 14;\n\n  // The request is denied because it violates [VPC Service\n  // Controls](https://cloud.google.com/vpc-service-controls/docs/overview).\n  // The 'uid' field is a random generated identifier that customer can use it\n  // to search the audit log for a request rejected by VPC Service Controls. For\n  // more information, please refer [VPC Service Controls\n  // Troubleshooting](https://cloud.google.com/vpc-service-controls/docs/troubleshooting#unique-id)\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to call\n  // Cloud Storage service because the request is prohibited by the VPC Service\n  // Controls.\n  //\n  //     { \"reason\": \"SECURITY_POLICY_VIOLATED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"uid\": \"123456789abcde\",\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  SECURITY_POLICY_VIOLATED = 15;\n\n  // The request is denied because the provided access token has expired.\n  //\n  // Example of an ErrorInfo when the request is calling Cloud Storage service\n  // with an expired access token:\n  //\n  //     { \"reason\": \"ACCESS_TOKEN_EXPIRED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\"\n  //       }\n  //     }\n  ACCESS_TOKEN_EXPIRED = 16;\n\n  // The request is denied because the provided access token doesn't have at\n  // least one of the acceptable scopes required for the API. Please check\n  // [OAuth 2.0 Scopes for Google\n  // APIs](https://developers.google.com/identity/protocols/oauth2/scopes) for\n  // the list of the OAuth 2.0 scopes that you might need to request to access\n  // the API.\n  //\n  // Example of an ErrorInfo when the request is calling Cloud Storage service\n  // with an access token that is missing required scopes:\n  //\n  //     { \"reason\": \"ACCESS_TOKEN_SCOPE_INSUFFICIENT\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\"\n  //       }\n  //     }\n  ACCESS_TOKEN_SCOPE_INSUFFICIENT = 17;\n\n  // The request is denied because the account associated with the provided\n  // access token is in an invalid state, such as disabled or deleted.\n  // For more information, see https://cloud.google.com/docs/authentication.\n  //\n  // Warning: For privacy reasons, the server may not be able to disclose the\n  // email address for some accounts. The client MUST NOT depend on the\n  // availability of the `email` attribute.\n  //\n  // Example of an ErrorInfo when the request is to the Cloud Storage API with\n  // an access token that is associated with a disabled or deleted [service\n  // account](http://cloud/iam/docs/service-accounts):\n  //\n  //     { \"reason\": \"ACCOUNT_STATE_INVALID\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\",\n  //         \"email\": \"user@123.iam.gserviceaccount.com\"\n  //       }\n  //     }\n  ACCOUNT_STATE_INVALID = 18;\n\n  // The request is denied because the type of the provided access token is not\n  // supported by the API being called.\n  //\n  // Example of an ErrorInfo when the request is to the Cloud Storage API with\n  // an unsupported token type.\n  //\n  //     { \"reason\": \"ACCESS_TOKEN_TYPE_UNSUPPORTED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\"\n  //       }\n  //     }\n  ACCESS_TOKEN_TYPE_UNSUPPORTED = 19;\n\n  // The request is denied because the request doesn't have any authentication\n  // credentials. For more information regarding the supported authentication\n  // strategies for Google Cloud APIs, see\n  // https://cloud.google.com/docs/authentication.\n  //\n  // Example of an ErrorInfo when the request is to the Cloud Storage API\n  // without any authentication credentials.\n  //\n  //     { \"reason\": \"CREDENTIALS_MISSING\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\"\n  //       }\n  //     }\n  CREDENTIALS_MISSING = 20;\n\n  // The request is denied because the provided project owning the resource\n  // which acts as the [API\n  // consumer](https://cloud.google.com/apis/design/glossary#api_consumer) is\n  // invalid. It may be in a bad format or empty.\n  //\n  // Example of an ErrorInfo when the request is to the Cloud Functions API,\n  // but the offered resource project in the request in a bad format which can't\n  // perform the ListFunctions method.\n  //\n  //     { \"reason\": \"RESOURCE_PROJECT_INVALID\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"cloudfunctions.googleapis.com\",\n  //         \"method\":\n  //         \"google.cloud.functions.v1.CloudFunctionsService.ListFunctions\"\n  //       }\n  //     }\n  RESOURCE_PROJECT_INVALID = 21;\n\n  // The request is denied because the provided session cookie is missing,\n  // invalid or failed to decode.\n  //\n  // Example of an ErrorInfo when the request is calling Cloud Storage service\n  // with a SID cookie which can't be decoded.\n  //\n  //     { \"reason\": \"SESSION_COOKIE_INVALID\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\",\n  //         \"cookie\": \"SID\"\n  //       }\n  //     }\n  SESSION_COOKIE_INVALID = 23;\n\n  // The request is denied because the user is from a Google Workspace customer\n  // that blocks their users from accessing a particular service.\n  //\n  // Example scenario: https://support.google.com/a/answer/9197205?hl=en\n  //\n  // Example of an ErrorInfo when access to Google Cloud Storage service is\n  // blocked by the Google Workspace administrator:\n  //\n  //     { \"reason\": \"USER_BLOCKED_BY_ADMIN\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\",\n  //       }\n  //     }\n  USER_BLOCKED_BY_ADMIN = 24;\n\n  // The request is denied because the resource service usage is restricted\n  // by administrators according to the organization policy constraint.\n  // For more information see\n  // https://cloud.google.com/resource-manager/docs/organization-policy/restricting-services.\n  //\n  // Example of an ErrorInfo when access to Google Cloud Storage service is\n  // restricted by Resource Usage Restriction policy:\n  //\n  //     { \"reason\": \"RESOURCE_USAGE_RESTRICTION_VIOLATED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/project-123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  RESOURCE_USAGE_RESTRICTION_VIOLATED = 25;\n\n  // Unimplemented. Do not use.\n  //\n  // The request is denied because it contains unsupported system parameters in\n  // URL query parameters or HTTP headers. For more information,\n  // see https://cloud.google.com/apis/docs/system-parameters\n  //\n  // Example of an ErrorInfo when access \"pubsub.googleapis.com\" service with\n  // a request header of \"x-goog-user-ip\":\n  //\n  //     { \"reason\": \"SYSTEM_PARAMETER_UNSUPPORTED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"pubsub.googleapis.com\"\n  //         \"parameter\": \"x-goog-user-ip\"\n  //       }\n  //     }\n  SYSTEM_PARAMETER_UNSUPPORTED = 26;\n\n  // The request is denied because it violates Org Restriction: the requested\n  // resource does not belong to allowed organizations specified in\n  // \"X-Goog-Allowed-Resources\" header.\n  //\n  // Example of an ErrorInfo when accessing a GCP resource that is restricted by\n  // Org Restriction for \"pubsub.googleapis.com\" service.\n  //\n  // {\n  //   reason: \"ORG_RESTRICTION_VIOLATION\"\n  //   domain: \"googleapis.com\"\n  //   metadata {\n  //     \"consumer\":\"projects/123456\"\n  //     \"service\": \"pubsub.googleapis.com\"\n  //   }\n  // }\n  ORG_RESTRICTION_VIOLATION = 27;\n\n  // The request is denied because \"X-Goog-Allowed-Resources\" header is in a bad\n  // format.\n  //\n  // Example of an ErrorInfo when\n  // accessing \"pubsub.googleapis.com\" service with an invalid\n  // \"X-Goog-Allowed-Resources\" request header.\n  //\n  // {\n  //   reason: \"ORG_RESTRICTION_HEADER_INVALID\"\n  //   domain: \"googleapis.com\"\n  //   metadata {\n  //     \"consumer\":\"projects/123456\"\n  //     \"service\": \"pubsub.googleapis.com\"\n  //   }\n  // }\n  ORG_RESTRICTION_HEADER_INVALID = 28;\n\n  // Unimplemented. Do not use.\n  //\n  // The request is calling a service that is not visible to the consumer.\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" contacting\n  //  \"pubsub.googleapis.com\" service which is not visible to the consumer.\n  //\n  //     { \"reason\": \"SERVICE_NOT_VISIBLE\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"pubsub.googleapis.com\"\n  //       }\n  //     }\n  //\n  // This response indicates the \"pubsub.googleapis.com\" is not visible to\n  // \"projects/123\" (or it may not exist).\n  SERVICE_NOT_VISIBLE = 29;\n\n  // The request is related to a project for which GCP access is suspended.\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to contact\n  // \"pubsub.googleapis.com\" service because GCP access is suspended:\n  //\n  //     { \"reason\": \"GCP_SUSPENDED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"pubsub.googleapis.com\"\n  //       }\n  //     }\n  //\n  // This response indicates the associated GCP account has been suspended.\n  GCP_SUSPENDED = 30;\n}\n","size_bytes":21934},"src/main/java/com/spiketrade/backend/SellSignal.java":{"content":"package com.spiketrade.backend;\n\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SellSignal {\n    public Instant timestamp;\n    public String symbol;\n    public double price;\n    public double signalProbability;\n    public IndicatorsData indicators;\n    public List<SpikeRecord> spikes;\n    public String reason;\n    \n    public SellSignal() {\n        this.timestamp = Instant.now();\n        this.indicators = new IndicatorsData();\n        this.spikes = new ArrayList<>();\n        this.signalProbability = 0.0;\n        this.price = 0.0;\n    }\n}\n","size_bytes":588},"build/extracted-include-protos/test/google/protobuf/timestamp.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/protobuf/types/known/timestamppb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"TimestampProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\n\n// A Timestamp represents a point in time independent of any time zone or local\n// calendar, encoded as a count of seconds and fractions of seconds at\n// nanosecond resolution. The count is relative to an epoch at UTC midnight on\n// January 1, 1970, in the proleptic Gregorian calendar which extends the\n// Gregorian calendar backwards to year one.\n//\n// All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n// second table is needed for interpretation, using a [24-hour linear\n// smear](https://developers.google.com/time/smear).\n//\n// The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n// restricting to that range, we ensure that we can convert to and from [RFC\n// 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n//\n// # Examples\n//\n// Example 1: Compute Timestamp from POSIX `time()`.\n//\n//     Timestamp timestamp;\n//     timestamp.set_seconds(time(NULL));\n//     timestamp.set_nanos(0);\n//\n// Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n//\n//     struct timeval tv;\n//     gettimeofday(&tv, NULL);\n//\n//     Timestamp timestamp;\n//     timestamp.set_seconds(tv.tv_sec);\n//     timestamp.set_nanos(tv.tv_usec * 1000);\n//\n// Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n//\n//     FILETIME ft;\n//     GetSystemTimeAsFileTime(&ft);\n//     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n//\n//     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n//     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n//     Timestamp timestamp;\n//     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n//     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n//\n// Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n//\n//     long millis = System.currentTimeMillis();\n//\n//     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n//         .setNanos((int) ((millis % 1000) * 1000000)).build();\n//\n// Example 5: Compute Timestamp from Java `Instant.now()`.\n//\n//     Instant now = Instant.now();\n//\n//     Timestamp timestamp =\n//         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n//             .setNanos(now.getNano()).build();\n//\n// Example 6: Compute Timestamp from current time in Python.\n//\n//     timestamp = Timestamp()\n//     timestamp.GetCurrentTime()\n//\n// # JSON Mapping\n//\n// In JSON format, the Timestamp type is encoded as a string in the\n// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n// format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n// where {year} is always expressed using four digits while {month}, {day},\n// {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n// seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n// are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n// is required. A proto3 JSON serializer should always use UTC (as indicated by\n// \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n// able to accept both UTC and other timezones (as indicated by an offset).\n//\n// For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n// 01:30 UTC on January 15, 2017.\n//\n// In JavaScript, one can convert a Date object to this format using the\n// standard\n// [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n// method. In Python, a standard `datetime.datetime` object can be converted\n// to this format using\n// [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n// the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n// the Joda Time's [`ISODateTimeFormat.dateTime()`](\n// http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n// ) to obtain a formatter capable of generating timestamps in this format.\n//\nmessage Timestamp {\n  // Represents seconds of UTC time since Unix epoch\n  // 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n  // 9999-12-31T23:59:59Z inclusive.\n  int64 seconds = 1;\n\n  // Non-negative fractions of a second at nanosecond resolution. Negative\n  // second values with fractions must still have non-negative nanos values\n  // that count forward in time. Must be from 0 to 999,999,999\n  // inclusive.\n  int32 nanos = 2;\n}\n","size_bytes":6449},"build/extracted-include-protos/test/google/rpc/context/audit_context.proto":{"content":"// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.rpc.context;\n\nimport \"google/protobuf/struct.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/rpc/context;context\";\noption java_multiple_files = true;\noption java_outer_classname = \"AuditContextProto\";\noption java_package = \"com.google.rpc.context\";\n\n// `AuditContext` provides information that is needed for audit logging.\nmessage AuditContext {\n  // Serialized audit log.\n  bytes audit_log = 1;\n\n  // An API request message that is scrubbed based on the method annotation.\n  // This field should only be filled if audit_log field is present.\n  // Service Control will use this to assemble a complete log for Cloud Audit\n  // Logs and Google internal audit logs.\n  google.protobuf.Struct scrubbed_request = 2;\n\n  // An API response message that is scrubbed based on the method annotation.\n  // This field should only be filled if audit_log field is present.\n  // Service Control will use this to assemble a complete log for Cloud Audit\n  // Logs and Google internal audit logs.\n  google.protobuf.Struct scrubbed_response = 3;\n\n  // Number of scrubbed response items.\n  int32 scrubbed_response_item_count = 4;\n\n  // Audit resource name which is scrubbed.\n  string target_resource = 5;\n}\n","size_bytes":1861},"src/main/java/com/spiketrade/controller/BacktestController.java":{"content":"package com.spiketrade.controller;\n\nimport com.spiketrade.backend.*;\nimport com.spiketrade.model.BacktestParameters;\nimport com.spiketrade.model.BacktestTrade;\nimport com.spiketrade.model.OptimizationResult;\nimport com.spiketrade.proto.ConfigProto;\nimport javafx.application.Platform;\nimport javafx.collections.ObservableList;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class BacktestController {\n    private static final Logger logger = LoggerFactory.getLogger(BacktestController.class);\n    \n    private final ExecutorService backtestExecutor = Executors.newSingleThreadExecutor();\n    private final ForkJoinPool optimizationPool = new ForkJoinPool(Runtime.getRuntime().availableProcessors());\n    \n    private volatile boolean optimizationRunning = false;\n    private volatile boolean stopRequested = false;\n    \n    // NOTE: Yahoo Finance is a FALLBACK data source only\n    // Primary data source should be Questrade API for accurate historical intraday data\n    // Yahoo Finance limitations:\n    //   - Only 7 days of intraday data available\n    //   - No intraday data beyond 7 days (only daily candles)\n    //   - For production backtesting, use Questrade historical API\n    private final YahooFinanceClient yahooClient = new YahooFinanceClient();\n    \n    public void runBacktest(String symbol, LocalDate startDate, LocalDate endDate, \n                           double initialCapital, double targetGain, \n                           ConfigProto.TradingConfig config,\n                           BacktestResultCallback callback) {\n        backtestExecutor.submit(() -> {\n            try {\n                logger.info(\"Starting backtest for {} from {} to {} with config\", symbol, startDate, endDate);\n                \n                // Convert TradingConfig to SpikeAnalysisConfig (same as live trading)\n                SpikeAnalysisConfig spikeConfig = convertToSpikeAnalysisConfig(config);\n                \n                // Create SpikeAnalyzer with the same config as live trading\n                SpikeAnalyzer analyzer = new SpikeAnalyzer(spikeConfig);\n                analyzer.setTargetGainPercent(targetGain);\n                \n                // Calculate number of days needed\n                long daysBetween = java.time.temporal.ChronoUnit.DAYS.between(startDate, endDate);\n                int numDays = (int) daysBetween + 1;\n                \n                // CRITICAL FIX: Yahoo Finance only supports intraday data for last 7 days\n                // Using 5-minute candles for realistic intraday strategy testing\n                // For longer backtests, users must use Questrade API\n                \n                int candleIntervalMinutes;\n                int numBars;\n                \n                if (numDays > 7) {\n                    // WARNING: Beyond 7 days, Yahoo only provides DAILY candles\n                    // This will produce INVALID backtest results for intraday strategies\n                    logger.warn(\"BACKTEST LIMITATION: Requested {} days exceeds Yahoo Finance 7-day intraday limit\", numDays);\n                    logger.warn(\"Falling back to DAILY candles - results will NOT reflect intraday trading!\");\n                    logger.warn(\"For accurate intraday backtesting, use Questrade API or limit backtest to 7 days\");\n                    \n                    candleIntervalMinutes = 1440;  // Daily candles\n                    numBars = numDays;\n                } else {\n                    // Use 5-minute candles for intraday strategy testing (within 7-day Yahoo limit)\n                    candleIntervalMinutes = 5;  // 5-minute candles for realistic intraday testing\n                    numBars = numDays * 24 * 12;  // 12 bars per hour, 24 hours per day\n                    \n                    logger.info(\"Fetching {} 5-minute candles ({} days) for intraday strategy testing\", numBars, numDays);\n                    logger.info(\"NOTE: Yahoo Finance intraday data limited to last 7 days\");\n                }\n                \n                List<Candle> candles = yahooClient.getHistoricalData(symbol, candleIntervalMinutes, numBars);\n                \n                if (candles.isEmpty()) {\n                    logger.error(\"No historical data available for {}\", symbol);\n                    Platform.runLater(() -> callback.onError(\"No historical data available for \" + symbol));\n                    return;\n                }\n                \n                logger.info(\"Loaded {} candles for backtest\", candles.size());\n                \n                // Simulate trading (candles fed incrementally inside simulateTrading)\n                List<BacktestTrade> trades = simulateTrading(symbol, candles, analyzer, initialCapital, targetGain, config, spikeConfig);\n                \n                logger.info(\"Backtest completed: {} trades executed\", trades.size());\n                Platform.runLater(() -> callback.onSuccess(trades));\n                \n            } catch (Exception e) {\n                logger.error(\"Backtest failed\", e);\n                Platform.runLater(() -> callback.onError(e.getMessage()));\n            }\n        });\n    }\n    \n    private SpikeAnalysisConfig convertToSpikeAnalysisConfig(ConfigProto.TradingConfig config) {\n        SpikeAnalysisConfig spikeConfig = new SpikeAnalysisConfig();\n        \n        // Window parameters and data points\n        spikeConfig.buyPeriodMinutes = config.getBuyPeriodMinutes();\n        spikeConfig.vwapPeriodMinutes = config.getVwapPeriodMinutes();\n        \n        // Note: dataPoints/warmupDataPoints is in TradingConfig but not in SpikeAnalysisConfig\n        // It's used by TradingServiceImpl to determine readiness, not by SpikeAnalyzer\n        \n        // Indicator periods\n        spikeConfig.rsiLengthMinutes = config.getRsiLengthMinutes();\n        spikeConfig.mfiPeriodMinutes = config.getMfiPeriodMinutes();\n        spikeConfig.bbLengthMinutes = config.getBbLengthMinutes();\n        \n        // ROC periods\n        spikeConfig.regularPriceRocPeriod = config.getRegularPriceRocPeriod();\n        spikeConfig.regularRsiRocPeriod = config.getRegularRsiRocPeriod();\n        spikeConfig.regularObvRocPeriod = config.getRegularObvRocPeriod();\n        spikeConfig.regularMfiRocPeriod = config.getRegularMfiRocPeriod();\n        spikeConfig.regularPercentBRocPeriod = config.getRegularPercentBRocPeriod();\n        spikeConfig.regularVwapRocPeriod = config.getRegularVwapRocPeriod();\n        spikeConfig.regularVolumeRocPeriod = config.getRegularVolumeRocPeriod();\n        \n        // ROC thresholds\n        spikeConfig.regularPriceRocThreshold = config.getRegularPriceRocThreshold();\n        spikeConfig.regularRsiRocThreshold = config.getRegularRsiRocThreshold();\n        spikeConfig.regularObvRocThreshold = config.getRegularObvRocThreshold();\n        spikeConfig.regularMfiRocThreshold = config.getRegularMfiRocThreshold();\n        spikeConfig.regularPercentBRocThreshold = config.getRegularPercentBRocThreshold();\n        spikeConfig.regularVwapRocThreshold = config.getRegularVwapRocThreshold();\n        spikeConfig.regularVolumeRocThreshold = config.getRegularVolumeRocThreshold();\n        \n        // Spike Z-score thresholds\n        spikeConfig.spikePriceRocZThreshold = config.getSpikePriceRocZThreshold();\n        spikeConfig.spikeRsiRocZThreshold = config.getSpikeRsiRocZThreshold();\n        spikeConfig.spikeObvRocZThreshold = config.getSpikeObvRocZThreshold();\n        spikeConfig.spikeMfiRocZThreshold = config.getSpikeMfiRocZThreshold();\n        spikeConfig.spikePercentBRocZThreshold = config.getSpikePercentBRocZThreshold();\n        spikeConfig.spikeVwapRocZThreshold = config.getSpikeVwapRocZThreshold();\n        spikeConfig.spikeVolumeRocZThreshold = config.getSpikeVolumeRocZThreshold();\n        \n        // Enable/disable flags\n        spikeConfig.enablePriceRocSpike = config.getEnablePriceRocSpike();\n        spikeConfig.enableRsiRocSpike = config.getEnableRsiRocSpike();\n        spikeConfig.enableObvRocSpike = config.getEnableObvRocSpike();\n        spikeConfig.enableMfiRocSpike = config.getEnableMfiRocSpike();\n        spikeConfig.enablePercentBRocSpike = config.getEnablePercentBRocSpike();\n        spikeConfig.enableVwapRocSpike = config.getEnableVwapRocSpike();\n        spikeConfig.enableVolumeRocSpike = config.getEnableVolumeRocSpike();\n        spikeConfig.useMlSpikes = config.getUseMlSpikes();\n        spikeConfig.enableCooldowns = config.getEnableCooldowns();\n        spikeConfig.enableAdxIndicator = config.getEnableAdxIndicator();\n        \n        // Penny stock indicators\n        spikeConfig.enableMacdHistogramRoc = config.getEnableMacdHistogramRoc();\n        spikeConfig.enableStochasticIndicator = config.getEnableStochasticIndicator();\n        spikeConfig.enableRvolIndicator = config.getEnableRvolIndicator();\n        spikeConfig.enableEmaIndicator = config.getEnableEmaIndicator();\n        spikeConfig.enableEmaTrendFilter = config.getEnableEmaTrendFilter();\n        \n        spikeConfig.macdFastPeriod = config.getMacdFastPeriod();\n        spikeConfig.macdSlowPeriod = config.getMacdSlowPeriod();\n        spikeConfig.macdSignalPeriod = config.getMacdSignalPeriod();\n        spikeConfig.macdHistogramRocThreshold = config.getMacdHistogramRocThreshold();\n        \n        spikeConfig.stochasticPeriod = config.getStochasticPeriod();\n        spikeConfig.stochasticKSmooth = config.getStochasticKSmooth();\n        spikeConfig.stochasticDSmooth = config.getStochasticDSmooth();\n        spikeConfig.stochasticOversoldThreshold = config.getStochasticOversoldThreshold();\n        \n        spikeConfig.rvolPeriod = config.getRvolPeriod();\n        spikeConfig.rvolThreshold = config.getRvolThreshold();\n        \n        spikeConfig.ema9Period = config.getEma9Period();\n        spikeConfig.ema20Period = config.getEma20Period();\n        spikeConfig.ema50Period = config.getEma50Period();\n        spikeConfig.volumeSpikeThreshold = config.getVolumeSpikeThreshold();\n        \n        // Trading parameters\n        spikeConfig.comboSignalThreshold = config.getComboSignalThreshold();\n        spikeConfig.highProbThreshold = config.getHighProbThreshold();\n        spikeConfig.stopLossPct = config.getStopLossPct();\n        spikeConfig.spikeCooldownStddevThreshold = config.getSpikeCooldownStddevThreshold();\n        \n        return spikeConfig;\n    }\n    \n    private List<BacktestTrade> simulateTrading(String symbol, List<Candle> candles, \n                                                 SpikeAnalyzer analyzer, double initialCapital,\n                                                 double targetGain, ConfigProto.TradingConfig tradingConfig,\n                                                 SpikeAnalysisConfig spikeConfig) {\n        List<BacktestTrade> trades = new ArrayList<>();\n        double currentCapital = initialCapital;\n        Trade activePosition = null;\n        double highestProfitSinceEntry = 0.0;\n        boolean initialProfitFloorHit = false;\n        int maxOpenTrades = (int) tradingConfig.getMaxOpenTrades();\n        int openTradesCount = 0;\n        \n        // Extract equity per trade from config (matching live trading)\n        double equityPerTrade = tradingConfig.getEquityPerTrade();\n        \n        logger.info(\"Simulating trading with initial capital: ${}, equity per trade: ${}, max open trades: {}\", \n                   initialCapital, equityPerTrade, maxOpenTrades);\n        \n        for (int i = 0; i < candles.size(); i++) {\n            Candle candle = candles.get(i);\n            \n            // Feed candle to analyzer incrementally (same as live trading)\n            // This prevents lookahead bias - analyzer only knows about candles up to current time\n            analyzer.addCandle(symbol, candle);\n            \n            // Check if we have an active position\n            if (activePosition != null) {\n                // Update position with current price\n                double currentPrice = candle.close;\n                double profitPct = ((currentPrice - activePosition.entryPrice) / activePosition.entryPrice) * 100.0;\n                \n                // Track highest profit for trailing stop\n                if (profitPct > highestProfitSinceEntry) {\n                    highestProfitSinceEntry = profitPct;\n                }\n                \n                // Check initial profit floor\n                if (!initialProfitFloorHit && profitPct >= spikeConfig.stopLossPct * 100.0) {\n                    initialProfitFloorHit = true;\n                }\n                \n                String exitReason = null;\n                \n                // Stop loss check\n                if (profitPct <= -spikeConfig.stopLossPct * 100.0) {\n                    exitReason = \"Stop Loss\";\n                }\n                // Target gain check\n                else if (profitPct >= targetGain) {\n                    exitReason = \"Target Gain Reached\";\n                }\n                // Trailing stop (if initial profit floor hit)\n                else if (initialProfitFloorHit) {\n                    double trailingStopPct = spikeConfig.stopLossPct * 100.0;\n                    if (profitPct < highestProfitSinceEntry - trailingStopPct) {\n                        exitReason = \"Trailing Stop\";\n                    }\n                }\n                \n                // Check sell warning from analyzer\n                if (exitReason == null) {\n                    SellWarning warning = analyzer.analyzeSellWarning(symbol);\n                    if (warning != null && warning.warningProbability > 0.7) {\n                        exitReason = \"Sell Signal: \" + warning.reason;\n                    }\n                }\n                \n                // Exit position if triggered\n                if (exitReason != null) {\n                    BacktestTrade trade = new BacktestTrade();\n                    trade.setSymbol(symbol);\n                    trade.setEntryTime(LocalDateTime.ofInstant(activePosition.entryTime, ZoneId.systemDefault()));\n                    trade.setExitTime(LocalDateTime.ofInstant(candle.timestamp, ZoneId.systemDefault()));\n                    trade.setEntryPrice(activePosition.entryPrice);\n                    trade.setExitPrice(currentPrice);\n                    trade.setQuantity(activePosition.shares);\n                    \n                    double profitLoss = (currentPrice - activePosition.entryPrice) * activePosition.shares;\n                    trade.setProfitLoss(profitLoss);\n                    trade.setProfitPct(profitPct);\n                    \n                    // Credit capital with sale proceeds (matching live trading)\n                    double saleProceeds = currentPrice * activePosition.shares;\n                    currentCapital += saleProceeds;\n                    \n                    trades.add(trade);\n                    logger.info(\"Closed position: {} @ ${} -> ${} ({:.2f}%) - {}\", \n                               symbol, activePosition.entryPrice, currentPrice, profitPct, exitReason);\n                    \n                    activePosition = null;\n                    highestProfitSinceEntry = 0.0;\n                    initialProfitFloorHit = false;\n                    openTradesCount--;\n                }\n            }\n            \n            // Check for buy signals if no active position and within max open trades limit\n            if (activePosition == null && openTradesCount < maxOpenTrades) {\n                BuySignal signal = analyzer.analyzeBuySignal(symbol);\n                \n                // Check signal probability threshold (matching live trading)\n                if (signal != null && signal.signalProbability >= spikeConfig.highProbThreshold) {\n                    // Position sizing matching live trading logic\n                    // TradingServiceImpl uses: shares = (int) (config.equityPerTrade / signal.price)\n                    // Use candle.close as entry price (in live trading, this would be ask price from signal)\n                    double entryPrice = candle.close;\n                    int shares = (int) (equityPerTrade / entryPrice);\n                    double cost = shares * entryPrice;\n                    \n                    // Check liquidity - position should not exceed 10% of average volume\n                    double avgVolume = analyzer.getAverageVolume(symbol);\n                    if (avgVolume > 0) {\n                        double positionVsVolume = shares / avgVolume;\n                        if (positionVsVolume > 0.10) {\n                            shares = (int) (avgVolume * 0.10); // Limit to 10% of avg volume\n                            cost = shares * candle.close;\n                            logger.info(\"Reduced position size for liquidity: {} shares (10% of avg volume)\", shares);\n                        }\n                    }\n                    \n                    // Only enter if we have enough capital\n                    if (shares > 0 && currentCapital >= cost) {\n                        activePosition = new Trade();\n                        activePosition.symbol = symbol;\n                        activePosition.entryPrice = entryPrice;\n                        activePosition.shares = shares;\n                        activePosition.entryTime = candle.timestamp;\n                        activePosition.isOpen = true;\n                        \n                        // Debit capital (matching live trading)\n                        currentCapital -= cost;\n                        openTradesCount++;\n                        \n                        logger.info(\"Opened position: {} @ ${} x {} shares (cost: ${}, remaining capital: ${}, signal prob: {:.1f}%)\", \n                                   symbol, entryPrice, shares, cost, currentCapital, signal.signalProbability * 100);\n                    }\n                }\n            }\n        }\n        \n        // Close any remaining open position at the end\n        if (activePosition != null) {\n            Candle lastCandle = candles.get(candles.size() - 1);\n            double profitPct = ((lastCandle.close - activePosition.entryPrice) / activePosition.entryPrice) * 100.0;\n            \n            BacktestTrade trade = new BacktestTrade();\n            trade.setSymbol(symbol);\n            trade.setEntryTime(LocalDateTime.ofInstant(activePosition.entryTime, ZoneId.systemDefault()));\n            trade.setExitTime(LocalDateTime.ofInstant(lastCandle.timestamp, ZoneId.systemDefault()));\n            trade.setEntryPrice(activePosition.entryPrice);\n            trade.setExitPrice(lastCandle.close);\n            trade.setQuantity(activePosition.shares);\n            \n            double profitLoss = (lastCandle.close - activePosition.entryPrice) * activePosition.shares;\n            trade.setProfitLoss(profitLoss);\n            trade.setProfitPct(profitPct);\n            \n            // Credit capital with sale proceeds\n            double saleProceeds = lastCandle.close * activePosition.shares;\n            currentCapital += saleProceeds;\n            \n            trades.add(trade);\n            logger.info(\"Closed final position: {} @ ${} -> ${} ({:.2f}%)\", \n                       symbol, activePosition.entryPrice, lastCandle.close, profitPct);\n        }\n        \n        double finalCapital = currentCapital;\n        double totalReturn = ((finalCapital - initialCapital) / initialCapital) * 100.0;\n        logger.info(\"Backtest complete: Final capital ${} ({:.2f}% return)\", finalCapital, totalReturn);\n        \n        return trades;\n    }\n    \n    public void runOptimization(String symbol, LocalDate startDate, LocalDate endDate,\n                               double initialCapital, double targetGain,\n                               ConfigProto.TradingConfig baseConfig,\n                               OptimizationProgressCallback progressCallback,\n                               OptimizationResultCallback resultCallback) {\n        if (optimizationRunning) {\n            logger.warn(\"Optimization already running\");\n            return;\n        }\n        \n        optimizationRunning = true;\n        stopRequested = false;\n        \n        CompletableFuture.supplyAsync(() -> {\n            try {\n                logger.info(\"Starting parameter optimization for {}\", symbol);\n                logger.warn(\"Optimization not fully implemented - returning empty results\");\n                \n                return List.<OptimizationResult>of();\n                \n            } catch (Exception e) {\n                logger.error(\"Optimization failed\", e);\n                throw new RuntimeException(e);\n            } finally {\n                optimizationRunning = false;\n            }\n        }, optimizationPool).thenAccept(results -> {\n            Platform.runLater(() -> {\n                if (stopRequested) {\n                    resultCallback.onCancelled();\n                } else {\n                    resultCallback.onComplete(results);\n                }\n            });\n        }).exceptionally(e -> {\n            logger.error(\"Optimization exception\", e);\n            Platform.runLater(() -> resultCallback.onError(e.getMessage()));\n            return null;\n        });\n    }\n    \n    public void stopOptimization() {\n        stopRequested = true;\n        logger.info(\"Optimization stop requested\");\n    }\n    \n    public boolean isOptimizationRunning() {\n        return optimizationRunning;\n    }\n    \n    \n    public void shutdown() {\n        backtestExecutor.shutdown();\n        optimizationPool.shutdown();\n    }\n    \n    public interface BacktestResultCallback {\n        void onSuccess(List<BacktestTrade> trades);\n        void onError(String error);\n    }\n    \n    public interface OptimizationProgressCallback {\n        void onProgress(int current, int total);\n    }\n    \n    public interface OptimizationResultCallback {\n        void onComplete(List<OptimizationResult> results);\n        void onCancelled();\n        void onError(String error);\n    }\n}\n","size_bytes":22020},"build/resources/main/trading_service.proto":{"content":"syntax = \"proto3\";\n\npackage spiketrade.proto;\n\nimport \"market_data.proto\";\nimport \"spike_signals.proto\";\nimport \"config.proto\";\n\noption java_package = \"com.spiketrade.proto\";\noption java_outer_classname = \"TradingServiceProto\";\n\n// Trading service definition\nservice TradingService {\n  // Connection management\n  rpc Connect(ConnectRequest) returns (ConnectResponse);\n  rpc GetStatus(StatusRequest) returns (StatusResponse);\n  \n  // Market data\n  rpc GetHistoricalData(HistoricalDataRequest) returns (HistoricalDataResponse);\n  rpc StreamQuotes(QuoteStreamRequest) returns (stream Quote);\n  \n  // Signals and analysis\n  rpc StreamSignals(SignalStreamRequest) returns (stream BuySignal);\n  rpc GetAnalysisStatus(AnalysisStatusRequest) returns (AnalysisStatus);\n  rpc GetSellWarning(SellWarningRequest) returns (SellWarning);\n  \n  // Configuration\n  rpc UpdateConfig(ConfigUpdateRequest) returns (ConfigResponse);\n  rpc GetConfig(ConfigRequest) returns (ConfigResponse);\n  \n  // Trading control\n  rpc StartTrading(StartTradingRequest) returns (TradingControlResponse);\n  rpc StopTrading(StopTradingRequest) returns (TradingControlResponse);\n  \n  // Backtesting\n  rpc RunBacktest(BacktestRequest) returns (BacktestResponse);\n  rpc StreamIndicators(IndicatorStreamRequest) returns (stream IndicatorUpdate);\n  \n  // Trade Tracking\n  rpc GetOpenTrades(GetOpenTradesRequest) returns (GetOpenTradesResponse);\n  rpc GetClosedTrades(GetClosedTradesRequest) returns (GetClosedTradesResponse);\n}\n\n// Request/Response messages\nmessage ConnectRequest {\n  string questrade_token = 1;\n}\n\nmessage ConnectResponse {\n  bool success = 1;\n  string message = 2;\n  ConnectionStatus status = 3;\n}\n\nmessage StatusRequest {}\n\nmessage StatusResponse {\n  bool is_trading = 1;\n  ConnectionStatus connection_status = 2;\n  int32 total_signals = 3;\n  int32 active_positions = 4;\n}\n\nmessage AnalysisStatusRequest {\n  string symbol = 1;\n}\n\nmessage ConfigRequest {}\n\nmessage StartTradingRequest {\n  repeated string symbols = 1;\n}\n\nmessage StopTradingRequest {}\n\nmessage TradingControlResponse {\n  bool success = 1;\n  string message = 2;\n}\n\nmessage BacktestRequest {\n  string symbol = 1;\n  string start_date = 2;  // Format: YYYY-MM-DD\n  string end_date = 3;    // Format: YYYY-MM-DD\n  double initial_capital = 4;\n  int32 interval_minutes = 5;\n}\n\nmessage BacktestTrade {\n  string timestamp = 1;\n  string action = 2;  // \"BUY\" or \"SELL\"\n  double price = 3;\n  int32 shares = 4;\n  double total = 5;\n  double balance = 6;\n  double signal_probability = 7;\n}\n\nmessage BacktestResponse {\n  bool success = 1;\n  string message = 2;\n  repeated BacktestTrade trades = 3;\n  double final_balance = 4;\n  double total_return = 5;\n  int32 total_trades = 6;\n  int32 winning_trades = 7;\n  int32 losing_trades = 8;\n  double win_rate = 9;\n}\n\n// Trade tracking messages\nmessage Trade {\n  string symbol = 1;\n  double entry_price = 2;\n  double exit_price = 3;\n  int32 shares = 4;\n  int64 entry_time_ms = 5;\n  int64 exit_time_ms = 6;\n  double profit_loss = 7;\n  double profit_loss_pct = 8;\n  bool is_open = 9;\n}\n\nmessage GetOpenTradesRequest {}\n\nmessage GetOpenTradesResponse {\n  repeated Trade trades = 1;\n}\n\nmessage GetClosedTradesRequest {}\n\nmessage GetClosedTradesResponse {\n  repeated Trade trades = 1;\n  double total_profit_loss = 2;\n  int32 total_trades = 3;\n  int32 winning_trades = 4;\n  double win_rate = 5;\n}\n","size_bytes":3359},"src/main/java/com/spiketrade/backend/TradingServiceImpl.java":{"content":"package com.spiketrade.backend;\n\n\n\nimport com.spiketrade.proto.TradingServiceGrpc;\nimport com.spiketrade.proto.TradingServiceProto;\nimport static com.spiketrade.proto.TradingServiceProto.*;\nimport com.spiketrade.proto.MarketDataProto;\nimport com.spiketrade.proto.SpikeSignalsProto;\nimport com.spiketrade.proto.ConfigProto;\nimport io.grpc.stub.StreamObserver;\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class TradingServiceImpl extends TradingServiceGrpc.TradingServiceImplBase {\n    private final QuestradeClient questradeClient;\n    private final SpikeAnalyzer analyzer;\n    private final ConfigValidator configValidator;\n    private final TradeTracker tradeTracker;\n    private final CandleAggregator candleAggregator;  // NEW: Aggregates 1-min candles into N-min candles\n    private final com.spiketrade.service.NotificationService notificationService;  // FIX: Add notification support\n    \n    private final Object stateLock = new Object();\n    private final AtomicBoolean isTrading = new AtomicBoolean(false);\n    private final AtomicBoolean shutdown = new AtomicBoolean(false);\n    private final AtomicInteger totalSignals = new AtomicInteger(0);\n    private final AtomicInteger activePositions = new AtomicInteger(0);\n    \n    private final Set<String> activeSymbols = ConcurrentHashMap.newKeySet();\n    private final Map<String, Instant> lastCandleTimestamps = new ConcurrentHashMap<>();  // FIX: Track last candle timestamp per symbol\n    private volatile int currentTimeframeMultiplier = 1;  // FIX: Track current multiplier for newly added symbols\n    private Thread sellSignalMonitor;\n    private Thread stopLossMonitor;  // NEW: Monitor for stop-loss, target gain, and trailing stop\n    private final Map<String, Double> highestProfitBySymbol = new ConcurrentHashMap<>();  // Track highest profit for trailing stop\n    private final Map<String, Boolean> profitFloorHitBySymbol = new ConcurrentHashMap<>();  // Track if initial profit floor was hit\n    \n    // FIX #1: Thread lifecycle management for persistent streaming\n    private final Map<String, Thread> quoteStreamThreads = new ConcurrentHashMap<>();\n    private final Map<String, Thread> signalStreamThreads = new ConcurrentHashMap<>();\n    private final Map<String, StreamObserver<MarketDataProto.Quote>> quoteObservers = new ConcurrentHashMap<>();\n    private final Map<String, StreamObserver<SpikeSignalsProto.BuySignal>> signalObservers = new ConcurrentHashMap<>();\n    \n    // Dev mode flag for testing with injected data\n    private static final boolean DEV_MODE = Boolean.getBoolean(\"spiketrade.devmode\");\n    \n    // Constructor with NotificationService (preferred)\n    public TradingServiceImpl(\n            QuestradeClient questradeClient,\n            SpikeAnalyzer analyzer,\n            ConfigValidator configValidator,\n            com.spiketrade.service.NotificationService notificationService) {\n        this.questradeClient = questradeClient;\n        this.analyzer = analyzer;\n        this.configValidator = configValidator;\n        this.tradeTracker = new TradeTracker();\n        this.candleAggregator = new CandleAggregator();\n        this.notificationService = notificationService;\n        System.out.println(\"TradingServiceImpl initialized with TradeTracker, CandleAggregator, and NotificationService\");\n        if (DEV_MODE) {\n            System.out.println(\"*** DEV MODE ENABLED - Test data injection available ***\");\n        }\n    }\n    \n    // Constructor without NotificationService (backward compatibility - notifications disabled)\n    public TradingServiceImpl(\n            QuestradeClient questradeClient,\n            SpikeAnalyzer analyzer,\n            ConfigValidator configValidator) {\n        this(questradeClient, analyzer, configValidator, null);\n        System.out.println(\"WARNING: TradingServiceImpl initialized WITHOUT NotificationService - trade alerts disabled\");\n    }\n    \n    /**\n     * Inject test data for development/testing\n     * Allows manual data injection to bypass API fetch failures\n     */\n    public void injectTestData(String symbol, List<Candle> candles) {\n        if (!DEV_MODE) {\n            System.err.println(\"Test data injection only available in DEV_MODE\");\n            return;\n        }\n        \n        System.out.println(\"Injecting \" + candles.size() + \" test candles for \" + symbol);\n        // Add candles one by one through the normal path\n        for (Candle candle : candles) {\n            analyzer.addCandle(symbol, candle);\n        }\n        System.out.println(\"Test data injected for \" + symbol);\n    }\n    \n    @Override\n    public void connect(ConnectRequest request, \n                       StreamObserver<ConnectResponse> responseObserver) {\n        System.out.println(\"Connect request received with token: \" + \n            (request.getQuestradeToken().isEmpty() ? \"EMPTY\" : \"PROVIDED\"));\n        \n        ConnectResponse.Builder response = ConnectResponse.newBuilder();\n        \n        if (request.getQuestradeToken().isEmpty()) {\n            response.setSuccess(false);\n            response.setMessage(\"No token provided, cannot connect to Questrade\");\n            \n            ConnectionStatus status = questradeClient.getConnectionStatus();\n            response.setStatus(convertConnectionStatus(status));\n            \n            responseObserver.onNext(response.build());\n            responseObserver.onCompleted();\n            return;\n        }\n        \n        // Inject the token from GUI into QuestradeClient BEFORE authenticating\n        questradeClient.setRefreshToken(request.getQuestradeToken());\n        \n        // Now authenticate with the updated token\n        boolean success = questradeClient.authenticate();\n        \n        response.setSuccess(success);\n        if (success) {\n            response.setMessage(\"Connected to Questrade successfully\");\n        } else {\n            response.setMessage(\"Questrade authentication failed - check your token\");\n        }\n        \n        ConnectionStatus status = questradeClient.getConnectionStatus();\n        response.setStatus(convertConnectionStatus(status));\n        \n        System.out.println(\"Connect response: \" + response.getMessage());\n        \n        responseObserver.onNext(response.build());\n        responseObserver.onCompleted();\n    }\n    \n    @Override\n    public void getStatus(StatusRequest request, \n                         StreamObserver<StatusResponse> responseObserver) {\n        synchronized (stateLock) {\n            StatusResponse.Builder response = StatusResponse.newBuilder();\n            response.setIsTrading(isTrading.get());\n            response.setTotalSignals(totalSignals.get());\n            response.setActivePositions(activePositions.get());\n            \n            ConnectionStatus status = questradeClient.getConnectionStatus();\n            response.setConnectionStatus(convertConnectionStatus(status));\n            \n            responseObserver.onNext(response.build());\n            responseObserver.onCompleted();\n        }\n    }\n    \n    @Override\n    public void getHistoricalData(MarketDataProto.HistoricalDataRequest request,\n                                 StreamObserver<MarketDataProto.HistoricalDataResponse> responseObserver) {\n        System.out.println(\"GetHistoricalData request: \" + request.getSymbol() +\n                          \" interval=\" + request.getIntervalMinutes() +\n                          \" bars=\" + request.getNumBars());\n        \n        MarketDataProto.HistoricalDataResponse.Builder response = MarketDataProto.HistoricalDataResponse.newBuilder();\n        \n        try {\n            List<Candle> candles = questradeClient.getHistoricalData(\n                request.getSymbol(),\n                request.getIntervalMinutes(),\n                request.getNumBars()\n            );\n            \n            response.setSymbol(request.getSymbol());\n            \n            for (Candle candle : candles) {\n                response.addCandles(convertCandle(candle));\n            }\n            \n            System.out.println(\"Returned \" + candles.size() + \" candles\");\n            \n        } catch (Exception e) {\n            response.setErrorMessage(e.getMessage());\n            System.err.println(\"GetHistoricalData error: \" + e.getMessage());\n        }\n        \n        responseObserver.onNext(response.build());\n        responseObserver.onCompleted();\n    }\n    \n    @Override\n    public void streamQuotes(MarketDataProto.QuoteStreamRequest request,\n                            StreamObserver<MarketDataProto.Quote> responseObserver) {\n        String streamKey = String.join(\",\", request.getSymbolsList());\n        System.out.println(\" StreamQuotes request for \" + request.getSymbolsCount() + \" symbols: \" + streamKey);\n        \n        // FIX: Apply current timeframe multiplier IMMEDIATELY when symbols are added\n        for (String symbol : request.getSymbolsList()) {\n            synchronized (stateLock) {\n                boolean isNewSymbol = activeSymbols.add(symbol);\n                if (isNewSymbol) {\n                    candleAggregator.setTimeframeMultiplier(symbol, currentTimeframeMultiplier);\n                    System.out.println(\" Registered new symbol: \" + symbol + \" with \" + currentTimeframeMultiplier + \"x multiplier\");\n                }\n            }\n        }\n        \n        // FIX #1: Stop any existing quote stream for these symbols\n        Thread existingThread = quoteStreamThreads.get(streamKey);\n        if (existingThread != null && existingThread.isAlive()) {\n            System.out.println(\"  Interrupting existing quote stream for: \" + streamKey);\n            existingThread.interrupt();\n        }\n        \n        // FIX #1: Store the observer for lifecycle management\n        quoteObservers.put(streamKey, responseObserver);\n        \n        // FIX #1: Create persistent streaming thread with proper lifecycle\n        Thread streamThread = new Thread(() -> {\n            System.out.println(\" Quote streaming thread STARTED for: \" + streamKey);\n            \n            // FIX: Warmup each symbol with historical data BEFORE starting live polling\n            TradingConfig config = configValidator.getConfig();\n            int warmupCandles = config.warmupDataPoints;\n            System.out.println(\" WARMUP: Preloading \" + warmupCandles + \" candles per symbol (timeframe=\" + currentTimeframeMultiplier + \"x)\");\n            \n            for (String symbol : request.getSymbolsList()) {\n                try {\n                    int rawCandlesNeeded = warmupCandles * currentTimeframeMultiplier;\n                    List<Candle> historicalCandles = questradeClient.getHistoricalData(symbol, 1, rawCandlesNeeded);\n                    \n                    if (!historicalCandles.isEmpty()) {\n                        for (Candle candle : historicalCandles) {\n                            lastCandleTimestamps.put(symbol, candle.timestamp);\n                            Candle aggregatedCandle = candleAggregator.addCandleAndGetAggregated(symbol, candle);\n                            if (aggregatedCandle != null) {\n                                analyzer.addCandle(symbol, aggregatedCandle);\n                            }\n                        }\n                        int dataPoints = analyzer.getDataPointsCollected(symbol);\n                        System.out.println(\" WARMUP: \" + symbol + \" - Loaded \" + historicalCandles.size() + \" raw candles  \" + dataPoints + \" aggregated candles\");\n                    }\n                } catch (Exception e) {\n                    System.err.println(\" WARMUP: Failed to load historical data for \" + symbol + \": \" + e.getMessage());\n                }\n            }\n            \n            System.out.println(\" Live quote streaming begins for: \" + streamKey);\n            int updateCount = 0;\n            \n            try {\n                while (!shutdown.get() && !Thread.currentThread().isInterrupted()) {\n                    for (String symbol : request.getSymbolsList()) {\n                        try {\n                            Quote quote = questradeClient.getQuote(symbol);\n                            \n                            IndicatorsData indicators = analyzer.getCurrentIndicators(symbol);\n                            \n                            MarketDataProto.Quote protoQuote = convertQuote(quote, indicators);\n                            \n                            synchronized (stateLock) {\n                                responseObserver.onNext(protoQuote);\n                            }\n                            \n                            // FIX: Diagnostic logging every 10 updates with indicator status\n                            updateCount++;\n                            if (updateCount % 10 == 0) {\n                                int dataPoints = analyzer.getDataPointsCollected(symbol);\n                                boolean hasIndicatorData = (dataPoints >= 2 && indicators.rsi > 0);\n                                String indicatorInfo = hasIndicatorData\n                                    ? \" | RSI: \" + String.format(\"%.2f\", indicators.rsi) + \" | MFI: \" + String.format(\"%.2f\", indicators.mfi)\n                                    : \" | Indicators: warming up (\" + dataPoints + \" candles collected)\";\n                                System.out.println(\" Quote stream update #\" + updateCount + \" for \" + symbol + \n                                                 \" | Price: $\" + quote.price + \" | Volume: \" + quote.volume + indicatorInfo);\n                            }\n                            \n                            // FIX #3: Unified candle processing with diagnostic logging\n                            List<Candle> candles = questradeClient.getHistoricalData(symbol, 1, 1);\n                            if (!candles.isEmpty()) {\n                                Candle newCandle = candles.get(0);\n                                \n                                // FIX: Only process NEW candles (skip duplicates from polling same minute)\n                                Instant lastTimestamp = lastCandleTimestamps.get(symbol);\n                                if (lastTimestamp == null || newCandle.timestamp.isAfter(lastTimestamp)) {\n                                    // This is a NEW candle we haven't seen before\n                                    lastCandleTimestamps.put(symbol, newCandle.timestamp);\n                                    \n                                    System.out.println(\"  NEW 1-min candle for \" + symbol + \" at \" + newCandle.timestamp + \n                                                     \" | Close: $\" + newCandle.close + \" | Volume: \" + newCandle.volume);\n                                    \n                                    // Use candle aggregator to potentially aggregate before analysis\n                                    Candle aggregatedCandle = candleAggregator.addCandleAndGetAggregated(symbol, newCandle);\n                                    \n                                    // Only add to analyzer if we got an aggregated candle back\n                                    // (null means we're still collecting candles for the current bucket)\n                                    if (aggregatedCandle != null) {\n                                        analyzer.addCandle(symbol, aggregatedCandle);\n                                        int dataPoints = analyzer.getDataPointsCollected(symbol);\n                                        System.out.println(\" Added aggregated \" + currentTimeframeMultiplier + \"-min candle for \" + symbol + \n                                                         \" at \" + aggregatedCandle.timestamp + \n                                                         \" | Close: $\" + aggregatedCandle.close + \n                                                         \" | Data points: \" + dataPoints + \"/\" + configValidator.getConfig().warmupDataPoints);\n                                    } else {\n                                        int pending = candleAggregator.getPendingCount(symbol);\n                                        System.out.println(\" Collecting 1-min candles for \" + symbol + \n                                                         \" (\" + pending + \"/\" + currentTimeframeMultiplier + \" for next aggregation)\");\n                                    }\n                                }\n                            }\n                            \n                        } catch (Exception e) {\n                            System.err.println(\" StreamQuotes error for \" + symbol + \": \" + e.getMessage());\n                            // Continue streaming despite errors for individual symbols\n                        }\n                    }\n                    \n                    try {\n                        Thread.sleep(3000);\n                    } catch (InterruptedException e) {\n                        System.out.println(\" Quote stream interrupted for: \" + streamKey);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                System.err.println(\" Quote stream fatal error for \" + streamKey + \": \" + e.getMessage());\n                e.printStackTrace();\n            } finally {\n                // FIX #1: Only complete observer on shutdown or explicit stop, not on errors\n                if (shutdown.get() || Thread.currentThread().isInterrupted()) {\n                    System.out.println(\" Quote stream STOPPED for: \" + streamKey + \" (shutdown=\" + shutdown.get() + \")\");\n                    synchronized (stateLock) {\n                        try {\n                            responseObserver.onCompleted();\n                        } catch (Exception e) {\n                            System.err.println(\"Error completing quote observer: \" + e.getMessage());\n                        }\n                    }\n                    quoteObservers.remove(streamKey);\n                    quoteStreamThreads.remove(streamKey);\n                } else {\n                    System.out.println(\"  Quote stream encountered error but keeping observer alive for: \" + streamKey);\n                }\n            }\n        }, \"QuoteStream-\" + streamKey);\n        \n        quoteStreamThreads.put(streamKey, streamThread);\n        streamThread.start();\n    }\n    \n    @Override\n    public void streamSignals(SpikeSignalsProto.SignalStreamRequest request,\n                             StreamObserver<SpikeSignalsProto.BuySignal> responseObserver) {\n        String streamKey = String.join(\",\", request.getSymbolsList());\n        System.out.println(\" StreamSignals request for \" + request.getSymbolsCount() + \" symbols: \" + streamKey);\n        \n        // REMOVED PROBABILITY FILTER: Stream ALL signals regardless of probability\n        double minProbability = request.getMinProbability();\n        \n        final double finalMinProbability = minProbability;\n        \n        // FIX #1: Stop any existing signal stream for these symbols\n        Thread existingThread = signalStreamThreads.get(streamKey);\n        if (existingThread != null && existingThread.isAlive()) {\n            System.out.println(\"  Interrupting existing signal stream for: \" + streamKey);\n            existingThread.interrupt();\n        }\n        \n        // FIX #1: Store the observer for lifecycle management\n        signalObservers.put(streamKey, responseObserver);\n        \n        // FIX #1: Create persistent streaming thread with proper lifecycle\n        Thread streamThread = new Thread(() -> {\n            System.out.println(\" Signal streaming thread STARTED for: \" + streamKey);\n            int signalCount = 0;\n            \n            try {\n                // FIX #1: Remove isTrading from loop condition - keep stream alive regardless of trading state\n                while (!shutdown.get() && !Thread.currentThread().isInterrupted()) {\n                    // FIX #1: Only generate signals when trading is active, but keep stream alive\n                    if (!isTrading.get()) {\n                        // Trading is paused - keep stream alive but don't generate signals\n                        try {\n                            Thread.sleep(5000);\n                        } catch (InterruptedException e) {\n                            System.out.println(\" Signal stream interrupted for: \" + streamKey);\n                            break;\n                        }\n                        continue;\n                    }\n                    \n                    for (String symbol : request.getSymbolsList()) {\n                        try {\n                            // FIX #4: Check if analyzer is ready before generating signals\n                            boolean isReady = analyzer.isReadyForTrading(symbol);\n                            int dataPoints = analyzer.getDataPointsCollected(symbol);\n                            int warmupRequired = configValidator.getConfig().warmupDataPoints;\n                            \n                            if (!isReady) {\n                                // FIX #3: Diagnostic logging for warmup status\n                                if (dataPoints % 5 == 0 || dataPoints == 0) {  // Log every 5 data points\n                                    System.out.println(\" Analyzer not ready for \" + symbol + \n                                                     \" | Data points: \" + dataPoints + \"/\" + warmupRequired + \n                                                     \" | Need \" + (warmupRequired - dataPoints) + \" more\");\n                                }\n                                continue;  // Skip signal analysis until ready\n                            }\n                            \n                            BuySignal signal = analyzer.analyzeBuySignal(symbol);\n                            \n                            if (signal != null) {\n                                signalCount++;\n                                System.out.println(\" BUY SIGNAL #\" + signalCount + \" for \" + symbol + \n                                                 \" | Probability: \" + String.format(\"%.1f%%\", signal.signalProbability * 100) + \n                                                 \" | Price: $\" + signal.price);\n                            // FIX #4: Get current quote to calculate bid-ask spread\n                            Quote quote = questradeClient.getQuote(symbol);\n                            if (quote != null && quote.bid > 0 && quote.ask > 0) {\n                                signal.bid = quote.bid;\n                                signal.ask = quote.ask;\n                                double midpoint = (quote.bid + quote.ask) / 2.0;\n                                signal.spreadPercent = ((quote.ask - quote.bid) / midpoint) * 100.0;\n                                \n                                // FIX #4: Update signal price to ASK price to include spread cost\n                                // This ensures all downstream calculations use the actual execution price\n                                signal.price = quote.ask;\n                                \n                                System.out.println(String.format(\"Spread for %s: %.2f%% (bid=$%.2f ask=$%.2f, using ask for entry)\", \n                                    symbol, signal.spreadPercent, quote.bid, quote.ask));\n                            }\n                            \n                            SpikeSignalsProto.BuySignal protoSignal = convertBuySignal(signal);\n                            synchronized (stateLock) {\n                                responseObserver.onNext(protoSignal);\n                            }\n                            \n                            totalSignals.incrementAndGet();\n                            \n                            // Automatically open trade if probability exceeds configured threshold\n                            TradingConfig config = configValidator.getConfig();\n                            if (signal.signalProbability >= config.highProbThreshold) {\n                                System.out.println(\"Signal probability \" + signal.signalProbability + \n                                    \" >= threshold \" + config.highProbThreshold + \" - evaluating trade\");\n                                \n                                // FIX #4: Reject trades with spread > 2%\n                                if (signal.spreadPercent > 2.0) {\n                                    System.out.println(\"REJECTED: Spread too wide for \" + symbol + \n                                        \" (\" + String.format(\"%.2f\", signal.spreadPercent) + \"% > 2.0%)\");\n                                } else {\n                                    // FIX #4: Calculate shares using ASK price (signal.price now equals ask)\n                                    // This ensures position sizing accounts for spread cost\n                                    int shares = (int) (config.equityPerTrade / signal.price);\n                                    \n                                    // FIX #4: Reduce position size for spreads > 1%\n                                    if (signal.spreadPercent > 1.0) {\n                                        shares = (int) (shares * 0.5); // Reduce position by 50%\n                                        System.out.println(\"REDUCED POSITION: Spread > 1% for \" + symbol + \n                                            \" (\" + String.format(\"%.2f\", signal.spreadPercent) + \"%), reducing shares by 50%\");\n                                    }\n                                    \n                                    // FIX #5: Check liquidity - reject if position exceeds 10% of avg volume\n                                    double avgVolume = analyzer.getAverageVolume(symbol);\n                                    if (avgVolume > 0) {\n                                        double positionValue = shares * signal.price;  // Using ask price\n                                        double volumeDollarValue = avgVolume * signal.price;\n                                        double positionVsVolume = positionValue / volumeDollarValue;\n                                        \n                                        if (positionVsVolume > 0.10) {\n                                            System.out.println(\"REJECTED: Insufficient liquidity for \" + symbol + \n                                                \" (position would be \" + String.format(\"%.1f\", positionVsVolume * 100) + \n                                                \"% of avg volume, max 10%)\");\n                                            shares = 0; // Reject the trade\n                                        } else {\n                                            System.out.println(\"Liquidity check passed for \" + symbol + \n                                                \": position is \" + String.format(\"%.1f\", positionVsVolume * 100) + \n                                                \"% of avg volume (20-bar avg: \" + String.format(\"%.0f\", avgVolume) + \" shares)\");\n                                        }\n                                    }\n                                    \n                                    if (shares > 0) {\n                                        // FIX #4: Entry price is already set to ask price in signal.price\n                                        // TradeTracker will use the ask price for entry, properly accounting for spread\n                                        tradeTracker.openTrade(symbol, signal.price, shares);\n                                        activePositions.incrementAndGet();\n                                        System.out.println(\"Opened trade for \" + symbol + \n                                                          \": \" + shares + \" shares at $\" + signal.price +\n                                                          \" (spread: \" + String.format(\"%.2f\", signal.spreadPercent) + \"%)\");\n                                        \n                                        // FIX: Send notification for buy signal (error-safe)\n                                        if (notificationService != null) {\n                                            try {\n                                                String details = String.format(\"%d shares @ $%.2f (spread: %.2f%%)\", \n                                                    shares, signal.price, signal.spreadPercent);\n                                                notificationService.showBuySignal(symbol, signal.price, signal.signalProbability, details);\n                                            } catch (Exception notifError) {\n                                                System.err.println(\"Failed to send buy notification: \" + notifError.getMessage());\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        \n                        } catch (Exception e) {\n                            System.err.println(\" StreamSignals error for \" + symbol + \": \" + e.getMessage());\n                            // Continue streaming despite errors for individual symbols\n                        }\n                    }\n                    \n                    try {\n                        Thread.sleep(5000);\n                    } catch (InterruptedException e) {\n                        System.out.println(\" Signal stream interrupted for: \" + streamKey);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                System.err.println(\" Signal stream fatal error for \" + streamKey + \": \" + e.getMessage());\n                e.printStackTrace();\n            } finally {\n                // FIX #1: Only complete observer on shutdown or explicit interruption, not on trading state changes\n                if (shutdown.get() || Thread.currentThread().isInterrupted()) {\n                    System.out.println(\" Signal stream STOPPED for: \" + streamKey + \n                                     \" (shutdown=\" + shutdown.get() + \", interrupted=\" + Thread.currentThread().isInterrupted() + \")\");\n                    synchronized (stateLock) {\n                        try {\n                            responseObserver.onCompleted();\n                        } catch (Exception e) {\n                            System.err.println(\"Error completing signal observer: \" + e.getMessage());\n                        }\n                    }\n                    signalObservers.remove(streamKey);\n                    signalStreamThreads.remove(streamKey);\n                } else {\n                    System.out.println(\"  Signal stream encountered error but keeping observer alive for: \" + streamKey);\n                }\n            }\n        }, \"SignalStream-\" + streamKey);\n        \n        signalStreamThreads.put(streamKey, streamThread);\n        streamThread.start();\n    }\n    \n    @Override\n    public void getAnalysisStatus(AnalysisStatusRequest request,\n                                  StreamObserver<SpikeSignalsProto.AnalysisStatus> responseObserver) {\n        String symbol = request.getSymbol();\n        \n        SpikeSignalsProto.AnalysisStatus.Builder response = SpikeSignalsProto.AnalysisStatus.newBuilder();\n        response.setSymbol(symbol);\n        response.setDataPointsCollected(analyzer.getDataPointsCollected(symbol));\n        response.setWarmupRequired(configValidator.getConfig().warmupDataPoints);\n        response.setReadyForTrading(analyzer.isReadyForTrading(symbol));\n        response.setTotalSpikesDetected(analyzer.getTotalSpikeCount(symbol));\n        response.setBuySignalsGenerated(totalSignals.get());\n        \n        // Add latest indicators and buy probability\n        try {\n            IndicatorsData indicatorsData = analyzer.calculateIndicators(symbol);\n            if (indicatorsData != null) {\n                response.setLatestIndicators(convertIndicators(indicatorsData));\n            }\n            \n            BuySignal signal = analyzer.analyzeBuySignal(symbol);\n            if (signal != null) {\n                response.setLatestBuyProbability(signal.signalProbability);\n            } else {\n                response.setLatestBuyProbability(0.0);\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error getting indicators for \" + symbol + \": \" + e.getMessage());\n        }\n        \n        responseObserver.onNext(response.build());\n        responseObserver.onCompleted();\n    }\n    \n    @Override\n    public void getSellWarning(SpikeSignalsProto.SellWarningRequest request,\n                              StreamObserver<SpikeSignalsProto.SellWarning> responseObserver) {\n        String symbol = request.getSymbol();\n        \n        try {\n            SellWarning warning = analyzer.analyzeSellWarning(symbol);\n            \n            if (warning != null) {\n                // Convert to proto\n                SpikeSignalsProto.SellWarning.Builder protoWarning = \n                    SpikeSignalsProto.SellWarning.newBuilder();\n                protoWarning.setTimestampMs(warning.timestamp.toEpochMilli());\n                protoWarning.setSymbol(warning.symbol);\n                protoWarning.setPrice(warning.price);\n                protoWarning.setWarningProbability(warning.warningProbability);\n                protoWarning.setReason(warning.reason);\n                \n                // Add indicators\n                if (warning.indicators != null) {\n                    protoWarning.setIndicators(convertIndicators(warning.indicators));\n                }\n                \n                responseObserver.onNext(protoWarning.build());\n                System.out.println(\"Sent sell warning for \" + symbol + \n                                 \" with probability \" + warning.warningProbability);\n            } else {\n                // No warning detected - send empty warning with 0 probability\n                SpikeSignalsProto.SellWarning.Builder noWarning = \n                    SpikeSignalsProto.SellWarning.newBuilder();\n                noWarning.setSymbol(symbol);\n                noWarning.setWarningProbability(0.0);\n                noWarning.setReason(\"No sell warning conditions detected\");\n                responseObserver.onNext(noWarning.build());\n            }\n            \n            responseObserver.onCompleted();\n            \n        } catch (Exception e) {\n            System.err.println(\"Error analyzing sell warning for \" + symbol + \": \" + e.getMessage());\n            responseObserver.onError(e);\n        }\n    }\n    \n    @Override\n    public void updateConfig(ConfigProto.ConfigUpdateRequest request,\n                            StreamObserver<ConfigProto.ConfigResponse> responseObserver) {\n        System.out.println(\"UpdateConfig request received\");\n        \n        synchronized (stateLock) {\n            ConfigProto.ConfigResponse.Builder response = ConfigProto.ConfigResponse.newBuilder();\n            \n            try {\n                ConfigProto.TradingConfig newConfig = request.getConfig();\n                TradingConfig config = configValidator.getConfig();\n                \n                System.out.println(\"Applying configuration updates:\");\n                \n                if (newConfig.getDataPoints() > 0) {\n                    config.dataPoints = newConfig.getDataPoints();\n                    System.out.println(\"  - Data points: \" + config.dataPoints);\n                }\n                if (newConfig.getWarmupDataPoints() > 0) {\n                    config.warmupDataPoints = newConfig.getWarmupDataPoints();\n                    System.out.println(\"  - Warmup points: \" + config.warmupDataPoints);\n                }\n                if (newConfig.getBuyPeriodMinutes() > 0) {\n                    config.buyPeriodMinutes = newConfig.getBuyPeriodMinutes();\n                    System.out.println(\"  - Buy period: \" + config.buyPeriodMinutes + \" min\");\n                }\n                if (newConfig.getBbLengthMinutes() > 0) {\n                    config.bbLengthMinutes = newConfig.getBbLengthMinutes();\n                    System.out.println(\"  - BB length: \" + config.bbLengthMinutes + \" min\");\n                }\n                if (newConfig.getRsiLengthMinutes() > 0) {\n                    config.rsiLengthMinutes = newConfig.getRsiLengthMinutes();\n                    System.out.println(\"  - RSI length: \" + config.rsiLengthMinutes + \" min\");\n                }\n                if (newConfig.getComboSignalThreshold() > 0) {\n                    config.comboSignalThreshold = newConfig.getComboSignalThreshold();\n                    System.out.println(\"  - Combo threshold: \" + config.comboSignalThreshold);\n                }\n                if (newConfig.getHighProbThreshold() > 0) {\n                    config.highProbThreshold = newConfig.getHighProbThreshold();\n                    System.out.println(\"  - High prob threshold: \" + config.highProbThreshold);\n                }\n                if (newConfig.getSpikeCooldownStddevThreshold() > 0) {\n                    config.spikeCooldownStddevThreshold = newConfig.getSpikeCooldownStddevThreshold();\n                    System.out.println(\"  - Spike cooldown: \" + config.spikeCooldownStddevThreshold);\n                }\n                \n                config.enableCooldowns = newConfig.getEnableCooldowns();\n                System.out.println(\"  - Cooldowns enabled: \" + config.enableCooldowns);\n                \n                // CRITICAL FIX: Read timeframe multiplier directly from config\n                // Frontend now sends base periods + multiplier explicitly\n                int timeframeMultiplier = newConfig.getTimeframeMultiplier();\n                if (timeframeMultiplier <= 0) {\n                    timeframeMultiplier = 1;  // Default to 1-minute if not set\n                }\n                \n                boolean multiplierChanged = (currentTimeframeMultiplier != timeframeMultiplier);\n                config.timeframeMultiplier = timeframeMultiplier;\n                currentTimeframeMultiplier = timeframeMultiplier;  // FIX: Store for newly added symbols\n                System.out.println(\"  - Timeframe multiplier: \" + timeframeMultiplier + \"x (from config)\");\n                System.out.println(\"  - RSI period received: \" + newConfig.getRsiLengthMinutes() + \" (BASE value, will be applied to \" + timeframeMultiplier + \"-minute candles)\");\n                \n                // CRITICAL FIX: When multiplier changes, clear stale buckets and update ALL symbols\n                if (multiplierChanged) {\n                    System.out.println(\"  Timeframe multiplier changed! Clearing stale aggregation buckets...\");\n                }\n                \n                for (String symbol : activeSymbols) {\n                    if (multiplierChanged) {\n                        candleAggregator.clearPendingCandles(symbol);  // Clear stale 1-min data\n                    }\n                    candleAggregator.setTimeframeMultiplier(symbol, timeframeMultiplier);\n                    System.out.println(\"  - Set \" + timeframeMultiplier + \"x multiplier for symbol: \" + symbol);\n                }\n                \n                // Convert TradingConfig to SpikeAnalysisConfig and propagate to analyzer\n                SpikeAnalysisConfig analyzerConfig = new SpikeAnalysisConfig();\n                \n                // Legacy parameters\n                analyzerConfig.statisticalThreshold = config.spikeCooldownStddevThreshold;\n                analyzerConfig.spikeCooldownStddevThreshold = config.spikeCooldownStddevThreshold;\n                analyzerConfig.qualityScoreThreshold = config.highProbThreshold;\n                analyzerConfig.rollingWindowHours = 24;\n                analyzerConfig.minSpikeSamples = 10;\n                analyzerConfig.evaluationPeriodMinutes = config.buyPeriodMinutes;\n                analyzerConfig.retrainFrequency = 100;\n                analyzerConfig.maxSpikeHistory = 1000;\n                \n                // CRITICAL FIX: Use BASE periods (not multiplied) since we're feeding aggregated candles\n                // Example: 10-min mode with RSI 14  aggregated 10-min candles + RSI(14) = 140 min window\n                // NOT: aggregated 10-min candles + RSI(140) = 1400 min window (WRONG!)\n                analyzerConfig.rsiLengthMinutes = newConfig.getRsiLengthMinutes();  // BASE VALUE\n                analyzerConfig.buyPeriodMinutes = newConfig.getBuyPeriodMinutes();  // BASE VALUE\n                analyzerConfig.mfiPeriodMinutes = newConfig.getMfiPeriodMinutes();  // BASE VALUE\n                analyzerConfig.bbLengthMinutes = newConfig.getBbLengthMinutes();  // BASE VALUE\n                analyzerConfig.vwapPeriodMinutes = newConfig.getVwapPeriodMinutes();  // BASE VALUE\n                \n                // Individual spike ROC Z-thresholds\n                analyzerConfig.spikePriceRocZThreshold = newConfig.getSpikePriceRocZThreshold();\n                analyzerConfig.spikeRsiRocZThreshold = newConfig.getSpikeRsiRocZThreshold();\n                analyzerConfig.spikeObvRocZThreshold = newConfig.getSpikeObvRocZThreshold();\n                analyzerConfig.spikeMfiRocZThreshold = newConfig.getSpikeMfiRocZThreshold();\n                analyzerConfig.spikePercentBRocZThreshold = newConfig.getSpikePercentBRocZThreshold();\n                analyzerConfig.spikeVwapRocZThreshold = newConfig.getSpikeVwapRocZThreshold();\n                analyzerConfig.spikeVolumeRocZThreshold = newConfig.getSpikeVolumeRocZThreshold();\n                \n                // Regular ROC thresholds\n                analyzerConfig.regularPriceRocThreshold = newConfig.getRegularPriceRocThreshold();\n                analyzerConfig.regularRsiRocThreshold = newConfig.getRegularRsiRocThreshold();\n                analyzerConfig.regularObvRocThreshold = newConfig.getRegularObvRocThreshold();\n                analyzerConfig.regularMfiRocThreshold = newConfig.getRegularMfiRocThreshold();\n                analyzerConfig.regularPercentBRocThreshold = newConfig.getRegularPercentBRocThreshold();\n                analyzerConfig.regularVwapRocThreshold = newConfig.getRegularVwapRocThreshold();\n                analyzerConfig.regularVolumeRocThreshold = newConfig.getRegularVolumeRocThreshold();\n                \n                // Regular ROC periods\n                analyzerConfig.regularPriceRocPeriod = newConfig.getRegularPriceRocPeriod();\n                analyzerConfig.regularRsiRocPeriod = newConfig.getRegularRsiRocPeriod();\n                analyzerConfig.regularObvRocPeriod = newConfig.getRegularObvRocPeriod();\n                analyzerConfig.regularMfiRocPeriod = newConfig.getRegularMfiRocPeriod();\n                analyzerConfig.regularPercentBRocPeriod = newConfig.getRegularPercentBRocPeriod();\n                analyzerConfig.regularVwapRocPeriod = newConfig.getRegularVwapRocPeriod();\n                analyzerConfig.regularVolumeRocPeriod = newConfig.getRegularVolumeRocPeriod();\n                \n                // Signal Rules\n                analyzerConfig.enablePriceRocSpike = newConfig.getEnablePriceRocSpike();\n                analyzerConfig.enableRsiRocSpike = newConfig.getEnableRsiRocSpike();\n                analyzerConfig.enableObvRocSpike = newConfig.getEnableObvRocSpike();\n                analyzerConfig.enableMfiRocSpike = newConfig.getEnableMfiRocSpike();\n                analyzerConfig.enablePercentBRocSpike = newConfig.getEnablePercentBRocSpike();\n                analyzerConfig.enableVwapRocSpike = newConfig.getEnableVwapRocSpike();\n                analyzerConfig.enableVolumeRocSpike = newConfig.getEnableVolumeRocSpike();\n                analyzerConfig.enableAdxIndicator = newConfig.getEnableAdxIndicator();\n                analyzerConfig.useMlSpikes = newConfig.getUseMlSpikes();\n                \n                // Penny Stock Indicators\n                analyzerConfig.enableMacdHistogramRoc = newConfig.getEnableMacdHistogramRoc();\n                analyzerConfig.enableStochasticIndicator = newConfig.getEnableStochasticIndicator();\n                analyzerConfig.enableRvolIndicator = newConfig.getEnableRvolIndicator();\n                analyzerConfig.enableEmaIndicator = newConfig.getEnableEmaIndicator();\n                analyzerConfig.enableEmaTrendFilter = newConfig.getEnableEmaTrendFilter();\n                \n                // MACD parameters\n                analyzerConfig.macdFastPeriod = newConfig.getMacdFastPeriod();\n                analyzerConfig.macdSlowPeriod = newConfig.getMacdSlowPeriod();\n                analyzerConfig.macdSignalPeriod = newConfig.getMacdSignalPeriod();\n                analyzerConfig.macdHistogramRocThreshold = newConfig.getMacdHistogramRocThreshold();\n                \n                // Stochastic parameters\n                analyzerConfig.stochasticPeriod = newConfig.getStochasticPeriod();\n                analyzerConfig.stochasticKSmooth = newConfig.getStochasticKSmooth();\n                analyzerConfig.stochasticDSmooth = newConfig.getStochasticDSmooth();\n                analyzerConfig.stochasticOversoldThreshold = newConfig.getStochasticOversoldThreshold();\n                analyzerConfig.stochasticOverboughtThreshold = newConfig.getStochasticOverboughtThreshold();\n                \n                // RVOL parameters\n                analyzerConfig.rvolPeriod = newConfig.getRvolPeriod();\n                analyzerConfig.rvolThreshold = newConfig.getRvolThreshold();\n                \n                // EMA parameters\n                analyzerConfig.ema9Period = newConfig.getEma9Period();\n                analyzerConfig.ema20Period = newConfig.getEma20Period();\n                analyzerConfig.ema50Period = newConfig.getEma50Period();\n                \n                // Volume spike parameters\n                analyzerConfig.volumeSpikeThreshold = newConfig.getVolumeSpikeThreshold();\n                \n                // Trading parameters\n                analyzerConfig.comboSignalThreshold = newConfig.getComboSignalThreshold();\n                analyzerConfig.highProbThreshold = newConfig.getHighProbThreshold();\n                analyzerConfig.stopLossPct = newConfig.getStopLossPct();\n                analyzerConfig.enableCooldowns = newConfig.getEnableCooldowns();\n                \n                // Warmup data points (user-configured readiness threshold)\n                analyzerConfig.warmupDataPoints = newConfig.getWarmupDataPoints();\n                \n                // Propagate config updates to analyzer\n                analyzer.updateConfig(analyzerConfig);\n                System.out.println(\"Analyzer config updated with ALL parameters from UI\");\n                \n                configValidator.saveToJson(\"trading_settings.json\");\n                System.out.println(\"Configuration saved to trading_settings.json\");\n                \n                response.setSuccess(true);\n                response.setMessage(\"Configuration updated and applied successfully\");\n                response.setCurrentConfig(convertTradingConfig(config));\n                \n            } catch (Exception e) {\n                response.setSuccess(false);\n                response.setMessage(\"Failed to update configuration: \" + e.getMessage());\n                System.err.println(\"Config update error: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            \n            responseObserver.onNext(response.build());\n            responseObserver.onCompleted();\n        }\n    }\n    \n    @Override\n    public void getConfig(ConfigRequest request,\n                         StreamObserver<ConfigProto.ConfigResponse> responseObserver) {\n        synchronized (stateLock) {\n            ConfigProto.ConfigResponse.Builder response = ConfigProto.ConfigResponse.newBuilder();\n            response.setSuccess(true);\n            response.setMessage(\"Current configuration\");\n            \n            TradingConfig config = configValidator.getConfig();\n            response.setCurrentConfig(convertTradingConfig(config));\n            \n            responseObserver.onNext(response.build());\n            responseObserver.onCompleted();\n        }\n    }\n    \n    @Override\n    public void startTrading(StartTradingRequest request,\n                            StreamObserver<TradingControlResponse> responseObserver) {\n        System.out.println(\"StartTrading request received with \" + request.getSymbolsCount() + \" symbols\");\n        \n        synchronized (stateLock) {\n            TradingControlResponse.Builder response = TradingControlResponse.newBuilder();\n            \n            if (isTrading.get()) {\n                response.setSuccess(false);\n                response.setMessage(\"Trading is already active\");\n                responseObserver.onNext(response.build());\n                responseObserver.onCompleted();\n                return;\n            }\n            \n            TradingConfig config = configValidator.getConfig();\n            \n            // Warmup analyzer with configured amount of historical data\n            int warmupCandles = config.warmupDataPoints;\n            System.out.println(\"WARMUP: Preloading \" + warmupCandles + \" candles per symbol\");\n            \n            for (String symbol : request.getSymbolsList()) {\n                activeSymbols.add(symbol);\n                candleAggregator.setTimeframeMultiplier(symbol, config.timeframeMultiplier);\n                \n                try {\n                    int rawCandlesNeeded = warmupCandles * config.timeframeMultiplier;\n                    List<Candle> historicalCandles = questradeClient.getHistoricalData(symbol, 1, rawCandlesNeeded);\n                    \n                    if (!historicalCandles.isEmpty()) {\n                        for (Candle candle : historicalCandles) {\n                            lastCandleTimestamps.put(symbol, candle.timestamp);\n                            Candle aggregatedCandle = candleAggregator.addCandleAndGetAggregated(symbol, candle);\n                            if (aggregatedCandle != null) {\n                                analyzer.addCandle(symbol, aggregatedCandle);\n                            }\n                        }\n                        System.out.println(\"WARMUP: \" + symbol + \" - Loaded \" + historicalCandles.size() + \" historical candles\");\n                    }\n                } catch (Exception e) {\n                    System.err.println(\"WARMUP: Failed to load historical data for \" + symbol + \": \" + e.getMessage());\n                }\n            }\n            \n            isTrading.set(true);\n            \n            // Start sell signal monitoring thread\n            startSellSignalMonitoring();\n            \n            response.setSuccess(true);\n            response.setMessage(\"Trading started successfully with historical warmup\");\n            \n            System.out.println(\"Trading started for \" + activeSymbols.size() + \" symbols\");\n            \n            responseObserver.onNext(response.build());\n            responseObserver.onCompleted();\n        }\n    }\n    \n    @Override\n    public void stopTrading(StopTradingRequest request,\n                           StreamObserver<TradingControlResponse> responseObserver) {\n        System.out.println(\"StopTrading request received\");\n        \n        synchronized (stateLock) {\n            TradingControlResponse.Builder response = TradingControlResponse.newBuilder();\n            \n            if (!isTrading.get()) {\n                response.setSuccess(false);\n                response.setMessage(\"Trading is not active\");\n                responseObserver.onNext(response.build());\n                responseObserver.onCompleted();\n                return;\n            }\n            \n            isTrading.set(false);\n            \n            // Stop sell signal monitoring thread\n            if (sellSignalMonitor != null && sellSignalMonitor.isAlive()) {\n                sellSignalMonitor.interrupt();\n            }\n            \n            response.setSuccess(true);\n            response.setMessage(\"Trading stopped successfully\");\n            \n            System.out.println(\"Trading stopped\");\n            \n            responseObserver.onNext(response.build());\n            responseObserver.onCompleted();\n        }\n    }\n    \n    private void startSellSignalMonitoring() {\n        sellSignalMonitor = new Thread(() -> {\n            System.out.println(\"RISK MANAGEMENT: Stop-loss monitoring thread started\");\n            \n            while (!shutdown.get() && isTrading.get()) {\n                try {\n                    TradingConfig config = configValidator.getConfig();\n                    List<Trade> openTrades = tradeTracker.getOpenTrades();\n                    \n                    for (Trade trade : openTrades) {\n                        try {\n                            // Get current quote for the symbol\n                            Quote quote = questradeClient.getQuote(trade.symbol);\n                            double currentPrice = quote.bid;  // Use BID price for realistic exit (sell at bid)\n                            \n                            // Calculate profit/loss percentage\n                            double profitPct = ((currentPrice - trade.entryPrice) / trade.entryPrice) * 100.0;\n                            double profitLoss = (currentPrice - trade.entryPrice) * trade.shares;\n                            \n                            // Track highest profit for trailing stop\n                            String tradeKey = trade.symbol + \"_\" + trade.entryTime.toEpochMilli();\n                            double highestProfit = highestProfitBySymbol.getOrDefault(tradeKey, profitPct);\n                            if (profitPct > highestProfit) {\n                                highestProfit = profitPct;\n                                highestProfitBySymbol.put(tradeKey, highestProfit);\n                            }\n                            \n                            // Check if initial profit floor has been hit\n                            boolean profitFloorHit = profitFloorHitBySymbol.getOrDefault(tradeKey, false);\n                            if (!profitFloorHit && profitPct >= config.initialProfitFloorPct * 100.0) {\n                                profitFloorHit = true;\n                                profitFloorHitBySymbol.put(tradeKey, true);\n                                System.out.println(String.format(\"PROFIT FLOOR HIT: %s reached %.2f%% profit (floor: %.2f%%)\", \n                                    trade.symbol, profitPct, config.initialProfitFloorPct * 100.0));\n                            }\n                            \n                            String exitReason = null;\n                            \n                            // 1. STOP LOSS CHECK (highest priority - prevent losses)\n                            if (profitPct <= -config.stopLossPct * 100.0) {\n                                exitReason = String.format(\"Stop Loss Hit (%.2f%% loss)\", profitPct);\n                            }\n                            // 2. TARGET GAIN CHECK\n                            else if (profitPct >= config.targetGainPercent) {\n                                exitReason = String.format(\"Target Gain Reached (%.2f%% profit)\", profitPct);\n                            }\n                            // 3. TRAILING STOP CHECK (only if profit floor was hit)\n                            else if (profitFloorHit) {\n                                double trailingStopPct = config.subsequentProfitFloorPct * 100.0;\n                                double pullbackFromPeak = highestProfit - profitPct;\n                                \n                                if (pullbackFromPeak >= trailingStopPct) {\n                                    exitReason = String.format(\"Trailing Stop Hit (%.2f%% pullback from %.2f%% peak)\", \n                                        pullbackFromPeak, highestProfit);\n                                }\n                            }\n                            // 4. SELL WARNING CHECK (lowest priority)\n                            else {\n                                SellWarning sellWarning = analyzer.analyzeSellWarning(trade.symbol);\n                                if (sellWarning != null && sellWarning.warningProbability >= config.highProbThreshold) {\n                                    exitReason = String.format(\"Sell Signal (%.0f%% probability: %s)\", \n                                        sellWarning.warningProbability * 100, sellWarning.reason);\n                                }\n                            }\n                            \n                            // Execute exit if any condition triggered\n                            if (exitReason != null) {\n                                tradeTracker.closeTrade(trade.symbol, currentPrice);\n                                activePositions.decrementAndGet();\n                                \n                                // Clean up tracking maps\n                                highestProfitBySymbol.remove(tradeKey);\n                                profitFloorHitBySymbol.remove(tradeKey);\n                                \n                                System.out.println(String.format(\"TRADE CLOSED: %s @ $%.2f | Entry: $%.2f | P/L: $%.2f (%.2f%%) | Reason: %s\",\n                                    trade.symbol, currentPrice, trade.entryPrice, profitLoss, profitPct, exitReason));\n                                \n                                // Send notification\n                                if (notificationService != null) {\n                                    try {\n                                        notificationService.showSellSignal(trade.symbol, currentPrice, profitLoss, exitReason);\n                                    } catch (Exception notifError) {\n                                        System.err.println(\"Failed to send exit notification: \" + notifError.getMessage());\n                                    }\n                                }\n                            }\n                            \n                        } catch (Exception e) {\n                            System.err.println(\"Error monitoring trade for \" + trade.symbol + \": \" + e.getMessage());\n                        }\n                    }\n                    \n                    // Check every 5 seconds for responsive risk management\n                    Thread.sleep(5000);\n                    \n                } catch (InterruptedException e) {\n                    System.out.println(\"RISK MANAGEMENT: Stop-loss monitoring thread interrupted\");\n                    break;\n                } catch (Exception e) {\n                    System.err.println(\"RISK MANAGEMENT ERROR: \" + e.getMessage());\n                    e.printStackTrace();\n                }\n            }\n            \n            System.out.println(\"RISK MANAGEMENT: Stop-loss monitoring thread stopped\");\n        });\n        \n        sellSignalMonitor.start();\n    }\n    \n    @Override\n    public void getOpenTrades(GetOpenTradesRequest request,\n                             StreamObserver<GetOpenTradesResponse> responseObserver) {\n        GetOpenTradesResponse.Builder response = GetOpenTradesResponse.newBuilder();\n        \n        try {\n            List<Trade> openTrades = tradeTracker.getOpenTrades();\n            \n            for (Trade trade : openTrades) {\n                response.addTrades(convertTrade(trade));\n            }\n            \n            System.out.println(\"Returned \" + openTrades.size() + \" open trades\");\n            \n        } catch (Exception e) {\n            System.err.println(\"Error getting open trades: \" + e.getMessage());\n        }\n        \n        responseObserver.onNext(response.build());\n        responseObserver.onCompleted();\n    }\n    \n    @Override\n    public void getClosedTrades(GetClosedTradesRequest request,\n                               StreamObserver<GetClosedTradesResponse> responseObserver) {\n        GetClosedTradesResponse.Builder response = GetClosedTradesResponse.newBuilder();\n        \n        try {\n            List<Trade> closedTrades = tradeTracker.getClosedTrades();\n            double totalProfitLoss = tradeTracker.getTotalProfitLoss();\n            \n            int winningTrades = 0;\n            for (Trade trade : closedTrades) {\n                response.addTrades(convertTrade(trade));\n                if (trade.profitLoss > 0) {\n                    winningTrades++;\n                }\n            }\n            \n            response.setTotalProfitLoss(totalProfitLoss);\n            response.setTotalTrades(closedTrades.size());\n            response.setWinningTrades(winningTrades);\n            \n            if (closedTrades.size() > 0) {\n                double winRate = (double) winningTrades / closedTrades.size() * 100.0;\n                response.setWinRate(winRate);\n            } else {\n                response.setWinRate(0.0);\n            }\n            \n            System.out.println(\"Returned \" + closedTrades.size() + \" closed trades\");\n            \n        } catch (Exception e) {\n            System.err.println(\"Error getting closed trades: \" + e.getMessage());\n        }\n        \n        responseObserver.onNext(response.build());\n        responseObserver.onCompleted();\n    }\n    \n    public void shutdown() {\n        shutdown.set(true);\n        isTrading.set(false);\n        \n        if (sellSignalMonitor != null && sellSignalMonitor.isAlive()) {\n            sellSignalMonitor.interrupt();\n        }\n    }\n    \n    private MarketDataProto.ConnectionStatus convertConnectionStatus(ConnectionStatus src) {\n        MarketDataProto.ConnectionStatus.Builder dst = \n            MarketDataProto.ConnectionStatus.newBuilder();\n        \n        switch (src.state) {\n            case CONNECTED:\n                dst.setState(MarketDataProto.ConnectionStatus.State.CONNECTED);\n                break;\n            case DISCONNECTED:\n                dst.setState(MarketDataProto.ConnectionStatus.State.DISCONNECTED);\n                break;\n            case DEGRADED:\n                dst.setState(MarketDataProto.ConnectionStatus.State.DEGRADED);\n                break;\n            case FAILED:\n                dst.setState(MarketDataProto.ConnectionStatus.State.FAILED);\n                break;\n        }\n        \n        dst.setUsingFallback(src.usingFallback);\n        if (src.fallbackReason != null) {\n            dst.setFallbackReason(src.fallbackReason);\n        }\n        dst.setConsecutiveFailures(src.consecutiveFailures);\n        \n        return dst.build();\n    }\n    \n    private SpikeSignalsProto.Indicators convertIndicators(IndicatorsData src) {\n        return SpikeSignalsProto.Indicators.newBuilder()\n            .setRsi(src.rsi)\n            .setObv(src.obv)\n            .setMfi(src.mfi)\n            .setVwap(src.vwap)\n            .setBollingerUpper(src.bollingerUpper)\n            .setBollingerLower(src.bollingerLower)\n            .setBollingerPosition(src.bollingerPosition)\n            .setPercentB(src.percentB)\n            .setPriceRoc(src.priceRoc)\n            .setRsiRoc(src.rsiRoc)\n            .setObvRoc(src.obvRoc)\n            .setMfiRoc(src.mfiRoc)\n            .setBollingerPosRoc(src.bollingerPosRoc)\n            .setPercentBRoc(src.percentBRoc)\n            .setVwapRoc(src.vwapRoc)\n            .setVolumeRoc(src.volumeRoc)\n            .setMacdLine(src.macdLine)\n            .setMacdSignal(src.macdSignal)\n            .setMacdHistogram(src.macdHistogram)\n            .setEma9(src.ema9)\n            .setEma20(src.ema20)\n            .setEma50(src.ema50)\n            .setStochK(src.stochK)\n            .setStochD(src.stochD)\n            .setRvol(src.rvol)\n            .setVolumeSpike(src.volumeSpike)\n            .setVolumeRatio(src.volumeRatio)\n            .setAtr(src.atr)\n            .build();\n    }\n    \n    private MarketDataProto.IndicatorsData convertIndicatorsToMarketData(IndicatorsData src) {\n        return MarketDataProto.IndicatorsData.newBuilder()\n            .setRsi(src.rsi)\n            .setPriceRoc(src.priceRoc)\n            .setVolumeRoc(src.volumeRoc)\n            .setVolume(src.obv)\n            .setObv(src.obv)\n            .setMfi(src.mfi)\n            .setBollingerPosition(src.bollingerPosition)\n            .setPercentB(src.percentB)\n            .setVwap(src.vwap)\n            .setRsiRoc(src.rsiRoc)\n            .setObvRoc(src.obvRoc)\n            .setMfiRoc(src.mfiRoc)\n            .setBollingerPosRoc(src.bollingerPosRoc)\n            .setPercentBRoc(src.percentBRoc)\n            .setVwapRoc(src.vwapRoc)\n            .setMacdLine(src.macdLine)\n            .setMacdSignal(src.macdSignal)\n            .setMacdHistogram(src.macdHistogram)\n            .setEma9(src.ema9)\n            .setEma20(src.ema20)\n            .setEma50(src.ema50)\n            .setStochK(src.stochK)\n            .setStochD(src.stochD)\n            .setRvol(src.rvol)\n            .setVolumeSpike(src.volumeSpike)\n            .setVolumeRatio(src.volumeRatio)\n            .setAtr(src.atr)\n            .setBollingerUpper(src.bollingerUpper)\n            .setBollingerLower(src.bollingerLower)\n            .build();\n    }\n    \n    private SpikeSignalsProto.SpikeRecord convertSpikeRecord(SpikeRecord src) {\n        SpikeSignalsProto.SpikeRecord.Builder dst = \n            SpikeSignalsProto.SpikeRecord.newBuilder();\n        \n        dst.setTimestampMs(src.timestamp.toEpochMilli());\n        dst.setSymbol(src.symbol);\n        dst.setSpikeType(src.spikeType);\n        dst.setMagnitude(src.magnitude);\n        dst.setDuration(src.duration);\n        dst.setPriceAtSpike(src.priceAtSpike);\n        dst.setVolumeAtSpike(src.volumeAtSpike);\n        dst.setRsiAtSpike(src.rsiAtSpike);\n        dst.setBollingerPosition(src.bollingerPosition);\n        dst.setMarketVolatility(src.marketVolatility);\n        dst.setTimeOfDay(src.timeOfDay);\n        dst.setDayOfWeek(src.dayOfWeek);\n        \n        dst.setIndicators(convertIndicators(src.indicators));\n        \n        if (src.outcomeProfitable != null) {\n            dst.setOutcomeProfitable(src.outcomeProfitable);\n        }\n        if (src.outcomeScore != null) {\n            dst.setOutcomeScore(src.outcomeScore);\n        }\n        if (src.statisticalZScore != null) {\n            dst.setStatisticalZScore(src.statisticalZScore);\n        }\n        if (src.trendContext != null) {\n            dst.setTrendContext(src.trendContext);\n        }\n        if (src.spikeQualityScore != null) {\n            dst.setSpikeQualityScore(src.spikeQualityScore);\n        }\n        \n        dst.setIsRootSpike(src.isRootSpike);\n        dst.setRootSpikeScore(src.rootSpikeScore);\n        dst.setUsedForSignal(src.usedForSignal);\n        \n        return dst.build();\n    }\n    \n    private SpikeSignalsProto.BuySignal convertBuySignal(BuySignal src) {\n        SpikeSignalsProto.BuySignal.Builder dst = \n            SpikeSignalsProto.BuySignal.newBuilder();\n        \n        dst.setTimestampMs(src.timestamp.toEpochMilli());\n        dst.setSymbol(src.symbol);\n        dst.setPrice(src.price);\n        dst.setSignalProbability(src.signalProbability);\n        dst.setReason(src.reason);\n        \n        dst.setIndicators(convertIndicators(src.indicators));\n        \n        for (SpikeRecord spike : src.spikes) {\n            dst.addSpikes(convertSpikeRecord(spike));\n        }\n        \n        return dst.build();\n    }\n    \n    private MarketDataProto.Quote convertQuote(Quote src) {\n        return convertQuote(src, null);\n    }\n    \n    private MarketDataProto.Quote convertQuote(Quote src, IndicatorsData indicators) {\n        MarketDataProto.Quote.Builder builder = MarketDataProto.Quote.newBuilder()\n            .setSymbol(src.symbol)\n            .setPrice(src.price)\n            .setVolume(src.volume)\n            .setBid(src.bid)\n            .setAsk(src.ask)\n            .setTimestampMs(src.timestamp.toEpochMilli());\n        \n        if (indicators != null) {\n            builder.setRsi(indicators.rsi);\n            builder.setPriceRoc(indicators.priceRoc);\n            builder.setVolumeRoc(indicators.volumeRoc);\n            builder.setObv(indicators.obv);\n            builder.setMfi(indicators.mfi);\n            builder.setBollingerPosition(indicators.bollingerPosition);\n            builder.setPercentB(indicators.percentB);\n            builder.setVwap(indicators.vwap);\n            \n            // Set top-level fields for quick access\n            builder.setSignalProbability(indicators.probability);\n            builder.setAtr(indicators.atr);\n            \n            builder.setIndicators(convertIndicatorsToMarketData(indicators));\n        }\n        \n        return builder.build();\n    }\n    \n    private MarketDataProto.Candle convertCandle(Candle src) {\n        return MarketDataProto.Candle.newBuilder()\n            .setTimestampMs(src.timestamp.toEpochMilli())\n            .setOpen(src.open)\n            .setHigh(src.high)\n            .setLow(src.low)\n            .setClose(src.close)\n            .setVolume(src.volume)\n            .build();\n    }\n    \n    private ConfigProto.TradingConfig convertTradingConfig(TradingConfig src) {\n        return ConfigProto.TradingConfig.newBuilder()\n            .setDataPoints(src.dataPoints)\n            .setWarmupDataPoints(src.warmupDataPoints)\n            .setBuyPeriodMinutes(src.buyPeriodMinutes)\n            .setBbLengthMinutes(src.bbLengthMinutes)\n            .setRsiLengthMinutes(src.rsiLengthMinutes)\n            .setComboSignalThreshold(src.comboSignalThreshold)\n            .setSpikeCooldownStddevThreshold(src.spikeCooldownStddevThreshold)\n            .setEnableCooldowns(src.enableCooldowns)\n            .build();\n    }\n    \n    private TradingServiceProto.Trade convertTrade(Trade src) {\n        TradingServiceProto.Trade.Builder dst = TradingServiceProto.Trade.newBuilder();\n        \n        dst.setSymbol(src.symbol);\n        dst.setEntryPrice(src.entryPrice);\n        dst.setShares(src.shares);\n        dst.setIsOpen(src.isOpen);\n        \n        if (src.entryTime != null) {\n            dst.setEntryTimeMs(src.entryTime.toEpochMilli());\n        }\n        \n        if (!src.isOpen) {\n            dst.setExitPrice(src.exitPrice);\n            dst.setProfitLoss(src.profitLoss);\n            dst.setProfitLossPct(src.profitLossPct);\n            \n            if (src.exitTime != null) {\n                dst.setExitTimeMs(src.exitTime.toEpochMilli());\n            }\n        }\n        \n        return dst.build();\n    }\n}\n","size_bytes":70519},"build/extracted-include-protos/main/google/protobuf/descriptor.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Author: kenton@google.com (Kenton Varda)\n//  Based on original Protocol Buffers design by\n//  Sanjay Ghemawat, Jeff Dean, and others.\n//\n// The messages in this file describe the definitions found in .proto files.\n// A valid .proto file can be translated directly to a FileDescriptorProto\n// without any other information (e.g. without reading its imports).\n\nsyntax = \"proto2\";\n\npackage google.protobuf;\n\noption go_package = \"google.golang.org/protobuf/types/descriptorpb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"DescriptorProtos\";\noption csharp_namespace = \"Google.Protobuf.Reflection\";\noption objc_class_prefix = \"GPB\";\noption cc_enable_arenas = true;\n\n// descriptor.proto must be optimized for speed because reflection-based\n// algorithms don't work during bootstrapping.\noption optimize_for = SPEED;\n\n// The protocol compiler can output a FileDescriptorSet containing the .proto\n// files it parses.\nmessage FileDescriptorSet {\n  repeated FileDescriptorProto file = 1;\n}\n\n// The full set of known editions.\nenum Edition {\n  // A placeholder for an unknown edition value.\n  EDITION_UNKNOWN = 0;\n\n  // Legacy syntax \"editions\".  These pre-date editions, but behave much like\n  // distinct editions.  These can't be used to specify the edition of proto\n  // files, but feature definitions must supply proto2/proto3 defaults for\n  // backwards compatibility.\n  EDITION_PROTO2 = 998;\n  EDITION_PROTO3 = 999;\n\n  // Editions that have been released.  The specific values are arbitrary and\n  // should not be depended on, but they will always be time-ordered for easy\n  // comparison.\n  EDITION_2023 = 1000;\n\n  // Placeholder editions for testing feature resolution.  These should not be\n  // used or relyed on outside of tests.\n  EDITION_1_TEST_ONLY = 1;\n  EDITION_2_TEST_ONLY = 2;\n  EDITION_99997_TEST_ONLY = 99997;\n  EDITION_99998_TEST_ONLY = 99998;\n  EDITION_99999_TEST_ONLY = 99999;\n}\n\n// Describes a complete .proto file.\nmessage FileDescriptorProto {\n  optional string name = 1;     // file name, relative to root of source tree\n  optional string package = 2;  // e.g. \"foo\", \"foo.bar\", etc.\n\n  // Names of files imported by this file.\n  repeated string dependency = 3;\n  // Indexes of the public imported files in the dependency list above.\n  repeated int32 public_dependency = 10;\n  // Indexes of the weak imported files in the dependency list.\n  // For Google-internal migration only. Do not use.\n  repeated int32 weak_dependency = 11;\n\n  // All top-level definitions in this file.\n  repeated DescriptorProto message_type = 4;\n  repeated EnumDescriptorProto enum_type = 5;\n  repeated ServiceDescriptorProto service = 6;\n  repeated FieldDescriptorProto extension = 7;\n\n  optional FileOptions options = 8;\n\n  // This field contains optional information about the original source code.\n  // You may safely remove this entire field without harming runtime\n  // functionality of the descriptors -- the information is needed only by\n  // development tools.\n  optional SourceCodeInfo source_code_info = 9;\n\n  // The syntax of the proto file.\n  // The supported values are \"proto2\", \"proto3\", and \"editions\".\n  //\n  // If `edition` is present, this value must be \"editions\".\n  optional string syntax = 12;\n\n  // The edition of the proto file.\n  optional Edition edition = 14;\n}\n\n// Describes a message type.\nmessage DescriptorProto {\n  optional string name = 1;\n\n  repeated FieldDescriptorProto field = 2;\n  repeated FieldDescriptorProto extension = 6;\n\n  repeated DescriptorProto nested_type = 3;\n  repeated EnumDescriptorProto enum_type = 4;\n\n  message ExtensionRange {\n    optional int32 start = 1;  // Inclusive.\n    optional int32 end = 2;    // Exclusive.\n\n    optional ExtensionRangeOptions options = 3;\n  }\n  repeated ExtensionRange extension_range = 5;\n\n  repeated OneofDescriptorProto oneof_decl = 8;\n\n  optional MessageOptions options = 7;\n\n  // Range of reserved tag numbers. Reserved tag numbers may not be used by\n  // fields or extension ranges in the same message. Reserved ranges may\n  // not overlap.\n  message ReservedRange {\n    optional int32 start = 1;  // Inclusive.\n    optional int32 end = 2;    // Exclusive.\n  }\n  repeated ReservedRange reserved_range = 9;\n  // Reserved field names, which may not be used by fields in the same message.\n  // A given name may only be reserved once.\n  repeated string reserved_name = 10;\n}\n\nmessage ExtensionRangeOptions {\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  message Declaration {\n    // The extension number declared within the extension range.\n    optional int32 number = 1;\n\n    // The fully-qualified name of the extension field. There must be a leading\n    // dot in front of the full name.\n    optional string full_name = 2;\n\n    // The fully-qualified type name of the extension field. Unlike\n    // Metadata.type, Declaration.type must have a leading dot for messages\n    // and enums.\n    optional string type = 3;\n\n    // If true, indicates that the number is reserved in the extension range,\n    // and any extension field with the number will fail to compile. Set this\n    // when a declared extension field is deleted.\n    optional bool reserved = 5;\n\n    // If true, indicates that the extension must be defined as repeated.\n    // Otherwise the extension must be defined as optional.\n    optional bool repeated = 6;\n\n    reserved 4;  // removed is_repeated\n  }\n\n  // For external users: DO NOT USE. We are in the process of open sourcing\n  // extension declaration and executing internal cleanups before it can be\n  // used externally.\n  repeated Declaration declaration = 2 [retention = RETENTION_SOURCE];\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 50;\n\n  // The verification state of the extension range.\n  enum VerificationState {\n    // All the extensions of the range must be declared.\n    DECLARATION = 0;\n    UNVERIFIED = 1;\n  }\n\n  // The verification state of the range.\n  // TODO: flip the default to DECLARATION once all empty ranges\n  // are marked as UNVERIFIED.\n  optional VerificationState verification = 3 [default = UNVERIFIED];\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\n// Describes a field within a message.\nmessage FieldDescriptorProto {\n  enum Type {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    TYPE_DOUBLE = 1;\n    TYPE_FLOAT = 2;\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    TYPE_INT64 = 3;\n    TYPE_UINT64 = 4;\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    TYPE_INT32 = 5;\n    TYPE_FIXED64 = 6;\n    TYPE_FIXED32 = 7;\n    TYPE_BOOL = 8;\n    TYPE_STRING = 9;\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported after google.protobuf. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.  In Editions, the group wire format\n    // can be enabled via the `message_encoding` feature.\n    TYPE_GROUP = 10;\n    TYPE_MESSAGE = 11;  // Length-delimited aggregate.\n\n    // New in version 2.\n    TYPE_BYTES = 12;\n    TYPE_UINT32 = 13;\n    TYPE_ENUM = 14;\n    TYPE_SFIXED32 = 15;\n    TYPE_SFIXED64 = 16;\n    TYPE_SINT32 = 17;  // Uses ZigZag encoding.\n    TYPE_SINT64 = 18;  // Uses ZigZag encoding.\n  }\n\n  enum Label {\n    // 0 is reserved for errors\n    LABEL_OPTIONAL = 1;\n    LABEL_REPEATED = 3;\n    // The required label is only allowed in google.protobuf.  In proto3 and Editions\n    // it's explicitly prohibited.  In Editions, the `field_presence` feature\n    // can be used to get this behavior.\n    LABEL_REQUIRED = 2;\n  }\n\n  optional string name = 1;\n  optional int32 number = 3;\n  optional Label label = 4;\n\n  // If type_name is set, this need not be set.  If both this and type_name\n  // are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.\n  optional Type type = 5;\n\n  // For message and enum types, this is the name of the type.  If the name\n  // starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping\n  // rules are used to find the type (i.e. first the nested types within this\n  // message are searched, then within the parent, on up to the root\n  // namespace).\n  optional string type_name = 6;\n\n  // For extensions, this is the name of the type being extended.  It is\n  // resolved in the same manner as type_name.\n  optional string extendee = 2;\n\n  // For numeric types, contains the original text representation of the value.\n  // For booleans, \"true\" or \"false\".\n  // For strings, contains the default text contents (not escaped in any way).\n  // For bytes, contains the C escaped value.  All bytes >= 128 are escaped.\n  optional string default_value = 7;\n\n  // If set, gives the index of a oneof in the containing type's oneof_decl\n  // list.  This field is a member of that oneof.\n  optional int32 oneof_index = 9;\n\n  // JSON name of this field. The value is set by protocol compiler. If the\n  // user has set a \"json_name\" option on this field, that option's value\n  // will be used. Otherwise, it's deduced from the field's name by converting\n  // it to camelCase.\n  optional string json_name = 10;\n\n  optional FieldOptions options = 8;\n\n  // If true, this is a proto3 \"optional\". When a proto3 field is optional, it\n  // tracks presence regardless of field type.\n  //\n  // When proto3_optional is true, this field must be belong to a oneof to\n  // signal to old proto3 clients that presence is tracked for this field. This\n  // oneof is known as a \"synthetic\" oneof, and this field must be its sole\n  // member (each proto3 optional field gets its own synthetic oneof). Synthetic\n  // oneofs exist in the descriptor only, and do not generate any API. Synthetic\n  // oneofs must be ordered after all \"real\" oneofs.\n  //\n  // For message fields, proto3_optional doesn't create any semantic change,\n  // since non-repeated message fields always track presence. However it still\n  // indicates the semantic detail of whether the user wrote \"optional\" or not.\n  // This can be useful for round-tripping the .proto file. For consistency we\n  // give message fields a synthetic oneof also, even though it is not required\n  // to track presence. This is especially important because the parser can't\n  // tell if a field is a message or an enum, so it must always create a\n  // synthetic oneof.\n  //\n  // Proto2 optional fields do not set this flag, because they already indicate\n  // optional with `LABEL_OPTIONAL`.\n  optional bool proto3_optional = 17;\n}\n\n// Describes a oneof.\nmessage OneofDescriptorProto {\n  optional string name = 1;\n  optional OneofOptions options = 2;\n}\n\n// Describes an enum type.\nmessage EnumDescriptorProto {\n  optional string name = 1;\n\n  repeated EnumValueDescriptorProto value = 2;\n\n  optional EnumOptions options = 3;\n\n  // Range of reserved numeric values. Reserved values may not be used by\n  // entries in the same enum. Reserved ranges may not overlap.\n  //\n  // Note that this is distinct from DescriptorProto.ReservedRange in that it\n  // is inclusive such that it can appropriately represent the entire int32\n  // domain.\n  message EnumReservedRange {\n    optional int32 start = 1;  // Inclusive.\n    optional int32 end = 2;    // Inclusive.\n  }\n\n  // Range of reserved numeric values. Reserved numeric values may not be used\n  // by enum values in the same enum declaration. Reserved ranges may not\n  // overlap.\n  repeated EnumReservedRange reserved_range = 4;\n\n  // Reserved enum value names, which may not be reused. A given name may only\n  // be reserved once.\n  repeated string reserved_name = 5;\n}\n\n// Describes a value within an enum.\nmessage EnumValueDescriptorProto {\n  optional string name = 1;\n  optional int32 number = 2;\n\n  optional EnumValueOptions options = 3;\n}\n\n// Describes a service.\nmessage ServiceDescriptorProto {\n  optional string name = 1;\n  repeated MethodDescriptorProto method = 2;\n\n  optional ServiceOptions options = 3;\n}\n\n// Describes a method of a service.\nmessage MethodDescriptorProto {\n  optional string name = 1;\n\n  // Input and output type names.  These are resolved in the same way as\n  // FieldDescriptorProto.type_name, but must refer to a message type.\n  optional string input_type = 2;\n  optional string output_type = 3;\n\n  optional MethodOptions options = 4;\n\n  // Identifies if client streams multiple client messages\n  optional bool client_streaming = 5 [default = false];\n  // Identifies if server streams multiple server messages\n  optional bool server_streaming = 6 [default = false];\n}\n\n// ===================================================================\n// Options\n\n// Each of the definitions above may have \"options\" attached.  These are\n// just annotations which may cause code to be generated slightly differently\n// or may contain hints for code that manipulates protocol messages.\n//\n// Clients may define custom options as extensions of the *Options messages.\n// These extensions may not yet be known at parsing time, so the parser cannot\n// store the values in them.  Instead it stores them in a field in the *Options\n// message called uninterpreted_option. This field must have the same name\n// across all *Options messages. We then use this field to populate the\n// extensions when we build a descriptor, at which point all protos have been\n// parsed and so all extensions are known.\n//\n// Extension numbers for custom options may be chosen as follows:\n// * For options which will only be used within a single application or\n//   organization, or for experimental options, use field numbers 50000\n//   through 99999.  It is up to you to ensure that you do not use the\n//   same number for multiple options.\n// * For options which will be published and used publicly by multiple\n//   independent entities, e-mail protobuf-global-extension-registry@google.com\n//   to reserve extension numbers. Simply provide your project name (e.g.\n//   Objective-C plugin) and your project website (if available) -- there's no\n//   need to explain how you intend to use them. Usually you only need one\n//   extension number. You can declare multiple options with only one extension\n//   number by putting them in a sub-message. See the Custom Options section of\n//   the docs for examples:\n//   https://developers.google.com/protocol-buffers/docs/proto#options\n//   If this turns out to be popular, a web service will be set up\n//   to automatically assign option numbers.\n\nmessage FileOptions {\n\n  // Sets the Java package where classes generated from this .proto will be\n  // placed.  By default, the proto package is used, but this is often\n  // inappropriate because proto packages do not normally start with backwards\n  // domain names.\n  optional string java_package = 1;\n\n  // Controls the name of the wrapper Java class generated for the .proto file.\n  // That class will always contain the .proto file's getDescriptor() method as\n  // well as any top-level extensions defined in the .proto file.\n  // If java_multiple_files is disabled, then all the other classes from the\n  // .proto file will be nested inside the single wrapper outer class.\n  optional string java_outer_classname = 8;\n\n  // If enabled, then the Java code generator will generate a separate .java\n  // file for each top-level message, enum, and service defined in the .proto\n  // file.  Thus, these types will *not* be nested inside the wrapper class\n  // named by java_outer_classname.  However, the wrapper class will still be\n  // generated to contain the file's getDescriptor() method as well as any\n  // top-level extensions defined in the file.\n  optional bool java_multiple_files = 10 [default = false];\n\n  // This option does nothing.\n  optional bool java_generate_equals_and_hash = 20 [deprecated=true];\n\n  // If set true, then the Java2 code generator will generate code that\n  // throws an exception whenever an attempt is made to assign a non-UTF-8\n  // byte sequence to a string field.\n  // Message reflection will do the same.\n  // However, an extension field still accepts non-UTF-8 byte sequences.\n  // This option has no effect on when used with the lite runtime.\n  optional bool java_string_check_utf8 = 27 [default = false];\n\n  // Generated classes can be optimized for speed or code size.\n  enum OptimizeMode {\n    SPEED = 1;         // Generate complete code for parsing, serialization,\n                       // etc.\n    CODE_SIZE = 2;     // Use ReflectionOps to implement these methods.\n    LITE_RUNTIME = 3;  // Generate code using MessageLite and the lite runtime.\n  }\n  optional OptimizeMode optimize_for = 9 [default = SPEED];\n\n  // Sets the Go package where structs generated from this .proto will be\n  // placed. If omitted, the Go package will be derived from the following:\n  //   - The basename of the package import path, if provided.\n  //   - Otherwise, the package statement in the .proto file, if present.\n  //   - Otherwise, the basename of the .proto file, without extension.\n  optional string go_package = 11;\n\n  // Should generic services be generated in each language?  \"Generic\" services\n  // are not specific to any particular RPC system.  They are generated by the\n  // main code generators in each language (without additional plugins).\n  // Generic services were the only kind of service generation supported by\n  // early versions of google.protobuf.\n  //\n  // Generic services are now considered deprecated in favor of using plugins\n  // that generate code specific to your particular RPC system.  Therefore,\n  // these default to false.  Old code which depends on generic services should\n  // explicitly set them to true.\n  optional bool cc_generic_services = 16 [default = false];\n  optional bool java_generic_services = 17 [default = false];\n  optional bool py_generic_services = 18 [default = false];\n  optional bool php_generic_services = 42 [default = false];\n\n  // Is this file deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for everything in the file, or it will be completely ignored; in the very\n  // least, this is a formalization for deprecating files.\n  optional bool deprecated = 23 [default = false];\n\n  // Enables the use of arenas for the proto messages in this file. This applies\n  // only to generated classes for C++.\n  optional bool cc_enable_arenas = 31 [default = true];\n\n  // Sets the objective c class prefix which is prepended to all objective c\n  // generated classes from this .proto. There is no default.\n  optional string objc_class_prefix = 36;\n\n  // Namespace for generated classes; defaults to the package.\n  optional string csharp_namespace = 37;\n\n  // By default Swift generators will take the proto package and CamelCase it\n  // replacing '.' with underscore and use that to prefix the types/symbols\n  // defined. When this options is provided, they will use this value instead\n  // to prefix the types/symbols defined.\n  optional string swift_prefix = 39;\n\n  // Sets the php class prefix which is prepended to all php generated classes\n  // from this .proto. Default is empty.\n  optional string php_class_prefix = 40;\n\n  // Use this option to change the namespace of php generated classes. Default\n  // is empty. When this option is empty, the package name will be used for\n  // determining the namespace.\n  optional string php_namespace = 41;\n\n  // Use this option to change the namespace of php generated metadata classes.\n  // Default is empty. When this option is empty, the proto file name will be\n  // used for determining the namespace.\n  optional string php_metadata_namespace = 44;\n\n  // Use this option to change the package of ruby generated classes. Default\n  // is empty. When this option is not set, the package name will be used for\n  // determining the ruby package.\n  optional string ruby_package = 45;\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 50;\n\n  // The parser stores options it doesn't recognize here.\n  // See the documentation for the \"Options\" section above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message.\n  // See the documentation for the \"Options\" section above.\n  extensions 1000 to max;\n\n  reserved 38;\n}\n\nmessage MessageOptions {\n  // Set true to use the old proto1 MessageSet wire format for extensions.\n  // This is provided for backwards-compatibility with the MessageSet wire\n  // format.  You should not use this for any other reason:  It's less\n  // efficient, has fewer features, and is more complicated.\n  //\n  // The message must be defined exactly as follows:\n  //   message Foo {\n  //     option message_set_wire_format = true;\n  //     extensions 4 to max;\n  //   }\n  // Note that the message cannot have any defined fields; MessageSets only\n  // have extensions.\n  //\n  // All extensions of your type must be singular messages; e.g. they cannot\n  // be int32s, enums, or repeated messages.\n  //\n  // Because this is an option, the above two restrictions are not enforced by\n  // the protocol compiler.\n  optional bool message_set_wire_format = 1 [default = false];\n\n  // Disables the generation of the standard \"descriptor()\" accessor, which can\n  // conflict with a field of the same name.  This is meant to make migration\n  // from proto1 easier; new code should avoid fields named \"descriptor\".\n  optional bool no_standard_descriptor_accessor = 2 [default = false];\n\n  // Is this message deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for the message, or it will be completely ignored; in the very least,\n  // this is a formalization for deprecating messages.\n  optional bool deprecated = 3 [default = false];\n\n  reserved 4, 5, 6;\n\n  // NOTE: Do not set the option in .proto files. Always use the maps syntax\n  // instead. The option should only be implicitly set by the proto compiler\n  // parser.\n  //\n  // Whether the message is an automatically generated map entry type for the\n  // maps field.\n  //\n  // For maps fields:\n  //     map<KeyType, ValueType> map_field = 1;\n  // The parsed descriptor looks like:\n  //     message MapFieldEntry {\n  //         option map_entry = true;\n  //         optional KeyType key = 1;\n  //         optional ValueType value = 2;\n  //     }\n  //     repeated MapFieldEntry map_field = 1;\n  //\n  // Implementations may choose not to generate the map_entry=true message, but\n  // use a native map in the target language to hold the keys and values.\n  // The reflection APIs in such implementations still need to work as\n  // if the field is a repeated message field.\n  optional bool map_entry = 7;\n\n  reserved 8;  // javalite_serializable\n  reserved 9;  // javanano_as_lite\n\n  // Enable the legacy handling of JSON field name conflicts.  This lowercases\n  // and strips underscored from the fields before comparison in proto3 only.\n  // The new behavior takes `json_name` into account and applies to proto2 as\n  // well.\n  //\n  // This should only be used as a temporary measure against broken builds due\n  // to the change in behavior for JSON field name conflicts.\n  //\n  // TODO This is legacy behavior we plan to remove once downstream\n  // teams have had time to migrate.\n  optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 12;\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\nmessage FieldOptions {\n  // The ctype option instructs the C++ code generator to use a different\n  // representation of the field than it normally would.  See the specific\n  // options below.  This option is only implemented to support use of\n  // [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of\n  // type \"bytes\" in the open source release -- sorry, we'll try to include\n  // other types in a future version!\n  optional CType ctype = 1 [default = STRING];\n  enum CType {\n    // Default mode.\n    STRING = 0;\n\n    // The option [ctype=CORD] may be applied to a non-repeated field of type\n    // \"bytes\". It indicates that in C++, the data should be stored in a Cord\n    // instead of a string.  For very large strings, this may reduce memory\n    // fragmentation. It may also allow better performance when parsing from a\n    // Cord, or when parsing with aliasing enabled, as the parsed Cord may then\n    // alias the original buffer.\n    CORD = 1;\n\n    STRING_PIECE = 2;\n  }\n  // The packed option can be enabled for repeated primitive fields to enable\n  // a more efficient representation on the wire. Rather than repeatedly\n  // writing the tag and type for each element, the entire array is encoded as\n  // a single length-delimited blob. In proto3, only explicit setting it to\n  // false will avoid using packed encoding.  This option is prohibited in\n  // Editions, but the `repeated_field_encoding` feature can be used to control\n  // the behavior.\n  optional bool packed = 2;\n\n  // The jstype option determines the JavaScript type used for values of the\n  // field.  The option is permitted only for 64 bit integral and fixed types\n  // (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING\n  // is represented as JavaScript string, which avoids loss of precision that\n  // can happen when a large value is converted to a floating point JavaScript.\n  // Specifying JS_NUMBER for the jstype causes the generated JavaScript code to\n  // use the JavaScript \"number\" type.  The behavior of the default option\n  // JS_NORMAL is implementation dependent.\n  //\n  // This option is an enum to permit additional types to be added, e.g.\n  // goog.math.Integer.\n  optional JSType jstype = 6 [default = JS_NORMAL];\n  enum JSType {\n    // Use the default type.\n    JS_NORMAL = 0;\n\n    // Use JavaScript strings.\n    JS_STRING = 1;\n\n    // Use JavaScript numbers.\n    JS_NUMBER = 2;\n  }\n\n  // Should this field be parsed lazily?  Lazy applies only to message-type\n  // fields.  It means that when the outer message is initially parsed, the\n  // inner message's contents will not be parsed but instead stored in encoded\n  // form.  The inner message will actually be parsed when it is first accessed.\n  //\n  // This is only a hint.  Implementations are free to choose whether to use\n  // eager or lazy parsing regardless of the value of this option.  However,\n  // setting this option true suggests that the protocol author believes that\n  // using lazy parsing on this field is worth the additional bookkeeping\n  // overhead typically needed to implement it.\n  //\n  // This option does not affect the public interface of any generated code;\n  // all method signatures remain the same.  Furthermore, thread-safety of the\n  // interface is not affected by this option; const methods remain safe to\n  // call from multiple threads concurrently, while non-const methods continue\n  // to require exclusive access.\n  //\n  // Note that implementations may choose not to check required fields within\n  // a lazy sub-message.  That is, calling IsInitialized() on the outer message\n  // may return true even if the inner message has missing required fields.\n  // This is necessary because otherwise the inner message would have to be\n  // parsed in order to perform the check, defeating the purpose of lazy\n  // parsing.  An implementation which chooses not to check required fields\n  // must be consistent about it.  That is, for any particular sub-message, the\n  // implementation must either *always* check its required fields, or *never*\n  // check its required fields, regardless of whether or not the message has\n  // been parsed.\n  //\n  // As of May 2022, lazy verifies the contents of the byte stream during\n  // parsing.  An invalid byte stream will cause the overall parsing to fail.\n  optional bool lazy = 5 [default = false];\n\n  // unverified_lazy does no correctness checks on the byte stream. This should\n  // only be used where lazy with verification is prohibitive for performance\n  // reasons.\n  optional bool unverified_lazy = 15 [default = false];\n\n  // Is this field deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for accessors, or it will be completely ignored; in the very least, this\n  // is a formalization for deprecating fields.\n  optional bool deprecated = 3 [default = false];\n\n  // For Google-internal migration only. Do not use.\n  optional bool weak = 10 [default = false];\n\n  // Indicate that the field value should not be printed out when using debug\n  // formats, e.g. when the field contains sensitive credentials.\n  optional bool debug_redact = 16 [default = false];\n\n  // If set to RETENTION_SOURCE, the option will be omitted from the binary.\n  // Note: as of January 2023, support for this is in progress and does not yet\n  // have an effect (b/264593489).\n  enum OptionRetention {\n    RETENTION_UNKNOWN = 0;\n    RETENTION_RUNTIME = 1;\n    RETENTION_SOURCE = 2;\n  }\n\n  optional OptionRetention retention = 17;\n\n  // This indicates the types of entities that the field may apply to when used\n  // as an option. If it is unset, then the field may be freely used as an\n  // option on any kind of entity. Note: as of January 2023, support for this is\n  // in progress and does not yet have an effect (b/264593489).\n  enum OptionTargetType {\n    TARGET_TYPE_UNKNOWN = 0;\n    TARGET_TYPE_FILE = 1;\n    TARGET_TYPE_EXTENSION_RANGE = 2;\n    TARGET_TYPE_MESSAGE = 3;\n    TARGET_TYPE_FIELD = 4;\n    TARGET_TYPE_ONEOF = 5;\n    TARGET_TYPE_ENUM = 6;\n    TARGET_TYPE_ENUM_ENTRY = 7;\n    TARGET_TYPE_SERVICE = 8;\n    TARGET_TYPE_METHOD = 9;\n  }\n\n  repeated OptionTargetType targets = 19;\n\n  message EditionDefault {\n    optional Edition edition = 3;\n    optional string value = 2;  // Textproto value.\n  }\n  repeated EditionDefault edition_defaults = 20;\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 21;\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n\n  reserved 4;   // removed jtype\n  reserved 18;  // reserve target, target_obsolete_do_not_use\n}\n\nmessage OneofOptions {\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 1;\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\nmessage EnumOptions {\n\n  // Set this option to true to allow mapping different tag names to the same\n  // value.\n  optional bool allow_alias = 2;\n\n  // Is this enum deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for the enum, or it will be completely ignored; in the very least, this\n  // is a formalization for deprecating enums.\n  optional bool deprecated = 3 [default = false];\n\n  reserved 5;  // javanano_as_lite\n\n  // Enable the legacy handling of JSON field name conflicts.  This lowercases\n  // and strips underscored from the fields before comparison in proto3 only.\n  // The new behavior takes `json_name` into account and applies to proto2 as\n  // well.\n  // TODO Remove this legacy behavior once downstream teams have\n  // had time to migrate.\n  optional bool deprecated_legacy_json_field_conflicts = 6 [deprecated = true];\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 7;\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\nmessage EnumValueOptions {\n  // Is this enum value deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for the enum value, or it will be completely ignored; in the very least,\n  // this is a formalization for deprecating enum values.\n  optional bool deprecated = 1 [default = false];\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 2;\n\n  // Indicate that fields annotated with this enum value should not be printed\n  // out when using debug formats, e.g. when the field contains sensitive\n  // credentials.\n  optional bool debug_redact = 3 [default = false];\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\nmessage ServiceOptions {\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 34;\n\n  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC\n  //   framework.  We apologize for hoarding these numbers to ourselves, but\n  //   we were already using them long before we decided to release Protocol\n  //   Buffers.\n\n  // Is this service deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for the service, or it will be completely ignored; in the very least,\n  // this is a formalization for deprecating services.\n  optional bool deprecated = 33 [default = false];\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\nmessage MethodOptions {\n\n  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC\n  //   framework.  We apologize for hoarding these numbers to ourselves, but\n  //   we were already using them long before we decided to release Protocol\n  //   Buffers.\n\n  // Is this method deprecated?\n  // Depending on the target platform, this can emit Deprecated annotations\n  // for the method, or it will be completely ignored; in the very least,\n  // this is a formalization for deprecating methods.\n  optional bool deprecated = 33 [default = false];\n\n  // Is this method side-effect-free (or safe in HTTP parlance), or idempotent,\n  // or neither? HTTP based RPC implementation may choose GET verb for safe\n  // methods, and PUT verb for idempotent methods instead of the default POST.\n  enum IdempotencyLevel {\n    IDEMPOTENCY_UNKNOWN = 0;\n    NO_SIDE_EFFECTS = 1;  // implies idempotent\n    IDEMPOTENT = 2;       // idempotent, but may have side effects\n  }\n  optional IdempotencyLevel idempotency_level = 34\n      [default = IDEMPOTENCY_UNKNOWN];\n\n  // Any features defined in the specific edition.\n  optional FeatureSet features = 35;\n\n  // The parser stores options it doesn't recognize here. See above.\n  repeated UninterpretedOption uninterpreted_option = 999;\n\n  // Clients can define custom options in extensions of this message. See above.\n  extensions 1000 to max;\n}\n\n// A message representing a option the parser does not recognize. This only\n// appears in options protos created by the compiler::Parser class.\n// DescriptorPool resolves these when building Descriptor objects. Therefore,\n// options protos in descriptor objects (e.g. returned by Descriptor::options(),\n// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions\n// in them.\nmessage UninterpretedOption {\n  // The name of the uninterpreted option.  Each string represents a segment in\n  // a dot-separated name.  is_extension is true iff a segment represents an\n  // extension (denoted with parentheses in options specs in .proto files).\n  // E.g.,{ [\"foo\", false], [\"bar.baz\", true], [\"moo\", false] } represents\n  // \"foo.(bar.baz).moo\".\n  message NamePart {\n    required string name_part = 1;\n    required bool is_extension = 2;\n  }\n  repeated NamePart name = 2;\n\n  // The value of the uninterpreted option, in whatever type the tokenizer\n  // identified it as during parsing. Exactly one of these should be set.\n  optional string identifier_value = 3;\n  optional uint64 positive_int_value = 4;\n  optional int64 negative_int_value = 5;\n  optional double double_value = 6;\n  optional bytes string_value = 7;\n  optional string aggregate_value = 8;\n}\n\n// ===================================================================\n// Features\n\n// TODO Enums in C++ gencode (and potentially other languages) are\n// not well scoped.  This means that each of the feature enums below can clash\n// with each other.  The short names we've chosen maximize call-site\n// readability, but leave us very open to this scenario.  A future feature will\n// be designed and implemented to handle this, hopefully before we ever hit a\n// conflict here.\nmessage FeatureSet {\n  enum FieldPresence {\n    FIELD_PRESENCE_UNKNOWN = 0;\n    EXPLICIT = 1;\n    IMPLICIT = 2;\n    LEGACY_REQUIRED = 3;\n  }\n  optional FieldPresence field_presence = 1 [\n    retention = RETENTION_RUNTIME,\n    targets = TARGET_TYPE_FIELD,\n    targets = TARGET_TYPE_FILE,\n    edition_defaults = { edition: EDITION_PROTO2, value: \"EXPLICIT\" },\n    edition_defaults = { edition: EDITION_PROTO3, value: \"IMPLICIT\" },\n    edition_defaults = { edition: EDITION_2023, value: \"EXPLICIT\" }\n  ];\n\n  enum EnumType {\n    ENUM_TYPE_UNKNOWN = 0;\n    OPEN = 1;\n    CLOSED = 2;\n  }\n  optional EnumType enum_type = 2 [\n    retention = RETENTION_RUNTIME,\n    targets = TARGET_TYPE_ENUM,\n    targets = TARGET_TYPE_FILE,\n    edition_defaults = { edition: EDITION_PROTO2, value: \"CLOSED\" },\n    edition_defaults = { edition: EDITION_PROTO3, value: \"OPEN\" }\n  ];\n\n  enum RepeatedFieldEncoding {\n    REPEATED_FIELD_ENCODING_UNKNOWN = 0;\n    PACKED = 1;\n    EXPANDED = 2;\n  }\n  optional RepeatedFieldEncoding repeated_field_encoding = 3 [\n    retention = RETENTION_RUNTIME,\n    targets = TARGET_TYPE_FIELD,\n    targets = TARGET_TYPE_FILE,\n    edition_defaults = { edition: EDITION_PROTO2, value: \"EXPANDED\" },\n    edition_defaults = { edition: EDITION_PROTO3, value: \"PACKED\" }\n  ];\n\n  enum Utf8Validation {\n    UTF8_VALIDATION_UNKNOWN = 0;\n    NONE = 1;\n    VERIFY = 2;\n  }\n  optional Utf8Validation utf8_validation = 4 [\n    retention = RETENTION_RUNTIME,\n    targets = TARGET_TYPE_FIELD,\n    targets = TARGET_TYPE_FILE,\n    edition_defaults = { edition: EDITION_PROTO2, value: \"NONE\" },\n    edition_defaults = { edition: EDITION_PROTO3, value: \"VERIFY\" }\n  ];\n\n  enum MessageEncoding {\n    MESSAGE_ENCODING_UNKNOWN = 0;\n    LENGTH_PREFIXED = 1;\n    DELIMITED = 2;\n  }\n  optional MessageEncoding message_encoding = 5 [\n    retention = RETENTION_RUNTIME,\n    targets = TARGET_TYPE_FIELD,\n    targets = TARGET_TYPE_FILE,\n    edition_defaults = { edition: EDITION_PROTO2, value: \"LENGTH_PREFIXED\" }\n  ];\n\n  enum JsonFormat {\n    JSON_FORMAT_UNKNOWN = 0;\n    ALLOW = 1;\n    LEGACY_BEST_EFFORT = 2;\n  }\n  optional JsonFormat json_format = 6 [\n    retention = RETENTION_RUNTIME,\n    targets = TARGET_TYPE_MESSAGE,\n    targets = TARGET_TYPE_ENUM,\n    targets = TARGET_TYPE_FILE,\n    edition_defaults = { edition: EDITION_PROTO2, value: \"LEGACY_BEST_EFFORT\" },\n    edition_defaults = { edition: EDITION_PROTO3, value: \"ALLOW\" }\n  ];\n\n  reserved 999;\n\n  extensions 1000;  // for Protobuf C++\n  extensions 1001;  // for Protobuf Java\n\n  extensions 9995 to 9999;  // For internal testing\n}\n\n// A compiled specification for the defaults of a set of features.  These\n// messages are generated from FeatureSet extensions and can be used to seed\n// feature resolution. The resolution with this object becomes a simple search\n// for the closest matching edition, followed by proto merges.\nmessage FeatureSetDefaults {\n  // A map from every known edition with a unique set of defaults to its\n  // defaults. Not all editions may be contained here.  For a given edition,\n  // the defaults at the closest matching edition ordered at or before it should\n  // be used.  This field must be in strict ascending order by edition.\n  message FeatureSetEditionDefault {\n    optional Edition edition = 3;\n    optional FeatureSet features = 2;\n  }\n  repeated FeatureSetEditionDefault defaults = 1;\n\n  // The minimum supported edition (inclusive) when this was constructed.\n  // Editions before this will not have defaults.\n  optional Edition minimum_edition = 4;\n\n  // The maximum known edition (inclusive) when this was constructed. Editions\n  // after this will not have reliable defaults.\n  optional Edition maximum_edition = 5;\n}\n\n// ===================================================================\n// Optional source code info\n\n// Encapsulates information about the original source file from which a\n// FileDescriptorProto was generated.\nmessage SourceCodeInfo {\n  // A Location identifies a piece of source code in a .proto file which\n  // corresponds to a particular definition.  This information is intended\n  // to be useful to IDEs, code indexers, documentation generators, and similar\n  // tools.\n  //\n  // For example, say we have a file like:\n  //   message Foo {\n  //     optional string foo = 1;\n  //   }\n  // Let's look at just the field definition:\n  //   optional string foo = 1;\n  //   ^       ^^     ^^  ^  ^^^\n  //   a       bc     de  f  ghi\n  // We have the following locations:\n  //   span   path               represents\n  //   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.\n  //   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).\n  //   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).\n  //   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).\n  //   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).\n  //\n  // Notes:\n  // - A location may refer to a repeated field itself (i.e. not to any\n  //   particular index within it).  This is used whenever a set of elements are\n  //   logically enclosed in a single code segment.  For example, an entire\n  //   extend block (possibly containing multiple extension definitions) will\n  //   have an outer location whose path refers to the \"extensions\" repeated\n  //   field without an index.\n  // - Multiple locations may have the same path.  This happens when a single\n  //   logical declaration is spread out across multiple places.  The most\n  //   obvious example is the \"extend\" block again -- there may be multiple\n  //   extend blocks in the same scope, each of which will have the same path.\n  // - A location's span is not always a subset of its parent's span.  For\n  //   example, the \"extendee\" of an extension declaration appears at the\n  //   beginning of the \"extend\" block and is shared by all extensions within\n  //   the block.\n  // - Just because a location's span is a subset of some other location's span\n  //   does not mean that it is a descendant.  For example, a \"group\" defines\n  //   both a type and a field in a single declaration.  Thus, the locations\n  //   corresponding to the type and field and their components will overlap.\n  // - Code which tries to interpret locations should probably be designed to\n  //   ignore those that it doesn't understand, as more types of locations could\n  //   be recorded in the future.\n  repeated Location location = 1;\n  message Location {\n    // Identifies which part of the FileDescriptorProto was defined at this\n    // location.\n    //\n    // Each element is a field number or an index.  They form a path from\n    // the root FileDescriptorProto to the place where the definition occurs.\n    // For example, this path:\n    //   [ 4, 3, 2, 7, 1 ]\n    // refers to:\n    //   file.message_type(3)  // 4, 3\n    //       .field(7)         // 2, 7\n    //       .name()           // 1\n    // This is because FileDescriptorProto.message_type has field number 4:\n    //   repeated DescriptorProto message_type = 4;\n    // and DescriptorProto.field has field number 2:\n    //   repeated FieldDescriptorProto field = 2;\n    // and FieldDescriptorProto.name has field number 1:\n    //   optional string name = 1;\n    //\n    // Thus, the above path gives the location of a field name.  If we removed\n    // the last element:\n    //   [ 4, 3, 2, 7 ]\n    // this path refers to the whole field declaration (from the beginning\n    // of the label to the terminating semicolon).\n    repeated int32 path = 1 [packed = true];\n\n    // Always has exactly three or four elements: start line, start column,\n    // end line (optional, otherwise assumed same as start line), end column.\n    // These are packed into a single field for efficiency.  Note that line\n    // and column numbers are zero-based -- typically you will want to add\n    // 1 to each before displaying to a user.\n    repeated int32 span = 2 [packed = true];\n\n    // If this SourceCodeInfo represents a complete declaration, these are any\n    // comments appearing before and after the declaration which appear to be\n    // attached to the declaration.\n    //\n    // A series of line comments appearing on consecutive lines, with no other\n    // tokens appearing on those lines, will be treated as a single comment.\n    //\n    // leading_detached_comments will keep paragraphs of comments that appear\n    // before (but not connected to) the current element. Each paragraph,\n    // separated by empty lines, will be one comment element in the repeated\n    // field.\n    //\n    // Only the comment content is provided; comment markers (e.g. //) are\n    // stripped out.  For block comments, leading whitespace and an asterisk\n    // will be stripped from the beginning of each line other than the first.\n    // Newlines are included in the output.\n    //\n    // Examples:\n    //\n    //   optional int32 foo = 1;  // Comment attached to foo.\n    //   // Comment attached to bar.\n    //   optional int32 bar = 2;\n    //\n    //   optional string baz = 3;\n    //   // Comment attached to baz.\n    //   // Another line attached to baz.\n    //\n    //   // Comment attached to moo.\n    //   //\n    //   // Another line attached to moo.\n    //   optional double moo = 4;\n    //\n    //   // Detached comment for corge. This is not leading or trailing comments\n    //   // to moo or corge because there are blank lines separating it from\n    //   // both.\n    //\n    //   // Detached comment for corge paragraph 2.\n    //\n    //   optional string corge = 5;\n    //   /* Block comment attached\n    //    * to corge.  Leading asterisks\n    //    * will be removed. */\n    //   /* Block comment attached to\n    //    * grault. */\n    //   optional int32 grault = 6;\n    //\n    //   // ignored detached comments.\n    optional string leading_comments = 3;\n    optional string trailing_comments = 4;\n    repeated string leading_detached_comments = 6;\n  }\n}\n\n// Describes the relationship between generated code and its original source\n// file. A GeneratedCodeInfo message is associated with only one generated\n// source file, but may contain references to different source .proto files.\nmessage GeneratedCodeInfo {\n  // An Annotation connects some span of text in generated code to an element\n  // of its generating .proto file.\n  repeated Annotation annotation = 1;\n  message Annotation {\n    // Identifies the element in the original source .proto file. This field\n    // is formatted the same as SourceCodeInfo.Location.path.\n    repeated int32 path = 1 [packed = true];\n\n    // Identifies the filesystem path to the original source .proto.\n    optional string source_file = 2;\n\n    // Identifies the starting offset in bytes in the generated code\n    // that relates to the identified object.\n    optional int32 begin = 3;\n\n    // Identifies the ending offset in bytes in the generated code that\n    // relates to the identified object. The end offset should be one past\n    // the last relevant byte (so the length of the text = end - begin).\n    optional int32 end = 4;\n\n    // Represents the identified object's effect on the element in the original\n    // .proto file.\n    enum Semantic {\n      // There is no effect or the effect is indescribable.\n      NONE = 0;\n      // The element is set or otherwise mutated.\n      SET = 1;\n      // An alias to the element is returned.\n      ALIAS = 2;\n    }\n    optional Semantic semantic = 5;\n  }\n}\n","size_bytes":49985},"build/extracted-include-protos/main/google/api/client.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/api/launch_stage.proto\";\nimport \"google/protobuf/descriptor.proto\";\nimport \"google/protobuf/duration.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/annotations;annotations\";\noption java_multiple_files = true;\noption java_outer_classname = \"ClientProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\nextend google.protobuf.MethodOptions {\n  // A definition of a client library method signature.\n  //\n  // In client libraries, each proto RPC corresponds to one or more methods\n  // which the end user is able to call, and calls the underlying RPC.\n  // Normally, this method receives a single argument (a struct or instance\n  // corresponding to the RPC request object). Defining this field will\n  // add one or more overloads providing flattened or simpler method signatures\n  // in some languages.\n  //\n  // The fields on the method signature are provided as a comma-separated\n  // string.\n  //\n  // For example, the proto RPC and annotation:\n  //\n  //   rpc CreateSubscription(CreateSubscriptionRequest)\n  //       returns (Subscription) {\n  //     option (google.api.method_signature) = \"name,topic\";\n  //   }\n  //\n  // Would add the following Java overload (in addition to the method accepting\n  // the request object):\n  //\n  //   public final Subscription createSubscription(String name, String topic)\n  //\n  // The following backwards-compatibility guidelines apply:\n  //\n  //   * Adding this annotation to an unannotated method is backwards\n  //     compatible.\n  //   * Adding this annotation to a method which already has existing\n  //     method signature annotations is backwards compatible if and only if\n  //     the new method signature annotation is last in the sequence.\n  //   * Modifying or removing an existing method signature annotation is\n  //     a breaking change.\n  //   * Re-ordering existing method signature annotations is a breaking\n  //     change.\n  repeated string method_signature = 1051;\n}\n\nextend google.protobuf.ServiceOptions {\n  // The hostname for this service.\n  // This should be specified with no prefix or protocol.\n  //\n  // Example:\n  //\n  //   service Foo {\n  //     option (google.api.default_host) = \"foo.googleapi.com\";\n  //     ...\n  //   }\n  string default_host = 1049;\n\n  // OAuth scopes needed for the client.\n  //\n  // Example:\n  //\n  //   service Foo {\n  //     option (google.api.oauth_scopes) = \\\n  //       \"https://www.googleapis.com/auth/cloud-platform\";\n  //     ...\n  //   }\n  //\n  // If there is more than one scope, use a comma-separated string:\n  //\n  // Example:\n  //\n  //   service Foo {\n  //     option (google.api.oauth_scopes) = \\\n  //       \"https://www.googleapis.com/auth/cloud-platform,\"\n  //       \"https://www.googleapis.com/auth/monitoring\";\n  //     ...\n  //   }\n  string oauth_scopes = 1050;\n}\n\n// Required information for every language.\nmessage CommonLanguageSettings {\n  // Link to automatically generated reference documentation.  Example:\n  // https://cloud.google.com/nodejs/docs/reference/asset/latest\n  string reference_docs_uri = 1 [deprecated = true];\n\n  // The destination where API teams want this client library to be published.\n  repeated ClientLibraryDestination destinations = 2;\n}\n\n// Details about how and where to publish client libraries.\nmessage ClientLibrarySettings {\n  // Version of the API to apply these settings to. This is the full protobuf\n  // package for the API, ending in the version element.\n  // Examples: \"google.cloud.speech.v1\" and \"google.spanner.admin.database.v1\".\n  string version = 1;\n\n  // Launch stage of this version of the API.\n  LaunchStage launch_stage = 2;\n\n  // When using transport=rest, the client request will encode enums as\n  // numbers rather than strings.\n  bool rest_numeric_enums = 3;\n\n  // Settings for legacy Java features, supported in the Service YAML.\n  JavaSettings java_settings = 21;\n\n  // Settings for C++ client libraries.\n  CppSettings cpp_settings = 22;\n\n  // Settings for PHP client libraries.\n  PhpSettings php_settings = 23;\n\n  // Settings for Python client libraries.\n  PythonSettings python_settings = 24;\n\n  // Settings for Node client libraries.\n  NodeSettings node_settings = 25;\n\n  // Settings for .NET client libraries.\n  DotnetSettings dotnet_settings = 26;\n\n  // Settings for Ruby client libraries.\n  RubySettings ruby_settings = 27;\n\n  // Settings for Go client libraries.\n  GoSettings go_settings = 28;\n}\n\n// This message configures the settings for publishing [Google Cloud Client\n// libraries](https://cloud.google.com/apis/docs/cloud-client-libraries)\n// generated from the service config.\nmessage Publishing {\n  // A list of API method settings, e.g. the behavior for methods that use the\n  // long-running operation pattern.\n  repeated MethodSettings method_settings = 2;\n\n  // Link to a *public* URI where users can report issues.  Example:\n  // https://issuetracker.google.com/issues/new?component=190865&template=1161103\n  string new_issue_uri = 101;\n\n  // Link to product home page.  Example:\n  // https://cloud.google.com/asset-inventory/docs/overview\n  string documentation_uri = 102;\n\n  // Used as a tracking tag when collecting data about the APIs developer\n  // relations artifacts like docs, packages delivered to package managers,\n  // etc.  Example: \"speech\".\n  string api_short_name = 103;\n\n  // GitHub label to apply to issues and pull requests opened for this API.\n  string github_label = 104;\n\n  // GitHub teams to be added to CODEOWNERS in the directory in GitHub\n  // containing source code for the client libraries for this API.\n  repeated string codeowner_github_teams = 105;\n\n  // A prefix used in sample code when demarking regions to be included in\n  // documentation.\n  string doc_tag_prefix = 106;\n\n  // For whom the client library is being published.\n  ClientLibraryOrganization organization = 107;\n\n  // Client library settings.  If the same version string appears multiple\n  // times in this list, then the last one wins.  Settings from earlier\n  // settings with the same version string are discarded.\n  repeated ClientLibrarySettings library_settings = 109;\n\n  // Optional link to proto reference documentation.  Example:\n  // https://cloud.google.com/pubsub/lite/docs/reference/rpc\n  string proto_reference_documentation_uri = 110;\n}\n\n// Settings for Java client libraries.\nmessage JavaSettings {\n  // The package name to use in Java. Clobbers the java_package option\n  // set in the protobuf. This should be used **only** by APIs\n  // who have already set the language_settings.java.package_name\" field\n  // in gapic.yaml. API teams should use the protobuf java_package option\n  // where possible.\n  //\n  // Example of a YAML configuration::\n  //\n  //  publishing:\n  //    java_settings:\n  //      library_package: com.google.cloud.pubsub.v1\n  string library_package = 1;\n\n  // Configure the Java class name to use instead of the service's for its\n  // corresponding generated GAPIC client. Keys are fully-qualified\n  // service names as they appear in the protobuf (including the full\n  // the language_settings.java.interface_names\" field in gapic.yaml. API\n  // teams should otherwise use the service name as it appears in the\n  // protobuf.\n  //\n  // Example of a YAML configuration::\n  //\n  //  publishing:\n  //    java_settings:\n  //      service_class_names:\n  //        - google.pubsub.v1.Publisher: TopicAdmin\n  //        - google.pubsub.v1.Subscriber: SubscriptionAdmin\n  map<string, string> service_class_names = 2;\n\n  // Some settings.\n  CommonLanguageSettings common = 3;\n}\n\n// Settings for C++ client libraries.\nmessage CppSettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n}\n\n// Settings for Php client libraries.\nmessage PhpSettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n}\n\n// Settings for Python client libraries.\nmessage PythonSettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n}\n\n// Settings for Node client libraries.\nmessage NodeSettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n}\n\n// Settings for Dotnet client libraries.\nmessage DotnetSettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n\n  // Map from original service names to renamed versions.\n  // This is used when the default generated types\n  // would cause a naming conflict. (Neither name is\n  // fully-qualified.)\n  // Example: Subscriber to SubscriberServiceApi.\n  map<string, string> renamed_services = 2;\n\n  // Map from full resource types to the effective short name\n  // for the resource. This is used when otherwise resource\n  // named from different services would cause naming collisions.\n  // Example entry:\n  // \"datalabeling.googleapis.com/Dataset\": \"DataLabelingDataset\"\n  map<string, string> renamed_resources = 3;\n\n  // List of full resource types to ignore during generation.\n  // This is typically used for API-specific Location resources,\n  // which should be handled by the generator as if they were actually\n  // the common Location resources.\n  // Example entry: \"documentai.googleapis.com/Location\"\n  repeated string ignored_resources = 4;\n\n  // Namespaces which must be aliased in snippets due to\n  // a known (but non-generator-predictable) naming collision\n  repeated string forced_namespace_aliases = 5;\n\n  // Method signatures (in the form \"service.method(signature)\")\n  // which are provided separately, so shouldn't be generated.\n  // Snippets *calling* these methods are still generated, however.\n  repeated string handwritten_signatures = 6;\n}\n\n// Settings for Ruby client libraries.\nmessage RubySettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n}\n\n// Settings for Go client libraries.\nmessage GoSettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n}\n\n// Describes the generator configuration for a method.\nmessage MethodSettings {\n  // Describes settings to use when generating API methods that use the\n  // long-running operation pattern.\n  // All default values below are from those used in the client library\n  // generators (e.g.\n  // [Java](https://github.com/googleapis/gapic-generator-java/blob/04c2faa191a9b5a10b92392fe8482279c4404803/src/main/java/com/google/api/generator/gapic/composer/common/RetrySettingsComposer.java)).\n  message LongRunning {\n    // Initial delay after which the first poll request will be made.\n    // Default value: 5 seconds.\n    google.protobuf.Duration initial_poll_delay = 1;\n\n    // Multiplier to gradually increase delay between subsequent polls until it\n    // reaches max_poll_delay.\n    // Default value: 1.5.\n    float poll_delay_multiplier = 2;\n\n    // Maximum time between two subsequent poll requests.\n    // Default value: 45 seconds.\n    google.protobuf.Duration max_poll_delay = 3;\n\n    // Total polling timeout.\n    // Default value: 5 minutes.\n    google.protobuf.Duration total_poll_timeout = 4;\n  }\n\n  // The fully qualified name of the method, for which the options below apply.\n  // This is used to find the method to apply the options.\n  string selector = 1;\n\n  // Describes settings to use for long-running operations when generating\n  // API methods for RPCs. Complements RPCs that use the annotations in\n  // google/longrunning/operations.proto.\n  //\n  // Example of a YAML configuration::\n  //\n  //  publishing:\n  //    method_settings:\n  //      - selector: google.cloud.speech.v2.Speech.BatchRecognize\n  //        long_running:\n  //          initial_poll_delay:\n  //            seconds: 60 # 1 minute\n  //          poll_delay_multiplier: 1.5\n  //          max_poll_delay:\n  //            seconds: 360 # 6 minutes\n  //          total_poll_timeout:\n  //             seconds: 54000 # 90 minutes\n  LongRunning long_running = 2;\n}\n\n// The organization for which the client libraries are being published.\n// Affects the url where generated docs are published, etc.\nenum ClientLibraryOrganization {\n  // Not useful.\n  CLIENT_LIBRARY_ORGANIZATION_UNSPECIFIED = 0;\n\n  // Google Cloud Platform Org.\n  CLOUD = 1;\n\n  // Ads (Advertising) Org.\n  ADS = 2;\n\n  // Photos Org.\n  PHOTOS = 3;\n\n  // Street View Org.\n  STREET_VIEW = 4;\n\n  // Shopping Org.\n  SHOPPING = 5;\n\n  // Geo Org.\n  GEO = 6;\n\n  // Generative AI - https://developers.generativeai.google\n  GENERATIVE_AI = 7;\n}\n\n// To where should client libraries be published?\nenum ClientLibraryDestination {\n  // Client libraries will neither be generated nor published to package\n  // managers.\n  CLIENT_LIBRARY_DESTINATION_UNSPECIFIED = 0;\n\n  // Generate the client library in a repo under github.com/googleapis,\n  // but don't publish it to package managers.\n  GITHUB = 10;\n\n  // Publish the library to package managers like nuget.org and npmjs.com.\n  PACKAGE_MANAGER = 20;\n}\n","size_bytes":13316},"run_with_vnc.sh":{"content":"#!/bin/bash\nexport DISPLAY=:0\n./gradlew run\n","size_bytes":44},"src/main/java/com/spiketrade/backend/IndicatorsData.java":{"content":"package com.spiketrade.backend;\n\npublic class IndicatorsData {\n    // Legacy indicators (keep for backward compatibility)\n    public double rsi;\n    public double obv;\n    public double mfi;\n    public double vwap;\n    public double bollingerUpper;\n    public double bollingerLower;\n    public double bollingerPosition;\n    public double percentB;\n    public double priceRoc;\n    public double rsiRoc;\n    public double obvRoc;\n    public double mfiRoc;\n    public double bollingerPosRoc;\n    public double percentBRoc;\n    public double vwapRoc;\n    public double volumeRoc;\n    \n    // NEW INDICATORS for high volatility, low-priced stocks\n    // MACD (Moving Average Convergence Divergence)\n    public double macdLine;\n    public double macdSignal;\n    public double macdHistogram;\n    public double macdHistogramRoc;  // Histogram rate-of-change (normalized to price)\n    \n    // EMA (Exponential Moving Average) - multiple periods\n    public double ema9;\n    public double ema20;\n    public double ema50;\n    \n    // Stochastic Oscillator\n    public double stochK;  // %K line\n    public double stochD;  // %D line (signal)\n    \n    // Relative Volume\n    public double rvol;\n    \n    // Volume Spike Detection\n    public boolean volumeSpike;\n    public double volumeRatio;\n    \n    // ATR (Average True Range)\n    public double atr;\n    \n    // Buy signal probability (0.0 to 1.0)\n    public double probability;\n    \n    public IndicatorsData() {\n        this.rsi = 50.0;\n        this.obv = 0.0;\n        this.mfi = 50.0;\n        this.vwap = 0.0;\n        this.bollingerUpper = 0.0;\n        this.bollingerLower = 0.0;\n        this.bollingerPosition = 0.0;\n        this.percentB = 0.0;\n        this.priceRoc = 0.0;\n        this.rsiRoc = 0.0;\n        this.obvRoc = 0.0;\n        this.mfiRoc = 0.0;\n        this.bollingerPosRoc = 0.0;\n        this.percentBRoc = 0.0;\n        this.vwapRoc = 0.0;\n        this.volumeRoc = 0.0;\n        \n        // Initialize new indicators\n        this.macdLine = 0.0;\n        this.macdSignal = 0.0;\n        this.macdHistogram = 0.0;\n        this.macdHistogramRoc = 0.0;\n        this.ema9 = 0.0;\n        this.ema20 = 0.0;\n        this.ema50 = 0.0;\n        this.stochK = 50.0;\n        this.stochD = 50.0;\n        this.rvol = 1.0;\n        this.volumeSpike = false;\n        this.volumeRatio = 1.0;\n        this.atr = 0.0;\n        this.probability = 0.0;\n    }\n}\n","size_bytes":2390},"build/extracted-include-protos/main/google/api/documentation.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"DocumentationProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Documentation` provides the information for describing a service.\n//\n// Example:\n// <pre><code>documentation:\n//   summary: >\n//     The Google Calendar API gives access\n//     to most calendar features.\n//   pages:\n//   - name: Overview\n//     content: &#40;== include google/foo/overview.md ==&#41;\n//   - name: Tutorial\n//     content: &#40;== include google/foo/tutorial.md ==&#41;\n//     subpages;\n//     - name: Java\n//       content: &#40;== include google/foo/tutorial_java.md ==&#41;\n//   rules:\n//   - selector: google.calendar.Calendar.Get\n//     description: >\n//       ...\n//   - selector: google.calendar.Calendar.Put\n//     description: >\n//       ...\n// </code></pre>\n// Documentation is provided in markdown syntax. In addition to\n// standard markdown features, definition lists, tables and fenced\n// code blocks are supported. Section headers can be provided and are\n// interpreted relative to the section nesting of the context where\n// a documentation fragment is embedded.\n//\n// Documentation from the IDL is merged with documentation defined\n// via the config at normalization time, where documentation provided\n// by config rules overrides IDL provided.\n//\n// A number of constructs specific to the API platform are supported\n// in documentation text.\n//\n// In order to reference a proto element, the following\n// notation can be used:\n// <pre><code>&#91;fully.qualified.proto.name]&#91;]</code></pre>\n// To override the display text used for the link, this can be used:\n// <pre><code>&#91;display text]&#91;fully.qualified.proto.name]</code></pre>\n// Text can be excluded from doc using the following notation:\n// <pre><code>&#40;-- internal comment --&#41;</code></pre>\n//\n// A few directives are available in documentation. Note that\n// directives must appear on a single line to be properly\n// identified. The `include` directive includes a markdown file from\n// an external source:\n// <pre><code>&#40;== include path/to/file ==&#41;</code></pre>\n// The `resource_for` directive marks a message to be the resource of\n// a collection in REST view. If it is not specified, tools attempt\n// to infer the resource from the operations in a collection:\n// <pre><code>&#40;== resource_for v1.shelves.books ==&#41;</code></pre>\n// The directive `suppress_warning` does not directly affect documentation\n// and is documented together with service config validation.\nmessage Documentation {\n  // A short description of what the service does. The summary must be plain\n  // text. It becomes the overview of the service displayed in Google Cloud\n  // Console.\n  // NOTE: This field is equivalent to the standard field `description`.\n  string summary = 1;\n\n  // The top level pages for the documentation set.\n  repeated Page pages = 5;\n\n  // A list of documentation rules that apply to individual API elements.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated DocumentationRule rules = 3;\n\n  // The URL to the root of documentation.\n  string documentation_root_url = 4;\n\n  // Specifies the service root url if the default one (the service name\n  // from the yaml file) is not suitable. This can be seen in any fully\n  // specified service urls as well as sections that show a base that other\n  // urls are relative to.\n  string service_root_url = 6;\n\n  // Declares a single overview page. For example:\n  // <pre><code>documentation:\n  //   summary: ...\n  //   overview: &#40;== include overview.md ==&#41;\n  // </code></pre>\n  // This is a shortcut for the following declaration (using pages style):\n  // <pre><code>documentation:\n  //   summary: ...\n  //   pages:\n  //   - name: Overview\n  //     content: &#40;== include overview.md ==&#41;\n  // </code></pre>\n  // Note: you cannot specify both `overview` field and `pages` field.\n  string overview = 2;\n}\n\n// A documentation rule provides information about individual API elements.\nmessage DocumentationRule {\n  // The selector is a comma-separated list of patterns for any element such as\n  // a method, a field, an enum value. Each pattern is a qualified name of the\n  // element which may end in \"*\", indicating a wildcard. Wildcards are only\n  // allowed at the end and for a whole component of the qualified name,\n  // i.e. \"foo.*\" is ok, but not \"foo.b*\" or \"foo.*.bar\". A wildcard will match\n  // one or more components. To specify a default for all applicable elements,\n  // the whole pattern \"*\" is used.\n  string selector = 1;\n\n  // Description of the selected proto element (e.g. a message, a method, a\n  // 'service' definition, or a field). Defaults to leading & trailing comments\n  // taken from the proto source definition of the proto element.\n  string description = 2;\n\n  // Deprecation description of the selected element(s). It can be provided if\n  // an element is marked as `deprecated`.\n  string deprecation_description = 3;\n}\n\n// Represents a documentation page. A page can contain subpages to represent\n// nested documentation set structure.\nmessage Page {\n  // The name of the page. It will be used as an identity of the page to\n  // generate URI of the page, text of the link to this page in navigation,\n  // etc. The full page name (start from the root page name to this page\n  // concatenated with `.`) can be used as reference to the page in your\n  // documentation. For example:\n  // <pre><code>pages:\n  // - name: Tutorial\n  //   content: &#40;== include tutorial.md ==&#41;\n  //   subpages:\n  //   - name: Java\n  //     content: &#40;== include tutorial_java.md ==&#41;\n  // </code></pre>\n  // You can reference `Java` page using Markdown reference link syntax:\n  // `[Java][Tutorial.Java]`.\n  string name = 1;\n\n  // The Markdown content of the page. You can use <code>&#40;== include {path}\n  // ==&#41;</code> to include content from a Markdown file. The content can be\n  // used to produce the documentation page such as HTML format page.\n  string content = 2;\n\n  // Subpages of this page. The order of subpages specified here will be\n  // honored in the generated docset.\n  repeated Page subpages = 3;\n}\n","size_bytes":6940},"build/extracted-include-protos/test/google/api/documentation.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"DocumentationProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Documentation` provides the information for describing a service.\n//\n// Example:\n// <pre><code>documentation:\n//   summary: >\n//     The Google Calendar API gives access\n//     to most calendar features.\n//   pages:\n//   - name: Overview\n//     content: &#40;== include google/foo/overview.md ==&#41;\n//   - name: Tutorial\n//     content: &#40;== include google/foo/tutorial.md ==&#41;\n//     subpages;\n//     - name: Java\n//       content: &#40;== include google/foo/tutorial_java.md ==&#41;\n//   rules:\n//   - selector: google.calendar.Calendar.Get\n//     description: >\n//       ...\n//   - selector: google.calendar.Calendar.Put\n//     description: >\n//       ...\n// </code></pre>\n// Documentation is provided in markdown syntax. In addition to\n// standard markdown features, definition lists, tables and fenced\n// code blocks are supported. Section headers can be provided and are\n// interpreted relative to the section nesting of the context where\n// a documentation fragment is embedded.\n//\n// Documentation from the IDL is merged with documentation defined\n// via the config at normalization time, where documentation provided\n// by config rules overrides IDL provided.\n//\n// A number of constructs specific to the API platform are supported\n// in documentation text.\n//\n// In order to reference a proto element, the following\n// notation can be used:\n// <pre><code>&#91;fully.qualified.proto.name]&#91;]</code></pre>\n// To override the display text used for the link, this can be used:\n// <pre><code>&#91;display text]&#91;fully.qualified.proto.name]</code></pre>\n// Text can be excluded from doc using the following notation:\n// <pre><code>&#40;-- internal comment --&#41;</code></pre>\n//\n// A few directives are available in documentation. Note that\n// directives must appear on a single line to be properly\n// identified. The `include` directive includes a markdown file from\n// an external source:\n// <pre><code>&#40;== include path/to/file ==&#41;</code></pre>\n// The `resource_for` directive marks a message to be the resource of\n// a collection in REST view. If it is not specified, tools attempt\n// to infer the resource from the operations in a collection:\n// <pre><code>&#40;== resource_for v1.shelves.books ==&#41;</code></pre>\n// The directive `suppress_warning` does not directly affect documentation\n// and is documented together with service config validation.\nmessage Documentation {\n  // A short description of what the service does. The summary must be plain\n  // text. It becomes the overview of the service displayed in Google Cloud\n  // Console.\n  // NOTE: This field is equivalent to the standard field `description`.\n  string summary = 1;\n\n  // The top level pages for the documentation set.\n  repeated Page pages = 5;\n\n  // A list of documentation rules that apply to individual API elements.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated DocumentationRule rules = 3;\n\n  // The URL to the root of documentation.\n  string documentation_root_url = 4;\n\n  // Specifies the service root url if the default one (the service name\n  // from the yaml file) is not suitable. This can be seen in any fully\n  // specified service urls as well as sections that show a base that other\n  // urls are relative to.\n  string service_root_url = 6;\n\n  // Declares a single overview page. For example:\n  // <pre><code>documentation:\n  //   summary: ...\n  //   overview: &#40;== include overview.md ==&#41;\n  // </code></pre>\n  // This is a shortcut for the following declaration (using pages style):\n  // <pre><code>documentation:\n  //   summary: ...\n  //   pages:\n  //   - name: Overview\n  //     content: &#40;== include overview.md ==&#41;\n  // </code></pre>\n  // Note: you cannot specify both `overview` field and `pages` field.\n  string overview = 2;\n}\n\n// A documentation rule provides information about individual API elements.\nmessage DocumentationRule {\n  // The selector is a comma-separated list of patterns for any element such as\n  // a method, a field, an enum value. Each pattern is a qualified name of the\n  // element which may end in \"*\", indicating a wildcard. Wildcards are only\n  // allowed at the end and for a whole component of the qualified name,\n  // i.e. \"foo.*\" is ok, but not \"foo.b*\" or \"foo.*.bar\". A wildcard will match\n  // one or more components. To specify a default for all applicable elements,\n  // the whole pattern \"*\" is used.\n  string selector = 1;\n\n  // Description of the selected proto element (e.g. a message, a method, a\n  // 'service' definition, or a field). Defaults to leading & trailing comments\n  // taken from the proto source definition of the proto element.\n  string description = 2;\n\n  // Deprecation description of the selected element(s). It can be provided if\n  // an element is marked as `deprecated`.\n  string deprecation_description = 3;\n}\n\n// Represents a documentation page. A page can contain subpages to represent\n// nested documentation set structure.\nmessage Page {\n  // The name of the page. It will be used as an identity of the page to\n  // generate URI of the page, text of the link to this page in navigation,\n  // etc. The full page name (start from the root page name to this page\n  // concatenated with `.`) can be used as reference to the page in your\n  // documentation. For example:\n  // <pre><code>pages:\n  // - name: Tutorial\n  //   content: &#40;== include tutorial.md ==&#41;\n  //   subpages:\n  //   - name: Java\n  //     content: &#40;== include tutorial_java.md ==&#41;\n  // </code></pre>\n  // You can reference `Java` page using Markdown reference link syntax:\n  // `[Java][Tutorial.Java]`.\n  string name = 1;\n\n  // The Markdown content of the page. You can use <code>&#40;== include {path}\n  // ==&#41;</code> to include content from a Markdown file. The content can be\n  // used to produce the documentation page such as HTML format page.\n  string content = 2;\n\n  // Subpages of this page. The order of subpages specified here will be\n  // honored in the generated docset.\n  repeated Page subpages = 3;\n}\n","size_bytes":6940},"build/extracted-include-protos/main/google/api/auth.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"AuthProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Authentication` defines the authentication configuration for API methods\n// provided by an API service.\n//\n// Example:\n//\n//     name: calendar.googleapis.com\n//     authentication:\n//       providers:\n//       - id: google_calendar_auth\n//         jwks_uri: https://www.googleapis.com/oauth2/v1/certs\n//         issuer: https://securetoken.google.com\n//       rules:\n//       - selector: \"*\"\n//         requirements:\n//           provider_id: google_calendar_auth\n//       - selector: google.calendar.Delegate\n//         oauth:\n//           canonical_scopes: https://www.googleapis.com/auth/calendar.read\nmessage Authentication {\n  // A list of authentication rules that apply to individual API methods.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated AuthenticationRule rules = 3;\n\n  // Defines a set of authentication providers that a service supports.\n  repeated AuthProvider providers = 4;\n}\n\n// Authentication rules for the service.\n//\n// By default, if a method has any authentication requirements, every request\n// must include a valid credential matching one of the requirements.\n// It's an error to include more than one kind of credential in a single\n// request.\n//\n// If a method doesn't have any auth requirements, request credentials will be\n// ignored.\nmessage AuthenticationRule {\n  // Selects the methods to which this rule applies.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // The requirements for OAuth credentials.\n  OAuthRequirements oauth = 2;\n\n  // If true, the service accepts API keys without any other credential.\n  // This flag only applies to HTTP and gRPC requests.\n  bool allow_without_credential = 5;\n\n  // Requirements for additional authentication providers.\n  repeated AuthRequirement requirements = 7;\n}\n\n// Specifies a location to extract JWT from an API request.\nmessage JwtLocation {\n  oneof in {\n    // Specifies HTTP header name to extract JWT token.\n    string header = 1;\n\n    // Specifies URL query parameter name to extract JWT token.\n    string query = 2;\n\n    // Specifies cookie name to extract JWT token.\n    string cookie = 4;\n  }\n\n  // The value prefix. The value format is \"value_prefix{token}\"\n  // Only applies to \"in\" header type. Must be empty for \"in\" query type.\n  // If not empty, the header value has to match (case sensitive) this prefix.\n  // If not matched, JWT will not be extracted. If matched, JWT will be\n  // extracted after the prefix is removed.\n  //\n  // For example, for \"Authorization: Bearer {JWT}\",\n  // value_prefix=\"Bearer \" with a space at the end.\n  string value_prefix = 3;\n}\n\n// Configuration for an authentication provider, including support for\n// [JSON Web Token\n// (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).\nmessage AuthProvider {\n  // The unique identifier of the auth provider. It will be referred to by\n  // `AuthRequirement.provider_id`.\n  //\n  // Example: \"bookstore_auth\".\n  string id = 1;\n\n  // Identifies the principal that issued the JWT. See\n  // https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.1\n  // Usually a URL or an email address.\n  //\n  // Example: https://securetoken.google.com\n  // Example: 1234567-compute@developer.gserviceaccount.com\n  string issuer = 2;\n\n  // URL of the provider's public key set to validate signature of the JWT. See\n  // [OpenID\n  // Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n  // Optional if the key set document:\n  //  - can be retrieved from\n  //    [OpenID\n  //    Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html)\n  //    of the issuer.\n  //  - can be inferred from the email domain of the issuer (e.g. a Google\n  //  service account).\n  //\n  // Example: https://www.googleapis.com/oauth2/v1/certs\n  string jwks_uri = 3;\n\n  // The list of JWT\n  // [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).\n  // that are allowed to access. A JWT containing any of these audiences will\n  // be accepted. When this setting is absent, JWTs with audiences:\n  //   - \"https://[service.name]/[google.protobuf.Api.name]\"\n  //   - \"https://[service.name]/\"\n  // will be accepted.\n  // For example, if no audiences are in the setting, LibraryService API will\n  // accept JWTs with the following audiences:\n  //   -\n  //   https://library-example.googleapis.com/google.example.library.v1.LibraryService\n  //   - https://library-example.googleapis.com/\n  //\n  // Example:\n  //\n  //     audiences: bookstore_android.apps.googleusercontent.com,\n  //                bookstore_web.apps.googleusercontent.com\n  string audiences = 4;\n\n  // Redirect URL if JWT token is required but not present or is expired.\n  // Implement authorizationUrl of securityDefinitions in OpenAPI spec.\n  string authorization_url = 5;\n\n  // Defines the locations to extract the JWT.  For now it is only used by the\n  // Cloud Endpoints to store the OpenAPI extension [x-google-jwt-locations]\n  // (https://cloud.google.com/endpoints/docs/openapi/openapi-extensions#x-google-jwt-locations)\n  //\n  // JWT locations can be one of HTTP headers, URL query parameters or\n  // cookies. The rule is that the first match wins.\n  //\n  // If not specified,  default to use following 3 locations:\n  //    1) Authorization: Bearer\n  //    2) x-goog-iap-jwt-assertion\n  //    3) access_token query parameter\n  //\n  // Default locations can be specified as followings:\n  //    jwt_locations:\n  //    - header: Authorization\n  //      value_prefix: \"Bearer \"\n  //    - header: x-goog-iap-jwt-assertion\n  //    - query: access_token\n  repeated JwtLocation jwt_locations = 6;\n}\n\n// OAuth scopes are a way to define data and permissions on data. For example,\n// there are scopes defined for \"Read-only access to Google Calendar\" and\n// \"Access to Cloud Platform\". Users can consent to a scope for an application,\n// giving it permission to access that data on their behalf.\n//\n// OAuth scope specifications should be fairly coarse grained; a user will need\n// to see and understand the text description of what your scope means.\n//\n// In most cases: use one or at most two OAuth scopes for an entire family of\n// products. If your product has multiple APIs, you should probably be sharing\n// the OAuth scope across all of those APIs.\n//\n// When you need finer grained OAuth consent screens: talk with your product\n// management about how developers will use them in practice.\n//\n// Please note that even though each of the canonical scopes is enough for a\n// request to be accepted and passed to the backend, a request can still fail\n// due to the backend requiring additional scopes or permissions.\nmessage OAuthRequirements {\n  // The list of publicly documented OAuth scopes that are allowed access. An\n  // OAuth token containing any of these scopes will be accepted.\n  //\n  // Example:\n  //\n  //      canonical_scopes: https://www.googleapis.com/auth/calendar,\n  //                        https://www.googleapis.com/auth/calendar.read\n  string canonical_scopes = 1;\n}\n\n// User-defined authentication requirements, including support for\n// [JSON Web Token\n// (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).\nmessage AuthRequirement {\n  // [id][google.api.AuthProvider.id] from authentication provider.\n  //\n  // Example:\n  //\n  //     provider_id: bookstore_auth\n  string provider_id = 1;\n\n  // NOTE: This will be deprecated soon, once AuthProvider.audiences is\n  // implemented and accepted in all the runtime components.\n  //\n  // The list of JWT\n  // [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).\n  // that are allowed to access. A JWT containing any of these audiences will\n  // be accepted. When this setting is absent, only JWTs with audience\n  // \"https://[Service_name][google.api.Service.name]/[API_name][google.protobuf.Api.name]\"\n  // will be accepted. For example, if no audiences are in the setting,\n  // LibraryService API will only accept JWTs with the following audience\n  // \"https://library-example.googleapis.com/google.example.library.v1.LibraryService\".\n  //\n  // Example:\n  //\n  //     audiences: bookstore_android.apps.googleusercontent.com,\n  //                bookstore_web.apps.googleusercontent.com\n  string audiences = 2;\n}\n","size_bytes":9257},"build/extracted-include-protos/main/google/type/calendar_period.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption go_package = \"google.golang.org/genproto/googleapis/type/calendarperiod;calendarperiod\";\noption java_multiple_files = true;\noption java_outer_classname = \"CalendarPeriodProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// A `CalendarPeriod` represents the abstract concept of a time period that has\n// a canonical start. Grammatically, \"the start of the current\n// `CalendarPeriod`.\" All calendar times begin at midnight UTC.\nenum CalendarPeriod {\n  // Undefined period, raises an error.\n  CALENDAR_PERIOD_UNSPECIFIED = 0;\n\n  // A day.\n  DAY = 1;\n\n  // A week. Weeks begin on Monday, following\n  // [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date).\n  WEEK = 2;\n\n  // A fortnight. The first calendar fortnight of the year begins at the start\n  // of week 1 according to\n  // [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date).\n  FORTNIGHT = 3;\n\n  // A month.\n  MONTH = 4;\n\n  // A quarter. Quarters start on dates 1-Jan, 1-Apr, 1-Jul, and 1-Oct of each\n  // year.\n  QUARTER = 5;\n\n  // A half-year. Half-years start on dates 1-Jan and 1-Jul.\n  HALF = 6;\n\n  // A year.\n  YEAR = 7;\n}\n","size_bytes":1762},"build/extracted-include-protos/main/google/type/datetime.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\nimport \"google/protobuf/duration.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/datetime;datetime\";\noption java_multiple_files = true;\noption java_outer_classname = \"DateTimeProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents civil time (or occasionally physical time).\n//\n// This type can represent a civil time in one of a few possible ways:\n//\n//  * When utc_offset is set and time_zone is unset: a civil time on a calendar\n//    day with a particular offset from UTC.\n//  * When time_zone is set and utc_offset is unset: a civil time on a calendar\n//    day in a particular time zone.\n//  * When neither time_zone nor utc_offset is set: a civil time on a calendar\n//    day in local time.\n//\n// The date is relative to the Proleptic Gregorian Calendar.\n//\n// If year is 0, the DateTime is considered not to have a specific year. month\n// and day must have valid, non-zero values.\n//\n// This type may also be used to represent a physical time if all the date and\n// time fields are set and either case of the `time_offset` oneof is set.\n// Consider using `Timestamp` message for physical time instead. If your use\n// case also would like to store the user's timezone, that can be done in\n// another field.\n//\n// This type is more flexible than some applications may want. Make sure to\n// document and validate your application's limitations.\nmessage DateTime {\n  // Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a\n  // datetime without a year.\n  int32 year = 1;\n\n  // Required. Month of year. Must be from 1 to 12.\n  int32 month = 2;\n\n  // Required. Day of month. Must be from 1 to 31 and valid for the year and\n  // month.\n  int32 day = 3;\n\n  // Required. Hours of day in 24 hour format. Should be from 0 to 23. An API\n  // may choose to allow the value \"24:00:00\" for scenarios like business\n  // closing time.\n  int32 hours = 4;\n\n  // Required. Minutes of hour of day. Must be from 0 to 59.\n  int32 minutes = 5;\n\n  // Required. Seconds of minutes of the time. Must normally be from 0 to 59. An\n  // API may allow the value 60 if it allows leap-seconds.\n  int32 seconds = 6;\n\n  // Required. Fractions of seconds in nanoseconds. Must be from 0 to\n  // 999,999,999.\n  int32 nanos = 7;\n\n  // Optional. Specifies either the UTC offset or the time zone of the DateTime.\n  // Choose carefully between them, considering that time zone data may change\n  // in the future (for example, a country modifies their DST start/end dates,\n  // and future DateTimes in the affected range had already been stored).\n  // If omitted, the DateTime is considered to be in local time.\n  oneof time_offset {\n    // UTC offset. Must be whole seconds, between -18 hours and +18 hours.\n    // For example, a UTC offset of -4:00 would be represented as\n    // { seconds: -14400 }.\n    google.protobuf.Duration utc_offset = 8;\n\n    // Time zone.\n    TimeZone time_zone = 9;\n  }\n}\n\n// Represents a time zone from the\n// [IANA Time Zone Database](https://www.iana.org/time-zones).\nmessage TimeZone {\n  // IANA Time Zone Database time zone, e.g. \"America/New_York\".\n  string id = 1;\n\n  // Optional. IANA Time Zone Database version number, e.g. \"2019a\".\n  string version = 2;\n}\n","size_bytes":3905},"build/extracted-include-protos/test/google/geo/type/viewport.proto":{"content":"// Copyright 2019 Google LLC.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nsyntax = \"proto3\";\n\npackage google.geo.type;\n\nimport \"google/type/latlng.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/geo/type/viewport;viewport\";\noption java_multiple_files = true;\noption java_outer_classname = \"ViewportProto\";\noption java_package = \"com.google.geo.type\";\noption objc_class_prefix = \"GGTP\";\n\n// A latitude-longitude viewport, represented as two diagonally opposite `low`\n// and `high` points. A viewport is considered a closed region, i.e. it includes\n// its boundary. The latitude bounds must range between -90 to 90 degrees\n// inclusive, and the longitude bounds must range between -180 to 180 degrees\n// inclusive. Various cases include:\n//\n//  - If `low` = `high`, the viewport consists of that single point.\n//\n//  - If `low.longitude` > `high.longitude`, the longitude range is inverted\n//    (the viewport crosses the 180 degree longitude line).\n//\n//  - If `low.longitude` = -180 degrees and `high.longitude` = 180 degrees,\n//    the viewport includes all longitudes.\n//\n//  - If `low.longitude` = 180 degrees and `high.longitude` = -180 degrees,\n//    the longitude range is empty.\n//\n//  - If `low.latitude` > `high.latitude`, the latitude range is empty.\n//\n// Both `low` and `high` must be populated, and the represented box cannot be\n// empty (as specified by the definitions above). An empty viewport will result\n// in an error.\n//\n// For example, this viewport fully encloses New York City:\n//\n// {\n//     \"low\": {\n//         \"latitude\": 40.477398,\n//         \"longitude\": -74.259087\n//     },\n//     \"high\": {\n//         \"latitude\": 40.91618,\n//         \"longitude\": -73.70018\n//     }\n// }\nmessage Viewport {\n  // Required. The low point of the viewport.\n  google.type.LatLng low = 1;\n\n  // Required. The high point of the viewport.\n  google.type.LatLng high = 2;\n}\n","size_bytes":2416},"build/extracted-include-protos/test/google/type/localized_text.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/localized_text;localized_text\";\noption java_multiple_files = true;\noption java_outer_classname = \"LocalizedTextProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Localized variant of a text in a particular language.\nmessage LocalizedText {\n  // Localized string in the language corresponding to `language_code' below.\n  string text = 1;\n\n  // The text's BCP-47 language code, such as \"en-US\" or \"sr-Latn\".\n  //\n  // For more information, see\n  // http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.\n  string language_code = 2;\n}\n","size_bytes":1303},"build/extracted-include-protos/main/google/geo/type/viewport.proto":{"content":"// Copyright 2019 Google LLC.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nsyntax = \"proto3\";\n\npackage google.geo.type;\n\nimport \"google/type/latlng.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/geo/type/viewport;viewport\";\noption java_multiple_files = true;\noption java_outer_classname = \"ViewportProto\";\noption java_package = \"com.google.geo.type\";\noption objc_class_prefix = \"GGTP\";\n\n// A latitude-longitude viewport, represented as two diagonally opposite `low`\n// and `high` points. A viewport is considered a closed region, i.e. it includes\n// its boundary. The latitude bounds must range between -90 to 90 degrees\n// inclusive, and the longitude bounds must range between -180 to 180 degrees\n// inclusive. Various cases include:\n//\n//  - If `low` = `high`, the viewport consists of that single point.\n//\n//  - If `low.longitude` > `high.longitude`, the longitude range is inverted\n//    (the viewport crosses the 180 degree longitude line).\n//\n//  - If `low.longitude` = -180 degrees and `high.longitude` = 180 degrees,\n//    the viewport includes all longitudes.\n//\n//  - If `low.longitude` = 180 degrees and `high.longitude` = -180 degrees,\n//    the longitude range is empty.\n//\n//  - If `low.latitude` > `high.latitude`, the latitude range is empty.\n//\n// Both `low` and `high` must be populated, and the represented box cannot be\n// empty (as specified by the definitions above). An empty viewport will result\n// in an error.\n//\n// For example, this viewport fully encloses New York City:\n//\n// {\n//     \"low\": {\n//         \"latitude\": 40.477398,\n//         \"longitude\": -74.259087\n//     },\n//     \"high\": {\n//         \"latitude\": 40.91618,\n//         \"longitude\": -73.70018\n//     }\n// }\nmessage Viewport {\n  // Required. The low point of the viewport.\n  google.type.LatLng low = 1;\n\n  // Required. The high point of the viewport.\n  google.type.LatLng high = 2;\n}\n","size_bytes":2416},"build/extracted-include-protos/main/google/api/system_parameter.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"SystemParameterProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// ### System parameter configuration\n//\n// A system parameter is a special kind of parameter defined by the API\n// system, not by an individual API. It is typically mapped to an HTTP header\n// and/or a URL query parameter. This configuration specifies which methods\n// change the names of the system parameters.\nmessage SystemParameters {\n  // Define system parameters.\n  //\n  // The parameters defined here will override the default parameters\n  // implemented by the system. If this field is missing from the service\n  // config, default system parameters will be used. Default system parameters\n  // and names is implementation-dependent.\n  //\n  // Example: define api key for all methods\n  //\n  //     system_parameters\n  //       rules:\n  //         - selector: \"*\"\n  //           parameters:\n  //             - name: api_key\n  //               url_query_parameter: api_key\n  //\n  //\n  // Example: define 2 api key names for a specific method.\n  //\n  //     system_parameters\n  //       rules:\n  //         - selector: \"/ListShelves\"\n  //           parameters:\n  //             - name: api_key\n  //               http_header: Api-Key1\n  //             - name: api_key\n  //               http_header: Api-Key2\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated SystemParameterRule rules = 1;\n}\n\n// Define a system parameter rule mapping system parameter definitions to\n// methods.\nmessage SystemParameterRule {\n  // Selects the methods to which this rule applies. Use '*' to indicate all\n  // methods in all APIs.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // Define parameters. Multiple names may be defined for a parameter.\n  // For a given method call, only one of them should be used. If multiple\n  // names are used the behavior is implementation-dependent.\n  // If none of the specified names are present the behavior is\n  // parameter-dependent.\n  repeated SystemParameter parameters = 2;\n}\n\n// Define a parameter's name and location. The parameter may be passed as either\n// an HTTP header or a URL query parameter, and if both are passed the behavior\n// is implementation-dependent.\nmessage SystemParameter {\n  // Define the name of the parameter, such as \"api_key\" . It is case sensitive.\n  string name = 1;\n\n  // Define the HTTP header name to use for the parameter. It is case\n  // insensitive.\n  string http_header = 2;\n\n  // Define the URL query parameter name to use for the parameter. It is case\n  // sensitive.\n  string url_query_parameter = 3;\n}\n","size_bytes":3475},"build/extracted-include-protos/main/google/api/monitored_resource.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/api/label.proto\";\nimport \"google/api/launch_stage.proto\";\nimport \"google/protobuf/struct.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/api/monitoredres;monitoredres\";\noption java_multiple_files = true;\noption java_outer_classname = \"MonitoredResourceProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// An object that describes the schema of a\n// [MonitoredResource][google.api.MonitoredResource] object using a type name\n// and a set of labels.  For example, the monitored resource descriptor for\n// Google Compute Engine VM instances has a type of\n// `\"gce_instance\"` and specifies the use of the labels `\"instance_id\"` and\n// `\"zone\"` to identify particular VM instances.\n//\n// Different APIs can support different monitored resource types. APIs generally\n// provide a `list` method that returns the monitored resource descriptors used\n// by the API.\n//\nmessage MonitoredResourceDescriptor {\n  // Optional. The resource name of the monitored resource descriptor:\n  // `\"projects/{project_id}/monitoredResourceDescriptors/{type}\"` where\n  // {type} is the value of the `type` field in this object and\n  // {project_id} is a project ID that provides API-specific context for\n  // accessing the type.  APIs that do not use project information can use the\n  // resource name format `\"monitoredResourceDescriptors/{type}\"`.\n  string name = 5;\n\n  // Required. The monitored resource type. For example, the type\n  // `\"cloudsql_database\"` represents databases in Google Cloud SQL.\n  //  For a list of types, see [Monitoring resource\n  //  types](https://cloud.google.com/monitoring/api/resources)\n  // and [Logging resource\n  // types](https://cloud.google.com/logging/docs/api/v2/resource-list).\n  string type = 1;\n\n  // Optional. A concise name for the monitored resource type that might be\n  // displayed in user interfaces. It should be a Title Cased Noun Phrase,\n  // without any article or other determiners. For example,\n  // `\"Google Cloud SQL Database\"`.\n  string display_name = 2;\n\n  // Optional. A detailed description of the monitored resource type that might\n  // be used in documentation.\n  string description = 3;\n\n  // Required. A set of labels used to describe instances of this monitored\n  // resource type. For example, an individual Google Cloud SQL database is\n  // identified by values for the labels `\"database_id\"` and `\"zone\"`.\n  repeated LabelDescriptor labels = 4;\n\n  // Optional. The launch stage of the monitored resource definition.\n  LaunchStage launch_stage = 7;\n}\n\n// An object representing a resource that can be used for monitoring, logging,\n// billing, or other purposes. Examples include virtual machine instances,\n// databases, and storage devices such as disks. The `type` field identifies a\n// [MonitoredResourceDescriptor][google.api.MonitoredResourceDescriptor] object\n// that describes the resource's schema. Information in the `labels` field\n// identifies the actual resource and its attributes according to the schema.\n// For example, a particular Compute Engine VM instance could be represented by\n// the following object, because the\n// [MonitoredResourceDescriptor][google.api.MonitoredResourceDescriptor] for\n// `\"gce_instance\"` has labels\n// `\"project_id\"`, `\"instance_id\"` and `\"zone\"`:\n//\n//     { \"type\": \"gce_instance\",\n//       \"labels\": { \"project_id\": \"my-project\",\n//                   \"instance_id\": \"12345678901234\",\n//                   \"zone\": \"us-central1-a\" }}\nmessage MonitoredResource {\n  // Required. The monitored resource type. This field must match\n  // the `type` field of a\n  // [MonitoredResourceDescriptor][google.api.MonitoredResourceDescriptor]\n  // object. For example, the type of a Compute Engine VM instance is\n  // `gce_instance`. Some descriptors include the service name in the type; for\n  // example, the type of a Datastream stream is\n  // `datastream.googleapis.com/Stream`.\n  string type = 1;\n\n  // Required. Values for all of the labels listed in the associated monitored\n  // resource descriptor. For example, Compute Engine VM instances use the\n  // labels `\"project_id\"`, `\"instance_id\"`, and `\"zone\"`.\n  map<string, string> labels = 2;\n}\n\n// Auxiliary metadata for a [MonitoredResource][google.api.MonitoredResource]\n// object. [MonitoredResource][google.api.MonitoredResource] objects contain the\n// minimum set of information to uniquely identify a monitored resource\n// instance. There is some other useful auxiliary metadata. Monitoring and\n// Logging use an ingestion pipeline to extract metadata for cloud resources of\n// all types, and store the metadata in this message.\nmessage MonitoredResourceMetadata {\n  // Output only. Values for predefined system metadata labels.\n  // System labels are a kind of metadata extracted by Google, including\n  // \"machine_image\", \"vpc\", \"subnet_id\",\n  // \"security_group\", \"name\", etc.\n  // System label values can be only strings, Boolean values, or a list of\n  // strings. For example:\n  //\n  //     { \"name\": \"my-test-instance\",\n  //       \"security_group\": [\"a\", \"b\", \"c\"],\n  //       \"spot_instance\": false }\n  google.protobuf.Struct system_labels = 1;\n\n  // Output only. A map of user-defined metadata labels.\n  map<string, string> user_labels = 2;\n}\n","size_bytes":5921},"build/extracted-include-protos/main/google/protobuf/duration.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/protobuf/types/known/durationpb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"DurationProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\n\n// A Duration represents a signed, fixed-length span of time represented\n// as a count of seconds and fractions of seconds at nanosecond\n// resolution. It is independent of any calendar and concepts like \"day\"\n// or \"month\". It is related to Timestamp in that the difference between\n// two Timestamp values is a Duration and it can be added or subtracted\n// from a Timestamp. Range is approximately +-10,000 years.\n//\n// # Examples\n//\n// Example 1: Compute Duration from two Timestamps in pseudo code.\n//\n//     Timestamp start = ...;\n//     Timestamp end = ...;\n//     Duration duration = ...;\n//\n//     duration.seconds = end.seconds - start.seconds;\n//     duration.nanos = end.nanos - start.nanos;\n//\n//     if (duration.seconds < 0 && duration.nanos > 0) {\n//       duration.seconds += 1;\n//       duration.nanos -= 1000000000;\n//     } else if (duration.seconds > 0 && duration.nanos < 0) {\n//       duration.seconds -= 1;\n//       duration.nanos += 1000000000;\n//     }\n//\n// Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.\n//\n//     Timestamp start = ...;\n//     Duration duration = ...;\n//     Timestamp end = ...;\n//\n//     end.seconds = start.seconds + duration.seconds;\n//     end.nanos = start.nanos + duration.nanos;\n//\n//     if (end.nanos < 0) {\n//       end.seconds -= 1;\n//       end.nanos += 1000000000;\n//     } else if (end.nanos >= 1000000000) {\n//       end.seconds += 1;\n//       end.nanos -= 1000000000;\n//     }\n//\n// Example 3: Compute Duration from datetime.timedelta in Python.\n//\n//     td = datetime.timedelta(days=3, minutes=10)\n//     duration = Duration()\n//     duration.FromTimedelta(td)\n//\n// # JSON Mapping\n//\n// In JSON format, the Duration type is encoded as a string rather than an\n// object, where the string ends in the suffix \"s\" (indicating seconds) and\n// is preceded by the number of seconds, with nanoseconds expressed as\n// fractional seconds. For example, 3 seconds with 0 nanoseconds should be\n// encoded in JSON format as \"3s\", while 3 seconds and 1 nanosecond should\n// be expressed in JSON format as \"3.000000001s\", and 3 seconds and 1\n// microsecond should be expressed in JSON format as \"3.000001s\".\n//\nmessage Duration {\n  // Signed seconds of the span of time. Must be from -315,576,000,000\n  // to +315,576,000,000 inclusive. Note: these bounds are computed from:\n  // 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years\n  int64 seconds = 1;\n\n  // Signed fractions of a second at nanosecond resolution of the span\n  // of time. Durations less than one second are represented with a 0\n  // `seconds` field and a positive or negative `nanos` field. For durations\n  // of one second or more, a non-zero value for the `nanos` field must be\n  // of the same sign as the `seconds` field. Must be from -999,999,999\n  // to +999,999,999 inclusive.\n  int32 nanos = 2;\n}\n","size_bytes":4892},"src/main/java/com/spiketrade/backend/BackendServer.java":{"content":"package com.spiketrade.backend;\n\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.io.IOException;\nimport com.spiketrade.service.NotificationService;\n\npublic class BackendServer {\n    private Server server;\n    private TradingServiceImpl tradingService;\n    private NotificationService notificationService;\n    \n    public static void main(String[] args) {\n        BackendServer server = new BackendServer();\n        server.start(args);\n        server.blockUntilShutdown();\n    }\n    \n    public void start(String[] args) {\n        try {\n            System.out.println(\"=== SpikeTrade Java Backend ===\");\n            System.out.println(\"Version: 1.0.0\");\n            System.out.println(\"Migrated from C++ to Java\");\n            System.out.println();\n            \n            ConfigValidator configValidator = new ConfigValidator();\n            if (!configValidator.loadFromJson(\"trading_settings.json\")) {\n                System.out.println(\"Warning: Could not load trading_settings.json, using defaults\");\n            }\n            \n            TradingConfig config = configValidator.getConfig();\n            \n            // Validate configuration (all parameters must be positive except RSI thresholds)\n            if (!configValidator.validateTradingConfig(config)) {\n                System.err.println(\"WARNING: Configuration contains invalid values!\");\n                System.err.println(\"Please review and fix the trading_settings.json file.\");\n                System.err.println(\"Continuing with current values, but this may cause issues.\");\n            }\n            \n            System.out.println(\"Configuration loaded:\");\n            System.out.println(\"  - Data points: \" + config.dataPoints);\n            System.out.println(\"  - Warmup points: \" + config.warmupDataPoints);\n            System.out.println(\"  - Combo signal threshold: \" + config.comboSignalThreshold);\n            System.out.println();\n            \n            SpikeAnalysisConfig spikeConfig = new SpikeAnalysisConfig();\n            spikeConfig.rollingWindowHours = 24;\n            spikeConfig.statisticalThreshold = 2.0;\n            spikeConfig.spikeCooldownStddevThreshold = config.spikeCooldownStddevThreshold;\n            spikeConfig.warmupDataPoints = config.warmupDataPoints;  // Use user-configured warmup value\n            \n            SpikeAnalyzer analyzer = new SpikeAnalyzer(spikeConfig);\n            System.out.println(\"Spike analyzer initialized\");\n            \n            String refreshToken = \"\";\n            if (args.length > 0) {\n                refreshToken = args[0];\n            }\n            \n            QuestradeClient questradeClient = new QuestradeClient(refreshToken);\n            System.out.println(\"Questrade client initialized\");\n            System.out.println();\n            \n            // FIX: Initialize NotificationService for trade alerts\n            try {\n                notificationService = new NotificationService();\n                notificationService.initialize();\n                System.out.println(\"Notification service initialized\");\n                tradingService = new TradingServiceImpl(questradeClient, analyzer, configValidator, notificationService);\n            } catch (Exception e) {\n                System.err.println(\"WARNING: Failed to initialize NotificationService: \" + e.getMessage());\n                System.err.println(\"Continuing without notifications...\");\n                tradingService = new TradingServiceImpl(questradeClient, analyzer, configValidator);\n            }\n            \n            int port = 50051;\n            server = ServerBuilder.forPort(port)\n                .addService(tradingService)\n                .build()\n                .start();\n            \n            System.out.println(\" gRPC server listening on localhost:\" + port);\n            System.out.println(\"Backend ready. Waiting for gRPC connections...\");\n            System.out.println(\"Press Ctrl+C to stop\");\n            System.out.println();\n            \n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                System.err.println();\n                System.err.println(\"Shutdown signal received, stopping server...\");\n                BackendServer.this.stop();\n                System.err.println(\"Server stopped gracefully\");\n            }));\n            \n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to start server\", e);\n        }\n    }\n    \n    public void stop() {\n        if (tradingService != null) {\n            tradingService.shutdown();\n        }\n        if (notificationService != null) {\n            notificationService.shutdown();\n        }\n        if (server != null) {\n            server.shutdown();\n        }\n    }\n    \n    public void blockUntilShutdown() {\n        if (server != null) {\n            try {\n                server.awaitTermination();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n}\n","size_bytes":5003},"build/extracted-include-protos/test/google/protobuf/api.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\nimport \"google/protobuf/source_context.proto\";\nimport \"google/protobuf/type.proto\";\n\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"ApiProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\noption go_package = \"google.golang.org/protobuf/types/known/apipb\";\n\n// Api is a light-weight descriptor for an API Interface.\n//\n// Interfaces are also described as \"protocol buffer services\" in some contexts,\n// such as by the \"service\" keyword in a .proto file, but they are different\n// from API Services, which represent a concrete implementation of an interface\n// as opposed to simply a description of methods and bindings. They are also\n// sometimes simply referred to as \"APIs\" in other contexts, such as the name of\n// this message itself. See https://cloud.google.com/apis/design/glossary for\n// detailed terminology.\nmessage Api {\n  // The fully qualified name of this interface, including package name\n  // followed by the interface's simple name.\n  string name = 1;\n\n  // The methods of this interface, in unspecified order.\n  repeated Method methods = 2;\n\n  // Any metadata attached to the interface.\n  repeated Option options = 3;\n\n  // A version string for this interface. If specified, must have the form\n  // `major-version.minor-version`, as in `1.10`. If the minor version is\n  // omitted, it defaults to zero. If the entire version field is empty, the\n  // major version is derived from the package name, as outlined below. If the\n  // field is not empty, the version in the package name will be verified to be\n  // consistent with what is provided here.\n  //\n  // The versioning schema uses [semantic\n  // versioning](http://semver.org) where the major version number\n  // indicates a breaking change and the minor version an additive,\n  // non-breaking change. Both version numbers are signals to users\n  // what to expect from different versions, and should be carefully\n  // chosen based on the product plan.\n  //\n  // The major version is also reflected in the package name of the\n  // interface, which must end in `v<major-version>`, as in\n  // `google.feature.v1`. For major versions 0 and 1, the suffix can\n  // be omitted. Zero major versions must only be used for\n  // experimental, non-GA interfaces.\n  //\n  string version = 4;\n\n  // Source context for the protocol buffer service represented by this\n  // message.\n  SourceContext source_context = 5;\n\n  // Included interfaces. See [Mixin][].\n  repeated Mixin mixins = 6;\n\n  // The source syntax of the service.\n  Syntax syntax = 7;\n}\n\n// Method represents a method of an API interface.\nmessage Method {\n  // The simple name of this method.\n  string name = 1;\n\n  // A URL of the input message type.\n  string request_type_url = 2;\n\n  // If true, the request is streamed.\n  bool request_streaming = 3;\n\n  // The URL of the output message type.\n  string response_type_url = 4;\n\n  // If true, the response is streamed.\n  bool response_streaming = 5;\n\n  // Any metadata attached to the method.\n  repeated Option options = 6;\n\n  // The source syntax of this method.\n  Syntax syntax = 7;\n}\n\n// Declares an API Interface to be included in this interface. The including\n// interface must redeclare all the methods from the included interface, but\n// documentation and options are inherited as follows:\n//\n// - If after comment and whitespace stripping, the documentation\n//   string of the redeclared method is empty, it will be inherited\n//   from the original method.\n//\n// - Each annotation belonging to the service config (http,\n//   visibility) which is not set in the redeclared method will be\n//   inherited.\n//\n// - If an http annotation is inherited, the path pattern will be\n//   modified as follows. Any version prefix will be replaced by the\n//   version of the including interface plus the [root][] path if\n//   specified.\n//\n// Example of a simple mixin:\n//\n//     package google.acl.v1;\n//     service AccessControl {\n//       // Get the underlying ACL object.\n//       rpc GetAcl(GetAclRequest) returns (Acl) {\n//         option (google.api.http).get = \"/v1/{resource=**}:getAcl\";\n//       }\n//     }\n//\n//     package google.storage.v2;\n//     service Storage {\n//       rpc GetAcl(GetAclRequest) returns (Acl);\n//\n//       // Get a data record.\n//       rpc GetData(GetDataRequest) returns (Data) {\n//         option (google.api.http).get = \"/v2/{resource=**}\";\n//       }\n//     }\n//\n// Example of a mixin configuration:\n//\n//     apis:\n//     - name: google.storage.v2.Storage\n//       mixins:\n//       - name: google.acl.v1.AccessControl\n//\n// The mixin construct implies that all methods in `AccessControl` are\n// also declared with same name and request/response types in\n// `Storage`. A documentation generator or annotation processor will\n// see the effective `Storage.GetAcl` method after inherting\n// documentation and annotations as follows:\n//\n//     service Storage {\n//       // Get the underlying ACL object.\n//       rpc GetAcl(GetAclRequest) returns (Acl) {\n//         option (google.api.http).get = \"/v2/{resource=**}:getAcl\";\n//       }\n//       ...\n//     }\n//\n// Note how the version in the path pattern changed from `v1` to `v2`.\n//\n// If the `root` field in the mixin is specified, it should be a\n// relative path under which inherited HTTP paths are placed. Example:\n//\n//     apis:\n//     - name: google.storage.v2.Storage\n//       mixins:\n//       - name: google.acl.v1.AccessControl\n//         root: acls\n//\n// This implies the following inherited HTTP annotation:\n//\n//     service Storage {\n//       // Get the underlying ACL object.\n//       rpc GetAcl(GetAclRequest) returns (Acl) {\n//         option (google.api.http).get = \"/v2/acls/{resource=**}:getAcl\";\n//       }\n//       ...\n//     }\nmessage Mixin {\n  // The fully qualified name of the interface which is included.\n  string name = 1;\n\n  // If non-empty specifies a path under which inherited HTTP paths\n  // are rooted.\n  string root = 2;\n}\n","size_bytes":7728},"build/resources/main/config.proto":{"content":"syntax = \"proto3\";\n\npackage spiketrade.proto;\n\noption java_package = \"com.spiketrade.proto\";\noption java_outer_classname = \"ConfigProto\";\n\n// Trading configuration\nmessage TradingConfig {\n  // Window parameters\n  int32 buy_period_minutes = 1;\n  int32 bb_length_minutes = 2;\n  int32 rsi_length_minutes = 3;\n  int32 price_roc_period_minutes = 4;\n  int32 obv_roc_period_minutes = 5;\n  int32 mfi_period_minutes = 6;\n  int32 mfi_roc_period_minutes = 7;\n  int32 vwap_period_minutes = 8;\n  int32 data_points = 9;\n  int32 warmup_data_points = 10;\n  \n  // Spike ROC Threshold parameters (Z-score based)\n  double spike_price_roc_z_threshold = 20;\n  double spike_rsi_roc_z_threshold = 21;\n  double spike_obv_roc_z_threshold = 22;\n  double spike_mfi_roc_z_threshold = 23;\n  double spike_percent_b_roc_z_threshold = 24;\n  double spike_vwap_roc_z_threshold = 25;\n  double spike_volume_roc_z_threshold = 26;\n  \n  // Regular ROC Threshold parameters (absolute %)\n  double regular_price_roc_threshold = 31;\n  double regular_rsi_roc_threshold = 32;\n  double regular_obv_roc_threshold = 33;\n  double regular_mfi_roc_threshold = 34;\n  double regular_percent_b_roc_threshold = 35;\n  double regular_vwap_roc_threshold = 36;\n  double regular_volume_roc_threshold = 37;\n  \n  // Regular ROC Period parameters (minutes)\n  int32 regular_price_roc_period = 60;\n  int32 regular_rsi_roc_period = 61;\n  int32 regular_obv_roc_period = 62;\n  int32 regular_mfi_roc_period = 63;\n  int32 regular_percent_b_roc_period = 64;\n  int32 regular_vwap_roc_period = 65;\n  int32 regular_volume_roc_period = 66;\n  \n  double combo_signal_threshold = 27;\n  double high_prob_threshold = 28;\n  double stop_loss_pct = 29;\n  double spike_cooldown_stddev_threshold = 30;\n  \n  // Trading parameters\n  double equity_per_trade = 40;\n  double max_open_trades = 41;\n  double total_equity_available = 42;\n  \n  // Boolean flags\n  bool enable_price_roc_spike = 50;\n  bool enable_rsi_roc_spike = 51;\n  bool enable_obv_roc_spike = 52;\n  bool enable_mfi_roc_spike = 53;\n  bool enable_percent_b_roc_spike = 54;\n  bool enable_vwap_roc_spike = 55;\n  bool use_ml_spikes = 56;\n  bool enable_cooldowns = 57;\n  bool enable_adx_indicator = 58;\n  bool enable_volume_roc_spike = 59;\n  \n  // NEW PENNY STOCK INDICATORS\n  // Enable/disable flags\n  bool enable_macd_histogram_roc = 70;  // Predictive MACD histogram rate-of-change\n  bool enable_stochastic_indicator = 71;\n  bool enable_rvol_indicator = 72;\n  bool enable_ema_indicator = 73;\n  bool enable_ema_trend_filter = 74;\n  \n  // MACD periods (optimized for volatile 1-min candles)\n  int32 macd_fast_period = 80;\n  int32 macd_slow_period = 81;\n  int32 macd_signal_period = 82;\n  \n  // MACD Histogram ROC threshold (as % of price) - predictive convergence detection\n  double macd_histogram_roc_threshold = 83;\n  \n  // Stochastic periods and thresholds\n  int32 stochastic_period = 85;\n  int32 stochastic_k_smooth = 86;\n  int32 stochastic_d_smooth = 87;\n  double stochastic_oversold_threshold = 88;\n  double stochastic_overbought_threshold = 89;\n  \n  // Relative Volume (RVOL) settings\n  int32 rvol_period = 90;\n  double rvol_threshold = 91;\n  \n  // EMA periods\n  int32 ema9_period = 95;\n  int32 ema20_period = 96;\n  int32 ema50_period = 97;\n  \n  // Volume spike detection\n  double volume_spike_threshold = 98;\n  \n  // Timeframe multiplier for candle aggregation (1=1min, 10=10min, 30=30min, 60=1hour, 180=3hours)\n  // This tells the backend what timeframe to aggregate candles into before analysis\n  int32 timeframe_multiplier = 99;\n}\n\n// Configuration update request\nmessage ConfigUpdateRequest {\n  TradingConfig config = 1;\n}\n\n// Configuration response\nmessage ConfigResponse {\n  bool success = 1;\n  string message = 2;\n  TradingConfig current_config = 3;\n}\n","size_bytes":3736},"build/extracted-include-protos/main/google/api/log.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/api/label.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"LogProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// A description of a log type. Example in YAML format:\n//\n//     - name: library.googleapis.com/activity_history\n//       description: The history of borrowing and returning library items.\n//       display_name: Activity\n//       labels:\n//       - key: /customer_id\n//         description: Identifier of a library customer\nmessage LogDescriptor {\n  // The name of the log. It must be less than 512 characters long and can\n  // include the following characters: upper- and lower-case alphanumeric\n  // characters [A-Za-z0-9], and punctuation characters including\n  // slash, underscore, hyphen, period [/_-.].\n  string name = 1;\n\n  // The set of labels that are available to describe a specific log entry.\n  // Runtime requests that contain labels not specified here are\n  // considered invalid.\n  repeated LabelDescriptor labels = 2;\n\n  // A human-readable description of this log. This information appears in\n  // the documentation and can contain details.\n  string description = 3;\n\n  // The human-readable name for this log. This information appears on\n  // the user interface and should be concise.\n  string display_name = 4;\n}\n","size_bytes":2043},"build/extracted-include-protos/main/google/api/service.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/api/auth.proto\";\nimport \"google/api/backend.proto\";\nimport \"google/api/billing.proto\";\nimport \"google/api/client.proto\";\nimport \"google/api/context.proto\";\nimport \"google/api/control.proto\";\nimport \"google/api/documentation.proto\";\nimport \"google/api/endpoint.proto\";\nimport \"google/api/http.proto\";\nimport \"google/api/log.proto\";\nimport \"google/api/logging.proto\";\nimport \"google/api/metric.proto\";\nimport \"google/api/monitored_resource.proto\";\nimport \"google/api/monitoring.proto\";\nimport \"google/api/quota.proto\";\nimport \"google/api/source_info.proto\";\nimport \"google/api/system_parameter.proto\";\nimport \"google/api/usage.proto\";\nimport \"google/protobuf/api.proto\";\nimport \"google/protobuf/type.proto\";\nimport \"google/protobuf/wrappers.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"ServiceProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Service` is the root object of Google API service configuration (service\n// config). It describes the basic information about a logical service,\n// such as the service name and the user-facing title, and delegates other\n// aspects to sub-sections. Each sub-section is either a proto message or a\n// repeated proto message that configures a specific aspect, such as auth.\n// For more information, see each proto message definition.\n//\n// Example:\n//\n//     type: google.api.Service\n//     name: calendar.googleapis.com\n//     title: Google Calendar API\n//     apis:\n//     - name: google.calendar.v3.Calendar\n//\n//     visibility:\n//       rules:\n//       - selector: \"google.calendar.v3.*\"\n//         restriction: PREVIEW\n//     backend:\n//       rules:\n//       - selector: \"google.calendar.v3.*\"\n//         address: calendar.example.com\n//\n//     authentication:\n//       providers:\n//       - id: google_calendar_auth\n//         jwks_uri: https://www.googleapis.com/oauth2/v1/certs\n//         issuer: https://securetoken.google.com\n//       rules:\n//       - selector: \"*\"\n//         requirements:\n//           provider_id: google_calendar_auth\nmessage Service {\n  // The service name, which is a DNS-like logical identifier for the\n  // service, such as `calendar.googleapis.com`. The service name\n  // typically goes through DNS verification to make sure the owner\n  // of the service also owns the DNS name.\n  string name = 1;\n\n  // The product title for this service, it is the name displayed in Google\n  // Cloud Console.\n  string title = 2;\n\n  // The Google project that owns this service.\n  string producer_project_id = 22;\n\n  // A unique ID for a specific instance of this message, typically assigned\n  // by the client for tracking purpose. Must be no longer than 63 characters\n  // and only lower case letters, digits, '.', '_' and '-' are allowed. If\n  // empty, the server may choose to generate one instead.\n  string id = 33;\n\n  // A list of API interfaces exported by this service. Only the `name` field\n  // of the [google.protobuf.Api][google.protobuf.Api] needs to be provided by\n  // the configuration author, as the remaining fields will be derived from the\n  // IDL during the normalization process. It is an error to specify an API\n  // interface here which cannot be resolved against the associated IDL files.\n  repeated google.protobuf.Api apis = 3;\n\n  // A list of all proto message types included in this API service.\n  // Types referenced directly or indirectly by the `apis` are automatically\n  // included.  Messages which are not referenced but shall be included, such as\n  // types used by the `google.protobuf.Any` type, should be listed here by\n  // name by the configuration author. Example:\n  //\n  //     types:\n  //     - name: google.protobuf.Int32\n  repeated google.protobuf.Type types = 4;\n\n  // A list of all enum types included in this API service.  Enums referenced\n  // directly or indirectly by the `apis` are automatically included.  Enums\n  // which are not referenced but shall be included should be listed here by\n  // name by the configuration author. Example:\n  //\n  //     enums:\n  //     - name: google.someapi.v1.SomeEnum\n  repeated google.protobuf.Enum enums = 5;\n\n  // Additional API documentation.\n  Documentation documentation = 6;\n\n  // API backend configuration.\n  Backend backend = 8;\n\n  // HTTP configuration.\n  Http http = 9;\n\n  // Quota configuration.\n  Quota quota = 10;\n\n  // Auth configuration.\n  Authentication authentication = 11;\n\n  // Context configuration.\n  Context context = 12;\n\n  // Configuration controlling usage of this service.\n  Usage usage = 15;\n\n  // Configuration for network endpoints.  If this is empty, then an endpoint\n  // with the same name as the service is automatically generated to service all\n  // defined APIs.\n  repeated Endpoint endpoints = 18;\n\n  // Configuration for the service control plane.\n  Control control = 21;\n\n  // Defines the logs used by this service.\n  repeated LogDescriptor logs = 23;\n\n  // Defines the metrics used by this service.\n  repeated MetricDescriptor metrics = 24;\n\n  // Defines the monitored resources used by this service. This is required\n  // by the [Service.monitoring][google.api.Service.monitoring] and\n  // [Service.logging][google.api.Service.logging] configurations.\n  repeated MonitoredResourceDescriptor monitored_resources = 25;\n\n  // Billing configuration.\n  Billing billing = 26;\n\n  // Logging configuration.\n  Logging logging = 27;\n\n  // Monitoring configuration.\n  Monitoring monitoring = 28;\n\n  // System parameter configuration.\n  SystemParameters system_parameters = 29;\n\n  // Output only. The source information for this configuration if available.\n  SourceInfo source_info = 37;\n\n  // Settings for [Google Cloud Client\n  // libraries](https://cloud.google.com/apis/docs/cloud-client-libraries)\n  // generated from APIs defined as protocol buffers.\n  Publishing publishing = 45;\n\n  // Obsolete. Do not use.\n  //\n  // This field has no semantic meaning. The service config compiler always\n  // sets this field to `3`.\n  google.protobuf.UInt32Value config_version = 20;\n}\n","size_bytes":6762},"build/extracted-include-protos/main/google/api/distribution.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/any.proto\";\nimport \"google/protobuf/timestamp.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/distribution;distribution\";\noption java_multiple_files = true;\noption java_outer_classname = \"DistributionProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Distribution` contains summary statistics for a population of values. It\n// optionally contains a histogram representing the distribution of those values\n// across a set of buckets.\n//\n// The summary statistics are the count, mean, sum of the squared deviation from\n// the mean, the minimum, and the maximum of the set of population of values.\n// The histogram is based on a sequence of buckets and gives a count of values\n// that fall into each bucket. The boundaries of the buckets are given either\n// explicitly or by formulas for buckets of fixed or exponentially increasing\n// widths.\n//\n// Although it is not forbidden, it is generally a bad idea to include\n// non-finite values (infinities or NaNs) in the population of values, as this\n// will render the `mean` and `sum_of_squared_deviation` fields meaningless.\nmessage Distribution {\n  // The range of the population values.\n  message Range {\n    // The minimum of the population values.\n    double min = 1;\n\n    // The maximum of the population values.\n    double max = 2;\n  }\n\n  // `BucketOptions` describes the bucket boundaries used to create a histogram\n  // for the distribution. The buckets can be in a linear sequence, an\n  // exponential sequence, or each bucket can be specified explicitly.\n  // `BucketOptions` does not include the number of values in each bucket.\n  //\n  // A bucket has an inclusive lower bound and exclusive upper bound for the\n  // values that are counted for that bucket. The upper bound of a bucket must\n  // be strictly greater than the lower bound. The sequence of N buckets for a\n  // distribution consists of an underflow bucket (number 0), zero or more\n  // finite buckets (number 1 through N - 2) and an overflow bucket (number N -\n  // 1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the\n  // same as the upper bound of bucket i - 1. The buckets span the whole range\n  // of finite values: lower bound of the underflow bucket is -infinity and the\n  // upper bound of the overflow bucket is +infinity. The finite buckets are\n  // so-called because both bounds are finite.\n  message BucketOptions {\n    // Specifies a linear sequence of buckets that all have the same width\n    // (except overflow and underflow). Each bucket represents a constant\n    // absolute uncertainty on the specific value in the bucket.\n    //\n    // There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the\n    // following boundaries:\n    //\n    //    Upper bound (0 <= i < N-1):     offset + (width * i).\n    //\n    //    Lower bound (1 <= i < N):       offset + (width * (i - 1)).\n    message Linear {\n      // Must be greater than 0.\n      int32 num_finite_buckets = 1;\n\n      // Must be greater than 0.\n      double width = 2;\n\n      // Lower bound of the first bucket.\n      double offset = 3;\n    }\n\n    // Specifies an exponential sequence of buckets that have a width that is\n    // proportional to the value of the lower bound. Each bucket represents a\n    // constant relative uncertainty on a specific value in the bucket.\n    //\n    // There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the\n    // following boundaries:\n    //\n    //    Upper bound (0 <= i < N-1):     scale * (growth_factor ^ i).\n    //\n    //    Lower bound (1 <= i < N):       scale * (growth_factor ^ (i - 1)).\n    message Exponential {\n      // Must be greater than 0.\n      int32 num_finite_buckets = 1;\n\n      // Must be greater than 1.\n      double growth_factor = 2;\n\n      // Must be greater than 0.\n      double scale = 3;\n    }\n\n    // Specifies a set of buckets with arbitrary widths.\n    //\n    // There are `size(bounds) + 1` (= N) buckets. Bucket `i` has the following\n    // boundaries:\n    //\n    //    Upper bound (0 <= i < N-1):     bounds[i]\n    //    Lower bound (1 <= i < N);       bounds[i - 1]\n    //\n    // The `bounds` field must contain at least one element. If `bounds` has\n    // only one element, then there are no finite buckets, and that single\n    // element is the common boundary of the overflow and underflow buckets.\n    message Explicit {\n      // The values must be monotonically increasing.\n      repeated double bounds = 1;\n    }\n\n    // Exactly one of these three fields must be set.\n    oneof options {\n      // The linear bucket.\n      Linear linear_buckets = 1;\n\n      // The exponential buckets.\n      Exponential exponential_buckets = 2;\n\n      // The explicit buckets.\n      Explicit explicit_buckets = 3;\n    }\n  }\n\n  // Exemplars are example points that may be used to annotate aggregated\n  // distribution values. They are metadata that gives information about a\n  // particular value added to a Distribution bucket, such as a trace ID that\n  // was active when a value was added. They may contain further information,\n  // such as a example values and timestamps, origin, etc.\n  message Exemplar {\n    // Value of the exemplar point. This value determines to which bucket the\n    // exemplar belongs.\n    double value = 1;\n\n    // The observation (sampling) time of the above value.\n    google.protobuf.Timestamp timestamp = 2;\n\n    // Contextual information about the example value. Examples are:\n    //\n    //   Trace: type.googleapis.com/google.monitoring.v3.SpanContext\n    //\n    //   Literal string: type.googleapis.com/google.protobuf.StringValue\n    //\n    //   Labels dropped during aggregation:\n    //     type.googleapis.com/google.monitoring.v3.DroppedLabels\n    //\n    // There may be only a single attachment of any given message type in a\n    // single exemplar, and this is enforced by the system.\n    repeated google.protobuf.Any attachments = 3;\n  }\n\n  // The number of values in the population. Must be non-negative. This value\n  // must equal the sum of the values in `bucket_counts` if a histogram is\n  // provided.\n  int64 count = 1;\n\n  // The arithmetic mean of the values in the population. If `count` is zero\n  // then this field must be zero.\n  double mean = 2;\n\n  // The sum of squared deviations from the mean of the values in the\n  // population. For values x_i this is:\n  //\n  //     Sum[i=1..n]((x_i - mean)^2)\n  //\n  // Knuth, \"The Art of Computer Programming\", Vol. 2, page 232, 3rd edition\n  // describes Welford's method for accumulating this sum in one pass.\n  //\n  // If `count` is zero then this field must be zero.\n  double sum_of_squared_deviation = 3;\n\n  // If specified, contains the range of the population values. The field\n  // must not be present if the `count` is zero.\n  Range range = 4;\n\n  // Defines the histogram bucket boundaries. If the distribution does not\n  // contain a histogram, then omit this field.\n  BucketOptions bucket_options = 6;\n\n  // The number of values in each bucket of the histogram, as described in\n  // `bucket_options`. If the distribution does not have a histogram, then omit\n  // this field. If there is a histogram, then the sum of the values in\n  // `bucket_counts` must equal the value in the `count` field of the\n  // distribution.\n  //\n  // If present, `bucket_counts` should contain N values, where N is the number\n  // of buckets specified in `bucket_options`. If you supply fewer than N\n  // values, the remaining values are assumed to be 0.\n  //\n  // The order of the values in `bucket_counts` follows the bucket numbering\n  // schemes described for the three bucket types. The first value must be the\n  // count for the underflow bucket (number 0). The next N-2 values are the\n  // counts for the finite buckets (number 1 through N-2). The N'th value in\n  // `bucket_counts` is the count for the overflow bucket (number N-1).\n  repeated int64 bucket_counts = 7;\n\n  // Must be in increasing order of `value` field.\n  repeated Exemplar exemplars = 10;\n}\n","size_bytes":8660},"build/generated/source/proto/main/java/com/spiketrade/proto/TradingServiceProto.java":{"content":"// Generated by the protocol buffer compiler.  DO NOT EDIT!\n// source: trading_service.proto\n\n// Protobuf Java Version: 3.25.1\npackage com.spiketrade.proto;\n\npublic final class TradingServiceProto {\n  private TradingServiceProto() {}\n  public static void registerAllExtensions(\n      com.google.protobuf.ExtensionRegistryLite registry) {\n  }\n\n  public static void registerAllExtensions(\n      com.google.protobuf.ExtensionRegistry registry) {\n    registerAllExtensions(\n        (com.google.protobuf.ExtensionRegistryLite) registry);\n  }\n  public interface ConnectRequestOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.ConnectRequest)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>string questrade_token = 1;</code>\n     * @return The questradeToken.\n     */\n    java.lang.String getQuestradeToken();\n    /**\n     * <code>string questrade_token = 1;</code>\n     * @return The bytes for questradeToken.\n     */\n    com.google.protobuf.ByteString\n        getQuestradeTokenBytes();\n  }\n  /**\n   * <pre>\n   * Request/Response messages\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.ConnectRequest}\n   */\n  public static final class ConnectRequest extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.ConnectRequest)\n      ConnectRequestOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use ConnectRequest.newBuilder() to construct.\n    private ConnectRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private ConnectRequest() {\n      questradeToken_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new ConnectRequest();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConnectRequest_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConnectRequest_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.ConnectRequest.class, com.spiketrade.proto.TradingServiceProto.ConnectRequest.Builder.class);\n    }\n\n    public static final int QUESTRADE_TOKEN_FIELD_NUMBER = 1;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object questradeToken_ = \"\";\n    /**\n     * <code>string questrade_token = 1;</code>\n     * @return The questradeToken.\n     */\n    @java.lang.Override\n    public java.lang.String getQuestradeToken() {\n      java.lang.Object ref = questradeToken_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        questradeToken_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string questrade_token = 1;</code>\n     * @return The bytes for questradeToken.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getQuestradeTokenBytes() {\n      java.lang.Object ref = questradeToken_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        questradeToken_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(questradeToken_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, questradeToken_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(questradeToken_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, questradeToken_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.ConnectRequest)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.ConnectRequest other = (com.spiketrade.proto.TradingServiceProto.ConnectRequest) obj;\n\n      if (!getQuestradeToken()\n          .equals(other.getQuestradeToken())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + QUESTRADE_TOKEN_FIELD_NUMBER;\n      hash = (53 * hash) + getQuestradeToken().hashCode();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.ConnectRequest parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectRequest parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectRequest parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectRequest parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectRequest parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectRequest parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectRequest parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectRequest parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.ConnectRequest parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.ConnectRequest parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectRequest parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectRequest parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.ConnectRequest prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Request/Response messages\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.ConnectRequest}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.ConnectRequest)\n        com.spiketrade.proto.TradingServiceProto.ConnectRequestOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConnectRequest_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConnectRequest_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.TradingServiceProto.ConnectRequest.class, com.spiketrade.proto.TradingServiceProto.ConnectRequest.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.TradingServiceProto.ConnectRequest.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        questradeToken_ = \"\";\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConnectRequest_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.ConnectRequest getDefaultInstanceForType() {\n        return com.spiketrade.proto.TradingServiceProto.ConnectRequest.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.ConnectRequest build() {\n        com.spiketrade.proto.TradingServiceProto.ConnectRequest result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.ConnectRequest buildPartial() {\n        com.spiketrade.proto.TradingServiceProto.ConnectRequest result = new com.spiketrade.proto.TradingServiceProto.ConnectRequest(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.TradingServiceProto.ConnectRequest result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.questradeToken_ = questradeToken_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.TradingServiceProto.ConnectRequest) {\n          return mergeFrom((com.spiketrade.proto.TradingServiceProto.ConnectRequest)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.TradingServiceProto.ConnectRequest other) {\n        if (other == com.spiketrade.proto.TradingServiceProto.ConnectRequest.getDefaultInstance()) return this;\n        if (!other.getQuestradeToken().isEmpty()) {\n          questradeToken_ = other.questradeToken_;\n          bitField0_ |= 0x00000001;\n          onChanged();\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 10: {\n                questradeToken_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 10\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private java.lang.Object questradeToken_ = \"\";\n      /**\n       * <code>string questrade_token = 1;</code>\n       * @return The questradeToken.\n       */\n      public java.lang.String getQuestradeToken() {\n        java.lang.Object ref = questradeToken_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          questradeToken_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string questrade_token = 1;</code>\n       * @return The bytes for questradeToken.\n       */\n      public com.google.protobuf.ByteString\n          getQuestradeTokenBytes() {\n        java.lang.Object ref = questradeToken_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          questradeToken_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string questrade_token = 1;</code>\n       * @param value The questradeToken to set.\n       * @return This builder for chaining.\n       */\n      public Builder setQuestradeToken(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        questradeToken_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string questrade_token = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearQuestradeToken() {\n        questradeToken_ = getDefaultInstance().getQuestradeToken();\n        bitField0_ = (bitField0_ & ~0x00000001);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string questrade_token = 1;</code>\n       * @param value The bytes for questradeToken to set.\n       * @return This builder for chaining.\n       */\n      public Builder setQuestradeTokenBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        questradeToken_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.ConnectRequest)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.ConnectRequest)\n    private static final com.spiketrade.proto.TradingServiceProto.ConnectRequest DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.TradingServiceProto.ConnectRequest();\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.ConnectRequest getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<ConnectRequest>\n        PARSER = new com.google.protobuf.AbstractParser<ConnectRequest>() {\n      @java.lang.Override\n      public ConnectRequest parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<ConnectRequest> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<ConnectRequest> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.ConnectRequest getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface ConnectResponseOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.ConnectResponse)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>bool success = 1;</code>\n     * @return The success.\n     */\n    boolean getSuccess();\n\n    /**\n     * <code>string message = 2;</code>\n     * @return The message.\n     */\n    java.lang.String getMessage();\n    /**\n     * <code>string message = 2;</code>\n     * @return The bytes for message.\n     */\n    com.google.protobuf.ByteString\n        getMessageBytes();\n\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n     * @return Whether the status field is set.\n     */\n    boolean hasStatus();\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n     * @return The status.\n     */\n    com.spiketrade.proto.MarketDataProto.ConnectionStatus getStatus();\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n     */\n    com.spiketrade.proto.MarketDataProto.ConnectionStatusOrBuilder getStatusOrBuilder();\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.ConnectResponse}\n   */\n  public static final class ConnectResponse extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.ConnectResponse)\n      ConnectResponseOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use ConnectResponse.newBuilder() to construct.\n    private ConnectResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private ConnectResponse() {\n      message_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new ConnectResponse();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConnectResponse_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConnectResponse_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.ConnectResponse.class, com.spiketrade.proto.TradingServiceProto.ConnectResponse.Builder.class);\n    }\n\n    private int bitField0_;\n    public static final int SUCCESS_FIELD_NUMBER = 1;\n    private boolean success_ = false;\n    /**\n     * <code>bool success = 1;</code>\n     * @return The success.\n     */\n    @java.lang.Override\n    public boolean getSuccess() {\n      return success_;\n    }\n\n    public static final int MESSAGE_FIELD_NUMBER = 2;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object message_ = \"\";\n    /**\n     * <code>string message = 2;</code>\n     * @return The message.\n     */\n    @java.lang.Override\n    public java.lang.String getMessage() {\n      java.lang.Object ref = message_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        message_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string message = 2;</code>\n     * @return The bytes for message.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getMessageBytes() {\n      java.lang.Object ref = message_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        message_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int STATUS_FIELD_NUMBER = 3;\n    private com.spiketrade.proto.MarketDataProto.ConnectionStatus status_;\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n     * @return Whether the status field is set.\n     */\n    @java.lang.Override\n    public boolean hasStatus() {\n      return ((bitField0_ & 0x00000001) != 0);\n    }\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n     * @return The status.\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.ConnectionStatus getStatus() {\n      return status_ == null ? com.spiketrade.proto.MarketDataProto.ConnectionStatus.getDefaultInstance() : status_;\n    }\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.ConnectionStatusOrBuilder getStatusOrBuilder() {\n      return status_ == null ? com.spiketrade.proto.MarketDataProto.ConnectionStatus.getDefaultInstance() : status_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (success_ != false) {\n        output.writeBool(1, success_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(message_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, message_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        output.writeMessage(3, getStatus());\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (success_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(1, success_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(message_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, message_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(3, getStatus());\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.ConnectResponse)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.ConnectResponse other = (com.spiketrade.proto.TradingServiceProto.ConnectResponse) obj;\n\n      if (getSuccess()\n          != other.getSuccess()) return false;\n      if (!getMessage()\n          .equals(other.getMessage())) return false;\n      if (hasStatus() != other.hasStatus()) return false;\n      if (hasStatus()) {\n        if (!getStatus()\n            .equals(other.getStatus())) return false;\n      }\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + SUCCESS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getSuccess());\n      hash = (37 * hash) + MESSAGE_FIELD_NUMBER;\n      hash = (53 * hash) + getMessage().hashCode();\n      if (hasStatus()) {\n        hash = (37 * hash) + STATUS_FIELD_NUMBER;\n        hash = (53 * hash) + getStatus().hashCode();\n      }\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.ConnectResponse parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectResponse parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectResponse parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectResponse parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectResponse parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectResponse parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectResponse parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectResponse parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.ConnectResponse parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.ConnectResponse parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectResponse parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConnectResponse parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.ConnectResponse prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.ConnectResponse}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.ConnectResponse)\n        com.spiketrade.proto.TradingServiceProto.ConnectResponseOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConnectResponse_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConnectResponse_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.TradingServiceProto.ConnectResponse.class, com.spiketrade.proto.TradingServiceProto.ConnectResponse.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.TradingServiceProto.ConnectResponse.newBuilder()\n      private Builder() {\n        maybeForceBuilderInitialization();\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n        maybeForceBuilderInitialization();\n      }\n      private void maybeForceBuilderInitialization() {\n        if (com.google.protobuf.GeneratedMessageV3\n                .alwaysUseFieldBuilders) {\n          getStatusFieldBuilder();\n        }\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        success_ = false;\n        message_ = \"\";\n        status_ = null;\n        if (statusBuilder_ != null) {\n          statusBuilder_.dispose();\n          statusBuilder_ = null;\n        }\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConnectResponse_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.ConnectResponse getDefaultInstanceForType() {\n        return com.spiketrade.proto.TradingServiceProto.ConnectResponse.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.ConnectResponse build() {\n        com.spiketrade.proto.TradingServiceProto.ConnectResponse result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.ConnectResponse buildPartial() {\n        com.spiketrade.proto.TradingServiceProto.ConnectResponse result = new com.spiketrade.proto.TradingServiceProto.ConnectResponse(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.TradingServiceProto.ConnectResponse result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.success_ = success_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.message_ = message_;\n        }\n        int to_bitField0_ = 0;\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.status_ = statusBuilder_ == null\n              ? status_\n              : statusBuilder_.build();\n          to_bitField0_ |= 0x00000001;\n        }\n        result.bitField0_ |= to_bitField0_;\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.TradingServiceProto.ConnectResponse) {\n          return mergeFrom((com.spiketrade.proto.TradingServiceProto.ConnectResponse)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.TradingServiceProto.ConnectResponse other) {\n        if (other == com.spiketrade.proto.TradingServiceProto.ConnectResponse.getDefaultInstance()) return this;\n        if (other.getSuccess() != false) {\n          setSuccess(other.getSuccess());\n        }\n        if (!other.getMessage().isEmpty()) {\n          message_ = other.message_;\n          bitField0_ |= 0x00000002;\n          onChanged();\n        }\n        if (other.hasStatus()) {\n          mergeStatus(other.getStatus());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 8: {\n                success_ = input.readBool();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 8\n              case 18: {\n                message_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 18\n              case 26: {\n                input.readMessage(\n                    getStatusFieldBuilder().getBuilder(),\n                    extensionRegistry);\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 26\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private boolean success_ ;\n      /**\n       * <code>bool success = 1;</code>\n       * @return The success.\n       */\n      @java.lang.Override\n      public boolean getSuccess() {\n        return success_;\n      }\n      /**\n       * <code>bool success = 1;</code>\n       * @param value The success to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSuccess(boolean value) {\n\n        success_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool success = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSuccess() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        success_ = false;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object message_ = \"\";\n      /**\n       * <code>string message = 2;</code>\n       * @return The message.\n       */\n      public java.lang.String getMessage() {\n        java.lang.Object ref = message_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          message_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @return The bytes for message.\n       */\n      public com.google.protobuf.ByteString\n          getMessageBytes() {\n        java.lang.Object ref = message_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          message_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @param value The message to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMessage(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        message_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMessage() {\n        message_ = getDefaultInstance().getMessage();\n        bitField0_ = (bitField0_ & ~0x00000002);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @param value The bytes for message to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMessageBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        message_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n\n      private com.spiketrade.proto.MarketDataProto.ConnectionStatus status_;\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.MarketDataProto.ConnectionStatus, com.spiketrade.proto.MarketDataProto.ConnectionStatus.Builder, com.spiketrade.proto.MarketDataProto.ConnectionStatusOrBuilder> statusBuilder_;\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n       * @return Whether the status field is set.\n       */\n      public boolean hasStatus() {\n        return ((bitField0_ & 0x00000004) != 0);\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n       * @return The status.\n       */\n      public com.spiketrade.proto.MarketDataProto.ConnectionStatus getStatus() {\n        if (statusBuilder_ == null) {\n          return status_ == null ? com.spiketrade.proto.MarketDataProto.ConnectionStatus.getDefaultInstance() : status_;\n        } else {\n          return statusBuilder_.getMessage();\n        }\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n       */\n      public Builder setStatus(com.spiketrade.proto.MarketDataProto.ConnectionStatus value) {\n        if (statusBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          status_ = value;\n        } else {\n          statusBuilder_.setMessage(value);\n        }\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n       */\n      public Builder setStatus(\n          com.spiketrade.proto.MarketDataProto.ConnectionStatus.Builder builderForValue) {\n        if (statusBuilder_ == null) {\n          status_ = builderForValue.build();\n        } else {\n          statusBuilder_.setMessage(builderForValue.build());\n        }\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n       */\n      public Builder mergeStatus(com.spiketrade.proto.MarketDataProto.ConnectionStatus value) {\n        if (statusBuilder_ == null) {\n          if (((bitField0_ & 0x00000004) != 0) &&\n            status_ != null &&\n            status_ != com.spiketrade.proto.MarketDataProto.ConnectionStatus.getDefaultInstance()) {\n            getStatusBuilder().mergeFrom(value);\n          } else {\n            status_ = value;\n          }\n        } else {\n          statusBuilder_.mergeFrom(value);\n        }\n        if (status_ != null) {\n          bitField0_ |= 0x00000004;\n          onChanged();\n        }\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n       */\n      public Builder clearStatus() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        status_ = null;\n        if (statusBuilder_ != null) {\n          statusBuilder_.dispose();\n          statusBuilder_ = null;\n        }\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n       */\n      public com.spiketrade.proto.MarketDataProto.ConnectionStatus.Builder getStatusBuilder() {\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return getStatusFieldBuilder().getBuilder();\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n       */\n      public com.spiketrade.proto.MarketDataProto.ConnectionStatusOrBuilder getStatusOrBuilder() {\n        if (statusBuilder_ != null) {\n          return statusBuilder_.getMessageOrBuilder();\n        } else {\n          return status_ == null ?\n              com.spiketrade.proto.MarketDataProto.ConnectionStatus.getDefaultInstance() : status_;\n        }\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus status = 3;</code>\n       */\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.MarketDataProto.ConnectionStatus, com.spiketrade.proto.MarketDataProto.ConnectionStatus.Builder, com.spiketrade.proto.MarketDataProto.ConnectionStatusOrBuilder> \n          getStatusFieldBuilder() {\n        if (statusBuilder_ == null) {\n          statusBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<\n              com.spiketrade.proto.MarketDataProto.ConnectionStatus, com.spiketrade.proto.MarketDataProto.ConnectionStatus.Builder, com.spiketrade.proto.MarketDataProto.ConnectionStatusOrBuilder>(\n                  getStatus(),\n                  getParentForChildren(),\n                  isClean());\n          status_ = null;\n        }\n        return statusBuilder_;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.ConnectResponse)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.ConnectResponse)\n    private static final com.spiketrade.proto.TradingServiceProto.ConnectResponse DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.TradingServiceProto.ConnectResponse();\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.ConnectResponse getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<ConnectResponse>\n        PARSER = new com.google.protobuf.AbstractParser<ConnectResponse>() {\n      @java.lang.Override\n      public ConnectResponse parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<ConnectResponse> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<ConnectResponse> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.ConnectResponse getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface StatusRequestOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.StatusRequest)\n      com.google.protobuf.MessageOrBuilder {\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.StatusRequest}\n   */\n  public static final class StatusRequest extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.StatusRequest)\n      StatusRequestOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use StatusRequest.newBuilder() to construct.\n    private StatusRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private StatusRequest() {\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new StatusRequest();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StatusRequest_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StatusRequest_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.StatusRequest.class, com.spiketrade.proto.TradingServiceProto.StatusRequest.Builder.class);\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.StatusRequest)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.StatusRequest other = (com.spiketrade.proto.TradingServiceProto.StatusRequest) obj;\n\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StatusRequest parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusRequest parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusRequest parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusRequest parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusRequest parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusRequest parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusRequest parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusRequest parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StatusRequest parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StatusRequest parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusRequest parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusRequest parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.StatusRequest prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.StatusRequest}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.StatusRequest)\n        com.spiketrade.proto.TradingServiceProto.StatusRequestOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StatusRequest_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StatusRequest_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.TradingServiceProto.StatusRequest.class, com.spiketrade.proto.TradingServiceProto.StatusRequest.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.TradingServiceProto.StatusRequest.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StatusRequest_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.StatusRequest getDefaultInstanceForType() {\n        return com.spiketrade.proto.TradingServiceProto.StatusRequest.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.StatusRequest build() {\n        com.spiketrade.proto.TradingServiceProto.StatusRequest result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.StatusRequest buildPartial() {\n        com.spiketrade.proto.TradingServiceProto.StatusRequest result = new com.spiketrade.proto.TradingServiceProto.StatusRequest(this);\n        onBuilt();\n        return result;\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.TradingServiceProto.StatusRequest) {\n          return mergeFrom((com.spiketrade.proto.TradingServiceProto.StatusRequest)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.TradingServiceProto.StatusRequest other) {\n        if (other == com.spiketrade.proto.TradingServiceProto.StatusRequest.getDefaultInstance()) return this;\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.StatusRequest)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.StatusRequest)\n    private static final com.spiketrade.proto.TradingServiceProto.StatusRequest DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.TradingServiceProto.StatusRequest();\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StatusRequest getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<StatusRequest>\n        PARSER = new com.google.protobuf.AbstractParser<StatusRequest>() {\n      @java.lang.Override\n      public StatusRequest parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<StatusRequest> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<StatusRequest> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.StatusRequest getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface StatusResponseOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.StatusResponse)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>bool is_trading = 1;</code>\n     * @return The isTrading.\n     */\n    boolean getIsTrading();\n\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n     * @return Whether the connectionStatus field is set.\n     */\n    boolean hasConnectionStatus();\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n     * @return The connectionStatus.\n     */\n    com.spiketrade.proto.MarketDataProto.ConnectionStatus getConnectionStatus();\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n     */\n    com.spiketrade.proto.MarketDataProto.ConnectionStatusOrBuilder getConnectionStatusOrBuilder();\n\n    /**\n     * <code>int32 total_signals = 3;</code>\n     * @return The totalSignals.\n     */\n    int getTotalSignals();\n\n    /**\n     * <code>int32 active_positions = 4;</code>\n     * @return The activePositions.\n     */\n    int getActivePositions();\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.StatusResponse}\n   */\n  public static final class StatusResponse extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.StatusResponse)\n      StatusResponseOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use StatusResponse.newBuilder() to construct.\n    private StatusResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private StatusResponse() {\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new StatusResponse();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StatusResponse_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StatusResponse_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.StatusResponse.class, com.spiketrade.proto.TradingServiceProto.StatusResponse.Builder.class);\n    }\n\n    private int bitField0_;\n    public static final int IS_TRADING_FIELD_NUMBER = 1;\n    private boolean isTrading_ = false;\n    /**\n     * <code>bool is_trading = 1;</code>\n     * @return The isTrading.\n     */\n    @java.lang.Override\n    public boolean getIsTrading() {\n      return isTrading_;\n    }\n\n    public static final int CONNECTION_STATUS_FIELD_NUMBER = 2;\n    private com.spiketrade.proto.MarketDataProto.ConnectionStatus connectionStatus_;\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n     * @return Whether the connectionStatus field is set.\n     */\n    @java.lang.Override\n    public boolean hasConnectionStatus() {\n      return ((bitField0_ & 0x00000001) != 0);\n    }\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n     * @return The connectionStatus.\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.ConnectionStatus getConnectionStatus() {\n      return connectionStatus_ == null ? com.spiketrade.proto.MarketDataProto.ConnectionStatus.getDefaultInstance() : connectionStatus_;\n    }\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.ConnectionStatusOrBuilder getConnectionStatusOrBuilder() {\n      return connectionStatus_ == null ? com.spiketrade.proto.MarketDataProto.ConnectionStatus.getDefaultInstance() : connectionStatus_;\n    }\n\n    public static final int TOTAL_SIGNALS_FIELD_NUMBER = 3;\n    private int totalSignals_ = 0;\n    /**\n     * <code>int32 total_signals = 3;</code>\n     * @return The totalSignals.\n     */\n    @java.lang.Override\n    public int getTotalSignals() {\n      return totalSignals_;\n    }\n\n    public static final int ACTIVE_POSITIONS_FIELD_NUMBER = 4;\n    private int activePositions_ = 0;\n    /**\n     * <code>int32 active_positions = 4;</code>\n     * @return The activePositions.\n     */\n    @java.lang.Override\n    public int getActivePositions() {\n      return activePositions_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (isTrading_ != false) {\n        output.writeBool(1, isTrading_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        output.writeMessage(2, getConnectionStatus());\n      }\n      if (totalSignals_ != 0) {\n        output.writeInt32(3, totalSignals_);\n      }\n      if (activePositions_ != 0) {\n        output.writeInt32(4, activePositions_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (isTrading_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(1, isTrading_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(2, getConnectionStatus());\n      }\n      if (totalSignals_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(3, totalSignals_);\n      }\n      if (activePositions_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(4, activePositions_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.StatusResponse)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.StatusResponse other = (com.spiketrade.proto.TradingServiceProto.StatusResponse) obj;\n\n      if (getIsTrading()\n          != other.getIsTrading()) return false;\n      if (hasConnectionStatus() != other.hasConnectionStatus()) return false;\n      if (hasConnectionStatus()) {\n        if (!getConnectionStatus()\n            .equals(other.getConnectionStatus())) return false;\n      }\n      if (getTotalSignals()\n          != other.getTotalSignals()) return false;\n      if (getActivePositions()\n          != other.getActivePositions()) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + IS_TRADING_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getIsTrading());\n      if (hasConnectionStatus()) {\n        hash = (37 * hash) + CONNECTION_STATUS_FIELD_NUMBER;\n        hash = (53 * hash) + getConnectionStatus().hashCode();\n      }\n      hash = (37 * hash) + TOTAL_SIGNALS_FIELD_NUMBER;\n      hash = (53 * hash) + getTotalSignals();\n      hash = (37 * hash) + ACTIVE_POSITIONS_FIELD_NUMBER;\n      hash = (53 * hash) + getActivePositions();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StatusResponse parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusResponse parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusResponse parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusResponse parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusResponse parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusResponse parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusResponse parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusResponse parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StatusResponse parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StatusResponse parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusResponse parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StatusResponse parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.StatusResponse prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.StatusResponse}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.StatusResponse)\n        com.spiketrade.proto.TradingServiceProto.StatusResponseOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StatusResponse_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StatusResponse_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.TradingServiceProto.StatusResponse.class, com.spiketrade.proto.TradingServiceProto.StatusResponse.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.TradingServiceProto.StatusResponse.newBuilder()\n      private Builder() {\n        maybeForceBuilderInitialization();\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n        maybeForceBuilderInitialization();\n      }\n      private void maybeForceBuilderInitialization() {\n        if (com.google.protobuf.GeneratedMessageV3\n                .alwaysUseFieldBuilders) {\n          getConnectionStatusFieldBuilder();\n        }\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        isTrading_ = false;\n        connectionStatus_ = null;\n        if (connectionStatusBuilder_ != null) {\n          connectionStatusBuilder_.dispose();\n          connectionStatusBuilder_ = null;\n        }\n        totalSignals_ = 0;\n        activePositions_ = 0;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StatusResponse_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.StatusResponse getDefaultInstanceForType() {\n        return com.spiketrade.proto.TradingServiceProto.StatusResponse.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.StatusResponse build() {\n        com.spiketrade.proto.TradingServiceProto.StatusResponse result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.StatusResponse buildPartial() {\n        com.spiketrade.proto.TradingServiceProto.StatusResponse result = new com.spiketrade.proto.TradingServiceProto.StatusResponse(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.TradingServiceProto.StatusResponse result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.isTrading_ = isTrading_;\n        }\n        int to_bitField0_ = 0;\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.connectionStatus_ = connectionStatusBuilder_ == null\n              ? connectionStatus_\n              : connectionStatusBuilder_.build();\n          to_bitField0_ |= 0x00000001;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.totalSignals_ = totalSignals_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.activePositions_ = activePositions_;\n        }\n        result.bitField0_ |= to_bitField0_;\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.TradingServiceProto.StatusResponse) {\n          return mergeFrom((com.spiketrade.proto.TradingServiceProto.StatusResponse)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.TradingServiceProto.StatusResponse other) {\n        if (other == com.spiketrade.proto.TradingServiceProto.StatusResponse.getDefaultInstance()) return this;\n        if (other.getIsTrading() != false) {\n          setIsTrading(other.getIsTrading());\n        }\n        if (other.hasConnectionStatus()) {\n          mergeConnectionStatus(other.getConnectionStatus());\n        }\n        if (other.getTotalSignals() != 0) {\n          setTotalSignals(other.getTotalSignals());\n        }\n        if (other.getActivePositions() != 0) {\n          setActivePositions(other.getActivePositions());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 8: {\n                isTrading_ = input.readBool();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 8\n              case 18: {\n                input.readMessage(\n                    getConnectionStatusFieldBuilder().getBuilder(),\n                    extensionRegistry);\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 18\n              case 24: {\n                totalSignals_ = input.readInt32();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 24\n              case 32: {\n                activePositions_ = input.readInt32();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 32\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private boolean isTrading_ ;\n      /**\n       * <code>bool is_trading = 1;</code>\n       * @return The isTrading.\n       */\n      @java.lang.Override\n      public boolean getIsTrading() {\n        return isTrading_;\n      }\n      /**\n       * <code>bool is_trading = 1;</code>\n       * @param value The isTrading to set.\n       * @return This builder for chaining.\n       */\n      public Builder setIsTrading(boolean value) {\n\n        isTrading_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool is_trading = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearIsTrading() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        isTrading_ = false;\n        onChanged();\n        return this;\n      }\n\n      private com.spiketrade.proto.MarketDataProto.ConnectionStatus connectionStatus_;\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.MarketDataProto.ConnectionStatus, com.spiketrade.proto.MarketDataProto.ConnectionStatus.Builder, com.spiketrade.proto.MarketDataProto.ConnectionStatusOrBuilder> connectionStatusBuilder_;\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n       * @return Whether the connectionStatus field is set.\n       */\n      public boolean hasConnectionStatus() {\n        return ((bitField0_ & 0x00000002) != 0);\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n       * @return The connectionStatus.\n       */\n      public com.spiketrade.proto.MarketDataProto.ConnectionStatus getConnectionStatus() {\n        if (connectionStatusBuilder_ == null) {\n          return connectionStatus_ == null ? com.spiketrade.proto.MarketDataProto.ConnectionStatus.getDefaultInstance() : connectionStatus_;\n        } else {\n          return connectionStatusBuilder_.getMessage();\n        }\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n       */\n      public Builder setConnectionStatus(com.spiketrade.proto.MarketDataProto.ConnectionStatus value) {\n        if (connectionStatusBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          connectionStatus_ = value;\n        } else {\n          connectionStatusBuilder_.setMessage(value);\n        }\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n       */\n      public Builder setConnectionStatus(\n          com.spiketrade.proto.MarketDataProto.ConnectionStatus.Builder builderForValue) {\n        if (connectionStatusBuilder_ == null) {\n          connectionStatus_ = builderForValue.build();\n        } else {\n          connectionStatusBuilder_.setMessage(builderForValue.build());\n        }\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n       */\n      public Builder mergeConnectionStatus(com.spiketrade.proto.MarketDataProto.ConnectionStatus value) {\n        if (connectionStatusBuilder_ == null) {\n          if (((bitField0_ & 0x00000002) != 0) &&\n            connectionStatus_ != null &&\n            connectionStatus_ != com.spiketrade.proto.MarketDataProto.ConnectionStatus.getDefaultInstance()) {\n            getConnectionStatusBuilder().mergeFrom(value);\n          } else {\n            connectionStatus_ = value;\n          }\n        } else {\n          connectionStatusBuilder_.mergeFrom(value);\n        }\n        if (connectionStatus_ != null) {\n          bitField0_ |= 0x00000002;\n          onChanged();\n        }\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n       */\n      public Builder clearConnectionStatus() {\n        bitField0_ = (bitField0_ & ~0x00000002);\n        connectionStatus_ = null;\n        if (connectionStatusBuilder_ != null) {\n          connectionStatusBuilder_.dispose();\n          connectionStatusBuilder_ = null;\n        }\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n       */\n      public com.spiketrade.proto.MarketDataProto.ConnectionStatus.Builder getConnectionStatusBuilder() {\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return getConnectionStatusFieldBuilder().getBuilder();\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n       */\n      public com.spiketrade.proto.MarketDataProto.ConnectionStatusOrBuilder getConnectionStatusOrBuilder() {\n        if (connectionStatusBuilder_ != null) {\n          return connectionStatusBuilder_.getMessageOrBuilder();\n        } else {\n          return connectionStatus_ == null ?\n              com.spiketrade.proto.MarketDataProto.ConnectionStatus.getDefaultInstance() : connectionStatus_;\n        }\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus connection_status = 2;</code>\n       */\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.MarketDataProto.ConnectionStatus, com.spiketrade.proto.MarketDataProto.ConnectionStatus.Builder, com.spiketrade.proto.MarketDataProto.ConnectionStatusOrBuilder> \n          getConnectionStatusFieldBuilder() {\n        if (connectionStatusBuilder_ == null) {\n          connectionStatusBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<\n              com.spiketrade.proto.MarketDataProto.ConnectionStatus, com.spiketrade.proto.MarketDataProto.ConnectionStatus.Builder, com.spiketrade.proto.MarketDataProto.ConnectionStatusOrBuilder>(\n                  getConnectionStatus(),\n                  getParentForChildren(),\n                  isClean());\n          connectionStatus_ = null;\n        }\n        return connectionStatusBuilder_;\n      }\n\n      private int totalSignals_ ;\n      /**\n       * <code>int32 total_signals = 3;</code>\n       * @return The totalSignals.\n       */\n      @java.lang.Override\n      public int getTotalSignals() {\n        return totalSignals_;\n      }\n      /**\n       * <code>int32 total_signals = 3;</code>\n       * @param value The totalSignals to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTotalSignals(int value) {\n\n        totalSignals_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 total_signals = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTotalSignals() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        totalSignals_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int activePositions_ ;\n      /**\n       * <code>int32 active_positions = 4;</code>\n       * @return The activePositions.\n       */\n      @java.lang.Override\n      public int getActivePositions() {\n        return activePositions_;\n      }\n      /**\n       * <code>int32 active_positions = 4;</code>\n       * @param value The activePositions to set.\n       * @return This builder for chaining.\n       */\n      public Builder setActivePositions(int value) {\n\n        activePositions_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 active_positions = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearActivePositions() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        activePositions_ = 0;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.StatusResponse)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.StatusResponse)\n    private static final com.spiketrade.proto.TradingServiceProto.StatusResponse DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.TradingServiceProto.StatusResponse();\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StatusResponse getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<StatusResponse>\n        PARSER = new com.google.protobuf.AbstractParser<StatusResponse>() {\n      @java.lang.Override\n      public StatusResponse parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<StatusResponse> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<StatusResponse> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.StatusResponse getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface AnalysisStatusRequestOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.AnalysisStatusRequest)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    java.lang.String getSymbol();\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    com.google.protobuf.ByteString\n        getSymbolBytes();\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.AnalysisStatusRequest}\n   */\n  public static final class AnalysisStatusRequest extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.AnalysisStatusRequest)\n      AnalysisStatusRequestOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use AnalysisStatusRequest.newBuilder() to construct.\n    private AnalysisStatusRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private AnalysisStatusRequest() {\n      symbol_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new AnalysisStatusRequest();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_AnalysisStatusRequest_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_AnalysisStatusRequest_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest.class, com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest.Builder.class);\n    }\n\n    public static final int SYMBOL_FIELD_NUMBER = 1;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object symbol_ = \"\";\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    @java.lang.Override\n    public java.lang.String getSymbol() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        symbol_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getSymbolBytes() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        symbol_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, symbol_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, symbol_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest other = (com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest) obj;\n\n      if (!getSymbol()\n          .equals(other.getSymbol())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + SYMBOL_FIELD_NUMBER;\n      hash = (53 * hash) + getSymbol().hashCode();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.AnalysisStatusRequest}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.AnalysisStatusRequest)\n        com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequestOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_AnalysisStatusRequest_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_AnalysisStatusRequest_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest.class, com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        symbol_ = \"\";\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_AnalysisStatusRequest_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest getDefaultInstanceForType() {\n        return com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest build() {\n        com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest buildPartial() {\n        com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest result = new com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.symbol_ = symbol_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest) {\n          return mergeFrom((com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest other) {\n        if (other == com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest.getDefaultInstance()) return this;\n        if (!other.getSymbol().isEmpty()) {\n          symbol_ = other.symbol_;\n          bitField0_ |= 0x00000001;\n          onChanged();\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 10: {\n                symbol_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 10\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private java.lang.Object symbol_ = \"\";\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The symbol.\n       */\n      public java.lang.String getSymbol() {\n        java.lang.Object ref = symbol_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          symbol_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The bytes for symbol.\n       */\n      public com.google.protobuf.ByteString\n          getSymbolBytes() {\n        java.lang.Object ref = symbol_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          symbol_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbol(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSymbol() {\n        symbol_ = getDefaultInstance().getSymbol();\n        bitField0_ = (bitField0_ & ~0x00000001);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The bytes for symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbolBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.AnalysisStatusRequest)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.AnalysisStatusRequest)\n    private static final com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest();\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<AnalysisStatusRequest>\n        PARSER = new com.google.protobuf.AbstractParser<AnalysisStatusRequest>() {\n      @java.lang.Override\n      public AnalysisStatusRequest parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<AnalysisStatusRequest> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<AnalysisStatusRequest> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.AnalysisStatusRequest getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface ConfigRequestOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.ConfigRequest)\n      com.google.protobuf.MessageOrBuilder {\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.ConfigRequest}\n   */\n  public static final class ConfigRequest extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.ConfigRequest)\n      ConfigRequestOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use ConfigRequest.newBuilder() to construct.\n    private ConfigRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private ConfigRequest() {\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new ConfigRequest();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConfigRequest_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConfigRequest_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.ConfigRequest.class, com.spiketrade.proto.TradingServiceProto.ConfigRequest.Builder.class);\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.ConfigRequest)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.ConfigRequest other = (com.spiketrade.proto.TradingServiceProto.ConfigRequest) obj;\n\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.ConfigRequest parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConfigRequest parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConfigRequest parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConfigRequest parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConfigRequest parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConfigRequest parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConfigRequest parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConfigRequest parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.ConfigRequest parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.ConfigRequest parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConfigRequest parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.ConfigRequest parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.ConfigRequest prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.ConfigRequest}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.ConfigRequest)\n        com.spiketrade.proto.TradingServiceProto.ConfigRequestOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConfigRequest_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConfigRequest_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.TradingServiceProto.ConfigRequest.class, com.spiketrade.proto.TradingServiceProto.ConfigRequest.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.TradingServiceProto.ConfigRequest.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_ConfigRequest_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.ConfigRequest getDefaultInstanceForType() {\n        return com.spiketrade.proto.TradingServiceProto.ConfigRequest.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.ConfigRequest build() {\n        com.spiketrade.proto.TradingServiceProto.ConfigRequest result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.ConfigRequest buildPartial() {\n        com.spiketrade.proto.TradingServiceProto.ConfigRequest result = new com.spiketrade.proto.TradingServiceProto.ConfigRequest(this);\n        onBuilt();\n        return result;\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.TradingServiceProto.ConfigRequest) {\n          return mergeFrom((com.spiketrade.proto.TradingServiceProto.ConfigRequest)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.TradingServiceProto.ConfigRequest other) {\n        if (other == com.spiketrade.proto.TradingServiceProto.ConfigRequest.getDefaultInstance()) return this;\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.ConfigRequest)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.ConfigRequest)\n    private static final com.spiketrade.proto.TradingServiceProto.ConfigRequest DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.TradingServiceProto.ConfigRequest();\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.ConfigRequest getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<ConfigRequest>\n        PARSER = new com.google.protobuf.AbstractParser<ConfigRequest>() {\n      @java.lang.Override\n      public ConfigRequest parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<ConfigRequest> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<ConfigRequest> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.ConfigRequest getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface StartTradingRequestOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.StartTradingRequest)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @return A list containing the symbols.\n     */\n    java.util.List<java.lang.String>\n        getSymbolsList();\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @return The count of symbols.\n     */\n    int getSymbolsCount();\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @param index The index of the element to return.\n     * @return The symbols at the given index.\n     */\n    java.lang.String getSymbols(int index);\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @param index The index of the value to return.\n     * @return The bytes of the symbols at the given index.\n     */\n    com.google.protobuf.ByteString\n        getSymbolsBytes(int index);\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.StartTradingRequest}\n   */\n  public static final class StartTradingRequest extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.StartTradingRequest)\n      StartTradingRequestOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use StartTradingRequest.newBuilder() to construct.\n    private StartTradingRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private StartTradingRequest() {\n      symbols_ =\n          com.google.protobuf.LazyStringArrayList.emptyList();\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new StartTradingRequest();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StartTradingRequest_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StartTradingRequest_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.StartTradingRequest.class, com.spiketrade.proto.TradingServiceProto.StartTradingRequest.Builder.class);\n    }\n\n    public static final int SYMBOLS_FIELD_NUMBER = 1;\n    @SuppressWarnings(\"serial\")\n    private com.google.protobuf.LazyStringArrayList symbols_ =\n        com.google.protobuf.LazyStringArrayList.emptyList();\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @return A list containing the symbols.\n     */\n    public com.google.protobuf.ProtocolStringList\n        getSymbolsList() {\n      return symbols_;\n    }\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @return The count of symbols.\n     */\n    public int getSymbolsCount() {\n      return symbols_.size();\n    }\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @param index The index of the element to return.\n     * @return The symbols at the given index.\n     */\n    public java.lang.String getSymbols(int index) {\n      return symbols_.get(index);\n    }\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @param index The index of the value to return.\n     * @return The bytes of the symbols at the given index.\n     */\n    public com.google.protobuf.ByteString\n        getSymbolsBytes(int index) {\n      return symbols_.getByteString(index);\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      for (int i = 0; i < symbols_.size(); i++) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, symbols_.getRaw(i));\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      {\n        int dataSize = 0;\n        for (int i = 0; i < symbols_.size(); i++) {\n          dataSize += computeStringSizeNoTag(symbols_.getRaw(i));\n        }\n        size += dataSize;\n        size += 1 * getSymbolsList().size();\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.StartTradingRequest)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.StartTradingRequest other = (com.spiketrade.proto.TradingServiceProto.StartTradingRequest) obj;\n\n      if (!getSymbolsList()\n          .equals(other.getSymbolsList())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      if (getSymbolsCount() > 0) {\n        hash = (37 * hash) + SYMBOLS_FIELD_NUMBER;\n        hash = (53 * hash) + getSymbolsList().hashCode();\n      }\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StartTradingRequest parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StartTradingRequest parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StartTradingRequest parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StartTradingRequest parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StartTradingRequest parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StartTradingRequest parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StartTradingRequest parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StartTradingRequest parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StartTradingRequest parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StartTradingRequest parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StartTradingRequest parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StartTradingRequest parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.StartTradingRequest prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.StartTradingRequest}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.StartTradingRequest)\n        com.spiketrade.proto.TradingServiceProto.StartTradingRequestOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StartTradingRequest_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StartTradingRequest_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.TradingServiceProto.StartTradingRequest.class, com.spiketrade.proto.TradingServiceProto.StartTradingRequest.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.TradingServiceProto.StartTradingRequest.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        symbols_ =\n            com.google.protobuf.LazyStringArrayList.emptyList();\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StartTradingRequest_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.StartTradingRequest getDefaultInstanceForType() {\n        return com.spiketrade.proto.TradingServiceProto.StartTradingRequest.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.StartTradingRequest build() {\n        com.spiketrade.proto.TradingServiceProto.StartTradingRequest result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.StartTradingRequest buildPartial() {\n        com.spiketrade.proto.TradingServiceProto.StartTradingRequest result = new com.spiketrade.proto.TradingServiceProto.StartTradingRequest(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.TradingServiceProto.StartTradingRequest result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          symbols_.makeImmutable();\n          result.symbols_ = symbols_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.TradingServiceProto.StartTradingRequest) {\n          return mergeFrom((com.spiketrade.proto.TradingServiceProto.StartTradingRequest)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.TradingServiceProto.StartTradingRequest other) {\n        if (other == com.spiketrade.proto.TradingServiceProto.StartTradingRequest.getDefaultInstance()) return this;\n        if (!other.symbols_.isEmpty()) {\n          if (symbols_.isEmpty()) {\n            symbols_ = other.symbols_;\n            bitField0_ |= 0x00000001;\n          } else {\n            ensureSymbolsIsMutable();\n            symbols_.addAll(other.symbols_);\n          }\n          onChanged();\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 10: {\n                java.lang.String s = input.readStringRequireUtf8();\n                ensureSymbolsIsMutable();\n                symbols_.add(s);\n                break;\n              } // case 10\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private com.google.protobuf.LazyStringArrayList symbols_ =\n          com.google.protobuf.LazyStringArrayList.emptyList();\n      private void ensureSymbolsIsMutable() {\n        if (!symbols_.isModifiable()) {\n          symbols_ = new com.google.protobuf.LazyStringArrayList(symbols_);\n        }\n        bitField0_ |= 0x00000001;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @return A list containing the symbols.\n       */\n      public com.google.protobuf.ProtocolStringList\n          getSymbolsList() {\n        symbols_.makeImmutable();\n        return symbols_;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @return The count of symbols.\n       */\n      public int getSymbolsCount() {\n        return symbols_.size();\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param index The index of the element to return.\n       * @return The symbols at the given index.\n       */\n      public java.lang.String getSymbols(int index) {\n        return symbols_.get(index);\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param index The index of the value to return.\n       * @return The bytes of the symbols at the given index.\n       */\n      public com.google.protobuf.ByteString\n          getSymbolsBytes(int index) {\n        return symbols_.getByteString(index);\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param index The index to set the value at.\n       * @param value The symbols to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbols(\n          int index, java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        ensureSymbolsIsMutable();\n        symbols_.set(index, value);\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param value The symbols to add.\n       * @return This builder for chaining.\n       */\n      public Builder addSymbols(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        ensureSymbolsIsMutable();\n        symbols_.add(value);\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param values The symbols to add.\n       * @return This builder for chaining.\n       */\n      public Builder addAllSymbols(\n          java.lang.Iterable<java.lang.String> values) {\n        ensureSymbolsIsMutable();\n        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n            values, symbols_);\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSymbols() {\n        symbols_ =\n          com.google.protobuf.LazyStringArrayList.emptyList();\n        bitField0_ = (bitField0_ & ~0x00000001);;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param value The bytes of the symbols to add.\n       * @return This builder for chaining.\n       */\n      public Builder addSymbolsBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        ensureSymbolsIsMutable();\n        symbols_.add(value);\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.StartTradingRequest)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.StartTradingRequest)\n    private static final com.spiketrade.proto.TradingServiceProto.StartTradingRequest DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.TradingServiceProto.StartTradingRequest();\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StartTradingRequest getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<StartTradingRequest>\n        PARSER = new com.google.protobuf.AbstractParser<StartTradingRequest>() {\n      @java.lang.Override\n      public StartTradingRequest parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<StartTradingRequest> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<StartTradingRequest> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.StartTradingRequest getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface StopTradingRequestOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.StopTradingRequest)\n      com.google.protobuf.MessageOrBuilder {\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.StopTradingRequest}\n   */\n  public static final class StopTradingRequest extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.StopTradingRequest)\n      StopTradingRequestOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use StopTradingRequest.newBuilder() to construct.\n    private StopTradingRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private StopTradingRequest() {\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new StopTradingRequest();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StopTradingRequest_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StopTradingRequest_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.StopTradingRequest.class, com.spiketrade.proto.TradingServiceProto.StopTradingRequest.Builder.class);\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.StopTradingRequest)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.StopTradingRequest other = (com.spiketrade.proto.TradingServiceProto.StopTradingRequest) obj;\n\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StopTradingRequest parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StopTradingRequest parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StopTradingRequest parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StopTradingRequest parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StopTradingRequest parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StopTradingRequest parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StopTradingRequest parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StopTradingRequest parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StopTradingRequest parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StopTradingRequest parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StopTradingRequest parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.StopTradingRequest parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.StopTradingRequest prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.StopTradingRequest}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.StopTradingRequest)\n        com.spiketrade.proto.TradingServiceProto.StopTradingRequestOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StopTradingRequest_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StopTradingRequest_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.TradingServiceProto.StopTradingRequest.class, com.spiketrade.proto.TradingServiceProto.StopTradingRequest.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.TradingServiceProto.StopTradingRequest.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_StopTradingRequest_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.StopTradingRequest getDefaultInstanceForType() {\n        return com.spiketrade.proto.TradingServiceProto.StopTradingRequest.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.StopTradingRequest build() {\n        com.spiketrade.proto.TradingServiceProto.StopTradingRequest result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.StopTradingRequest buildPartial() {\n        com.spiketrade.proto.TradingServiceProto.StopTradingRequest result = new com.spiketrade.proto.TradingServiceProto.StopTradingRequest(this);\n        onBuilt();\n        return result;\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.TradingServiceProto.StopTradingRequest) {\n          return mergeFrom((com.spiketrade.proto.TradingServiceProto.StopTradingRequest)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.TradingServiceProto.StopTradingRequest other) {\n        if (other == com.spiketrade.proto.TradingServiceProto.StopTradingRequest.getDefaultInstance()) return this;\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.StopTradingRequest)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.StopTradingRequest)\n    private static final com.spiketrade.proto.TradingServiceProto.StopTradingRequest DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.TradingServiceProto.StopTradingRequest();\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.StopTradingRequest getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<StopTradingRequest>\n        PARSER = new com.google.protobuf.AbstractParser<StopTradingRequest>() {\n      @java.lang.Override\n      public StopTradingRequest parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<StopTradingRequest> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<StopTradingRequest> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.StopTradingRequest getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface TradingControlResponseOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.TradingControlResponse)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>bool success = 1;</code>\n     * @return The success.\n     */\n    boolean getSuccess();\n\n    /**\n     * <code>string message = 2;</code>\n     * @return The message.\n     */\n    java.lang.String getMessage();\n    /**\n     * <code>string message = 2;</code>\n     * @return The bytes for message.\n     */\n    com.google.protobuf.ByteString\n        getMessageBytes();\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.TradingControlResponse}\n   */\n  public static final class TradingControlResponse extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.TradingControlResponse)\n      TradingControlResponseOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use TradingControlResponse.newBuilder() to construct.\n    private TradingControlResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private TradingControlResponse() {\n      message_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new TradingControlResponse();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_TradingControlResponse_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_TradingControlResponse_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.TradingControlResponse.class, com.spiketrade.proto.TradingServiceProto.TradingControlResponse.Builder.class);\n    }\n\n    public static final int SUCCESS_FIELD_NUMBER = 1;\n    private boolean success_ = false;\n    /**\n     * <code>bool success = 1;</code>\n     * @return The success.\n     */\n    @java.lang.Override\n    public boolean getSuccess() {\n      return success_;\n    }\n\n    public static final int MESSAGE_FIELD_NUMBER = 2;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object message_ = \"\";\n    /**\n     * <code>string message = 2;</code>\n     * @return The message.\n     */\n    @java.lang.Override\n    public java.lang.String getMessage() {\n      java.lang.Object ref = message_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        message_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string message = 2;</code>\n     * @return The bytes for message.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getMessageBytes() {\n      java.lang.Object ref = message_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        message_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (success_ != false) {\n        output.writeBool(1, success_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(message_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, message_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (success_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(1, success_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(message_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, message_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.TradingControlResponse)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.TradingControlResponse other = (com.spiketrade.proto.TradingServiceProto.TradingControlResponse) obj;\n\n      if (getSuccess()\n          != other.getSuccess()) return false;\n      if (!getMessage()\n          .equals(other.getMessage())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + SUCCESS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getSuccess());\n      hash = (37 * hash) + MESSAGE_FIELD_NUMBER;\n      hash = (53 * hash) + getMessage().hashCode();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.TradingControlResponse parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.TradingControlResponse parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.TradingControlResponse parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.TradingControlResponse parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.TradingControlResponse parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.TradingControlResponse parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.TradingControlResponse parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.TradingControlResponse parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.TradingControlResponse parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.TradingControlResponse parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.TradingControlResponse parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.TradingControlResponse parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.TradingControlResponse prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.TradingControlResponse}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.TradingControlResponse)\n        com.spiketrade.proto.TradingServiceProto.TradingControlResponseOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_TradingControlResponse_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_TradingControlResponse_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.TradingServiceProto.TradingControlResponse.class, com.spiketrade.proto.TradingServiceProto.TradingControlResponse.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.TradingServiceProto.TradingControlResponse.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        success_ = false;\n        message_ = \"\";\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_TradingControlResponse_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.TradingControlResponse getDefaultInstanceForType() {\n        return com.spiketrade.proto.TradingServiceProto.TradingControlResponse.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.TradingControlResponse build() {\n        com.spiketrade.proto.TradingServiceProto.TradingControlResponse result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.TradingControlResponse buildPartial() {\n        com.spiketrade.proto.TradingServiceProto.TradingControlResponse result = new com.spiketrade.proto.TradingServiceProto.TradingControlResponse(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.TradingServiceProto.TradingControlResponse result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.success_ = success_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.message_ = message_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.TradingServiceProto.TradingControlResponse) {\n          return mergeFrom((com.spiketrade.proto.TradingServiceProto.TradingControlResponse)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.TradingServiceProto.TradingControlResponse other) {\n        if (other == com.spiketrade.proto.TradingServiceProto.TradingControlResponse.getDefaultInstance()) return this;\n        if (other.getSuccess() != false) {\n          setSuccess(other.getSuccess());\n        }\n        if (!other.getMessage().isEmpty()) {\n          message_ = other.message_;\n          bitField0_ |= 0x00000002;\n          onChanged();\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 8: {\n                success_ = input.readBool();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 8\n              case 18: {\n                message_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 18\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private boolean success_ ;\n      /**\n       * <code>bool success = 1;</code>\n       * @return The success.\n       */\n      @java.lang.Override\n      public boolean getSuccess() {\n        return success_;\n      }\n      /**\n       * <code>bool success = 1;</code>\n       * @param value The success to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSuccess(boolean value) {\n\n        success_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool success = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSuccess() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        success_ = false;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object message_ = \"\";\n      /**\n       * <code>string message = 2;</code>\n       * @return The message.\n       */\n      public java.lang.String getMessage() {\n        java.lang.Object ref = message_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          message_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @return The bytes for message.\n       */\n      public com.google.protobuf.ByteString\n          getMessageBytes() {\n        java.lang.Object ref = message_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          message_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @param value The message to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMessage(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        message_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMessage() {\n        message_ = getDefaultInstance().getMessage();\n        bitField0_ = (bitField0_ & ~0x00000002);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @param value The bytes for message to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMessageBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        message_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.TradingControlResponse)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.TradingControlResponse)\n    private static final com.spiketrade.proto.TradingServiceProto.TradingControlResponse DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.TradingServiceProto.TradingControlResponse();\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.TradingControlResponse getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<TradingControlResponse>\n        PARSER = new com.google.protobuf.AbstractParser<TradingControlResponse>() {\n      @java.lang.Override\n      public TradingControlResponse parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<TradingControlResponse> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<TradingControlResponse> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.TradingControlResponse getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface BacktestRequestOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.BacktestRequest)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    java.lang.String getSymbol();\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    com.google.protobuf.ByteString\n        getSymbolBytes();\n\n    /**\n     * <pre>\n     * Format: YYYY-MM-DD\n     * </pre>\n     *\n     * <code>string start_date = 2;</code>\n     * @return The startDate.\n     */\n    java.lang.String getStartDate();\n    /**\n     * <pre>\n     * Format: YYYY-MM-DD\n     * </pre>\n     *\n     * <code>string start_date = 2;</code>\n     * @return The bytes for startDate.\n     */\n    com.google.protobuf.ByteString\n        getStartDateBytes();\n\n    /**\n     * <pre>\n     * Format: YYYY-MM-DD\n     * </pre>\n     *\n     * <code>string end_date = 3;</code>\n     * @return The endDate.\n     */\n    java.lang.String getEndDate();\n    /**\n     * <pre>\n     * Format: YYYY-MM-DD\n     * </pre>\n     *\n     * <code>string end_date = 3;</code>\n     * @return The bytes for endDate.\n     */\n    com.google.protobuf.ByteString\n        getEndDateBytes();\n\n    /**\n     * <code>double initial_capital = 4;</code>\n     * @return The initialCapital.\n     */\n    double getInitialCapital();\n\n    /**\n     * <code>int32 interval_minutes = 5;</code>\n     * @return The intervalMinutes.\n     */\n    int getIntervalMinutes();\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.BacktestRequest}\n   */\n  public static final class BacktestRequest extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.BacktestRequest)\n      BacktestRequestOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use BacktestRequest.newBuilder() to construct.\n    private BacktestRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private BacktestRequest() {\n      symbol_ = \"\";\n      startDate_ = \"\";\n      endDate_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new BacktestRequest();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestRequest_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestRequest_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.BacktestRequest.class, com.spiketrade.proto.TradingServiceProto.BacktestRequest.Builder.class);\n    }\n\n    public static final int SYMBOL_FIELD_NUMBER = 1;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object symbol_ = \"\";\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    @java.lang.Override\n    public java.lang.String getSymbol() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        symbol_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getSymbolBytes() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        symbol_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int START_DATE_FIELD_NUMBER = 2;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object startDate_ = \"\";\n    /**\n     * <pre>\n     * Format: YYYY-MM-DD\n     * </pre>\n     *\n     * <code>string start_date = 2;</code>\n     * @return The startDate.\n     */\n    @java.lang.Override\n    public java.lang.String getStartDate() {\n      java.lang.Object ref = startDate_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        startDate_ = s;\n        return s;\n      }\n    }\n    /**\n     * <pre>\n     * Format: YYYY-MM-DD\n     * </pre>\n     *\n     * <code>string start_date = 2;</code>\n     * @return The bytes for startDate.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getStartDateBytes() {\n      java.lang.Object ref = startDate_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        startDate_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int END_DATE_FIELD_NUMBER = 3;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object endDate_ = \"\";\n    /**\n     * <pre>\n     * Format: YYYY-MM-DD\n     * </pre>\n     *\n     * <code>string end_date = 3;</code>\n     * @return The endDate.\n     */\n    @java.lang.Override\n    public java.lang.String getEndDate() {\n      java.lang.Object ref = endDate_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        endDate_ = s;\n        return s;\n      }\n    }\n    /**\n     * <pre>\n     * Format: YYYY-MM-DD\n     * </pre>\n     *\n     * <code>string end_date = 3;</code>\n     * @return The bytes for endDate.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getEndDateBytes() {\n      java.lang.Object ref = endDate_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        endDate_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int INITIAL_CAPITAL_FIELD_NUMBER = 4;\n    private double initialCapital_ = 0D;\n    /**\n     * <code>double initial_capital = 4;</code>\n     * @return The initialCapital.\n     */\n    @java.lang.Override\n    public double getInitialCapital() {\n      return initialCapital_;\n    }\n\n    public static final int INTERVAL_MINUTES_FIELD_NUMBER = 5;\n    private int intervalMinutes_ = 0;\n    /**\n     * <code>int32 interval_minutes = 5;</code>\n     * @return The intervalMinutes.\n     */\n    @java.lang.Override\n    public int getIntervalMinutes() {\n      return intervalMinutes_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, symbol_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(startDate_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, startDate_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(endDate_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, endDate_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(initialCapital_) != 0) {\n        output.writeDouble(4, initialCapital_);\n      }\n      if (intervalMinutes_ != 0) {\n        output.writeInt32(5, intervalMinutes_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, symbol_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(startDate_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, startDate_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(endDate_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, endDate_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(initialCapital_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(4, initialCapital_);\n      }\n      if (intervalMinutes_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(5, intervalMinutes_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.BacktestRequest)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.BacktestRequest other = (com.spiketrade.proto.TradingServiceProto.BacktestRequest) obj;\n\n      if (!getSymbol()\n          .equals(other.getSymbol())) return false;\n      if (!getStartDate()\n          .equals(other.getStartDate())) return false;\n      if (!getEndDate()\n          .equals(other.getEndDate())) return false;\n      if (java.lang.Double.doubleToLongBits(getInitialCapital())\n          != java.lang.Double.doubleToLongBits(\n              other.getInitialCapital())) return false;\n      if (getIntervalMinutes()\n          != other.getIntervalMinutes()) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + SYMBOL_FIELD_NUMBER;\n      hash = (53 * hash) + getSymbol().hashCode();\n      hash = (37 * hash) + START_DATE_FIELD_NUMBER;\n      hash = (53 * hash) + getStartDate().hashCode();\n      hash = (37 * hash) + END_DATE_FIELD_NUMBER;\n      hash = (53 * hash) + getEndDate().hashCode();\n      hash = (37 * hash) + INITIAL_CAPITAL_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getInitialCapital()));\n      hash = (37 * hash) + INTERVAL_MINUTES_FIELD_NUMBER;\n      hash = (53 * hash) + getIntervalMinutes();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.BacktestRequest parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestRequest parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestRequest parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestRequest parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestRequest parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestRequest parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestRequest parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestRequest parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.BacktestRequest parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.BacktestRequest parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestRequest parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestRequest parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.BacktestRequest prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.BacktestRequest}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.BacktestRequest)\n        com.spiketrade.proto.TradingServiceProto.BacktestRequestOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestRequest_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestRequest_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.TradingServiceProto.BacktestRequest.class, com.spiketrade.proto.TradingServiceProto.BacktestRequest.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.TradingServiceProto.BacktestRequest.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        symbol_ = \"\";\n        startDate_ = \"\";\n        endDate_ = \"\";\n        initialCapital_ = 0D;\n        intervalMinutes_ = 0;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestRequest_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.BacktestRequest getDefaultInstanceForType() {\n        return com.spiketrade.proto.TradingServiceProto.BacktestRequest.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.BacktestRequest build() {\n        com.spiketrade.proto.TradingServiceProto.BacktestRequest result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.BacktestRequest buildPartial() {\n        com.spiketrade.proto.TradingServiceProto.BacktestRequest result = new com.spiketrade.proto.TradingServiceProto.BacktestRequest(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.TradingServiceProto.BacktestRequest result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.symbol_ = symbol_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.startDate_ = startDate_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.endDate_ = endDate_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.initialCapital_ = initialCapital_;\n        }\n        if (((from_bitField0_ & 0x00000010) != 0)) {\n          result.intervalMinutes_ = intervalMinutes_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.TradingServiceProto.BacktestRequest) {\n          return mergeFrom((com.spiketrade.proto.TradingServiceProto.BacktestRequest)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.TradingServiceProto.BacktestRequest other) {\n        if (other == com.spiketrade.proto.TradingServiceProto.BacktestRequest.getDefaultInstance()) return this;\n        if (!other.getSymbol().isEmpty()) {\n          symbol_ = other.symbol_;\n          bitField0_ |= 0x00000001;\n          onChanged();\n        }\n        if (!other.getStartDate().isEmpty()) {\n          startDate_ = other.startDate_;\n          bitField0_ |= 0x00000002;\n          onChanged();\n        }\n        if (!other.getEndDate().isEmpty()) {\n          endDate_ = other.endDate_;\n          bitField0_ |= 0x00000004;\n          onChanged();\n        }\n        if (other.getInitialCapital() != 0D) {\n          setInitialCapital(other.getInitialCapital());\n        }\n        if (other.getIntervalMinutes() != 0) {\n          setIntervalMinutes(other.getIntervalMinutes());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 10: {\n                symbol_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 10\n              case 18: {\n                startDate_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 18\n              case 26: {\n                endDate_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 26\n              case 33: {\n                initialCapital_ = input.readDouble();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 33\n              case 40: {\n                intervalMinutes_ = input.readInt32();\n                bitField0_ |= 0x00000010;\n                break;\n              } // case 40\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private java.lang.Object symbol_ = \"\";\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The symbol.\n       */\n      public java.lang.String getSymbol() {\n        java.lang.Object ref = symbol_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          symbol_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The bytes for symbol.\n       */\n      public com.google.protobuf.ByteString\n          getSymbolBytes() {\n        java.lang.Object ref = symbol_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          symbol_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbol(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSymbol() {\n        symbol_ = getDefaultInstance().getSymbol();\n        bitField0_ = (bitField0_ & ~0x00000001);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The bytes for symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbolBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object startDate_ = \"\";\n      /**\n       * <pre>\n       * Format: YYYY-MM-DD\n       * </pre>\n       *\n       * <code>string start_date = 2;</code>\n       * @return The startDate.\n       */\n      public java.lang.String getStartDate() {\n        java.lang.Object ref = startDate_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          startDate_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <pre>\n       * Format: YYYY-MM-DD\n       * </pre>\n       *\n       * <code>string start_date = 2;</code>\n       * @return The bytes for startDate.\n       */\n      public com.google.protobuf.ByteString\n          getStartDateBytes() {\n        java.lang.Object ref = startDate_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          startDate_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <pre>\n       * Format: YYYY-MM-DD\n       * </pre>\n       *\n       * <code>string start_date = 2;</code>\n       * @param value The startDate to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStartDate(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        startDate_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Format: YYYY-MM-DD\n       * </pre>\n       *\n       * <code>string start_date = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStartDate() {\n        startDate_ = getDefaultInstance().getStartDate();\n        bitField0_ = (bitField0_ & ~0x00000002);\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Format: YYYY-MM-DD\n       * </pre>\n       *\n       * <code>string start_date = 2;</code>\n       * @param value The bytes for startDate to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStartDateBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        startDate_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object endDate_ = \"\";\n      /**\n       * <pre>\n       * Format: YYYY-MM-DD\n       * </pre>\n       *\n       * <code>string end_date = 3;</code>\n       * @return The endDate.\n       */\n      public java.lang.String getEndDate() {\n        java.lang.Object ref = endDate_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          endDate_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <pre>\n       * Format: YYYY-MM-DD\n       * </pre>\n       *\n       * <code>string end_date = 3;</code>\n       * @return The bytes for endDate.\n       */\n      public com.google.protobuf.ByteString\n          getEndDateBytes() {\n        java.lang.Object ref = endDate_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          endDate_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <pre>\n       * Format: YYYY-MM-DD\n       * </pre>\n       *\n       * <code>string end_date = 3;</code>\n       * @param value The endDate to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEndDate(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        endDate_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Format: YYYY-MM-DD\n       * </pre>\n       *\n       * <code>string end_date = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEndDate() {\n        endDate_ = getDefaultInstance().getEndDate();\n        bitField0_ = (bitField0_ & ~0x00000004);\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Format: YYYY-MM-DD\n       * </pre>\n       *\n       * <code>string end_date = 3;</code>\n       * @param value The bytes for endDate to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEndDateBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        endDate_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n\n      private double initialCapital_ ;\n      /**\n       * <code>double initial_capital = 4;</code>\n       * @return The initialCapital.\n       */\n      @java.lang.Override\n      public double getInitialCapital() {\n        return initialCapital_;\n      }\n      /**\n       * <code>double initial_capital = 4;</code>\n       * @param value The initialCapital to set.\n       * @return This builder for chaining.\n       */\n      public Builder setInitialCapital(double value) {\n\n        initialCapital_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double initial_capital = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearInitialCapital() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        initialCapital_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private int intervalMinutes_ ;\n      /**\n       * <code>int32 interval_minutes = 5;</code>\n       * @return The intervalMinutes.\n       */\n      @java.lang.Override\n      public int getIntervalMinutes() {\n        return intervalMinutes_;\n      }\n      /**\n       * <code>int32 interval_minutes = 5;</code>\n       * @param value The intervalMinutes to set.\n       * @return This builder for chaining.\n       */\n      public Builder setIntervalMinutes(int value) {\n\n        intervalMinutes_ = value;\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 interval_minutes = 5;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearIntervalMinutes() {\n        bitField0_ = (bitField0_ & ~0x00000010);\n        intervalMinutes_ = 0;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.BacktestRequest)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.BacktestRequest)\n    private static final com.spiketrade.proto.TradingServiceProto.BacktestRequest DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.TradingServiceProto.BacktestRequest();\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.BacktestRequest getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<BacktestRequest>\n        PARSER = new com.google.protobuf.AbstractParser<BacktestRequest>() {\n      @java.lang.Override\n      public BacktestRequest parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<BacktestRequest> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<BacktestRequest> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.BacktestRequest getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface BacktestTradeOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.BacktestTrade)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>string timestamp = 1;</code>\n     * @return The timestamp.\n     */\n    java.lang.String getTimestamp();\n    /**\n     * <code>string timestamp = 1;</code>\n     * @return The bytes for timestamp.\n     */\n    com.google.protobuf.ByteString\n        getTimestampBytes();\n\n    /**\n     * <pre>\n     * \"BUY\" or \"SELL\"\n     * </pre>\n     *\n     * <code>string action = 2;</code>\n     * @return The action.\n     */\n    java.lang.String getAction();\n    /**\n     * <pre>\n     * \"BUY\" or \"SELL\"\n     * </pre>\n     *\n     * <code>string action = 2;</code>\n     * @return The bytes for action.\n     */\n    com.google.protobuf.ByteString\n        getActionBytes();\n\n    /**\n     * <code>double price = 3;</code>\n     * @return The price.\n     */\n    double getPrice();\n\n    /**\n     * <code>int32 shares = 4;</code>\n     * @return The shares.\n     */\n    int getShares();\n\n    /**\n     * <code>double total = 5;</code>\n     * @return The total.\n     */\n    double getTotal();\n\n    /**\n     * <code>double balance = 6;</code>\n     * @return The balance.\n     */\n    double getBalance();\n\n    /**\n     * <code>double signal_probability = 7;</code>\n     * @return The signalProbability.\n     */\n    double getSignalProbability();\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.BacktestTrade}\n   */\n  public static final class BacktestTrade extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.BacktestTrade)\n      BacktestTradeOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use BacktestTrade.newBuilder() to construct.\n    private BacktestTrade(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private BacktestTrade() {\n      timestamp_ = \"\";\n      action_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new BacktestTrade();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestTrade_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestTrade_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.BacktestTrade.class, com.spiketrade.proto.TradingServiceProto.BacktestTrade.Builder.class);\n    }\n\n    public static final int TIMESTAMP_FIELD_NUMBER = 1;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object timestamp_ = \"\";\n    /**\n     * <code>string timestamp = 1;</code>\n     * @return The timestamp.\n     */\n    @java.lang.Override\n    public java.lang.String getTimestamp() {\n      java.lang.Object ref = timestamp_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        timestamp_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string timestamp = 1;</code>\n     * @return The bytes for timestamp.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getTimestampBytes() {\n      java.lang.Object ref = timestamp_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        timestamp_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int ACTION_FIELD_NUMBER = 2;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object action_ = \"\";\n    /**\n     * <pre>\n     * \"BUY\" or \"SELL\"\n     * </pre>\n     *\n     * <code>string action = 2;</code>\n     * @return The action.\n     */\n    @java.lang.Override\n    public java.lang.String getAction() {\n      java.lang.Object ref = action_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        action_ = s;\n        return s;\n      }\n    }\n    /**\n     * <pre>\n     * \"BUY\" or \"SELL\"\n     * </pre>\n     *\n     * <code>string action = 2;</code>\n     * @return The bytes for action.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getActionBytes() {\n      java.lang.Object ref = action_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        action_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int PRICE_FIELD_NUMBER = 3;\n    private double price_ = 0D;\n    /**\n     * <code>double price = 3;</code>\n     * @return The price.\n     */\n    @java.lang.Override\n    public double getPrice() {\n      return price_;\n    }\n\n    public static final int SHARES_FIELD_NUMBER = 4;\n    private int shares_ = 0;\n    /**\n     * <code>int32 shares = 4;</code>\n     * @return The shares.\n     */\n    @java.lang.Override\n    public int getShares() {\n      return shares_;\n    }\n\n    public static final int TOTAL_FIELD_NUMBER = 5;\n    private double total_ = 0D;\n    /**\n     * <code>double total = 5;</code>\n     * @return The total.\n     */\n    @java.lang.Override\n    public double getTotal() {\n      return total_;\n    }\n\n    public static final int BALANCE_FIELD_NUMBER = 6;\n    private double balance_ = 0D;\n    /**\n     * <code>double balance = 6;</code>\n     * @return The balance.\n     */\n    @java.lang.Override\n    public double getBalance() {\n      return balance_;\n    }\n\n    public static final int SIGNAL_PROBABILITY_FIELD_NUMBER = 7;\n    private double signalProbability_ = 0D;\n    /**\n     * <code>double signal_probability = 7;</code>\n     * @return The signalProbability.\n     */\n    @java.lang.Override\n    public double getSignalProbability() {\n      return signalProbability_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(timestamp_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, timestamp_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(action_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, action_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(price_) != 0) {\n        output.writeDouble(3, price_);\n      }\n      if (shares_ != 0) {\n        output.writeInt32(4, shares_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(total_) != 0) {\n        output.writeDouble(5, total_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(balance_) != 0) {\n        output.writeDouble(6, balance_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(signalProbability_) != 0) {\n        output.writeDouble(7, signalProbability_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(timestamp_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, timestamp_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(action_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, action_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(price_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(3, price_);\n      }\n      if (shares_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(4, shares_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(total_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(5, total_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(balance_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(6, balance_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(signalProbability_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(7, signalProbability_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.BacktestTrade)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.BacktestTrade other = (com.spiketrade.proto.TradingServiceProto.BacktestTrade) obj;\n\n      if (!getTimestamp()\n          .equals(other.getTimestamp())) return false;\n      if (!getAction()\n          .equals(other.getAction())) return false;\n      if (java.lang.Double.doubleToLongBits(getPrice())\n          != java.lang.Double.doubleToLongBits(\n              other.getPrice())) return false;\n      if (getShares()\n          != other.getShares()) return false;\n      if (java.lang.Double.doubleToLongBits(getTotal())\n          != java.lang.Double.doubleToLongBits(\n              other.getTotal())) return false;\n      if (java.lang.Double.doubleToLongBits(getBalance())\n          != java.lang.Double.doubleToLongBits(\n              other.getBalance())) return false;\n      if (java.lang.Double.doubleToLongBits(getSignalProbability())\n          != java.lang.Double.doubleToLongBits(\n              other.getSignalProbability())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + TIMESTAMP_FIELD_NUMBER;\n      hash = (53 * hash) + getTimestamp().hashCode();\n      hash = (37 * hash) + ACTION_FIELD_NUMBER;\n      hash = (53 * hash) + getAction().hashCode();\n      hash = (37 * hash) + PRICE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPrice()));\n      hash = (37 * hash) + SHARES_FIELD_NUMBER;\n      hash = (53 * hash) + getShares();\n      hash = (37 * hash) + TOTAL_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getTotal()));\n      hash = (37 * hash) + BALANCE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getBalance()));\n      hash = (37 * hash) + SIGNAL_PROBABILITY_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getSignalProbability()));\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.BacktestTrade parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestTrade parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestTrade parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestTrade parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestTrade parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestTrade parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestTrade parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestTrade parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.BacktestTrade parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.BacktestTrade parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestTrade parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestTrade parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.BacktestTrade prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.BacktestTrade}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.BacktestTrade)\n        com.spiketrade.proto.TradingServiceProto.BacktestTradeOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestTrade_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestTrade_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.TradingServiceProto.BacktestTrade.class, com.spiketrade.proto.TradingServiceProto.BacktestTrade.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.TradingServiceProto.BacktestTrade.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        timestamp_ = \"\";\n        action_ = \"\";\n        price_ = 0D;\n        shares_ = 0;\n        total_ = 0D;\n        balance_ = 0D;\n        signalProbability_ = 0D;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestTrade_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.BacktestTrade getDefaultInstanceForType() {\n        return com.spiketrade.proto.TradingServiceProto.BacktestTrade.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.BacktestTrade build() {\n        com.spiketrade.proto.TradingServiceProto.BacktestTrade result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.BacktestTrade buildPartial() {\n        com.spiketrade.proto.TradingServiceProto.BacktestTrade result = new com.spiketrade.proto.TradingServiceProto.BacktestTrade(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.TradingServiceProto.BacktestTrade result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.timestamp_ = timestamp_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.action_ = action_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.price_ = price_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.shares_ = shares_;\n        }\n        if (((from_bitField0_ & 0x00000010) != 0)) {\n          result.total_ = total_;\n        }\n        if (((from_bitField0_ & 0x00000020) != 0)) {\n          result.balance_ = balance_;\n        }\n        if (((from_bitField0_ & 0x00000040) != 0)) {\n          result.signalProbability_ = signalProbability_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.TradingServiceProto.BacktestTrade) {\n          return mergeFrom((com.spiketrade.proto.TradingServiceProto.BacktestTrade)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.TradingServiceProto.BacktestTrade other) {\n        if (other == com.spiketrade.proto.TradingServiceProto.BacktestTrade.getDefaultInstance()) return this;\n        if (!other.getTimestamp().isEmpty()) {\n          timestamp_ = other.timestamp_;\n          bitField0_ |= 0x00000001;\n          onChanged();\n        }\n        if (!other.getAction().isEmpty()) {\n          action_ = other.action_;\n          bitField0_ |= 0x00000002;\n          onChanged();\n        }\n        if (other.getPrice() != 0D) {\n          setPrice(other.getPrice());\n        }\n        if (other.getShares() != 0) {\n          setShares(other.getShares());\n        }\n        if (other.getTotal() != 0D) {\n          setTotal(other.getTotal());\n        }\n        if (other.getBalance() != 0D) {\n          setBalance(other.getBalance());\n        }\n        if (other.getSignalProbability() != 0D) {\n          setSignalProbability(other.getSignalProbability());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 10: {\n                timestamp_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 10\n              case 18: {\n                action_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 18\n              case 25: {\n                price_ = input.readDouble();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 25\n              case 32: {\n                shares_ = input.readInt32();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 32\n              case 41: {\n                total_ = input.readDouble();\n                bitField0_ |= 0x00000010;\n                break;\n              } // case 41\n              case 49: {\n                balance_ = input.readDouble();\n                bitField0_ |= 0x00000020;\n                break;\n              } // case 49\n              case 57: {\n                signalProbability_ = input.readDouble();\n                bitField0_ |= 0x00000040;\n                break;\n              } // case 57\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private java.lang.Object timestamp_ = \"\";\n      /**\n       * <code>string timestamp = 1;</code>\n       * @return The timestamp.\n       */\n      public java.lang.String getTimestamp() {\n        java.lang.Object ref = timestamp_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          timestamp_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string timestamp = 1;</code>\n       * @return The bytes for timestamp.\n       */\n      public com.google.protobuf.ByteString\n          getTimestampBytes() {\n        java.lang.Object ref = timestamp_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          timestamp_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string timestamp = 1;</code>\n       * @param value The timestamp to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTimestamp(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        timestamp_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string timestamp = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTimestamp() {\n        timestamp_ = getDefaultInstance().getTimestamp();\n        bitField0_ = (bitField0_ & ~0x00000001);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string timestamp = 1;</code>\n       * @param value The bytes for timestamp to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTimestampBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        timestamp_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object action_ = \"\";\n      /**\n       * <pre>\n       * \"BUY\" or \"SELL\"\n       * </pre>\n       *\n       * <code>string action = 2;</code>\n       * @return The action.\n       */\n      public java.lang.String getAction() {\n        java.lang.Object ref = action_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          action_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <pre>\n       * \"BUY\" or \"SELL\"\n       * </pre>\n       *\n       * <code>string action = 2;</code>\n       * @return The bytes for action.\n       */\n      public com.google.protobuf.ByteString\n          getActionBytes() {\n        java.lang.Object ref = action_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          action_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <pre>\n       * \"BUY\" or \"SELL\"\n       * </pre>\n       *\n       * <code>string action = 2;</code>\n       * @param value The action to set.\n       * @return This builder for chaining.\n       */\n      public Builder setAction(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        action_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * \"BUY\" or \"SELL\"\n       * </pre>\n       *\n       * <code>string action = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearAction() {\n        action_ = getDefaultInstance().getAction();\n        bitField0_ = (bitField0_ & ~0x00000002);\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * \"BUY\" or \"SELL\"\n       * </pre>\n       *\n       * <code>string action = 2;</code>\n       * @param value The bytes for action to set.\n       * @return This builder for chaining.\n       */\n      public Builder setActionBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        action_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n\n      private double price_ ;\n      /**\n       * <code>double price = 3;</code>\n       * @return The price.\n       */\n      @java.lang.Override\n      public double getPrice() {\n        return price_;\n      }\n      /**\n       * <code>double price = 3;</code>\n       * @param value The price to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPrice(double value) {\n\n        price_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double price = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPrice() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        price_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private int shares_ ;\n      /**\n       * <code>int32 shares = 4;</code>\n       * @return The shares.\n       */\n      @java.lang.Override\n      public int getShares() {\n        return shares_;\n      }\n      /**\n       * <code>int32 shares = 4;</code>\n       * @param value The shares to set.\n       * @return This builder for chaining.\n       */\n      public Builder setShares(int value) {\n\n        shares_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 shares = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearShares() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        shares_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private double total_ ;\n      /**\n       * <code>double total = 5;</code>\n       * @return The total.\n       */\n      @java.lang.Override\n      public double getTotal() {\n        return total_;\n      }\n      /**\n       * <code>double total = 5;</code>\n       * @param value The total to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTotal(double value) {\n\n        total_ = value;\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double total = 5;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTotal() {\n        bitField0_ = (bitField0_ & ~0x00000010);\n        total_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double balance_ ;\n      /**\n       * <code>double balance = 6;</code>\n       * @return The balance.\n       */\n      @java.lang.Override\n      public double getBalance() {\n        return balance_;\n      }\n      /**\n       * <code>double balance = 6;</code>\n       * @param value The balance to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBalance(double value) {\n\n        balance_ = value;\n        bitField0_ |= 0x00000020;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double balance = 6;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBalance() {\n        bitField0_ = (bitField0_ & ~0x00000020);\n        balance_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double signalProbability_ ;\n      /**\n       * <code>double signal_probability = 7;</code>\n       * @return The signalProbability.\n       */\n      @java.lang.Override\n      public double getSignalProbability() {\n        return signalProbability_;\n      }\n      /**\n       * <code>double signal_probability = 7;</code>\n       * @param value The signalProbability to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSignalProbability(double value) {\n\n        signalProbability_ = value;\n        bitField0_ |= 0x00000040;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double signal_probability = 7;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSignalProbability() {\n        bitField0_ = (bitField0_ & ~0x00000040);\n        signalProbability_ = 0D;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.BacktestTrade)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.BacktestTrade)\n    private static final com.spiketrade.proto.TradingServiceProto.BacktestTrade DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.TradingServiceProto.BacktestTrade();\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.BacktestTrade getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<BacktestTrade>\n        PARSER = new com.google.protobuf.AbstractParser<BacktestTrade>() {\n      @java.lang.Override\n      public BacktestTrade parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<BacktestTrade> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<BacktestTrade> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.BacktestTrade getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface BacktestResponseOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.BacktestResponse)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>bool success = 1;</code>\n     * @return The success.\n     */\n    boolean getSuccess();\n\n    /**\n     * <code>string message = 2;</code>\n     * @return The message.\n     */\n    java.lang.String getMessage();\n    /**\n     * <code>string message = 2;</code>\n     * @return The bytes for message.\n     */\n    com.google.protobuf.ByteString\n        getMessageBytes();\n\n    /**\n     * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n     */\n    java.util.List<com.spiketrade.proto.TradingServiceProto.BacktestTrade> \n        getTradesList();\n    /**\n     * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n     */\n    com.spiketrade.proto.TradingServiceProto.BacktestTrade getTrades(int index);\n    /**\n     * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n     */\n    int getTradesCount();\n    /**\n     * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n     */\n    java.util.List<? extends com.spiketrade.proto.TradingServiceProto.BacktestTradeOrBuilder> \n        getTradesOrBuilderList();\n    /**\n     * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n     */\n    com.spiketrade.proto.TradingServiceProto.BacktestTradeOrBuilder getTradesOrBuilder(\n        int index);\n\n    /**\n     * <code>double final_balance = 4;</code>\n     * @return The finalBalance.\n     */\n    double getFinalBalance();\n\n    /**\n     * <code>double total_return = 5;</code>\n     * @return The totalReturn.\n     */\n    double getTotalReturn();\n\n    /**\n     * <code>int32 total_trades = 6;</code>\n     * @return The totalTrades.\n     */\n    int getTotalTrades();\n\n    /**\n     * <code>int32 winning_trades = 7;</code>\n     * @return The winningTrades.\n     */\n    int getWinningTrades();\n\n    /**\n     * <code>int32 losing_trades = 8;</code>\n     * @return The losingTrades.\n     */\n    int getLosingTrades();\n\n    /**\n     * <code>double win_rate = 9;</code>\n     * @return The winRate.\n     */\n    double getWinRate();\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.BacktestResponse}\n   */\n  public static final class BacktestResponse extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.BacktestResponse)\n      BacktestResponseOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use BacktestResponse.newBuilder() to construct.\n    private BacktestResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private BacktestResponse() {\n      message_ = \"\";\n      trades_ = java.util.Collections.emptyList();\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new BacktestResponse();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestResponse_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestResponse_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.BacktestResponse.class, com.spiketrade.proto.TradingServiceProto.BacktestResponse.Builder.class);\n    }\n\n    public static final int SUCCESS_FIELD_NUMBER = 1;\n    private boolean success_ = false;\n    /**\n     * <code>bool success = 1;</code>\n     * @return The success.\n     */\n    @java.lang.Override\n    public boolean getSuccess() {\n      return success_;\n    }\n\n    public static final int MESSAGE_FIELD_NUMBER = 2;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object message_ = \"\";\n    /**\n     * <code>string message = 2;</code>\n     * @return The message.\n     */\n    @java.lang.Override\n    public java.lang.String getMessage() {\n      java.lang.Object ref = message_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        message_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string message = 2;</code>\n     * @return The bytes for message.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getMessageBytes() {\n      java.lang.Object ref = message_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        message_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int TRADES_FIELD_NUMBER = 3;\n    @SuppressWarnings(\"serial\")\n    private java.util.List<com.spiketrade.proto.TradingServiceProto.BacktestTrade> trades_;\n    /**\n     * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n     */\n    @java.lang.Override\n    public java.util.List<com.spiketrade.proto.TradingServiceProto.BacktestTrade> getTradesList() {\n      return trades_;\n    }\n    /**\n     * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n     */\n    @java.lang.Override\n    public java.util.List<? extends com.spiketrade.proto.TradingServiceProto.BacktestTradeOrBuilder> \n        getTradesOrBuilderList() {\n      return trades_;\n    }\n    /**\n     * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n     */\n    @java.lang.Override\n    public int getTradesCount() {\n      return trades_.size();\n    }\n    /**\n     * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.BacktestTrade getTrades(int index) {\n      return trades_.get(index);\n    }\n    /**\n     * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.BacktestTradeOrBuilder getTradesOrBuilder(\n        int index) {\n      return trades_.get(index);\n    }\n\n    public static final int FINAL_BALANCE_FIELD_NUMBER = 4;\n    private double finalBalance_ = 0D;\n    /**\n     * <code>double final_balance = 4;</code>\n     * @return The finalBalance.\n     */\n    @java.lang.Override\n    public double getFinalBalance() {\n      return finalBalance_;\n    }\n\n    public static final int TOTAL_RETURN_FIELD_NUMBER = 5;\n    private double totalReturn_ = 0D;\n    /**\n     * <code>double total_return = 5;</code>\n     * @return The totalReturn.\n     */\n    @java.lang.Override\n    public double getTotalReturn() {\n      return totalReturn_;\n    }\n\n    public static final int TOTAL_TRADES_FIELD_NUMBER = 6;\n    private int totalTrades_ = 0;\n    /**\n     * <code>int32 total_trades = 6;</code>\n     * @return The totalTrades.\n     */\n    @java.lang.Override\n    public int getTotalTrades() {\n      return totalTrades_;\n    }\n\n    public static final int WINNING_TRADES_FIELD_NUMBER = 7;\n    private int winningTrades_ = 0;\n    /**\n     * <code>int32 winning_trades = 7;</code>\n     * @return The winningTrades.\n     */\n    @java.lang.Override\n    public int getWinningTrades() {\n      return winningTrades_;\n    }\n\n    public static final int LOSING_TRADES_FIELD_NUMBER = 8;\n    private int losingTrades_ = 0;\n    /**\n     * <code>int32 losing_trades = 8;</code>\n     * @return The losingTrades.\n     */\n    @java.lang.Override\n    public int getLosingTrades() {\n      return losingTrades_;\n    }\n\n    public static final int WIN_RATE_FIELD_NUMBER = 9;\n    private double winRate_ = 0D;\n    /**\n     * <code>double win_rate = 9;</code>\n     * @return The winRate.\n     */\n    @java.lang.Override\n    public double getWinRate() {\n      return winRate_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (success_ != false) {\n        output.writeBool(1, success_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(message_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, message_);\n      }\n      for (int i = 0; i < trades_.size(); i++) {\n        output.writeMessage(3, trades_.get(i));\n      }\n      if (java.lang.Double.doubleToRawLongBits(finalBalance_) != 0) {\n        output.writeDouble(4, finalBalance_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(totalReturn_) != 0) {\n        output.writeDouble(5, totalReturn_);\n      }\n      if (totalTrades_ != 0) {\n        output.writeInt32(6, totalTrades_);\n      }\n      if (winningTrades_ != 0) {\n        output.writeInt32(7, winningTrades_);\n      }\n      if (losingTrades_ != 0) {\n        output.writeInt32(8, losingTrades_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(winRate_) != 0) {\n        output.writeDouble(9, winRate_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (success_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(1, success_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(message_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, message_);\n      }\n      for (int i = 0; i < trades_.size(); i++) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(3, trades_.get(i));\n      }\n      if (java.lang.Double.doubleToRawLongBits(finalBalance_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(4, finalBalance_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(totalReturn_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(5, totalReturn_);\n      }\n      if (totalTrades_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(6, totalTrades_);\n      }\n      if (winningTrades_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(7, winningTrades_);\n      }\n      if (losingTrades_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(8, losingTrades_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(winRate_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(9, winRate_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.BacktestResponse)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.BacktestResponse other = (com.spiketrade.proto.TradingServiceProto.BacktestResponse) obj;\n\n      if (getSuccess()\n          != other.getSuccess()) return false;\n      if (!getMessage()\n          .equals(other.getMessage())) return false;\n      if (!getTradesList()\n          .equals(other.getTradesList())) return false;\n      if (java.lang.Double.doubleToLongBits(getFinalBalance())\n          != java.lang.Double.doubleToLongBits(\n              other.getFinalBalance())) return false;\n      if (java.lang.Double.doubleToLongBits(getTotalReturn())\n          != java.lang.Double.doubleToLongBits(\n              other.getTotalReturn())) return false;\n      if (getTotalTrades()\n          != other.getTotalTrades()) return false;\n      if (getWinningTrades()\n          != other.getWinningTrades()) return false;\n      if (getLosingTrades()\n          != other.getLosingTrades()) return false;\n      if (java.lang.Double.doubleToLongBits(getWinRate())\n          != java.lang.Double.doubleToLongBits(\n              other.getWinRate())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + SUCCESS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getSuccess());\n      hash = (37 * hash) + MESSAGE_FIELD_NUMBER;\n      hash = (53 * hash) + getMessage().hashCode();\n      if (getTradesCount() > 0) {\n        hash = (37 * hash) + TRADES_FIELD_NUMBER;\n        hash = (53 * hash) + getTradesList().hashCode();\n      }\n      hash = (37 * hash) + FINAL_BALANCE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getFinalBalance()));\n      hash = (37 * hash) + TOTAL_RETURN_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getTotalReturn()));\n      hash = (37 * hash) + TOTAL_TRADES_FIELD_NUMBER;\n      hash = (53 * hash) + getTotalTrades();\n      hash = (37 * hash) + WINNING_TRADES_FIELD_NUMBER;\n      hash = (53 * hash) + getWinningTrades();\n      hash = (37 * hash) + LOSING_TRADES_FIELD_NUMBER;\n      hash = (53 * hash) + getLosingTrades();\n      hash = (37 * hash) + WIN_RATE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getWinRate()));\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.BacktestResponse parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestResponse parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestResponse parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestResponse parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestResponse parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestResponse parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestResponse parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestResponse parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.BacktestResponse parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.BacktestResponse parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestResponse parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.BacktestResponse parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.BacktestResponse prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.BacktestResponse}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.BacktestResponse)\n        com.spiketrade.proto.TradingServiceProto.BacktestResponseOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestResponse_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestResponse_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.TradingServiceProto.BacktestResponse.class, com.spiketrade.proto.TradingServiceProto.BacktestResponse.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.TradingServiceProto.BacktestResponse.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        success_ = false;\n        message_ = \"\";\n        if (tradesBuilder_ == null) {\n          trades_ = java.util.Collections.emptyList();\n        } else {\n          trades_ = null;\n          tradesBuilder_.clear();\n        }\n        bitField0_ = (bitField0_ & ~0x00000004);\n        finalBalance_ = 0D;\n        totalReturn_ = 0D;\n        totalTrades_ = 0;\n        winningTrades_ = 0;\n        losingTrades_ = 0;\n        winRate_ = 0D;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_BacktestResponse_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.BacktestResponse getDefaultInstanceForType() {\n        return com.spiketrade.proto.TradingServiceProto.BacktestResponse.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.BacktestResponse build() {\n        com.spiketrade.proto.TradingServiceProto.BacktestResponse result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.BacktestResponse buildPartial() {\n        com.spiketrade.proto.TradingServiceProto.BacktestResponse result = new com.spiketrade.proto.TradingServiceProto.BacktestResponse(this);\n        buildPartialRepeatedFields(result);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartialRepeatedFields(com.spiketrade.proto.TradingServiceProto.BacktestResponse result) {\n        if (tradesBuilder_ == null) {\n          if (((bitField0_ & 0x00000004) != 0)) {\n            trades_ = java.util.Collections.unmodifiableList(trades_);\n            bitField0_ = (bitField0_ & ~0x00000004);\n          }\n          result.trades_ = trades_;\n        } else {\n          result.trades_ = tradesBuilder_.build();\n        }\n      }\n\n      private void buildPartial0(com.spiketrade.proto.TradingServiceProto.BacktestResponse result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.success_ = success_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.message_ = message_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.finalBalance_ = finalBalance_;\n        }\n        if (((from_bitField0_ & 0x00000010) != 0)) {\n          result.totalReturn_ = totalReturn_;\n        }\n        if (((from_bitField0_ & 0x00000020) != 0)) {\n          result.totalTrades_ = totalTrades_;\n        }\n        if (((from_bitField0_ & 0x00000040) != 0)) {\n          result.winningTrades_ = winningTrades_;\n        }\n        if (((from_bitField0_ & 0x00000080) != 0)) {\n          result.losingTrades_ = losingTrades_;\n        }\n        if (((from_bitField0_ & 0x00000100) != 0)) {\n          result.winRate_ = winRate_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.TradingServiceProto.BacktestResponse) {\n          return mergeFrom((com.spiketrade.proto.TradingServiceProto.BacktestResponse)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.TradingServiceProto.BacktestResponse other) {\n        if (other == com.spiketrade.proto.TradingServiceProto.BacktestResponse.getDefaultInstance()) return this;\n        if (other.getSuccess() != false) {\n          setSuccess(other.getSuccess());\n        }\n        if (!other.getMessage().isEmpty()) {\n          message_ = other.message_;\n          bitField0_ |= 0x00000002;\n          onChanged();\n        }\n        if (tradesBuilder_ == null) {\n          if (!other.trades_.isEmpty()) {\n            if (trades_.isEmpty()) {\n              trades_ = other.trades_;\n              bitField0_ = (bitField0_ & ~0x00000004);\n            } else {\n              ensureTradesIsMutable();\n              trades_.addAll(other.trades_);\n            }\n            onChanged();\n          }\n        } else {\n          if (!other.trades_.isEmpty()) {\n            if (tradesBuilder_.isEmpty()) {\n              tradesBuilder_.dispose();\n              tradesBuilder_ = null;\n              trades_ = other.trades_;\n              bitField0_ = (bitField0_ & ~0x00000004);\n              tradesBuilder_ = \n                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?\n                   getTradesFieldBuilder() : null;\n            } else {\n              tradesBuilder_.addAllMessages(other.trades_);\n            }\n          }\n        }\n        if (other.getFinalBalance() != 0D) {\n          setFinalBalance(other.getFinalBalance());\n        }\n        if (other.getTotalReturn() != 0D) {\n          setTotalReturn(other.getTotalReturn());\n        }\n        if (other.getTotalTrades() != 0) {\n          setTotalTrades(other.getTotalTrades());\n        }\n        if (other.getWinningTrades() != 0) {\n          setWinningTrades(other.getWinningTrades());\n        }\n        if (other.getLosingTrades() != 0) {\n          setLosingTrades(other.getLosingTrades());\n        }\n        if (other.getWinRate() != 0D) {\n          setWinRate(other.getWinRate());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 8: {\n                success_ = input.readBool();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 8\n              case 18: {\n                message_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 18\n              case 26: {\n                com.spiketrade.proto.TradingServiceProto.BacktestTrade m =\n                    input.readMessage(\n                        com.spiketrade.proto.TradingServiceProto.BacktestTrade.parser(),\n                        extensionRegistry);\n                if (tradesBuilder_ == null) {\n                  ensureTradesIsMutable();\n                  trades_.add(m);\n                } else {\n                  tradesBuilder_.addMessage(m);\n                }\n                break;\n              } // case 26\n              case 33: {\n                finalBalance_ = input.readDouble();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 33\n              case 41: {\n                totalReturn_ = input.readDouble();\n                bitField0_ |= 0x00000010;\n                break;\n              } // case 41\n              case 48: {\n                totalTrades_ = input.readInt32();\n                bitField0_ |= 0x00000020;\n                break;\n              } // case 48\n              case 56: {\n                winningTrades_ = input.readInt32();\n                bitField0_ |= 0x00000040;\n                break;\n              } // case 56\n              case 64: {\n                losingTrades_ = input.readInt32();\n                bitField0_ |= 0x00000080;\n                break;\n              } // case 64\n              case 73: {\n                winRate_ = input.readDouble();\n                bitField0_ |= 0x00000100;\n                break;\n              } // case 73\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private boolean success_ ;\n      /**\n       * <code>bool success = 1;</code>\n       * @return The success.\n       */\n      @java.lang.Override\n      public boolean getSuccess() {\n        return success_;\n      }\n      /**\n       * <code>bool success = 1;</code>\n       * @param value The success to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSuccess(boolean value) {\n\n        success_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool success = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSuccess() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        success_ = false;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object message_ = \"\";\n      /**\n       * <code>string message = 2;</code>\n       * @return The message.\n       */\n      public java.lang.String getMessage() {\n        java.lang.Object ref = message_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          message_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @return The bytes for message.\n       */\n      public com.google.protobuf.ByteString\n          getMessageBytes() {\n        java.lang.Object ref = message_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          message_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @param value The message to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMessage(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        message_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMessage() {\n        message_ = getDefaultInstance().getMessage();\n        bitField0_ = (bitField0_ & ~0x00000002);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @param value The bytes for message to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMessageBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        message_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n\n      private java.util.List<com.spiketrade.proto.TradingServiceProto.BacktestTrade> trades_ =\n        java.util.Collections.emptyList();\n      private void ensureTradesIsMutable() {\n        if (!((bitField0_ & 0x00000004) != 0)) {\n          trades_ = new java.util.ArrayList<com.spiketrade.proto.TradingServiceProto.BacktestTrade>(trades_);\n          bitField0_ |= 0x00000004;\n         }\n      }\n\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          com.spiketrade.proto.TradingServiceProto.BacktestTrade, com.spiketrade.proto.TradingServiceProto.BacktestTrade.Builder, com.spiketrade.proto.TradingServiceProto.BacktestTradeOrBuilder> tradesBuilder_;\n\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public java.util.List<com.spiketrade.proto.TradingServiceProto.BacktestTrade> getTradesList() {\n        if (tradesBuilder_ == null) {\n          return java.util.Collections.unmodifiableList(trades_);\n        } else {\n          return tradesBuilder_.getMessageList();\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public int getTradesCount() {\n        if (tradesBuilder_ == null) {\n          return trades_.size();\n        } else {\n          return tradesBuilder_.getCount();\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public com.spiketrade.proto.TradingServiceProto.BacktestTrade getTrades(int index) {\n        if (tradesBuilder_ == null) {\n          return trades_.get(index);\n        } else {\n          return tradesBuilder_.getMessage(index);\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public Builder setTrades(\n          int index, com.spiketrade.proto.TradingServiceProto.BacktestTrade value) {\n        if (tradesBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureTradesIsMutable();\n          trades_.set(index, value);\n          onChanged();\n        } else {\n          tradesBuilder_.setMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public Builder setTrades(\n          int index, com.spiketrade.proto.TradingServiceProto.BacktestTrade.Builder builderForValue) {\n        if (tradesBuilder_ == null) {\n          ensureTradesIsMutable();\n          trades_.set(index, builderForValue.build());\n          onChanged();\n        } else {\n          tradesBuilder_.setMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public Builder addTrades(com.spiketrade.proto.TradingServiceProto.BacktestTrade value) {\n        if (tradesBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureTradesIsMutable();\n          trades_.add(value);\n          onChanged();\n        } else {\n          tradesBuilder_.addMessage(value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public Builder addTrades(\n          int index, com.spiketrade.proto.TradingServiceProto.BacktestTrade value) {\n        if (tradesBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureTradesIsMutable();\n          trades_.add(index, value);\n          onChanged();\n        } else {\n          tradesBuilder_.addMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public Builder addTrades(\n          com.spiketrade.proto.TradingServiceProto.BacktestTrade.Builder builderForValue) {\n        if (tradesBuilder_ == null) {\n          ensureTradesIsMutable();\n          trades_.add(builderForValue.build());\n          onChanged();\n        } else {\n          tradesBuilder_.addMessage(builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public Builder addTrades(\n          int index, com.spiketrade.proto.TradingServiceProto.BacktestTrade.Builder builderForValue) {\n        if (tradesBuilder_ == null) {\n          ensureTradesIsMutable();\n          trades_.add(index, builderForValue.build());\n          onChanged();\n        } else {\n          tradesBuilder_.addMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public Builder addAllTrades(\n          java.lang.Iterable<? extends com.spiketrade.proto.TradingServiceProto.BacktestTrade> values) {\n        if (tradesBuilder_ == null) {\n          ensureTradesIsMutable();\n          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n              values, trades_);\n          onChanged();\n        } else {\n          tradesBuilder_.addAllMessages(values);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public Builder clearTrades() {\n        if (tradesBuilder_ == null) {\n          trades_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000004);\n          onChanged();\n        } else {\n          tradesBuilder_.clear();\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public Builder removeTrades(int index) {\n        if (tradesBuilder_ == null) {\n          ensureTradesIsMutable();\n          trades_.remove(index);\n          onChanged();\n        } else {\n          tradesBuilder_.remove(index);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public com.spiketrade.proto.TradingServiceProto.BacktestTrade.Builder getTradesBuilder(\n          int index) {\n        return getTradesFieldBuilder().getBuilder(index);\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public com.spiketrade.proto.TradingServiceProto.BacktestTradeOrBuilder getTradesOrBuilder(\n          int index) {\n        if (tradesBuilder_ == null) {\n          return trades_.get(index);  } else {\n          return tradesBuilder_.getMessageOrBuilder(index);\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public java.util.List<? extends com.spiketrade.proto.TradingServiceProto.BacktestTradeOrBuilder> \n           getTradesOrBuilderList() {\n        if (tradesBuilder_ != null) {\n          return tradesBuilder_.getMessageOrBuilderList();\n        } else {\n          return java.util.Collections.unmodifiableList(trades_);\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public com.spiketrade.proto.TradingServiceProto.BacktestTrade.Builder addTradesBuilder() {\n        return getTradesFieldBuilder().addBuilder(\n            com.spiketrade.proto.TradingServiceProto.BacktestTrade.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public com.spiketrade.proto.TradingServiceProto.BacktestTrade.Builder addTradesBuilder(\n          int index) {\n        return getTradesFieldBuilder().addBuilder(\n            index, com.spiketrade.proto.TradingServiceProto.BacktestTrade.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .spiketrade.proto.BacktestTrade trades = 3;</code>\n       */\n      public java.util.List<com.spiketrade.proto.TradingServiceProto.BacktestTrade.Builder> \n           getTradesBuilderList() {\n        return getTradesFieldBuilder().getBuilderList();\n      }\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          com.spiketrade.proto.TradingServiceProto.BacktestTrade, com.spiketrade.proto.TradingServiceProto.BacktestTrade.Builder, com.spiketrade.proto.TradingServiceProto.BacktestTradeOrBuilder> \n          getTradesFieldBuilder() {\n        if (tradesBuilder_ == null) {\n          tradesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<\n              com.spiketrade.proto.TradingServiceProto.BacktestTrade, com.spiketrade.proto.TradingServiceProto.BacktestTrade.Builder, com.spiketrade.proto.TradingServiceProto.BacktestTradeOrBuilder>(\n                  trades_,\n                  ((bitField0_ & 0x00000004) != 0),\n                  getParentForChildren(),\n                  isClean());\n          trades_ = null;\n        }\n        return tradesBuilder_;\n      }\n\n      private double finalBalance_ ;\n      /**\n       * <code>double final_balance = 4;</code>\n       * @return The finalBalance.\n       */\n      @java.lang.Override\n      public double getFinalBalance() {\n        return finalBalance_;\n      }\n      /**\n       * <code>double final_balance = 4;</code>\n       * @param value The finalBalance to set.\n       * @return This builder for chaining.\n       */\n      public Builder setFinalBalance(double value) {\n\n        finalBalance_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double final_balance = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearFinalBalance() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        finalBalance_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double totalReturn_ ;\n      /**\n       * <code>double total_return = 5;</code>\n       * @return The totalReturn.\n       */\n      @java.lang.Override\n      public double getTotalReturn() {\n        return totalReturn_;\n      }\n      /**\n       * <code>double total_return = 5;</code>\n       * @param value The totalReturn to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTotalReturn(double value) {\n\n        totalReturn_ = value;\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double total_return = 5;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTotalReturn() {\n        bitField0_ = (bitField0_ & ~0x00000010);\n        totalReturn_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private int totalTrades_ ;\n      /**\n       * <code>int32 total_trades = 6;</code>\n       * @return The totalTrades.\n       */\n      @java.lang.Override\n      public int getTotalTrades() {\n        return totalTrades_;\n      }\n      /**\n       * <code>int32 total_trades = 6;</code>\n       * @param value The totalTrades to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTotalTrades(int value) {\n\n        totalTrades_ = value;\n        bitField0_ |= 0x00000020;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 total_trades = 6;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTotalTrades() {\n        bitField0_ = (bitField0_ & ~0x00000020);\n        totalTrades_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int winningTrades_ ;\n      /**\n       * <code>int32 winning_trades = 7;</code>\n       * @return The winningTrades.\n       */\n      @java.lang.Override\n      public int getWinningTrades() {\n        return winningTrades_;\n      }\n      /**\n       * <code>int32 winning_trades = 7;</code>\n       * @param value The winningTrades to set.\n       * @return This builder for chaining.\n       */\n      public Builder setWinningTrades(int value) {\n\n        winningTrades_ = value;\n        bitField0_ |= 0x00000040;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 winning_trades = 7;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearWinningTrades() {\n        bitField0_ = (bitField0_ & ~0x00000040);\n        winningTrades_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int losingTrades_ ;\n      /**\n       * <code>int32 losing_trades = 8;</code>\n       * @return The losingTrades.\n       */\n      @java.lang.Override\n      public int getLosingTrades() {\n        return losingTrades_;\n      }\n      /**\n       * <code>int32 losing_trades = 8;</code>\n       * @param value The losingTrades to set.\n       * @return This builder for chaining.\n       */\n      public Builder setLosingTrades(int value) {\n\n        losingTrades_ = value;\n        bitField0_ |= 0x00000080;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 losing_trades = 8;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearLosingTrades() {\n        bitField0_ = (bitField0_ & ~0x00000080);\n        losingTrades_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private double winRate_ ;\n      /**\n       * <code>double win_rate = 9;</code>\n       * @return The winRate.\n       */\n      @java.lang.Override\n      public double getWinRate() {\n        return winRate_;\n      }\n      /**\n       * <code>double win_rate = 9;</code>\n       * @param value The winRate to set.\n       * @return This builder for chaining.\n       */\n      public Builder setWinRate(double value) {\n\n        winRate_ = value;\n        bitField0_ |= 0x00000100;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double win_rate = 9;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearWinRate() {\n        bitField0_ = (bitField0_ & ~0x00000100);\n        winRate_ = 0D;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.BacktestResponse)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.BacktestResponse)\n    private static final com.spiketrade.proto.TradingServiceProto.BacktestResponse DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.TradingServiceProto.BacktestResponse();\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.BacktestResponse getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<BacktestResponse>\n        PARSER = new com.google.protobuf.AbstractParser<BacktestResponse>() {\n      @java.lang.Override\n      public BacktestResponse parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<BacktestResponse> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<BacktestResponse> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.BacktestResponse getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface TradeOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.Trade)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    java.lang.String getSymbol();\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    com.google.protobuf.ByteString\n        getSymbolBytes();\n\n    /**\n     * <code>double entry_price = 2;</code>\n     * @return The entryPrice.\n     */\n    double getEntryPrice();\n\n    /**\n     * <code>double exit_price = 3;</code>\n     * @return The exitPrice.\n     */\n    double getExitPrice();\n\n    /**\n     * <code>int32 shares = 4;</code>\n     * @return The shares.\n     */\n    int getShares();\n\n    /**\n     * <code>int64 entry_time_ms = 5;</code>\n     * @return The entryTimeMs.\n     */\n    long getEntryTimeMs();\n\n    /**\n     * <code>int64 exit_time_ms = 6;</code>\n     * @return The exitTimeMs.\n     */\n    long getExitTimeMs();\n\n    /**\n     * <code>double profit_loss = 7;</code>\n     * @return The profitLoss.\n     */\n    double getProfitLoss();\n\n    /**\n     * <code>double profit_loss_pct = 8;</code>\n     * @return The profitLossPct.\n     */\n    double getProfitLossPct();\n\n    /**\n     * <code>bool is_open = 9;</code>\n     * @return The isOpen.\n     */\n    boolean getIsOpen();\n  }\n  /**\n   * <pre>\n   * Trade tracking messages\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.Trade}\n   */\n  public static final class Trade extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.Trade)\n      TradeOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use Trade.newBuilder() to construct.\n    private Trade(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private Trade() {\n      symbol_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new Trade();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_Trade_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_Trade_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.Trade.class, com.spiketrade.proto.TradingServiceProto.Trade.Builder.class);\n    }\n\n    public static final int SYMBOL_FIELD_NUMBER = 1;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object symbol_ = \"\";\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    @java.lang.Override\n    public java.lang.String getSymbol() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        symbol_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getSymbolBytes() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        symbol_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int ENTRY_PRICE_FIELD_NUMBER = 2;\n    private double entryPrice_ = 0D;\n    /**\n     * <code>double entry_price = 2;</code>\n     * @return The entryPrice.\n     */\n    @java.lang.Override\n    public double getEntryPrice() {\n      return entryPrice_;\n    }\n\n    public static final int EXIT_PRICE_FIELD_NUMBER = 3;\n    private double exitPrice_ = 0D;\n    /**\n     * <code>double exit_price = 3;</code>\n     * @return The exitPrice.\n     */\n    @java.lang.Override\n    public double getExitPrice() {\n      return exitPrice_;\n    }\n\n    public static final int SHARES_FIELD_NUMBER = 4;\n    private int shares_ = 0;\n    /**\n     * <code>int32 shares = 4;</code>\n     * @return The shares.\n     */\n    @java.lang.Override\n    public int getShares() {\n      return shares_;\n    }\n\n    public static final int ENTRY_TIME_MS_FIELD_NUMBER = 5;\n    private long entryTimeMs_ = 0L;\n    /**\n     * <code>int64 entry_time_ms = 5;</code>\n     * @return The entryTimeMs.\n     */\n    @java.lang.Override\n    public long getEntryTimeMs() {\n      return entryTimeMs_;\n    }\n\n    public static final int EXIT_TIME_MS_FIELD_NUMBER = 6;\n    private long exitTimeMs_ = 0L;\n    /**\n     * <code>int64 exit_time_ms = 6;</code>\n     * @return The exitTimeMs.\n     */\n    @java.lang.Override\n    public long getExitTimeMs() {\n      return exitTimeMs_;\n    }\n\n    public static final int PROFIT_LOSS_FIELD_NUMBER = 7;\n    private double profitLoss_ = 0D;\n    /**\n     * <code>double profit_loss = 7;</code>\n     * @return The profitLoss.\n     */\n    @java.lang.Override\n    public double getProfitLoss() {\n      return profitLoss_;\n    }\n\n    public static final int PROFIT_LOSS_PCT_FIELD_NUMBER = 8;\n    private double profitLossPct_ = 0D;\n    /**\n     * <code>double profit_loss_pct = 8;</code>\n     * @return The profitLossPct.\n     */\n    @java.lang.Override\n    public double getProfitLossPct() {\n      return profitLossPct_;\n    }\n\n    public static final int IS_OPEN_FIELD_NUMBER = 9;\n    private boolean isOpen_ = false;\n    /**\n     * <code>bool is_open = 9;</code>\n     * @return The isOpen.\n     */\n    @java.lang.Override\n    public boolean getIsOpen() {\n      return isOpen_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, symbol_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(entryPrice_) != 0) {\n        output.writeDouble(2, entryPrice_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(exitPrice_) != 0) {\n        output.writeDouble(3, exitPrice_);\n      }\n      if (shares_ != 0) {\n        output.writeInt32(4, shares_);\n      }\n      if (entryTimeMs_ != 0L) {\n        output.writeInt64(5, entryTimeMs_);\n      }\n      if (exitTimeMs_ != 0L) {\n        output.writeInt64(6, exitTimeMs_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(profitLoss_) != 0) {\n        output.writeDouble(7, profitLoss_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(profitLossPct_) != 0) {\n        output.writeDouble(8, profitLossPct_);\n      }\n      if (isOpen_ != false) {\n        output.writeBool(9, isOpen_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, symbol_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(entryPrice_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(2, entryPrice_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(exitPrice_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(3, exitPrice_);\n      }\n      if (shares_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(4, shares_);\n      }\n      if (entryTimeMs_ != 0L) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt64Size(5, entryTimeMs_);\n      }\n      if (exitTimeMs_ != 0L) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt64Size(6, exitTimeMs_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(profitLoss_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(7, profitLoss_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(profitLossPct_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(8, profitLossPct_);\n      }\n      if (isOpen_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(9, isOpen_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.Trade)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.Trade other = (com.spiketrade.proto.TradingServiceProto.Trade) obj;\n\n      if (!getSymbol()\n          .equals(other.getSymbol())) return false;\n      if (java.lang.Double.doubleToLongBits(getEntryPrice())\n          != java.lang.Double.doubleToLongBits(\n              other.getEntryPrice())) return false;\n      if (java.lang.Double.doubleToLongBits(getExitPrice())\n          != java.lang.Double.doubleToLongBits(\n              other.getExitPrice())) return false;\n      if (getShares()\n          != other.getShares()) return false;\n      if (getEntryTimeMs()\n          != other.getEntryTimeMs()) return false;\n      if (getExitTimeMs()\n          != other.getExitTimeMs()) return false;\n      if (java.lang.Double.doubleToLongBits(getProfitLoss())\n          != java.lang.Double.doubleToLongBits(\n              other.getProfitLoss())) return false;\n      if (java.lang.Double.doubleToLongBits(getProfitLossPct())\n          != java.lang.Double.doubleToLongBits(\n              other.getProfitLossPct())) return false;\n      if (getIsOpen()\n          != other.getIsOpen()) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + SYMBOL_FIELD_NUMBER;\n      hash = (53 * hash) + getSymbol().hashCode();\n      hash = (37 * hash) + ENTRY_PRICE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getEntryPrice()));\n      hash = (37 * hash) + EXIT_PRICE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getExitPrice()));\n      hash = (37 * hash) + SHARES_FIELD_NUMBER;\n      hash = (53 * hash) + getShares();\n      hash = (37 * hash) + ENTRY_TIME_MS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          getEntryTimeMs());\n      hash = (37 * hash) + EXIT_TIME_MS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          getExitTimeMs());\n      hash = (37 * hash) + PROFIT_LOSS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getProfitLoss()));\n      hash = (37 * hash) + PROFIT_LOSS_PCT_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getProfitLossPct()));\n      hash = (37 * hash) + IS_OPEN_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getIsOpen());\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.Trade parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.Trade parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.Trade parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.Trade parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.Trade parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.Trade parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.Trade parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.Trade parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.Trade parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.Trade parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.Trade parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.Trade parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.Trade prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Trade tracking messages\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.Trade}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.Trade)\n        com.spiketrade.proto.TradingServiceProto.TradeOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_Trade_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_Trade_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.TradingServiceProto.Trade.class, com.spiketrade.proto.TradingServiceProto.Trade.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.TradingServiceProto.Trade.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        symbol_ = \"\";\n        entryPrice_ = 0D;\n        exitPrice_ = 0D;\n        shares_ = 0;\n        entryTimeMs_ = 0L;\n        exitTimeMs_ = 0L;\n        profitLoss_ = 0D;\n        profitLossPct_ = 0D;\n        isOpen_ = false;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_Trade_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.Trade getDefaultInstanceForType() {\n        return com.spiketrade.proto.TradingServiceProto.Trade.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.Trade build() {\n        com.spiketrade.proto.TradingServiceProto.Trade result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.TradingServiceProto.Trade buildPartial() {\n        com.spiketrade.proto.TradingServiceProto.Trade result = new com.spiketrade.proto.TradingServiceProto.Trade(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.TradingServiceProto.Trade result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.symbol_ = symbol_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.entryPrice_ = entryPrice_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.exitPrice_ = exitPrice_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.shares_ = shares_;\n        }\n        if (((from_bitField0_ & 0x00000010) != 0)) {\n          result.entryTimeMs_ = entryTimeMs_;\n        }\n        if (((from_bitField0_ & 0x00000020) != 0)) {\n          result.exitTimeMs_ = exitTimeMs_;\n        }\n        if (((from_bitField0_ & 0x00000040) != 0)) {\n          result.profitLoss_ = profitLoss_;\n        }\n        if (((from_bitField0_ & 0x00000080) != 0)) {\n          result.profitLossPct_ = profitLossPct_;\n        }\n        if (((from_bitField0_ & 0x00000100) != 0)) {\n          result.isOpen_ = isOpen_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.TradingServiceProto.Trade) {\n          return mergeFrom((com.spiketrade.proto.TradingServiceProto.Trade)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.TradingServiceProto.Trade other) {\n        if (other == com.spiketrade.proto.TradingServiceProto.Trade.getDefaultInstance()) return this;\n        if (!other.getSymbol().isEmpty()) {\n          symbol_ = other.symbol_;\n          bitField0_ |= 0x00000001;\n          onChanged();\n        }\n        if (other.getEntryPrice() != 0D) {\n          setEntryPrice(other.getEntryPrice());\n        }\n        if (other.getExitPrice() != 0D) {\n          setExitPrice(other.getExitPrice());\n        }\n        if (other.getShares() != 0) {\n          setShares(other.getShares());\n        }\n        if (other.getEntryTimeMs() != 0L) {\n          setEntryTimeMs(other.getEntryTimeMs());\n        }\n        if (other.getExitTimeMs() != 0L) {\n          setExitTimeMs(other.getExitTimeMs());\n        }\n        if (other.getProfitLoss() != 0D) {\n          setProfitLoss(other.getProfitLoss());\n        }\n        if (other.getProfitLossPct() != 0D) {\n          setProfitLossPct(other.getProfitLossPct());\n        }\n        if (other.getIsOpen() != false) {\n          setIsOpen(other.getIsOpen());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 10: {\n                symbol_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 10\n              case 17: {\n                entryPrice_ = input.readDouble();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 17\n              case 25: {\n                exitPrice_ = input.readDouble();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 25\n              case 32: {\n                shares_ = input.readInt32();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 32\n              case 40: {\n                entryTimeMs_ = input.readInt64();\n                bitField0_ |= 0x00000010;\n                break;\n              } // case 40\n              case 48: {\n                exitTimeMs_ = input.readInt64();\n                bitField0_ |= 0x00000020;\n                break;\n              } // case 48\n              case 57: {\n                profitLoss_ = input.readDouble();\n                bitField0_ |= 0x00000040;\n                break;\n              } // case 57\n              case 65: {\n                profitLossPct_ = input.readDouble();\n                bitField0_ |= 0x00000080;\n                break;\n              } // case 65\n              case 72: {\n                isOpen_ = input.readBool();\n                bitField0_ |= 0x00000100;\n                break;\n              } // case 72\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private java.lang.Object symbol_ = \"\";\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The symbol.\n       */\n      public java.lang.String getSymbol() {\n        java.lang.Object ref = symbol_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          symbol_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The bytes for symbol.\n       */\n      public com.google.protobuf.ByteString\n          getSymbolBytes() {\n        java.lang.Object ref = symbol_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          symbol_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbol(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSymbol() {\n        symbol_ = getDefaultInstance().getSymbol();\n        bitField0_ = (bitField0_ & ~0x00000001);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The bytes for symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbolBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n\n      private double entryPrice_ ;\n      /**\n       * <code>double entry_price = 2;</code>\n       * @return The entryPrice.\n       */\n      @java.lang.Override\n      public double getEntryPrice() {\n        return entryPrice_;\n      }\n      /**\n       * <code>double entry_price = 2;</code>\n       * @param value The entryPrice to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEntryPrice(double value) {\n\n        entryPrice_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double entry_price = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEntryPrice() {\n        bitField0_ = (bitField0_ & ~0x00000002);\n        entryPrice_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double exitPrice_ ;\n      /**\n       * <code>double exit_price = 3;</code>\n       * @return The exitPrice.\n       */\n      @java.lang.Override\n      public double getExitPrice() {\n        return exitPrice_;\n      }\n      /**\n       * <code>double exit_price = 3;</code>\n       * @param value The exitPrice to set.\n       * @return This builder for chaining.\n       */\n      public Builder setExitPrice(double value) {\n\n        exitPrice_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double exit_price = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearExitPrice() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        exitPrice_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private int shares_ ;\n      /**\n       * <code>int32 shares = 4;</code>\n       * @return The shares.\n       */\n      @java.lang.Override\n      public int getShares() {\n        return shares_;\n      }\n      /**\n       * <code>int32 shares = 4;</code>\n       * @param value The shares to set.\n       * @return This builder for chaining.\n       */\n      public Builder setShares(int value) {\n\n        shares_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 shares = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearShares() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        shares_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private long entryTimeMs_ ;\n      /**\n       * <code>int64 entry_time_ms = 5;</code>\n       * @return The entryTimeMs.\n       */\n      @java.lang.Override\n      public long getEntryTimeMs() {\n        return entryTimeMs_;\n      }\n      /**\n       * <code>int64 entry_time_ms = 5;</code>\n       * @param value The entryTimeMs to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEntryTimeMs(long value) {\n\n        entryTimeMs_ = value;\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int64 entry_time_ms = 5;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEntryTimeMs() {\n        bitField0_ = (bitField0_ & ~0x00000010);\n        entryTimeMs_ = 0L;\n        onChanged();\n        return this;\n      }\n\n      private long exitTimeMs_ ;\n      /**\n       * <code>int64 exit_time_ms = 6;</code>\n       * @return The exitTimeMs.\n       */\n      @java.lang.Override\n      public long getExitTimeMs() {\n        return exitTimeMs_;\n      }\n      /**\n       * <code>int64 exit_time_ms = 6;</code>\n       * @param value The exitTimeMs to set.\n       * @return This builder for chaining.\n       */\n      public Builder setExitTimeMs(long value) {\n\n        exitTimeMs_ = value;\n        bitField0_ |= 0x00000020;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int64 exit_time_ms = 6;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearExitTimeMs() {\n        bitField0_ = (bitField0_ & ~0x00000020);\n        exitTimeMs_ = 0L;\n        onChanged();\n        return this;\n      }\n\n      private double profitLoss_ ;\n      /**\n       * <code>double profit_loss = 7;</code>\n       * @return The profitLoss.\n       */\n      @java.lang.Override\n      public double getProfitLoss() {\n        return profitLoss_;\n      }\n      /**\n       * <code>double profit_loss = 7;</code>\n       * @param value The profitLoss to set.\n       * @return This builder for chaining.\n       */\n      public Builder setProfitLoss(double value) {\n\n        profitLoss_ = value;\n        bitField0_ |= 0x00000040;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double profit_loss = 7;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearProfitLoss() {\n        bitField0_ = (bitField0_ & ~0x00000040);\n        profitLoss_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double profitLossPct_ ;\n      /**\n       * <code>double profit_loss_pct = 8;</code>\n       * @return The profitLossPct.\n       */\n      @java.lang.Override\n      public double getProfitLossPct() {\n        return profitLossPct_;\n      }\n      /**\n       * <code>double profit_loss_pct = 8;</code>\n       * @param value The profitLossPct to set.\n       * @return This builder for chaining.\n       */\n      public Builder setProfitLossPct(double value) {\n\n        profitLossPct_ = value;\n        bitField0_ |= 0x00000080;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double profit_loss_pct = 8;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearProfitLossPct() {\n        bitField0_ = (bitField0_ & ~0x00000080);\n        profitLossPct_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private boolean isOpen_ ;\n      /**\n       * <code>bool is_open = 9;</code>\n       * @return The isOpen.\n       */\n      @java.lang.Override\n      public boolean getIsOpen() {\n        return isOpen_;\n      }\n      /**\n       * <code>bool is_open = 9;</code>\n       * @param value The isOpen to set.\n       * @return This builder for chaining.\n       */\n      public Builder setIsOpen(boolean value) {\n\n        isOpen_ = value;\n        bitField0_ |= 0x00000100;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool is_open = 9;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearIsOpen() {\n        bitField0_ = (bitField0_ & ~0x00000100);\n        isOpen_ = false;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.Trade)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.Trade)\n    private static final com.spiketrade.proto.TradingServiceProto.Trade DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.TradingServiceProto.Trade();\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.Trade getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<Trade>\n        PARSER = new com.google.protobuf.AbstractParser<Trade>() {\n      @java.lang.Override\n      public Trade parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<Trade> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<Trade> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.TradingServiceProto.Trade getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface GetOpenTradesRequestOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.GetOpenTradesRequest)\n      com.google.protobuf.MessageOrBuilder {\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.GetOpenTradesRequest}\n   */\n  public static final class GetOpenTradesRequest extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.GetOpenTradesRequest)\n      GetOpenTradesRequestOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use GetOpenTradesRequest.newBuilder() to construct.\n    private GetOpenTradesRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private GetOpenTradesRequest() {\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new GetOpenTradesRequest();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_GetOpenTradesRequest_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_GetOpenTradesRequest_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest.class, com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest.Builder.class);\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest other = (com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest) obj;\n\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequest prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.GetOpenTradesRequest}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.GetOpenTradesRequest)\n        com.spiketrade.proto.TradingServiceProto.GetOpenTradesRequestOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_proto_GetOpenTradesRequest_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.TradingServiceProto.internal_static_spiketrade_prot","size_bytes":360000},"build/extracted-include-protos/main/google/api/field_behavior.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/descriptor.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/annotations;annotations\";\noption java_multiple_files = true;\noption java_outer_classname = \"FieldBehaviorProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\nextend google.protobuf.FieldOptions {\n  // A designation of a specific field behavior (required, output only, etc.)\n  // in protobuf messages.\n  //\n  // Examples:\n  //\n  //   string name = 1 [(google.api.field_behavior) = REQUIRED];\n  //   State state = 1 [(google.api.field_behavior) = OUTPUT_ONLY];\n  //   google.protobuf.Duration ttl = 1\n  //     [(google.api.field_behavior) = INPUT_ONLY];\n  //   google.protobuf.Timestamp expire_time = 1\n  //     [(google.api.field_behavior) = OUTPUT_ONLY,\n  //      (google.api.field_behavior) = IMMUTABLE];\n  repeated google.api.FieldBehavior field_behavior = 1052;\n}\n\n// An indicator of the behavior of a given field (for example, that a field\n// is required in requests, or given as output but ignored as input).\n// This **does not** change the behavior in protocol buffers itself; it only\n// denotes the behavior and may affect how API tooling handles the field.\n//\n// Note: This enum **may** receive new values in the future.\nenum FieldBehavior {\n  // Conventional default for enums. Do not use this.\n  FIELD_BEHAVIOR_UNSPECIFIED = 0;\n\n  // Specifically denotes a field as optional.\n  // While all fields in protocol buffers are optional, this may be specified\n  // for emphasis if appropriate.\n  OPTIONAL = 1;\n\n  // Denotes a field as required.\n  // This indicates that the field **must** be provided as part of the request,\n  // and failure to do so will cause an error (usually `INVALID_ARGUMENT`).\n  REQUIRED = 2;\n\n  // Denotes a field as output only.\n  // This indicates that the field is provided in responses, but including the\n  // field in a request does nothing (the server *must* ignore it and\n  // *must not* throw an error as a result of the field's presence).\n  OUTPUT_ONLY = 3;\n\n  // Denotes a field as input only.\n  // This indicates that the field is provided in requests, and the\n  // corresponding field is not included in output.\n  INPUT_ONLY = 4;\n\n  // Denotes a field as immutable.\n  // This indicates that the field may be set once in a request to create a\n  // resource, but may not be changed thereafter.\n  IMMUTABLE = 5;\n\n  // Denotes that a (repeated) field is an unordered list.\n  // This indicates that the service may provide the elements of the list\n  // in any arbitrary  order, rather than the order the user originally\n  // provided. Additionally, the list's order may or may not be stable.\n  UNORDERED_LIST = 6;\n\n  // Denotes that this field returns a non-empty default value if not set.\n  // This indicates that if the user provides the empty value in a request,\n  // a non-empty value will be returned. The user will not be aware of what\n  // non-empty value to expect.\n  NON_EMPTY_DEFAULT = 7;\n}\n","size_bytes":3604},"build/extracted-include-protos/main/google/type/month.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption go_package = \"google.golang.org/genproto/googleapis/type/month;month\";\noption java_multiple_files = true;\noption java_outer_classname = \"MonthProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a month in the Gregorian calendar.\nenum Month {\n  // The unspecified month.\n  MONTH_UNSPECIFIED = 0;\n\n  // The month of January.\n  JANUARY = 1;\n\n  // The month of February.\n  FEBRUARY = 2;\n\n  // The month of March.\n  MARCH = 3;\n\n  // The month of April.\n  APRIL = 4;\n\n  // The month of May.\n  MAY = 5;\n\n  // The month of June.\n  JUNE = 6;\n\n  // The month of July.\n  JULY = 7;\n\n  // The month of August.\n  AUGUST = 8;\n\n  // The month of September.\n  SEPTEMBER = 9;\n\n  // The month of October.\n  OCTOBER = 10;\n\n  // The month of November.\n  NOVEMBER = 11;\n\n  // The month of December.\n  DECEMBER = 12;\n}\n","size_bytes":1479},"build/extracted-include-protos/test/google/api/quota.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"QuotaProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Quota configuration helps to achieve fairness and budgeting in service\n// usage.\n//\n// The metric based quota configuration works this way:\n// - The service configuration defines a set of metrics.\n// - For API calls, the quota.metric_rules maps methods to metrics with\n//   corresponding costs.\n// - The quota.limits defines limits on the metrics, which will be used for\n//   quota checks at runtime.\n//\n// An example quota configuration in yaml format:\n//\n//    quota:\n//      limits:\n//\n//      - name: apiWriteQpsPerProject\n//        metric: library.googleapis.com/write_calls\n//        unit: \"1/min/{project}\"  # rate limit for consumer projects\n//        values:\n//          STANDARD: 10000\n//\n//\n//      (The metric rules bind all methods to the read_calls metric,\n//       except for the UpdateBook and DeleteBook methods. These two methods\n//       are mapped to the write_calls metric, with the UpdateBook method\n//       consuming at twice rate as the DeleteBook method.)\n//      metric_rules:\n//      - selector: \"*\"\n//        metric_costs:\n//          library.googleapis.com/read_calls: 1\n//      - selector: google.example.library.v1.LibraryService.UpdateBook\n//        metric_costs:\n//          library.googleapis.com/write_calls: 2\n//      - selector: google.example.library.v1.LibraryService.DeleteBook\n//        metric_costs:\n//          library.googleapis.com/write_calls: 1\n//\n//  Corresponding Metric definition:\n//\n//      metrics:\n//      - name: library.googleapis.com/read_calls\n//        display_name: Read requests\n//        metric_kind: DELTA\n//        value_type: INT64\n//\n//      - name: library.googleapis.com/write_calls\n//        display_name: Write requests\n//        metric_kind: DELTA\n//        value_type: INT64\n//\n//\nmessage Quota {\n  // List of QuotaLimit definitions for the service.\n  repeated QuotaLimit limits = 3;\n\n  // List of MetricRule definitions, each one mapping a selected method to one\n  // or more metrics.\n  repeated MetricRule metric_rules = 4;\n}\n\n// Bind API methods to metrics. Binding a method to a metric causes that\n// metric's configured quota behaviors to apply to the method call.\nmessage MetricRule {\n  // Selects the methods to which this rule applies.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // Metrics to update when the selected methods are called, and the associated\n  // cost applied to each metric.\n  //\n  // The key of the map is the metric name, and the values are the amount\n  // increased for the metric against which the quota limits are defined.\n  // The value must not be negative.\n  map<string, int64> metric_costs = 2;\n}\n\n// `QuotaLimit` defines a specific limit that applies over a specified duration\n// for a limit type. There can be at most one limit for a duration and limit\n// type combination defined within a `QuotaGroup`.\nmessage QuotaLimit {\n  // Name of the quota limit.\n  //\n  // The name must be provided, and it must be unique within the service. The\n  // name can only include alphanumeric characters as well as '-'.\n  //\n  // The maximum length of the limit name is 64 characters.\n  string name = 6;\n\n  // Optional. User-visible, extended description for this quota limit.\n  // Should be used only when more context is needed to understand this limit\n  // than provided by the limit's display name (see: `display_name`).\n  string description = 2;\n\n  // Default number of tokens that can be consumed during the specified\n  // duration. This is the number of tokens assigned when a client\n  // application developer activates the service for his/her project.\n  //\n  // Specifying a value of 0 will block all requests. This can be used if you\n  // are provisioning quota to selected consumers and blocking others.\n  // Similarly, a value of -1 will indicate an unlimited quota. No other\n  // negative values are allowed.\n  //\n  // Used by group-based quotas only.\n  int64 default_limit = 3;\n\n  // Maximum number of tokens that can be consumed during the specified\n  // duration. Client application developers can override the default limit up\n  // to this maximum. If specified, this value cannot be set to a value less\n  // than the default limit. If not specified, it is set to the default limit.\n  //\n  // To allow clients to apply overrides with no upper bound, set this to -1,\n  // indicating unlimited maximum quota.\n  //\n  // Used by group-based quotas only.\n  int64 max_limit = 4;\n\n  // Free tier value displayed in the Developers Console for this limit.\n  // The free tier is the number of tokens that will be subtracted from the\n  // billed amount when billing is enabled.\n  // This field can only be set on a limit with duration \"1d\", in a billable\n  // group; it is invalid on any other limit. If this field is not set, it\n  // defaults to 0, indicating that there is no free tier for this service.\n  //\n  // Used by group-based quotas only.\n  int64 free_tier = 7;\n\n  // Duration of this limit in textual notation. Must be \"100s\" or \"1d\".\n  //\n  // Used by group-based quotas only.\n  string duration = 5;\n\n  // The name of the metric this quota limit applies to. The quota limits with\n  // the same metric will be checked together during runtime. The metric must be\n  // defined within the service config.\n  string metric = 8;\n\n  // Specify the unit of the quota limit. It uses the same syntax as\n  // [Metric.unit][]. The supported unit kinds are determined by the quota\n  // backend system.\n  //\n  // Here are some examples:\n  // * \"1/min/{project}\" for quota per minute per project.\n  //\n  // Note: the order of unit components is insignificant.\n  // The \"1\" at the beginning is required to follow the metric unit syntax.\n  string unit = 9;\n\n  // Tiered limit values. You must specify this as a key:value pair, with an\n  // integer value that is the maximum number of requests allowed for the\n  // specified unit. Currently only STANDARD is supported.\n  map<string, int64> values = 10;\n\n  // User-visible display name for this limit.\n  // Optional. If not set, the UI will provide a default display name based on\n  // the quota configuration. This field can be used to override the default\n  // display name generated from the configuration.\n  string display_name = 12;\n}\n","size_bytes":7138},"src/main/java/com/spiketrade/repository/TradeRepository.java":{"content":"package com.spiketrade.repository;\n\nimport com.spiketrade.model.TradeRecord;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.sql.DataSource;\nimport java.sql.*;\nimport java.time.LocalDateTime;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\npublic class TradeRepository {\n    private static final Logger logger = LoggerFactory.getLogger(TradeRepository.class);\n    private final DataSource dataSource;\n    \n    public TradeRepository(DataSource dataSource) {\n        this.dataSource = dataSource;\n        initializeTables();\n    }\n    \n    private void initializeTables() {\n        String createTableSql = \"\"\"\n            CREATE TABLE IF NOT EXISTS trades (\n                id SERIAL PRIMARY KEY,\n                symbol VARCHAR(20) NOT NULL,\n                entry_price DECIMAL(10, 2) NOT NULL,\n                exit_price DECIMAL(10, 2),\n                quantity INTEGER NOT NULL,\n                entry_time TIMESTAMP NOT NULL,\n                exit_time TIMESTAMP,\n                profit_loss DECIMAL(10, 2),\n                profit_pct DECIMAL(10, 4),\n                status VARCHAR(20) NOT NULL,\n                strategy VARCHAR(50),\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\";\n        \n        try (Connection conn = dataSource.getConnection();\n             Statement stmt = conn.createStatement()) {\n            stmt.execute(createTableSql);\n            logger.info(\"Trade table initialized\");\n        } catch (SQLException e) {\n            logger.error(\"Failed to initialize trade table\", e);\n        }\n    }\n    \n    public void save(TradeRecord trade) {\n        String sql = \"\"\"\n            INSERT INTO trades (symbol, entry_price, exit_price, quantity, entry_time, \n                               exit_time, profit_loss, profit_pct, status, strategy)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\";\n        \n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            \n            pstmt.setString(1, trade.getSymbol());\n            pstmt.setDouble(2, trade.getEntryPrice());\n            pstmt.setDouble(3, trade.getExitPrice());\n            pstmt.setInt(4, trade.getQuantity());\n            pstmt.setTimestamp(5, Timestamp.valueOf(trade.getEntryTime()));\n            pstmt.setTimestamp(6, trade.getExitTime() != null ? \n                Timestamp.valueOf(trade.getExitTime()) : null);\n            pstmt.setDouble(7, trade.getProfitLoss());\n            pstmt.setDouble(8, trade.getProfitPct());\n            pstmt.setString(9, trade.getStatus());\n            pstmt.setString(10, \"\");\n            \n            pstmt.executeUpdate();\n            logger.debug(\"Saved trade: {}\", trade.getSymbol());\n            \n        } catch (SQLException e) {\n            logger.error(\"Failed to save trade\", e);\n        }\n    }\n    \n    public List<TradeRecord> findAll() {\n        String sql = \"SELECT * FROM trades ORDER BY entry_time DESC\";\n        List<TradeRecord> trades = new ArrayList<>();\n        \n        try (Connection conn = dataSource.getConnection();\n             Statement stmt = conn.createStatement();\n             ResultSet rs = stmt.executeQuery(sql)) {\n            \n            while (rs.next()) {\n                trades.add(mapResultSetToTrade(rs));\n            }\n            \n        } catch (SQLException e) {\n            logger.error(\"Failed to fetch trades\", e);\n        }\n        \n        return trades;\n    }\n    \n    public List<TradeRecord> findBySymbol(String symbol) {\n        String sql = \"SELECT * FROM trades WHERE symbol = ? ORDER BY entry_time DESC\";\n        List<TradeRecord> trades = new ArrayList<>();\n        \n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            \n            pstmt.setString(1, symbol);\n            ResultSet rs = pstmt.executeQuery();\n            \n            while (rs.next()) {\n                trades.add(mapResultSetToTrade(rs));\n            }\n            \n        } catch (SQLException e) {\n            logger.error(\"Failed to fetch trades for symbol: {}\", symbol, e);\n        }\n        \n        return trades;\n    }\n    \n    public List<TradeRecord> findByDateRange(LocalDateTime start, LocalDateTime end) {\n        String sql = \"SELECT * FROM trades WHERE entry_time BETWEEN ? AND ? ORDER BY entry_time DESC\";\n        List<TradeRecord> trades = new ArrayList<>();\n        \n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            \n            pstmt.setTimestamp(1, Timestamp.valueOf(start));\n            pstmt.setTimestamp(2, Timestamp.valueOf(end));\n            ResultSet rs = pstmt.executeQuery();\n            \n            while (rs.next()) {\n                trades.add(mapResultSetToTrade(rs));\n            }\n            \n        } catch (SQLException e) {\n            logger.error(\"Failed to fetch trades in date range\", e);\n        }\n        \n        return trades;\n    }\n    \n    private TradeRecord mapResultSetToTrade(ResultSet rs) throws SQLException {\n        TradeRecord trade = new TradeRecord(\n            rs.getString(\"symbol\"),\n            rs.getDouble(\"entry_price\"),\n            rs.getInt(\"quantity\"),\n            rs.getTimestamp(\"entry_time\").toLocalDateTime()\n        );\n        \n        Timestamp exitTime = rs.getTimestamp(\"exit_time\");\n        if (exitTime != null) {\n            trade.setExitTime(exitTime.toLocalDateTime());\n        }\n        \n        trade.setExitPrice(rs.getDouble(\"exit_price\"));\n        trade.setProfitLoss(rs.getDouble(\"profit_loss\"));\n        trade.setProfitPct(rs.getDouble(\"profit_pct\"));\n        trade.setStatus(rs.getString(\"status\"));\n        \n        return trade;\n    }\n}\n","size_bytes":5844},"src/main/proto/spike_signals.proto":{"content":"syntax = \"proto3\";\n\npackage spiketrade.proto;\n\noption java_package = \"com.spiketrade.proto\";\noption java_outer_classname = \"SpikeSignalsProto\";\n\n// Technical indicators\nmessage Indicators {\n  // Legacy indicators (keep for backward compatibility)\n  double rsi = 1;\n  double obv = 2;\n  double mfi = 3;\n  double vwap = 4;\n  double bollinger_upper = 5;\n  double bollinger_lower = 6;\n  double bollinger_position = 7;\n  double percent_b = 8;\n  double price_roc = 9;\n  double rsi_roc = 10;\n  double obv_roc = 11;\n  double mfi_roc = 12;\n  double bollinger_pos_roc = 13;\n  double percent_b_roc = 14;\n  double vwap_roc = 15;\n  double volume_roc = 16;\n  \n  // NEW INDICATORS for high volatility, low-priced stocks\n  // MACD (Moving Average Convergence Divergence)\n  double macd_line = 17;\n  double macd_signal = 18;\n  double macd_histogram = 19;\n  \n  // EMA (Exponential Moving Average) - multiple periods\n  double ema_9 = 20;\n  double ema_20 = 21;\n  double ema_50 = 22;\n  \n  // Stochastic Oscillator\n  double stoch_k = 23;  // %K line\n  double stoch_d = 24;  // %D line (signal)\n  \n  // Relative Volume\n  double rvol = 25;\n  \n  // Volume Spike Detection\n  bool volume_spike = 26;\n  double volume_ratio = 27;\n  \n  // ATR (Average True Range) - volatility indicator\n  double atr = 28;\n}\nmessage IndicatorStreamRequest {\n    repeated string symbols = 1;\n}\n\nmessage IndicatorUpdate {\n    string symbol = 1;\n    double rsi = 2;\n    double price_roc = 3;\n    double volume_roc = 4;\n    double obv = 5;\n    double mfi = 6;\n    double bollinger_position = 7;\n    double percent_b = 8;\n    double vwap = 9;\n    \n    // NEW INDICATORS\n    double macd_histogram = 10;\n    double ema_9 = 11;\n    double ema_20 = 12;\n    double ema_50 = 13;\n    double stoch_k = 14;\n    double stoch_d = 15;\n    double rvol = 16;\n    bool volume_spike = 17;\n    double atr = 18;\n}\n// Spike record\nmessage SpikeRecord {\n  int64 timestamp_ms = 1;\n  string symbol = 2;\n  string spike_type = 3;\n  double magnitude = 4;\n  int32 duration = 5;\n  double price_at_spike = 6;\n  int64 volume_at_spike = 7;\n  double rsi_at_spike = 8;\n  double bollinger_position = 9;\n  double market_volatility = 10;\n  int32 time_of_day = 11;\n  int32 day_of_week = 12;\n  \n  Indicators indicators = 13;\n  \n  bool outcome_profitable = 14;\n  double outcome_score = 15;\n  double statistical_z_score = 16;\n  string trend_context = 17;\n  double spike_quality_score = 18;\n  \n  bool is_root_spike = 19;\n  double root_spike_score = 20;\n  bool used_for_signal = 21;\n}\n\n// Buy signal message\nmessage BuySignal {\n  int64 timestamp_ms = 1;\n  string symbol = 2;\n  double price = 3;\n  double signal_probability = 4;\n  Indicators indicators = 5;\n  repeated SpikeRecord spikes = 6;\n  string reason = 7;\n  optional double predicted_gain_target = 8;\n  optional int32 predicted_time_to_target_minutes = 9;\n  optional double prediction_confidence = 10;\n  optional string prediction_reasoning = 11;\n}\n\n// Sell signal message\nmessage SellSignal {\n  int64 timestamp_ms = 1;\n  string symbol = 2;\n  double price = 3;\n  string reason = 4;\n  double profit_loss = 5;\n  double profit_loss_pct = 6;\n}\n\n// Sell warning message\nmessage SellWarning {\n  int64 timestamp_ms = 1;\n  string symbol = 2;\n  double price = 3;\n  double warning_probability = 4;\n  Indicators indicators = 5;\n  string reason = 6;\n}\n\n// Sell warning request\nmessage SellWarningRequest {\n  string symbol = 1;\n}\n\n// Signal stream request\nmessage SignalStreamRequest {\n  repeated string symbols = 1;\n  double min_probability = 2;\n}\n\n// Analysis status\nmessage AnalysisStatus {\n  string symbol = 1;\n  int32 data_points_collected = 2;\n  int32 warmup_required = 3;\n  bool ready_for_trading = 4;\n  int32 total_spikes_detected = 5;\n  int32 buy_signals_generated = 6;\n  Indicators latest_indicators = 7;\n  double latest_buy_probability = 8;\n}\n","size_bytes":3803},"build/extracted-include-protos/main/google/type/phone_number.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/phone_number;phone_number\";\noption java_multiple_files = true;\noption java_outer_classname = \"PhoneNumberProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// An object representing a phone number, suitable as an API wire format.\n//\n// This representation:\n//\n//  - should not be used for locale-specific formatting of a phone number, such\n//    as \"+1 (650) 253-0000 ext. 123\"\n//\n//  - is not designed for efficient storage\n//  - may not be suitable for dialing - specialized libraries (see references)\n//    should be used to parse the number for that purpose\n//\n// To do something meaningful with this number, such as format it for various\n// use-cases, convert it to an `i18n.phonenumbers.PhoneNumber` object first.\n//\n// For instance, in Java this would be:\n//\n//    com.google.type.PhoneNumber wireProto =\n//        com.google.type.PhoneNumber.newBuilder().build();\n//    com.google.i18n.phonenumbers.Phonenumber.PhoneNumber phoneNumber =\n//        PhoneNumberUtil.getInstance().parse(wireProto.getE164Number(), \"ZZ\");\n//    if (!wireProto.getExtension().isEmpty()) {\n//      phoneNumber.setExtension(wireProto.getExtension());\n//    }\n//\n//  Reference(s):\n//   - https://github.com/google/libphonenumber\nmessage PhoneNumber {\n  // An object representing a short code, which is a phone number that is\n  // typically much shorter than regular phone numbers and can be used to\n  // address messages in MMS and SMS systems, as well as for abbreviated dialing\n  // (e.g. \"Text 611 to see how many minutes you have remaining on your plan.\").\n  //\n  // Short codes are restricted to a region and are not internationally\n  // dialable, which means the same short code can exist in different regions,\n  // with different usage and pricing, even if those regions share the same\n  // country calling code (e.g. US and CA).\n  message ShortCode {\n    // Required. The BCP-47 region code of the location where calls to this\n    // short code can be made, such as \"US\" and \"BB\".\n    //\n    // Reference(s):\n    //  - http://www.unicode.org/reports/tr35/#unicode_region_subtag\n    string region_code = 1;\n\n    // Required. The short code digits, without a leading plus ('+') or country\n    // calling code, e.g. \"611\".\n    string number = 2;\n  }\n\n  // Required.  Either a regular number, or a short code.  New fields may be\n  // added to the oneof below in the future, so clients should ignore phone\n  // numbers for which none of the fields they coded against are set.\n  oneof kind {\n    // The phone number, represented as a leading plus sign ('+'), followed by a\n    // phone number that uses a relaxed ITU E.164 format consisting of the\n    // country calling code (1 to 3 digits) and the subscriber number, with no\n    // additional spaces or formatting, e.g.:\n    //  - correct: \"+15552220123\"\n    //  - incorrect: \"+1 (555) 222-01234 x123\".\n    //\n    // The ITU E.164 format limits the latter to 12 digits, but in practice not\n    // all countries respect that, so we relax that restriction here.\n    // National-only numbers are not allowed.\n    //\n    // References:\n    //  - https://www.itu.int/rec/T-REC-E.164-201011-I\n    //  - https://en.wikipedia.org/wiki/E.164.\n    //  - https://en.wikipedia.org/wiki/List_of_country_calling_codes\n    string e164_number = 1;\n\n    // A short code.\n    //\n    // Reference(s):\n    //  - https://en.wikipedia.org/wiki/Short_code\n    ShortCode short_code = 2;\n  }\n\n  // The phone number's extension. The extension is not standardized in ITU\n  // recommendations, except for being defined as a series of numbers with a\n  // maximum length of 40 digits. Other than digits, some other dialing\n  // characters such as ',' (indicating a wait) or '#' may be stored here.\n  //\n  // Note that no regions currently use extensions with short codes, so this\n  // field is normally only set in conjunction with an E.164 number. It is held\n  // separately from the E.164 number to allow for short code extensions in the\n  // future.\n  string extension = 3;\n}\n","size_bytes":4744},"src/main/java/com/spiketrade/controller/TradingController.java":{"content":"package com.spiketrade.controller;\n\nimport com.spiketrade.TradingServiceClient;\nimport com.spiketrade.model.TradeRecord;\nimport com.spiketrade.proto.ConfigProto;\nimport com.spiketrade.viewmodel.ApplicationState;\nimport javafx.application.Platform;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\npublic class TradingController {\n    private static final Logger logger = LoggerFactory.getLogger(TradingController.class);\n    \n    private final ApplicationState appState;\n    private final TradingServiceClient grpcClient;\n    \n    public TradingController(ApplicationState appState, TradingServiceClient grpcClient) {\n        this.appState = appState;\n        this.grpcClient = grpcClient;\n    }\n    \n    public void startTrading(List<String> symbols) {\n        ConfigProto.TradingConfig config = appState.getCurrentConfig();\n        grpcClient.startTrading(symbols, config, new TradingServiceClient.StartTradingCallback() {\n            @Override\n            public void onSuccess(String message) {\n                Platform.runLater(() -> {\n                    appState.setTradingEnabled(true);\n                    logger.info(\"Trading started successfully: {}\", message);\n                });\n            }\n            \n            @Override\n            public void onError(String error) {\n                Platform.runLater(() -> {\n                    appState.setTradingEnabled(false);\n                    logger.error(\"Failed to start trading: {}\", error);\n                });\n            }\n        });\n    }\n    \n    public void stopTrading() {\n        grpcClient.stopTrading(new TradingServiceClient.StopTradingCallback() {\n            @Override\n            public void onSuccess(String message) {\n                Platform.runLater(() -> {\n                    appState.setTradingEnabled(false);\n                    logger.info(\"Trading stopped successfully: {}\", message);\n                });\n            }\n            \n            @Override\n            public void onError(String error) {\n                logger.error(\"Failed to stop trading: {}\", error);\n            }\n        });\n    }\n    \n    public void connectQuestrade(String token, ConnectionResultCallback callback) {\n        grpcClient.connectQuestrade(token, new TradingServiceClient.ConnectionCallback() {\n            @Override\n            public void onSuccess(String message, com.spiketrade.proto.MarketDataProto.ConnectionStatus status) {\n                Platform.runLater(() -> {\n                    appState.setConnected(true);\n                    appState.setConnectionStatus(\"Connected: \" + message);\n                    logger.info(\"Questrade connected: {}\", message);\n                    if (callback != null) callback.onSuccess(message);\n                });\n            }\n            \n            @Override\n            public void onError(String error) {\n                Platform.runLater(() -> {\n                    appState.setConnected(false);\n                    appState.setConnectionStatus(\"Connection failed\");\n                    logger.error(\"Questrade connection failed: {}\", error);\n                    if (callback != null) callback.onError(error);\n                });\n            }\n        });\n    }\n    \n    public void updateConfiguration(ConfigProto.TradingConfig newConfig) {\n        appState.setCurrentConfig(newConfig);\n        logger.info(\"Configuration updated\");\n    }\n    \n    public void addTradeRecord(TradeRecord trade) {\n        Platform.runLater(() -> {\n            appState.getTradeRecords().add(trade);\n            // Note: Table refresh should be handled in the UI layer (SpikeTradeApp)\n            // since TradingController shouldn't have direct UI references\n            logger.debug(\"Added trade record: {}\", trade.getSymbol());\n        });\n    }\n    \n    public interface ConnectionResultCallback {\n        void onSuccess(String message);\n        void onError(String error);\n    }\n}\n","size_bytes":3929},"build/extracted-include-protos/main/google/api/logging.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"LoggingProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Logging configuration of the service.\n//\n// The following example shows how to configure logs to be sent to the\n// producer and consumer projects. In the example, the `activity_history`\n// log is sent to both the producer and consumer projects, whereas the\n// `purchase_history` log is only sent to the producer project.\n//\n//     monitored_resources:\n//     - type: library.googleapis.com/branch\n//       labels:\n//       - key: /city\n//         description: The city where the library branch is located in.\n//       - key: /name\n//         description: The name of the branch.\n//     logs:\n//     - name: activity_history\n//       labels:\n//       - key: /customer_id\n//     - name: purchase_history\n//     logging:\n//       producer_destinations:\n//       - monitored_resource: library.googleapis.com/branch\n//         logs:\n//         - activity_history\n//         - purchase_history\n//       consumer_destinations:\n//       - monitored_resource: library.googleapis.com/branch\n//         logs:\n//         - activity_history\nmessage Logging {\n  // Configuration of a specific logging destination (the producer project\n  // or the consumer project).\n  message LoggingDestination {\n    // The monitored resource type. The type must be defined in the\n    // [Service.monitored_resources][google.api.Service.monitored_resources]\n    // section.\n    string monitored_resource = 3;\n\n    // Names of the logs to be sent to this destination. Each name must\n    // be defined in the [Service.logs][google.api.Service.logs] section. If the\n    // log name is not a domain scoped name, it will be automatically prefixed\n    // with the service name followed by \"/\".\n    repeated string logs = 1;\n  }\n\n  // Logging configurations for sending logs to the producer project.\n  // There can be multiple producer destinations, each one must have a\n  // different monitored resource type. A log can be used in at most\n  // one producer destination.\n  repeated LoggingDestination producer_destinations = 1;\n\n  // Logging configurations for sending logs to the consumer project.\n  // There can be multiple consumer destinations, each one must have a\n  // different monitored resource type. A log can be used in at most\n  // one consumer destination.\n  repeated LoggingDestination consumer_destinations = 2;\n}\n","size_bytes":3174},"build/extracted-include-protos/test/google/api/billing.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"BillingProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Billing related configuration of the service.\n//\n// The following example shows how to configure monitored resources and metrics\n// for billing, `consumer_destinations` is the only supported destination and\n// the monitored resources need at least one label key\n// `cloud.googleapis.com/location` to indicate the location of the billing\n// usage, using different monitored resources between monitoring and billing is\n// recommended so they can be evolved independently:\n//\n//\n//     monitored_resources:\n//     - type: library.googleapis.com/billing_branch\n//       labels:\n//       - key: cloud.googleapis.com/location\n//         description: |\n//           Predefined label to support billing location restriction.\n//       - key: city\n//         description: |\n//           Custom label to define the city where the library branch is located\n//           in.\n//       - key: name\n//         description: Custom label to define the name of the library branch.\n//     metrics:\n//     - name: library.googleapis.com/book/borrowed_count\n//       metric_kind: DELTA\n//       value_type: INT64\n//       unit: \"1\"\n//     billing:\n//       consumer_destinations:\n//       - monitored_resource: library.googleapis.com/billing_branch\n//         metrics:\n//         - library.googleapis.com/book/borrowed_count\nmessage Billing {\n  // Configuration of a specific billing destination (Currently only support\n  // bill against consumer project).\n  message BillingDestination {\n    // The monitored resource type. The type must be defined in\n    // [Service.monitored_resources][google.api.Service.monitored_resources]\n    // section.\n    string monitored_resource = 1;\n\n    // Names of the metrics to report to this billing destination.\n    // Each name must be defined in\n    // [Service.metrics][google.api.Service.metrics] section.\n    repeated string metrics = 2;\n  }\n\n  // Billing configurations for sending metrics to the consumer project.\n  // There can be multiple consumer destinations per service, each one must have\n  // a different monitored resource type. A metric can be used in at most\n  // one consumer destination.\n  repeated BillingDestination consumer_destinations = 8;\n}\n","size_bytes":3062},"build/extracted-include-protos/test/google/api/control.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"ControlProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Selects and configures the service controller used by the service.\n//\n// Example:\n//\n//     control:\n//       environment: servicecontrol.googleapis.com\nmessage Control {\n  // The service controller environment to use. If empty, no control plane\n  // feature (like quota and billing) will be enabled. The recommended value for\n  // most services is servicecontrol.googleapis.com\n  string environment = 1;\n}\n","size_bytes":1289},"src/main/java/com/spiketrade/model/TradeRecord.java":{"content":"package com.spiketrade.model;\n\nimport java.time.LocalDateTime;\n\npublic class TradeRecord {\n    private String symbol;\n    private String entryTime;\n    private String exitTime;\n    private Double entryPrice;\n    private Double exitPrice;\n    private Integer shares;\n    private Double profit;\n    private Double profitPercent;\n    private String exitReason;\n    private String status;\n    \n    public TradeRecord(String symbol, String entryTime, String exitTime, Double entryPrice, \n                      Double exitPrice, Integer shares, Double profit, Double profitPercent, String exitReason) {\n        this.symbol = symbol;\n        this.entryTime = entryTime;\n        this.exitTime = exitTime;\n        this.entryPrice = entryPrice;\n        this.exitPrice = exitPrice;\n        this.shares = shares;\n        this.profit = profit;\n        this.profitPercent = profitPercent;\n        this.exitReason = exitReason;\n        this.status = \"CLOSED\";\n    }\n    \n    public TradeRecord(String symbol, Double entryPrice, Integer shares, LocalDateTime entryTime) {\n        this.symbol = symbol;\n        this.entryTime = entryTime.toString();\n        this.exitTime = null;\n        this.entryPrice = entryPrice;\n        this.exitPrice = null;\n        this.shares = shares;\n        this.profit = null;\n        this.profitPercent = null;\n        this.exitReason = null;\n        this.status = \"OPEN\";\n    }\n    \n    public String getSymbol() { return symbol; }\n    public String getEntryTime() { return entryTime; }\n    \n    public String getExitTime() { return exitTime; }\n    public void setExitTime(String exitTime) { this.exitTime = exitTime; }\n    public void setExitTime(LocalDateTime exitTime) { this.exitTime = exitTime.toString(); }\n    \n    public Double getEntryPrice() { return entryPrice; }\n    \n    public Double getExitPrice() { return exitPrice; }\n    public void setExitPrice(Double exitPrice) { this.exitPrice = exitPrice; }\n    \n    public Integer getShares() { return shares; }\n    public Integer getQuantity() { return shares; }\n    \n    public Double getProfit() { return profit; }\n    public Double getProfitLoss() { return profit; }\n    public void setProfitLoss(Double profitLoss) { this.profit = profitLoss; }\n    \n    public Double getProfitPercent() { return profitPercent; }\n    public Double getProfitPct() { return profitPercent; }\n    public void setProfitPct(Double profitPct) { this.profitPercent = profitPct; }\n    \n    public String getExitReason() { return exitReason; }\n    \n    public String getStatus() { return status; }\n    public void setStatus(String status) { this.status = status; }\n}\n","size_bytes":2617},"src/main/java/com/spiketrade/backend/QuestradeClient.java":{"content":"package com.spiketrade.backend;\n\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.JsonNode;\n\npublic class QuestradeClient {\n    private String refreshToken;\n    private String accessToken;\n    private String apiServer;\n    private Instant tokenExpiry;\n    \n    private ConnectionState connectionState;\n    private boolean usingFallback;\n    private String fallbackReason;\n    private int consecutiveFailures;\n    private Instant lastSuccessfulRequest;\n    \n    private ConnectionStatus.Stats stats;\n    private final Object lock = new Object();\n    \n    private final HttpClient httpClient;\n    private final ObjectMapper objectMapper;\n    private final YahooFinanceClient yahooClient;\n    \n    // Cache for symbol name to symbol ID mapping\n    private final Map<String, Integer> symbolIdCache = new HashMap<>();\n    \n    public QuestradeClient(String refreshToken) {\n        this.refreshToken = refreshToken;\n        this.connectionState = ConnectionState.DISCONNECTED;\n        this.usingFallback = false;\n        this.consecutiveFailures = 0;\n        this.stats = new ConnectionStatus.Stats();\n        this.lastSuccessfulRequest = Instant.now();\n        \n        this.httpClient = HttpClient.newBuilder()\n            .connectTimeout(Duration.ofSeconds(10))\n            .build();\n        this.objectMapper = new ObjectMapper();\n        this.yahooClient = new YahooFinanceClient();\n    }\n    \n    public void setRefreshToken(String refreshToken) {\n        synchronized (lock) {\n            this.refreshToken = refreshToken;\n            this.connectionState = ConnectionState.DISCONNECTED;\n            this.accessToken = null;\n            this.apiServer = null;\n            this.tokenExpiry = null;\n        }\n    }\n    \n    public boolean authenticate() {\n        try {\n            System.out.println(\"Authenticating with Questrade...\");\n            System.out.println(\"Refresh token: \" + (refreshToken != null ? refreshToken.substring(0, Math.min(10, refreshToken.length())) + \"...\" : \"NULL\"));\n            \n            String url = \"https://login.questrade.com/oauth2/token\";\n            String params = \"grant_type=refresh_token&refresh_token=\" + refreshToken;\n            \n            HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .timeout(Duration.ofSeconds(10))\n                .header(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                .POST(HttpRequest.BodyPublishers.ofString(params))\n                .build();\n            \n            HttpResponse<String> response = httpClient.send(request, \n                HttpResponse.BodyHandlers.ofString());\n            \n            System.out.println(\"Auth response status: \" + response.statusCode());\n            \n            if (response.statusCode() != 200) {\n                System.err.println(\"Authentication failed with status: \" + response.statusCode());\n                System.err.println(\"Response body: \" + response.body());\n                recordFailure(\"Authentication failed with status: \" + response.statusCode());\n                return false;\n            }\n            \n            JsonNode json = objectMapper.readTree(response.body());\n            accessToken = json.get(\"access_token\").asText();\n            apiServer = json.get(\"api_server\").asText();\n            \n            // NOTE: Questrade returns a NEW refresh token that should be used next time.\n            // We store it in memory only (never persisted to disk for security).\n            // When the app restarts, user must provide a fresh token.\n            if (json.has(\"refresh_token\")) {\n                String newRefreshToken = json.get(\"refresh_token\").asText();\n                System.out.println(\"New refresh token received from Questrade\");\n                System.out.println(\"IMPORTANT: Token is kept in memory only and will be lost on restart\");\n                System.out.println(\"If app restarts, you'll need to provide a new token via the GUI\");\n                refreshToken = newRefreshToken;\n            }\n            \n            int expiresIn = json.get(\"expires_in\").asInt();\n            tokenExpiry = Instant.now().plusSeconds(expiresIn);\n            \n            System.out.println(\"Authentication successful!\");\n            System.out.println(\"API Server: \" + apiServer);\n            System.out.println(\"Token expires in: \" + expiresIn + \" seconds\");\n            \n            recordSuccess();\n            return true;\n            \n        } catch (Exception e) {\n            System.err.println(\"Authentication exception: \" + e.getMessage());\n            e.printStackTrace();\n            recordFailure(\"Authentication exception: \" + e.getMessage());\n            return false;\n        }\n    }\n    \n    public boolean isAuthenticated() {\n        return accessToken != null && !accessToken.isEmpty() \n            && tokenExpiry != null && Instant.now().isBefore(tokenExpiry);\n    }\n    \n    /**\n     * Ensure the client is authenticated, auto-refreshing the token if needed.\n     * This method should be called before each API request to prevent token expiry issues.\n     * \n     * @return true if authenticated (or successfully refreshed), false otherwise\n     */\n    private boolean ensureAuthenticated() {\n        // Check if we need to authenticate or refresh token\n        // Refresh if token is null, expired, or will expire within 60 seconds\n        if (accessToken == null || tokenExpiry == null || \n            Instant.now().plusSeconds(60).isAfter(tokenExpiry)) {\n            \n            if (refreshToken == null || refreshToken.isEmpty()) {\n                System.err.println(\"Cannot authenticate: No refresh token available\");\n                return false;\n            }\n            \n            System.out.println(\"Token expired or about to expire - auto-refreshing...\");\n            return authenticate();\n        }\n        \n        return true;\n    }\n    \n    private Integer getSymbolId(String symbol) {\n        // Check cache first\n        if (symbolIdCache.containsKey(symbol)) {\n            return symbolIdCache.get(symbol);\n        }\n        \n        try {\n            // Ensure we're authenticated before making the API call\n            if (!ensureAuthenticated()) {\n                System.err.println(\"Not authenticated with Questrade - cannot search symbol\");\n                return null;\n            }\n            \n            // Debug: Print authentication status\n            System.out.println(\"DEBUG: Searching for symbol: \" + symbol);\n            System.out.println(\"DEBUG: API Server: \" + apiServer);\n            System.out.println(\"DEBUG: Access Token: \" + (accessToken != null ? \"Present\" : \"NULL\"));\n            \n            String url = apiServer + \"v1/symbols/search?prefix=\" + symbol;\n            System.out.println(\"DEBUG: Symbol search URL: \" + url);\n            \n            HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .timeout(Duration.ofSeconds(10))\n                .header(\"Authorization\", \"Bearer \" + accessToken)\n                .GET()\n                .build();\n            \n            HttpResponse<String> response = httpClient.send(request, \n                HttpResponse.BodyHandlers.ofString());\n            \n            System.out.println(\"DEBUG: Response status: \" + response.statusCode());\n            System.out.println(\"DEBUG: Response body: \" + response.body());\n            \n            if (response.statusCode() != 200) {\n                System.err.println(\"Symbol search failed with status: \" + response.statusCode());\n                System.err.println(\"Response body: \" + response.body());\n                recordFailure(\"Symbol search failed: \" + response.statusCode());\n                return null;\n            }\n            \n            JsonNode json = objectMapper.readTree(response.body());\n            JsonNode symbols = json.get(\"symbols\");\n            \n            if (symbols == null || !symbols.isArray()) {\n                System.err.println(\"No 'symbols' array in response\");\n                return null;\n            }\n            \n            if (symbols.size() == 0) {\n                System.err.println(\"No symbols found for: \" + symbol);\n                return null;\n            }\n            \n            // Find exact match (try both with and without .TO suffix for TSX symbols)\n            for (JsonNode symbolNode : symbols) {\n                String symbolName = symbolNode.get(\"symbol\").asText();\n                System.out.println(\"DEBUG: Found symbol: \" + symbolName);\n                \n                if (symbolName.equals(symbol) || \n                    symbolName.equals(symbol + \".TO\") ||\n                    symbolName.equals(symbol + \".US\")) {\n                    int symbolId = symbolNode.get(\"symbolId\").asInt();\n                    symbolIdCache.put(symbol, symbolId);\n                    System.out.println(\"Symbol \" + symbol + \" matched to ID: \" + symbolId);\n                    recordSuccess();\n                    return symbolId;\n                }\n            }\n            \n            // If no exact match, use first result if it's close\n            JsonNode firstSymbol = symbols.get(0);\n            String firstName = firstSymbol.get(\"symbol\").asText();\n            \n            if (firstName.startsWith(symbol)) {\n                int symbolId = firstSymbol.get(\"symbolId\").asInt();\n                symbolIdCache.put(symbol, symbolId);\n                System.out.println(\"Using closest match: \" + firstName + \" (ID: \" + symbolId + \")\");\n                recordSuccess();\n                return symbolId;\n            }\n            \n            System.err.println(\"No matching symbol found for: \" + symbol);\n            return null;\n            \n        } catch (Exception e) {\n            System.err.println(\"Symbol search exception for \" + symbol + \": \" + e.getMessage());\n            e.printStackTrace();\n            recordFailure(\"Symbol search exception: \" + e.getMessage());\n            return null;\n        }\n    }\n    \n    public List<Candle> getHistoricalData(String symbol, int intervalMinutes, int numBars) {\n        List<Candle> candles = new ArrayList<>();\n        \n        // Ensure we're authenticated before making API calls\n        if (ensureAuthenticated()) {\n            try {\n                Integer symbolId = getSymbolId(symbol);\n                if (symbolId != null) {\n                    // Use shared MarketTime utility for consistent timezone handling\n                    ZonedDateTime endTime = MarketTime.now();\n                    ZonedDateTime startTime = MarketTime.calculateStartTime(endTime, intervalMinutes, numBars);\n                    \n                    String startTimeStr = MarketTime.formatForApi(startTime);\n                    String endTimeStr = MarketTime.formatForApi(endTime);\n                    \n                    // Map interval minutes to Questrade interval\n                    String interval = mapInterval(intervalMinutes);\n                    \n                    String url = apiServer + \"v1/markets/candles/\" + symbolId + \n                        \"?startTime=\" + startTimeStr + \n                        \"&endTime=\" + endTimeStr + \n                        \"&interval=\" + interval;\n                    \n                    System.out.println(\"DEBUG: Fetching candles from: \" + url);\n                    \n                    HttpRequest request = HttpRequest.newBuilder()\n                        .uri(URI.create(url))\n                        .timeout(Duration.ofSeconds(30))\n                        .header(\"Authorization\", \"Bearer \" + accessToken)\n                        .GET()\n                        .build();\n                    \n                    HttpResponse<String> response = httpClient.send(request, \n                        HttpResponse.BodyHandlers.ofString());\n                    \n                    System.out.println(\"DEBUG: Candles response status: \" + response.statusCode());\n                    \n                    if (response.statusCode() == 200) {\n                        JsonNode json = objectMapper.readTree(response.body());\n                        JsonNode candlesArray = json.get(\"candles\");\n                        \n                        if (candlesArray != null && candlesArray.isArray()) {\n                            for (JsonNode candleNode : candlesArray) {\n                                Candle candle = new Candle();\n                                candle.timestamp = Instant.parse(candleNode.get(\"start\").asText());\n                                candle.open = candleNode.get(\"open\").asDouble();\n                                candle.high = candleNode.get(\"high\").asDouble();\n                                candle.low = candleNode.get(\"low\").asDouble();\n                                candle.close = candleNode.get(\"close\").asDouble();\n                                candle.volume = candleNode.get(\"volume\").asLong();\n                                candles.add(candle);\n                            }\n                            \n                            if (!candles.isEmpty()) {\n                                recordSuccess();\n                                System.out.println(\"Questrade: Fetched \" + candles.size() + \" candles for \" + symbol);\n                                return candles;\n                            }\n                        }\n                    } else {\n                        System.err.println(\"Candles response body: \" + response.body());\n                        recordFailure(\"Questrade candles request failed with status: \" + response.statusCode());\n                    }\n                } else {\n                    System.err.println(\"Failed to get symbol ID for: \" + symbol);\n                }\n            } catch (Exception e) {\n                recordFailure(\"Questrade historical data exception: \" + e.getMessage());\n                System.err.println(\"Questrade error: \" + e.getMessage());\n                e.printStackTrace();\n            }\n        } else {\n            System.err.println(\"Not authenticated with Questrade\");\n        }\n        \n        // Fallback to Yahoo Finance (supports intraday for last 7 days only)\n        if (intervalMinutes < 1440) {\n            int requestedDays = (numBars * intervalMinutes) / 1440;\n            if (requestedDays > 7) {\n                System.err.println(\"WARNING: Requested \" + requestedDays + \" days of intraday data, but Yahoo Finance only provides last 7 days\");\n                System.err.println(\"You will get limited data. For full historical intraday data, use a valid Questrade token.\");\n            } else {\n                System.out.println(\"Using Yahoo Finance for intraday data (limited to last 7 days)\");\n            }\n            \n            if (!usingFallback) {\n                usingFallback = true;\n                fallbackReason = \"Questrade unavailable - using Yahoo (7-day intraday limit)\";\n                stats.failovers++;\n            }\n        }\n        \n        if (!usingFallback) {\n            System.out.println(\"Falling back to Yahoo Finance for daily data: \" + symbol);\n            usingFallback = true;\n            fallbackReason = \"Questrade unavailable - using Yahoo daily data\";\n            stats.failovers++;\n        }\n        \n        try {\n            candles = yahooClient.getHistoricalData(symbol, intervalMinutes, numBars);\n            if (!candles.isEmpty()) {\n                stats.yahooRequests++;\n                System.out.println(\"Successfully retrieved daily data from Yahoo Finance\");\n            } else {\n                stats.yahooFailures++;\n            }\n        } catch (Exception e) {\n            System.err.println(\"Yahoo Finance error: \" + e.getMessage());\n            stats.yahooFailures++;\n        }\n        \n        return candles;\n    }\n    \n    public Quote getQuote(String symbol) {\n        Quote quote = new Quote();\n        quote.symbol = symbol;\n        quote.timestamp = Instant.now();\n        \n        // Ensure we're authenticated before making API calls\n        if (ensureAuthenticated()) {\n            try {\n                Integer symbolId = getSymbolId(symbol);\n                if (symbolId != null) {\n                    String url = apiServer + \"v1/markets/quotes?ids=\" + symbolId;\n                    \n                    HttpRequest request = HttpRequest.newBuilder()\n                        .uri(URI.create(url))\n                        .timeout(Duration.ofSeconds(10))\n                        .header(\"Authorization\", \"Bearer \" + accessToken)\n                        .GET()\n                        .build();\n                    \n                    HttpResponse<String> response = httpClient.send(request, \n                        HttpResponse.BodyHandlers.ofString());\n                    \n                    if (response.statusCode() == 200) {\n                        JsonNode json = objectMapper.readTree(response.body());\n                        JsonNode quotes = json.get(\"quotes\");\n                        \n                        if (quotes != null && quotes.isArray() && quotes.size() > 0) {\n                            JsonNode quoteData = quotes.get(0);\n                            quote.price = quoteData.get(\"lastTradePrice\").asDouble();\n                            quote.volume = quoteData.get(\"volume\").asLong();\n                            quote.bid = quoteData.get(\"bidPrice\").asDouble();\n                            quote.ask = quoteData.get(\"askPrice\").asDouble();\n                            quote.timestamp = Instant.parse(quoteData.get(\"lastTradeTime\").asText());\n                            \n                            recordSuccess();\n                            return quote;\n                        }\n                    } else {\n                        System.err.println(\"Questrade quote request failed with status: \" + response.statusCode());\n                        recordFailure(\"Quote request failed: \" + response.statusCode());\n                    }\n                }\n            } catch (Exception e) {\n                recordFailure(\"Questrade quote exception: \" + e.getMessage());\n                System.err.println(\"Questrade quote error: \" + e.getMessage());\n            }\n        }\n        \n        // Fallback to Yahoo Finance for quotes (real-time quotes available)\n        if (!usingFallback) {\n            System.out.println(\"Falling back to Yahoo Finance for quotes (delayed 15-20 minutes)\");\n            usingFallback = true;\n            fallbackReason = \"Questrade unavailable - using delayed Yahoo quotes\";\n            stats.failovers++;\n        }\n        \n        try {\n            quote = yahooClient.getQuote(symbol);\n            if (quote.price > 0) {\n                stats.yahooRequests++;\n            } else {\n                stats.yahooFailures++;\n            }\n        } catch (Exception e) {\n            System.err.println(\"Yahoo Finance quote error: \" + e.getMessage());\n            stats.yahooFailures++;\n            quote.price = 0.0;\n            quote.volume = 0;\n            quote.bid = 0.0;\n            quote.ask = 0.0;\n        }\n        \n        return quote;\n    }\n    \n    private String mapInterval(int minutes) {\n        if (minutes == 1) return \"OneMinute\";\n        if (minutes == 5) return \"FiveMinutes\";\n        if (minutes == 10) return \"TenMinutes\";\n        if (minutes == 30) return \"HalfHour\";\n        if (minutes == 60) return \"OneHour\";\n        if (minutes >= 1440) return \"OneDay\";\n        \n        // Default to closest match\n        if (minutes < 5) return \"OneMinute\";\n        if (minutes < 10) return \"FiveMinutes\";\n        if (minutes < 30) return \"TenMinutes\";\n        if (minutes < 60) return \"HalfHour\";\n        return \"OneHour\";\n    }\n    \n    public ConnectionStatus getConnectionStatus() {\n        synchronized (lock) {\n            ConnectionStatus status = new ConnectionStatus();\n            status.state = connectionState;\n            status.usingFallback = usingFallback;\n            status.fallbackReason = fallbackReason;\n            status.consecutiveFailures = consecutiveFailures;\n            status.lastSuccessfulRequest = lastSuccessfulRequest;\n            status.stats = stats;\n            return status;\n        }\n    }\n    \n    private void recordSuccess() {\n        synchronized (lock) {\n            consecutiveFailures = 0;\n            lastSuccessfulRequest = Instant.now();\n            connectionState = ConnectionState.CONNECTED;\n            stats.questradeRequests++;\n            \n            if (usingFallback) {\n                usingFallback = false;\n                fallbackReason = \"\";\n                stats.reconnections++;\n            }\n        }\n    }\n    \n    private void recordFailure(String reason) {\n        synchronized (lock) {\n            consecutiveFailures++;\n            stats.questradeFailures++;\n            \n            if (consecutiveFailures >= 3) {\n                connectionState = ConnectionState.FAILED;\n                usingFallback = true;\n                fallbackReason = reason;\n                stats.failovers++;\n            }\n        }\n    }\n}","size_bytes":21448},"build/extracted-include-protos/test/google/api/system_parameter.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"SystemParameterProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// ### System parameter configuration\n//\n// A system parameter is a special kind of parameter defined by the API\n// system, not by an individual API. It is typically mapped to an HTTP header\n// and/or a URL query parameter. This configuration specifies which methods\n// change the names of the system parameters.\nmessage SystemParameters {\n  // Define system parameters.\n  //\n  // The parameters defined here will override the default parameters\n  // implemented by the system. If this field is missing from the service\n  // config, default system parameters will be used. Default system parameters\n  // and names is implementation-dependent.\n  //\n  // Example: define api key for all methods\n  //\n  //     system_parameters\n  //       rules:\n  //         - selector: \"*\"\n  //           parameters:\n  //             - name: api_key\n  //               url_query_parameter: api_key\n  //\n  //\n  // Example: define 2 api key names for a specific method.\n  //\n  //     system_parameters\n  //       rules:\n  //         - selector: \"/ListShelves\"\n  //           parameters:\n  //             - name: api_key\n  //               http_header: Api-Key1\n  //             - name: api_key\n  //               http_header: Api-Key2\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated SystemParameterRule rules = 1;\n}\n\n// Define a system parameter rule mapping system parameter definitions to\n// methods.\nmessage SystemParameterRule {\n  // Selects the methods to which this rule applies. Use '*' to indicate all\n  // methods in all APIs.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // Define parameters. Multiple names may be defined for a parameter.\n  // For a given method call, only one of them should be used. If multiple\n  // names are used the behavior is implementation-dependent.\n  // If none of the specified names are present the behavior is\n  // parameter-dependent.\n  repeated SystemParameter parameters = 2;\n}\n\n// Define a parameter's name and location. The parameter may be passed as either\n// an HTTP header or a URL query parameter, and if both are passed the behavior\n// is implementation-dependent.\nmessage SystemParameter {\n  // Define the name of the parameter, such as \"api_key\" . It is case sensitive.\n  string name = 1;\n\n  // Define the HTTP header name to use for the parameter. It is case\n  // insensitive.\n  string http_header = 2;\n\n  // Define the URL query parameter name to use for the parameter. It is case\n  // sensitive.\n  string url_query_parameter = 3;\n}\n","size_bytes":3475},"build/extracted-include-protos/test/google/api/auth.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"AuthProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Authentication` defines the authentication configuration for API methods\n// provided by an API service.\n//\n// Example:\n//\n//     name: calendar.googleapis.com\n//     authentication:\n//       providers:\n//       - id: google_calendar_auth\n//         jwks_uri: https://www.googleapis.com/oauth2/v1/certs\n//         issuer: https://securetoken.google.com\n//       rules:\n//       - selector: \"*\"\n//         requirements:\n//           provider_id: google_calendar_auth\n//       - selector: google.calendar.Delegate\n//         oauth:\n//           canonical_scopes: https://www.googleapis.com/auth/calendar.read\nmessage Authentication {\n  // A list of authentication rules that apply to individual API methods.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated AuthenticationRule rules = 3;\n\n  // Defines a set of authentication providers that a service supports.\n  repeated AuthProvider providers = 4;\n}\n\n// Authentication rules for the service.\n//\n// By default, if a method has any authentication requirements, every request\n// must include a valid credential matching one of the requirements.\n// It's an error to include more than one kind of credential in a single\n// request.\n//\n// If a method doesn't have any auth requirements, request credentials will be\n// ignored.\nmessage AuthenticationRule {\n  // Selects the methods to which this rule applies.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // The requirements for OAuth credentials.\n  OAuthRequirements oauth = 2;\n\n  // If true, the service accepts API keys without any other credential.\n  // This flag only applies to HTTP and gRPC requests.\n  bool allow_without_credential = 5;\n\n  // Requirements for additional authentication providers.\n  repeated AuthRequirement requirements = 7;\n}\n\n// Specifies a location to extract JWT from an API request.\nmessage JwtLocation {\n  oneof in {\n    // Specifies HTTP header name to extract JWT token.\n    string header = 1;\n\n    // Specifies URL query parameter name to extract JWT token.\n    string query = 2;\n\n    // Specifies cookie name to extract JWT token.\n    string cookie = 4;\n  }\n\n  // The value prefix. The value format is \"value_prefix{token}\"\n  // Only applies to \"in\" header type. Must be empty for \"in\" query type.\n  // If not empty, the header value has to match (case sensitive) this prefix.\n  // If not matched, JWT will not be extracted. If matched, JWT will be\n  // extracted after the prefix is removed.\n  //\n  // For example, for \"Authorization: Bearer {JWT}\",\n  // value_prefix=\"Bearer \" with a space at the end.\n  string value_prefix = 3;\n}\n\n// Configuration for an authentication provider, including support for\n// [JSON Web Token\n// (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).\nmessage AuthProvider {\n  // The unique identifier of the auth provider. It will be referred to by\n  // `AuthRequirement.provider_id`.\n  //\n  // Example: \"bookstore_auth\".\n  string id = 1;\n\n  // Identifies the principal that issued the JWT. See\n  // https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.1\n  // Usually a URL or an email address.\n  //\n  // Example: https://securetoken.google.com\n  // Example: 1234567-compute@developer.gserviceaccount.com\n  string issuer = 2;\n\n  // URL of the provider's public key set to validate signature of the JWT. See\n  // [OpenID\n  // Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n  // Optional if the key set document:\n  //  - can be retrieved from\n  //    [OpenID\n  //    Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html)\n  //    of the issuer.\n  //  - can be inferred from the email domain of the issuer (e.g. a Google\n  //  service account).\n  //\n  // Example: https://www.googleapis.com/oauth2/v1/certs\n  string jwks_uri = 3;\n\n  // The list of JWT\n  // [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).\n  // that are allowed to access. A JWT containing any of these audiences will\n  // be accepted. When this setting is absent, JWTs with audiences:\n  //   - \"https://[service.name]/[google.protobuf.Api.name]\"\n  //   - \"https://[service.name]/\"\n  // will be accepted.\n  // For example, if no audiences are in the setting, LibraryService API will\n  // accept JWTs with the following audiences:\n  //   -\n  //   https://library-example.googleapis.com/google.example.library.v1.LibraryService\n  //   - https://library-example.googleapis.com/\n  //\n  // Example:\n  //\n  //     audiences: bookstore_android.apps.googleusercontent.com,\n  //                bookstore_web.apps.googleusercontent.com\n  string audiences = 4;\n\n  // Redirect URL if JWT token is required but not present or is expired.\n  // Implement authorizationUrl of securityDefinitions in OpenAPI spec.\n  string authorization_url = 5;\n\n  // Defines the locations to extract the JWT.  For now it is only used by the\n  // Cloud Endpoints to store the OpenAPI extension [x-google-jwt-locations]\n  // (https://cloud.google.com/endpoints/docs/openapi/openapi-extensions#x-google-jwt-locations)\n  //\n  // JWT locations can be one of HTTP headers, URL query parameters or\n  // cookies. The rule is that the first match wins.\n  //\n  // If not specified,  default to use following 3 locations:\n  //    1) Authorization: Bearer\n  //    2) x-goog-iap-jwt-assertion\n  //    3) access_token query parameter\n  //\n  // Default locations can be specified as followings:\n  //    jwt_locations:\n  //    - header: Authorization\n  //      value_prefix: \"Bearer \"\n  //    - header: x-goog-iap-jwt-assertion\n  //    - query: access_token\n  repeated JwtLocation jwt_locations = 6;\n}\n\n// OAuth scopes are a way to define data and permissions on data. For example,\n// there are scopes defined for \"Read-only access to Google Calendar\" and\n// \"Access to Cloud Platform\". Users can consent to a scope for an application,\n// giving it permission to access that data on their behalf.\n//\n// OAuth scope specifications should be fairly coarse grained; a user will need\n// to see and understand the text description of what your scope means.\n//\n// In most cases: use one or at most two OAuth scopes for an entire family of\n// products. If your product has multiple APIs, you should probably be sharing\n// the OAuth scope across all of those APIs.\n//\n// When you need finer grained OAuth consent screens: talk with your product\n// management about how developers will use them in practice.\n//\n// Please note that even though each of the canonical scopes is enough for a\n// request to be accepted and passed to the backend, a request can still fail\n// due to the backend requiring additional scopes or permissions.\nmessage OAuthRequirements {\n  // The list of publicly documented OAuth scopes that are allowed access. An\n  // OAuth token containing any of these scopes will be accepted.\n  //\n  // Example:\n  //\n  //      canonical_scopes: https://www.googleapis.com/auth/calendar,\n  //                        https://www.googleapis.com/auth/calendar.read\n  string canonical_scopes = 1;\n}\n\n// User-defined authentication requirements, including support for\n// [JSON Web Token\n// (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).\nmessage AuthRequirement {\n  // [id][google.api.AuthProvider.id] from authentication provider.\n  //\n  // Example:\n  //\n  //     provider_id: bookstore_auth\n  string provider_id = 1;\n\n  // NOTE: This will be deprecated soon, once AuthProvider.audiences is\n  // implemented and accepted in all the runtime components.\n  //\n  // The list of JWT\n  // [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).\n  // that are allowed to access. A JWT containing any of these audiences will\n  // be accepted. When this setting is absent, only JWTs with audience\n  // \"https://[Service_name][google.api.Service.name]/[API_name][google.protobuf.Api.name]\"\n  // will be accepted. For example, if no audiences are in the setting,\n  // LibraryService API will only accept JWTs with the following audience\n  // \"https://library-example.googleapis.com/google.example.library.v1.LibraryService\".\n  //\n  // Example:\n  //\n  //     audiences: bookstore_android.apps.googleusercontent.com,\n  //                bookstore_web.apps.googleusercontent.com\n  string audiences = 2;\n}\n","size_bytes":9257},"src/main/java/com/spiketrade/backend/YahooFinanceClient.java":{"content":"package com.spiketrade.backend;\n\nimport yahoofinance.YahooFinance;\nimport yahoofinance.Stock;\nimport yahoofinance.histquotes.HistoricalQuote;\nimport yahoofinance.histquotes.Interval;\nimport java.io.IOException;\nimport java.time.Instant;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\nimport java.util.List;\nimport java.util.TimeZone;\n\npublic class YahooFinanceClient {\n    private static final long RATE_LIMIT_DELAY_MS = 2000; // 2 seconds between requests\n    private long lastRequestTime = 0;\n    \n    public YahooFinanceClient() {\n    }\n    \n    private void enforceRateLimit() {\n        long now = System.currentTimeMillis();\n        long timeSinceLastRequest = now - lastRequestTime;\n        \n        if (timeSinceLastRequest < RATE_LIMIT_DELAY_MS) {\n            try {\n                long sleepTime = RATE_LIMIT_DELAY_MS - timeSinceLastRequest;\n                System.out.println(\"Yahoo Finance: Rate limiting - waiting \" + sleepTime + \"ms\");\n                Thread.sleep(sleepTime);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n        \n        lastRequestTime = System.currentTimeMillis();\n    }\n    \n    public List<Candle> getHistoricalData(String symbol, int intervalMinutes, int numBars) {\n        List<Candle> candles = new ArrayList<>();\n        \n        // Enforce rate limiting to avoid 429 errors\n        enforceRateLimit();\n        \n        try {\n            Stock stock = YahooFinance.get(symbol);\n            if (stock == null) {\n                System.err.println(\"Yahoo Finance: Symbol not found: \" + symbol);\n                return candles;\n            }\n            \n            // Use market timezone (ET) for all time calculations - consistent with Questrade\n            ZonedDateTime endTime = MarketTime.now();\n            ZonedDateTime startTime = MarketTime.calculateStartTime(endTime, intervalMinutes, numBars);\n            \n            // Convert ZonedDateTime to Calendar for Yahoo Finance API (legacy interface)\n            Calendar from = GregorianCalendar.from(startTime);\n            Calendar to = GregorianCalendar.from(endTime);\n            \n            Interval interval;\n            \n            // Yahoo Finance supports intraday data for the last 7 days only\n            if (intervalMinutes < 1440) {\n                // Intraday data requested\n                int requestedDays = (numBars * intervalMinutes) / 1440;\n                \n                // Fail fast with clear error message if intraday data exceeds Yahoo's limits\n                if (requestedDays > 7) {\n                    String errorMsg = String.format(\n                        \"ERROR: Yahoo Finance cannot provide %d days of intraday data (requested: %d bars x %d min intervals).\\n\" +\n                        \"Yahoo Finance intraday data is limited to the last 7 days only.\\n\" +\n                        \"For historical intraday data, please use a valid Questrade token.\\n\" +\n                        \"Returning empty dataset to avoid silently truncated results.\",\n                        requestedDays, numBars, intervalMinutes\n                    );\n                    System.err.println(errorMsg);\n                    throw new IllegalArgumentException(errorMsg);\n                }\n                \n                // Map interval minutes to Yahoo's Interval enum for intraday\n                if (intervalMinutes == 1) {\n                    interval = Interval.DAILY; // Yahoo uses DAILY for 1-min in some versions\n                } else if (intervalMinutes <= 5) {\n                    interval = Interval.DAILY; // Closest match\n                } else if (intervalMinutes <= 15) {\n                    interval = Interval.DAILY;\n                } else if (intervalMinutes <= 60) {\n                    interval = Interval.DAILY;\n                } else {\n                    interval = Interval.DAILY;\n                }\n                \n                System.out.println(\"Yahoo Finance: Fetching \" + intervalMinutes + \"-minute intraday data (last 7 days max) in ET timezone\");\n                System.out.println(\"WARNING: Yahoo Finance intraday data may be incomplete. Use Questrade for full intraday history.\");\n            } else {\n                // Daily or longer intervals\n                if (intervalMinutes >= 43200) {\n                    interval = Interval.MONTHLY;\n                } else if (intervalMinutes >= 10080) {\n                    interval = Interval.WEEKLY;\n                } else {\n                    interval = Interval.DAILY;\n                }\n            }\n            \n            List<HistoricalQuote> history = stock.getHistory(from, to, interval);\n            \n            if (history != null) {\n                for (HistoricalQuote quote : history) {\n                    if (quote.getOpen() != null && quote.getHigh() != null && \n                        quote.getLow() != null && quote.getClose() != null) {\n                        Candle candle = new Candle();\n                        candle.timestamp = quote.getDate().toInstant();\n                        candle.open = quote.getOpen().doubleValue();\n                        candle.high = quote.getHigh().doubleValue();\n                        candle.low = quote.getLow().doubleValue();\n                        candle.close = quote.getClose().doubleValue();\n                        candle.volume = quote.getVolume() != null ? quote.getVolume() : 0L;\n                        candles.add(candle);\n                    }\n                }\n                \n                String dataType = intervalMinutes < 1440 ? \"intraday\" : \"daily\";\n                System.out.println(\"Yahoo Finance: Fetched \" + candles.size() + \" \" + dataType + \" candles for \" + symbol);\n            }\n            \n        } catch (IOException e) {\n            System.err.println(\"Yahoo Finance error for \" + symbol + \": \" + e.getMessage());\n        }\n        \n        return candles;\n    }\n    \n    public Quote getQuote(String symbol) {\n        Quote quote = new Quote();\n        quote.symbol = symbol;\n        quote.timestamp = Instant.now();\n        \n        // Enforce rate limiting to avoid 429 errors\n        enforceRateLimit();\n        \n        try {\n            Stock stock = YahooFinance.get(symbol);\n            if (stock == null) {\n                System.err.println(\"Yahoo Finance: Symbol not found: \" + symbol);\n                quote.price = 0.0;\n                quote.volume = 0;\n                quote.bid = 0.0;\n                quote.ask = 0.0;\n                return quote;\n            }\n            \n            yahoofinance.quotes.stock.StockQuote stockQuote = stock.getQuote();\n            \n            if (stockQuote != null) {\n                quote.price = stockQuote.getPrice() != null ? stockQuote.getPrice().doubleValue() : 0.0;\n                quote.volume = stockQuote.getVolume() != null ? stockQuote.getVolume() : 0L;\n                quote.bid = stockQuote.getBid() != null ? stockQuote.getBid().doubleValue() : 0.0;\n                quote.ask = stockQuote.getAsk() != null ? stockQuote.getAsk().doubleValue() : 0.0;\n                \n                System.out.println(\"Yahoo Finance: Got quote for \" + symbol + \" @ $\" + quote.price);\n            }\n            \n        } catch (IOException e) {\n            System.err.println(\"Yahoo Finance quote error for \" + symbol + \": \" + e.getMessage());\n            quote.price = 0.0;\n            quote.volume = 0;\n            quote.bid = 0.0;\n            quote.ask = 0.0;\n        }\n        \n        return quote;\n    }\n    \n    private Interval mapInterval(int minutes) {\n        if (minutes == 1) return Interval.DAILY;\n        if (minutes <= 5) return Interval.DAILY;\n        if (minutes <= 60) return Interval.DAILY;\n        if (minutes <= 1440) return Interval.DAILY;\n        if (minutes <= 10080) return Interval.WEEKLY;\n        return Interval.MONTHLY;\n    }\n}\n","size_bytes":7980},"build/extracted-include-protos/test/google/api/config_change.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/configchange;configchange\";\noption java_multiple_files = true;\noption java_outer_classname = \"ConfigChangeProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Output generated from semantically comparing two versions of a service\n// configuration.\n//\n// Includes detailed information about a field that have changed with\n// applicable advice about potential consequences for the change, such as\n// backwards-incompatibility.\nmessage ConfigChange {\n  // Object hierarchy path to the change, with levels separated by a '.'\n  // character. For repeated fields, an applicable unique identifier field is\n  // used for the index (usually selector, name, or id). For maps, the term\n  // 'key' is used. If the field has no unique identifier, the numeric index\n  // is used.\n  // Examples:\n  // - visibility.rules[selector==\"google.LibraryService.ListBooks\"].restriction\n  // - quota.metric_rules[selector==\"google\"].metric_costs[key==\"reads\"].value\n  // - logging.producer_destinations[0]\n  string element = 1;\n\n  // Value of the changed object in the old Service configuration,\n  // in JSON format. This field will not be populated if ChangeType == ADDED.\n  string old_value = 2;\n\n  // Value of the changed object in the new Service configuration,\n  // in JSON format. This field will not be populated if ChangeType == REMOVED.\n  string new_value = 3;\n\n  // The type for this change, either ADDED, REMOVED, or MODIFIED.\n  ChangeType change_type = 4;\n\n  // Collection of advice provided for this change, useful for determining the\n  // possible impact of this change.\n  repeated Advice advices = 5;\n}\n\n// Generated advice about this change, used for providing more\n// information about how a change will affect the existing service.\nmessage Advice {\n  // Useful description for why this advice was applied and what actions should\n  // be taken to mitigate any implied risks.\n  string description = 2;\n}\n\n// Classifies set of possible modifications to an object in the service\n// configuration.\nenum ChangeType {\n  // No value was provided.\n  CHANGE_TYPE_UNSPECIFIED = 0;\n\n  // The changed object exists in the 'new' service configuration, but not\n  // in the 'old' service configuration.\n  ADDED = 1;\n\n  // The changed object exists in the 'old' service configuration, but not\n  // in the 'new' service configuration.\n  REMOVED = 2;\n\n  // The changed object exists in both service configurations, but its value\n  // is different.\n  MODIFIED = 3;\n}\n","size_bytes":3166},"src/main/proto/config.proto":{"content":"syntax = \"proto3\";\n\npackage spiketrade.proto;\n\noption java_package = \"com.spiketrade.proto\";\noption java_outer_classname = \"ConfigProto\";\n\n// Trading configuration\nmessage TradingConfig {\n  // Window parameters\n  int32 buy_period_minutes = 1;\n  int32 bb_length_minutes = 2;\n  int32 rsi_length_minutes = 3;\n  int32 price_roc_period_minutes = 4;\n  int32 obv_roc_period_minutes = 5;\n  int32 mfi_period_minutes = 6;\n  int32 mfi_roc_period_minutes = 7;\n  int32 vwap_period_minutes = 8;\n  int32 data_points = 9;\n  int32 warmup_data_points = 10;\n  \n  // Spike ROC Threshold parameters (Z-score based)\n  double spike_price_roc_z_threshold = 20;\n  double spike_rsi_roc_z_threshold = 21;\n  double spike_obv_roc_z_threshold = 22;\n  double spike_mfi_roc_z_threshold = 23;\n  double spike_percent_b_roc_z_threshold = 24;\n  double spike_vwap_roc_z_threshold = 25;\n  double spike_volume_roc_z_threshold = 26;\n  \n  // Regular ROC Threshold parameters (absolute %)\n  double regular_price_roc_threshold = 31;\n  double regular_rsi_roc_threshold = 32;\n  double regular_obv_roc_threshold = 33;\n  double regular_mfi_roc_threshold = 34;\n  double regular_percent_b_roc_threshold = 35;\n  double regular_vwap_roc_threshold = 36;\n  double regular_volume_roc_threshold = 37;\n  \n  // Regular ROC Period parameters (minutes)\n  int32 regular_price_roc_period = 60;\n  int32 regular_rsi_roc_period = 61;\n  int32 regular_obv_roc_period = 62;\n  int32 regular_mfi_roc_period = 63;\n  int32 regular_percent_b_roc_period = 64;\n  int32 regular_vwap_roc_period = 65;\n  int32 regular_volume_roc_period = 66;\n  \n  double combo_signal_threshold = 27;\n  double high_prob_threshold = 28;\n  double stop_loss_pct = 29;\n  double spike_cooldown_stddev_threshold = 30;\n  \n  // Trading parameters\n  double equity_per_trade = 40;\n  double max_open_trades = 41;\n  double total_equity_available = 42;\n  \n  // Boolean flags\n  bool enable_price_roc_spike = 50;\n  bool enable_rsi_roc_spike = 51;\n  bool enable_obv_roc_spike = 52;\n  bool enable_mfi_roc_spike = 53;\n  bool enable_percent_b_roc_spike = 54;\n  bool enable_vwap_roc_spike = 55;\n  bool use_ml_spikes = 56;\n  bool enable_cooldowns = 57;\n  bool enable_adx_indicator = 58;\n  bool enable_volume_roc_spike = 59;\n  \n  // NEW PENNY STOCK INDICATORS\n  // Enable/disable flags\n  bool enable_macd_histogram_roc = 70;  // Predictive MACD histogram rate-of-change\n  bool enable_stochastic_indicator = 71;\n  bool enable_rvol_indicator = 72;\n  bool enable_ema_indicator = 73;\n  bool enable_ema_trend_filter = 74;\n  \n  // MACD periods (optimized for volatile 1-min candles)\n  int32 macd_fast_period = 80;\n  int32 macd_slow_period = 81;\n  int32 macd_signal_period = 82;\n  \n  // MACD Histogram ROC threshold (as % of price) - predictive convergence detection\n  double macd_histogram_roc_threshold = 83;\n  \n  // Stochastic periods and thresholds\n  int32 stochastic_period = 85;\n  int32 stochastic_k_smooth = 86;\n  int32 stochastic_d_smooth = 87;\n  double stochastic_oversold_threshold = 88;\n  double stochastic_overbought_threshold = 89;\n  \n  // Relative Volume (RVOL) settings\n  int32 rvol_period = 90;\n  double rvol_threshold = 91;\n  \n  // EMA periods\n  int32 ema9_period = 95;\n  int32 ema20_period = 96;\n  int32 ema50_period = 97;\n  \n  // Volume spike detection\n  double volume_spike_threshold = 98;\n  \n  // Timeframe multiplier for candle aggregation (1=1min, 10=10min, 30=30min, 60=1hour, 180=3hours)\n  // This tells the backend what timeframe to aggregate candles into before analysis\n  int32 timeframe_multiplier = 99;\n}\n\n// Configuration update request\nmessage ConfigUpdateRequest {\n  TradingConfig config = 1;\n}\n\n// Configuration response\nmessage ConfigResponse {\n  bool success = 1;\n  string message = 2;\n  TradingConfig current_config = 3;\n}\n","size_bytes":3736},"build/extracted-include-protos/test/google/cloud/audit/audit_log.proto":{"content":"// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.cloud.audit;\n\nimport \"google/api/field_behavior.proto\";\nimport \"google/protobuf/any.proto\";\nimport \"google/protobuf/struct.proto\";\nimport \"google/rpc/context/attribute_context.proto\";\nimport \"google/rpc/status.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/cloud/audit;audit\";\noption java_multiple_files = true;\noption java_outer_classname = \"AuditLogProto\";\noption java_package = \"com.google.cloud.audit\";\n\n// Common audit log format for Google Cloud Platform API operations.\nmessage AuditLog {\n  // The name of the API service performing the operation. For example,\n  // `\"compute.googleapis.com\"`.\n  string service_name = 7;\n\n  // The name of the service method or operation.\n  // For API calls, this should be the name of the API method.\n  // For example,\n  //\n  //     \"google.cloud.bigquery.v2.TableService.InsertTable\"\n  //     \"google.logging.v2.ConfigServiceV2.CreateSink\"\n  string method_name = 8;\n\n  // The resource or collection that is the target of the operation.\n  // The name is a scheme-less URI, not including the API service name.\n  // For example:\n  //\n  //     \"projects/PROJECT_ID/zones/us-central1-a/instances\"\n  //     \"projects/PROJECT_ID/datasets/DATASET_ID\"\n  string resource_name = 11;\n\n  // The resource location information.\n  ResourceLocation resource_location = 20;\n\n  // The resource's original state before mutation. Present only for\n  // operations which have successfully modified the targeted resource(s).\n  // In general, this field should contain all changed fields, except those\n  // that are already been included in `request`, `response`, `metadata` or\n  // `service_data` fields.\n  // When the JSON object represented here has a proto equivalent,\n  // the proto name will be indicated in the `@type` property.\n  google.protobuf.Struct resource_original_state = 19;\n\n  // The number of items returned from a List or Query API method,\n  // if applicable.\n  int64 num_response_items = 12;\n\n  // The status of the overall operation.\n  google.rpc.Status status = 2;\n\n  // Authentication information.\n  AuthenticationInfo authentication_info = 3;\n\n  // Authorization information. If there are multiple\n  // resources or permissions involved, then there is\n  // one AuthorizationInfo element for each {resource, permission} tuple.\n  repeated AuthorizationInfo authorization_info = 9;\n\n  // Indicates the policy violations for this request. If the request\n  // is denied by the policy, violation information will be logged\n  // here.\n  PolicyViolationInfo policy_violation_info = 25;\n\n  // Metadata about the operation.\n  RequestMetadata request_metadata = 4;\n\n  // The operation request. This may not include all request parameters,\n  // such as those that are too large, privacy-sensitive, or duplicated\n  // elsewhere in the log record.\n  // It should never include user-generated data, such as file contents.\n  // When the JSON object represented here has a proto equivalent, the proto\n  // name will be indicated in the `@type` property.\n  google.protobuf.Struct request = 16;\n\n  // The operation response. This may not include all response elements,\n  // such as those that are too large, privacy-sensitive, or duplicated\n  // elsewhere in the log record.\n  // It should never include user-generated data, such as file contents.\n  // When the JSON object represented here has a proto equivalent, the proto\n  // name will be indicated in the `@type` property.\n  google.protobuf.Struct response = 17;\n\n  // Other service-specific data about the request, response, and other\n  // information associated with the current audited event.\n  google.protobuf.Struct metadata = 18;\n\n  // Deprecated. Use the `metadata` field instead.\n  // Other service-specific data about the request, response, and other\n  // activities.\n  google.protobuf.Any service_data = 15 [deprecated = true];\n}\n\n// Authentication information for the operation.\nmessage AuthenticationInfo {\n  // The email address of the authenticated user (or service account on behalf\n  // of third party principal) making the request. For third party identity\n  // callers, the `principal_subject` field is populated instead of this field.\n  // For privacy reasons, the principal email address is sometimes redacted.\n  // For more information, see [Caller identities in audit\n  // logs](https://cloud.google.com/logging/docs/audit#user-id).\n  string principal_email = 1;\n\n  // The authority selector specified by the requestor, if any.\n  // It is not guaranteed that the principal was allowed to use this authority.\n  string authority_selector = 2;\n\n  // The third party identification (if any) of the authenticated user making\n  // the request.\n  // When the JSON object represented here has a proto equivalent, the proto\n  // name will be indicated in the `@type` property.\n  google.protobuf.Struct third_party_principal = 4;\n\n  // The name of the service account key used to create or exchange\n  // credentials for authenticating the service account making the request.\n  // This is a scheme-less URI full resource name. For example:\n  //\n  // \"//iam.googleapis.com/projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}\"\n  string service_account_key_name = 5;\n\n  // Identity delegation history of an authenticated service account that makes\n  // the request. It contains information on the real authorities that try to\n  // access GCP resources by delegating on a service account. When multiple\n  // authorities present, they are guaranteed to be sorted based on the original\n  // ordering of the identity delegation events.\n  repeated ServiceAccountDelegationInfo service_account_delegation_info = 6;\n\n  // String representation of identity of requesting party.\n  // Populated for both first and third party identities.\n  string principal_subject = 8;\n}\n\n// Authorization information for the operation.\nmessage AuthorizationInfo {\n  // The resource being accessed, as a REST-style or cloud resource string.\n  // For example:\n  //\n  //     bigquery.googleapis.com/projects/PROJECTID/datasets/DATASETID\n  // or\n  //     projects/PROJECTID/datasets/DATASETID\n  string resource = 1;\n\n  // The required IAM permission.\n  string permission = 2;\n\n  // Whether or not authorization for `resource` and `permission`\n  // was granted.\n  bool granted = 3;\n\n  // Resource attributes used in IAM condition evaluation. This field contains\n  // resource attributes like resource type and resource name.\n  //\n  // To get the whole view of the attributes used in IAM\n  // condition evaluation, the user must also look into\n  // `AuditLog.request_metadata.request_attributes`.\n  google.rpc.context.AttributeContext.Resource resource_attributes = 5;\n}\n\n// Metadata about the request.\nmessage RequestMetadata {\n  // The IP address of the caller.\n  // For a caller from the internet, this will be the public IPv4 or IPv6\n  // address. For calls made from inside Google's internal production network\n  // from one GCP service to another, `caller_ip` will be redacted to \"private\".\n  // For a caller from a Compute Engine VM with a external IP address,\n  // `caller_ip` will be the VM's external IP address. For a caller from a\n  // Compute Engine VM without a external IP address, if the VM is in the same\n  // organization (or project) as the accessed resource, `caller_ip` will be the\n  // VM's internal IPv4 address, otherwise `caller_ip` will be redacted to\n  // \"gce-internal-ip\". See https://cloud.google.com/compute/docs/vpc/ for more\n  // information.\n  string caller_ip = 1;\n\n  // The user agent of the caller.\n  // This information is not authenticated and should be treated accordingly.\n  // For example:\n  //\n  // +   `google-api-python-client/1.4.0`:\n  //     The request was made by the Google API client for Python.\n  // +   `Cloud SDK Command Line Tool apitools-client/1.0 gcloud/0.9.62`:\n  //     The request was made by the Google Cloud SDK CLI (gcloud).\n  // +   `AppEngine-Google; (+http://code.google.com/appengine; appid:\n  // s~my-project`:\n  //     The request was made from the `my-project` App Engine app.\n  string caller_supplied_user_agent = 2;\n\n  // The network of the caller.\n  // Set only if the network host project is part of the same GCP organization\n  // (or project) as the accessed resource.\n  // See https://cloud.google.com/compute/docs/vpc/ for more information.\n  // This is a scheme-less URI full resource name. For example:\n  //\n  //     \"//compute.googleapis.com/projects/PROJECT_ID/global/networks/NETWORK_ID\"\n  string caller_network = 3;\n\n  // Request attributes used in IAM condition evaluation. This field contains\n  // request attributes like request time and access levels associated with\n  // the request.\n  //\n  //\n  // To get the whole view of the attributes used in IAM\n  // condition evaluation, the user must also look into\n  // `AuditLog.authentication_info.resource_attributes`.\n  google.rpc.context.AttributeContext.Request request_attributes = 7;\n\n  // The destination of a network activity, such as accepting a TCP connection.\n  // In a multi hop network activity, the destination represents the receiver of\n  // the last hop. Only two fields are used in this message, Peer.port and\n  // Peer.ip. These fields are optionally populated by those services utilizing\n  // the IAM condition feature.\n  google.rpc.context.AttributeContext.Peer destination_attributes = 8;\n}\n\n// Location information about a resource.\nmessage ResourceLocation {\n  // The locations of a resource after the execution of the operation.\n  // Requests to create or delete a location based resource must populate\n  // the 'current_locations' field and not the 'original_locations' field.\n  // For example:\n  //\n  //     \"europe-west1-a\"\n  //     \"us-east1\"\n  //     \"nam3\"\n  repeated string current_locations = 1;\n\n  // The locations of a resource prior to the execution of the operation.\n  // Requests that mutate the resource's location must populate both the\n  // 'original_locations' as well as the 'current_locations' fields.\n  // For example:\n  //\n  //     \"europe-west1-a\"\n  //     \"us-east1\"\n  //     \"nam3\"\n  repeated string original_locations = 2;\n}\n\n// Identity delegation history of an authenticated service account.\nmessage ServiceAccountDelegationInfo {\n  // First party identity principal.\n  message FirstPartyPrincipal {\n    // The email address of a Google account.\n    string principal_email = 1;\n\n    // Metadata about the service that uses the service account.\n    google.protobuf.Struct service_metadata = 2;\n  }\n\n  // Third party identity principal.\n  message ThirdPartyPrincipal {\n    // Metadata about third party identity.\n    google.protobuf.Struct third_party_claims = 1;\n  }\n\n  // A string representing the principal_subject associated with the identity.\n  // For most identities, the format will be\n  // `principal://iam.googleapis.com/{identity pool name}/subject/{subject)`\n  // except for some GKE identities (GKE_WORKLOAD, FREEFORM, GKE_HUB_WORKLOAD)\n  // that are still in the legacy format `serviceAccount:{identity pool\n  // name}[{subject}]`\n  string principal_subject = 3;\n\n  // Entity that creates credentials for service account and assumes its\n  // identity for authentication.\n  oneof Authority {\n    // First party (Google) identity as the real authority.\n    FirstPartyPrincipal first_party_principal = 1;\n\n    // Third party identity as the real authority.\n    ThirdPartyPrincipal third_party_principal = 2;\n  }\n}\n\n// Information related to policy violations for this request.\nmessage PolicyViolationInfo {\n  // Indicates the orgpolicy violations for this resource.\n  OrgPolicyViolationInfo org_policy_violation_info = 1;\n}\n\n// Represents OrgPolicy Violation information.\nmessage OrgPolicyViolationInfo {\n  // Optional. Resource payload that is currently in scope and is subjected to orgpolicy\n  // conditions. This payload may be the subset of the actual Resource that may\n  // come in the request. This payload should not contain any core content.\n  google.protobuf.Struct payload = 1 [(google.api.field_behavior) = OPTIONAL];\n\n  // Optional. Resource type that the orgpolicy is checked against.\n  // Example: compute.googleapis.com/Instance, store.googleapis.com/bucket\n  string resource_type = 2 [(google.api.field_behavior) = OPTIONAL];\n\n  // Optional. Tags referenced on the resource at the time of evaluation. These also\n  // include the federated tags, if they are supplied in the CheckOrgPolicy\n  // or CheckCustomConstraints Requests.\n  //\n  // Optional field as of now. These tags are the Cloud tags that are\n  // available on the resource during the policy evaluation and will\n  // be available as part of the OrgPolicy check response for logging purposes.\n  map<string, string> resource_tags = 3 [(google.api.field_behavior) = OPTIONAL];\n\n  // Optional. Policy violations\n  repeated ViolationInfo violation_info = 4 [(google.api.field_behavior) = OPTIONAL];\n}\n\n// Provides information about the Policy violation info for this request.\nmessage ViolationInfo {\n  // Policy Type enum\n  enum PolicyType {\n    // Default value. This value should not be used.\n    POLICY_TYPE_UNSPECIFIED = 0;\n\n    // Indicates boolean policy constraint\n    BOOLEAN_CONSTRAINT = 1;\n\n    // Indicates list policy constraint\n    LIST_CONSTRAINT = 2;\n\n    // Indicates custom policy constraint\n    CUSTOM_CONSTRAINT = 3;\n  }\n\n  // Optional. Constraint name\n  string constraint = 1 [(google.api.field_behavior) = OPTIONAL];\n\n  // Optional. Error message that policy is indicating.\n  string error_message = 2 [(google.api.field_behavior) = OPTIONAL];\n\n  // Optional. Value that is being checked for the policy.\n  // This could be in encrypted form (if pii sensitive).\n  // This field will only be emitted in LIST_POLICY types\n  string checked_value = 3 [(google.api.field_behavior) = OPTIONAL];\n\n  // Optional. Indicates the type of the policy.\n  PolicyType policy_type = 4 [(google.api.field_behavior) = OPTIONAL];\n}","size_bytes":14531},"build/extracted-include-protos/main/google/type/dayofweek.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption go_package = \"google.golang.org/genproto/googleapis/type/dayofweek;dayofweek\";\noption java_multiple_files = true;\noption java_outer_classname = \"DayOfWeekProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a day of the week.\nenum DayOfWeek {\n  // The day of the week is unspecified.\n  DAY_OF_WEEK_UNSPECIFIED = 0;\n\n  // Monday\n  MONDAY = 1;\n\n  // Tuesday\n  TUESDAY = 2;\n\n  // Wednesday\n  WEDNESDAY = 3;\n\n  // Thursday\n  THURSDAY = 4;\n\n  // Friday\n  FRIDAY = 5;\n\n  // Saturday\n  SATURDAY = 6;\n\n  // Sunday\n  SUNDAY = 7;\n}\n","size_bytes":1204},"build/extracted-include-protos/main/google/type/money.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/money;money\";\noption java_multiple_files = true;\noption java_outer_classname = \"MoneyProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents an amount of money with its currency type.\nmessage Money {\n  // The three-letter currency code defined in ISO 4217.\n  string currency_code = 1;\n\n  // The whole units of the amount.\n  // For example if `currencyCode` is `\"USD\"`, then 1 unit is one US dollar.\n  int64 units = 2;\n\n  // Number of nano (10^-9) units of the amount.\n  // The value must be between -999,999,999 and +999,999,999 inclusive.\n  // If `units` is positive, `nanos` must be positive or zero.\n  // If `units` is zero, `nanos` can be positive, zero, or negative.\n  // If `units` is negative, `nanos` must be negative or zero.\n  // For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.\n  int32 nanos = 3;\n}\n","size_bytes":1603},"build/extracted-include-protos/test/google/api/distribution.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/any.proto\";\nimport \"google/protobuf/timestamp.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/distribution;distribution\";\noption java_multiple_files = true;\noption java_outer_classname = \"DistributionProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Distribution` contains summary statistics for a population of values. It\n// optionally contains a histogram representing the distribution of those values\n// across a set of buckets.\n//\n// The summary statistics are the count, mean, sum of the squared deviation from\n// the mean, the minimum, and the maximum of the set of population of values.\n// The histogram is based on a sequence of buckets and gives a count of values\n// that fall into each bucket. The boundaries of the buckets are given either\n// explicitly or by formulas for buckets of fixed or exponentially increasing\n// widths.\n//\n// Although it is not forbidden, it is generally a bad idea to include\n// non-finite values (infinities or NaNs) in the population of values, as this\n// will render the `mean` and `sum_of_squared_deviation` fields meaningless.\nmessage Distribution {\n  // The range of the population values.\n  message Range {\n    // The minimum of the population values.\n    double min = 1;\n\n    // The maximum of the population values.\n    double max = 2;\n  }\n\n  // `BucketOptions` describes the bucket boundaries used to create a histogram\n  // for the distribution. The buckets can be in a linear sequence, an\n  // exponential sequence, or each bucket can be specified explicitly.\n  // `BucketOptions` does not include the number of values in each bucket.\n  //\n  // A bucket has an inclusive lower bound and exclusive upper bound for the\n  // values that are counted for that bucket. The upper bound of a bucket must\n  // be strictly greater than the lower bound. The sequence of N buckets for a\n  // distribution consists of an underflow bucket (number 0), zero or more\n  // finite buckets (number 1 through N - 2) and an overflow bucket (number N -\n  // 1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the\n  // same as the upper bound of bucket i - 1. The buckets span the whole range\n  // of finite values: lower bound of the underflow bucket is -infinity and the\n  // upper bound of the overflow bucket is +infinity. The finite buckets are\n  // so-called because both bounds are finite.\n  message BucketOptions {\n    // Specifies a linear sequence of buckets that all have the same width\n    // (except overflow and underflow). Each bucket represents a constant\n    // absolute uncertainty on the specific value in the bucket.\n    //\n    // There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the\n    // following boundaries:\n    //\n    //    Upper bound (0 <= i < N-1):     offset + (width * i).\n    //\n    //    Lower bound (1 <= i < N):       offset + (width * (i - 1)).\n    message Linear {\n      // Must be greater than 0.\n      int32 num_finite_buckets = 1;\n\n      // Must be greater than 0.\n      double width = 2;\n\n      // Lower bound of the first bucket.\n      double offset = 3;\n    }\n\n    // Specifies an exponential sequence of buckets that have a width that is\n    // proportional to the value of the lower bound. Each bucket represents a\n    // constant relative uncertainty on a specific value in the bucket.\n    //\n    // There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the\n    // following boundaries:\n    //\n    //    Upper bound (0 <= i < N-1):     scale * (growth_factor ^ i).\n    //\n    //    Lower bound (1 <= i < N):       scale * (growth_factor ^ (i - 1)).\n    message Exponential {\n      // Must be greater than 0.\n      int32 num_finite_buckets = 1;\n\n      // Must be greater than 1.\n      double growth_factor = 2;\n\n      // Must be greater than 0.\n      double scale = 3;\n    }\n\n    // Specifies a set of buckets with arbitrary widths.\n    //\n    // There are `size(bounds) + 1` (= N) buckets. Bucket `i` has the following\n    // boundaries:\n    //\n    //    Upper bound (0 <= i < N-1):     bounds[i]\n    //    Lower bound (1 <= i < N);       bounds[i - 1]\n    //\n    // The `bounds` field must contain at least one element. If `bounds` has\n    // only one element, then there are no finite buckets, and that single\n    // element is the common boundary of the overflow and underflow buckets.\n    message Explicit {\n      // The values must be monotonically increasing.\n      repeated double bounds = 1;\n    }\n\n    // Exactly one of these three fields must be set.\n    oneof options {\n      // The linear bucket.\n      Linear linear_buckets = 1;\n\n      // The exponential buckets.\n      Exponential exponential_buckets = 2;\n\n      // The explicit buckets.\n      Explicit explicit_buckets = 3;\n    }\n  }\n\n  // Exemplars are example points that may be used to annotate aggregated\n  // distribution values. They are metadata that gives information about a\n  // particular value added to a Distribution bucket, such as a trace ID that\n  // was active when a value was added. They may contain further information,\n  // such as a example values and timestamps, origin, etc.\n  message Exemplar {\n    // Value of the exemplar point. This value determines to which bucket the\n    // exemplar belongs.\n    double value = 1;\n\n    // The observation (sampling) time of the above value.\n    google.protobuf.Timestamp timestamp = 2;\n\n    // Contextual information about the example value. Examples are:\n    //\n    //   Trace: type.googleapis.com/google.monitoring.v3.SpanContext\n    //\n    //   Literal string: type.googleapis.com/google.protobuf.StringValue\n    //\n    //   Labels dropped during aggregation:\n    //     type.googleapis.com/google.monitoring.v3.DroppedLabels\n    //\n    // There may be only a single attachment of any given message type in a\n    // single exemplar, and this is enforced by the system.\n    repeated google.protobuf.Any attachments = 3;\n  }\n\n  // The number of values in the population. Must be non-negative. This value\n  // must equal the sum of the values in `bucket_counts` if a histogram is\n  // provided.\n  int64 count = 1;\n\n  // The arithmetic mean of the values in the population. If `count` is zero\n  // then this field must be zero.\n  double mean = 2;\n\n  // The sum of squared deviations from the mean of the values in the\n  // population. For values x_i this is:\n  //\n  //     Sum[i=1..n]((x_i - mean)^2)\n  //\n  // Knuth, \"The Art of Computer Programming\", Vol. 2, page 232, 3rd edition\n  // describes Welford's method for accumulating this sum in one pass.\n  //\n  // If `count` is zero then this field must be zero.\n  double sum_of_squared_deviation = 3;\n\n  // If specified, contains the range of the population values. The field\n  // must not be present if the `count` is zero.\n  Range range = 4;\n\n  // Defines the histogram bucket boundaries. If the distribution does not\n  // contain a histogram, then omit this field.\n  BucketOptions bucket_options = 6;\n\n  // The number of values in each bucket of the histogram, as described in\n  // `bucket_options`. If the distribution does not have a histogram, then omit\n  // this field. If there is a histogram, then the sum of the values in\n  // `bucket_counts` must equal the value in the `count` field of the\n  // distribution.\n  //\n  // If present, `bucket_counts` should contain N values, where N is the number\n  // of buckets specified in `bucket_options`. If you supply fewer than N\n  // values, the remaining values are assumed to be 0.\n  //\n  // The order of the values in `bucket_counts` follows the bucket numbering\n  // schemes described for the three bucket types. The first value must be the\n  // count for the underflow bucket (number 0). The next N-2 values are the\n  // counts for the finite buckets (number 1 through N-2). The N'th value in\n  // `bucket_counts` is the count for the overflow bucket (number N-1).\n  repeated int64 bucket_counts = 7;\n\n  // Must be in increasing order of `value` field.\n  repeated Exemplar exemplars = 10;\n}\n","size_bytes":8660},"build/extracted-include-protos/main/google/protobuf/empty.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption go_package = \"google.golang.org/protobuf/types/known/emptypb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"EmptyProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\noption cc_enable_arenas = true;\n\n// A generic empty message that you can re-use to avoid defining duplicated\n// empty messages in your APIs. A typical example is to use it as the request\n// or the response type of an API method. For instance:\n//\n//     service Foo {\n//       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);\n//     }\n//\nmessage Empty {}\n","size_bytes":2363},"src/main/java/com/spiketrade/config/ConfigurationValidator.java":{"content":"package com.spiketrade.config;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ConfigurationValidator {\n    private static final Logger logger = LoggerFactory.getLogger(ConfigurationValidator.class);\n    \n    private static final String CURRENT_VERSION = \"1.0\";\n    private static final List<String> REQUIRED_FIELDS = List.of(\"params\");\n    \n    public static class ValidationResult {\n        private final boolean valid;\n        private final List<String> errors;\n        private final List<String> warnings;\n        \n        public ValidationResult(boolean valid, List<String> errors, List<String> warnings) {\n            this.valid = valid;\n            this.errors = errors;\n            this.warnings = warnings;\n        }\n        \n        public boolean isValid() {\n            return valid;\n        }\n        \n        public List<String> getErrors() {\n            return errors;\n        }\n        \n        public List<String> getWarnings() {\n            return warnings;\n        }\n        \n        public boolean hasWarnings() {\n            return !warnings.isEmpty();\n        }\n    }\n    \n    public static ValidationResult validate(JsonNode config) {\n        List<String> errors = new ArrayList<>();\n        List<String> warnings = new ArrayList<>();\n        \n        if (config == null) {\n            errors.add(\"Configuration is null\");\n            return new ValidationResult(false, errors, warnings);\n        }\n        \n        if (!config.has(\"version\")) {\n            warnings.add(\"Configuration missing version field - assuming current version\");\n        } else {\n            String version = config.get(\"version\").asText();\n            if (!CURRENT_VERSION.equals(version)) {\n                warnings.add(\"Configuration version mismatch: found \" + version + \n                           \", expected \" + CURRENT_VERSION);\n            }\n        }\n        \n        for (String field : REQUIRED_FIELDS) {\n            if (!config.has(field)) {\n                errors.add(\"Missing required field: \" + field);\n            }\n        }\n        \n        if (config.has(\"params\")) {\n            JsonNode params = config.get(\"params\");\n            validateParameters(params, errors, warnings);\n        }\n        \n        boolean valid = errors.isEmpty();\n        return new ValidationResult(valid, errors, warnings);\n    }\n    \n    private static void validateParameters(JsonNode params, List<String> errors, List<String> warnings) {\n        validateNumericRange(params, \"stddev_master\", 0.5, 5.0, errors, warnings);\n        validateNumericRange(params, \"period_master\", 5, 100, errors, warnings);\n        validateNumericRange(params, \"combo_signal_threshold\", 0.0, 1.0, errors, warnings);\n        validateNumericRange(params, \"stop_loss_pct\", 0.0, 20.0, errors, warnings);\n        validateNumericRange(params, \"equity_per_trade\", 100.0, 1000000.0, errors, warnings);\n        \n        if (params.has(\"warmup_data_points\")) {\n            int warmup = params.get(\"warmup_data_points\").asInt();\n            if (warmup < 10) {\n                warnings.add(\"warmup_data_points is very low (\" + warmup + \"), may cause unstable indicators\");\n            }\n        }\n        \n        if (params.has(\"max_open_trades\")) {\n            int maxTrades = params.get(\"max_open_trades\").asInt();\n            if (maxTrades > 20) {\n                warnings.add(\"max_open_trades is very high (\" + maxTrades + \"), may expose to excessive risk\");\n            }\n        }\n    }\n    \n    private static void validateNumericRange(JsonNode params, String field, \n                                            double min, double max, \n                                            List<String> errors, List<String> warnings) {\n        if (!params.has(field)) {\n            return;\n        }\n        \n        double value = params.get(field).asDouble();\n        if (value < min || value > max) {\n            errors.add(String.format(\"%s value %.2f is outside valid range [%.2f, %.2f]\", \n                                    field, value, min, max));\n        }\n    }\n    \n    public static JsonNode migrateConfig(JsonNode oldConfig, String fromVersion) {\n        logger.info(\"Migrating configuration from version {} to {}\", fromVersion, CURRENT_VERSION);\n        return oldConfig;\n    }\n}\n","size_bytes":4382},"build/extracted-include-protos/main/google/protobuf/field_mask.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"FieldMaskProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\noption go_package = \"google.golang.org/protobuf/types/known/fieldmaskpb\";\noption cc_enable_arenas = true;\n\n// `FieldMask` represents a set of symbolic field paths, for example:\n//\n//     paths: \"f.a\"\n//     paths: \"f.b.d\"\n//\n// Here `f` represents a field in some root message, `a` and `b`\n// fields in the message found in `f`, and `d` a field found in the\n// message in `f.b`.\n//\n// Field masks are used to specify a subset of fields that should be\n// returned by a get operation or modified by an update operation.\n// Field masks also have a custom JSON encoding (see below).\n//\n// # Field Masks in Projections\n//\n// When used in the context of a projection, a response message or\n// sub-message is filtered by the API to only contain those fields as\n// specified in the mask. For example, if the mask in the previous\n// example is applied to a response message as follows:\n//\n//     f {\n//       a : 22\n//       b {\n//         d : 1\n//         x : 2\n//       }\n//       y : 13\n//     }\n//     z: 8\n//\n// The result will not contain specific values for fields x,y and z\n// (their value will be set to the default, and omitted in proto text\n// output):\n//\n//\n//     f {\n//       a : 22\n//       b {\n//         d : 1\n//       }\n//     }\n//\n// A repeated field is not allowed except at the last position of a\n// paths string.\n//\n// If a FieldMask object is not present in a get operation, the\n// operation applies to all fields (as if a FieldMask of all fields\n// had been specified).\n//\n// Note that a field mask does not necessarily apply to the\n// top-level response message. In case of a REST get operation, the\n// field mask applies directly to the response, but in case of a REST\n// list operation, the mask instead applies to each individual message\n// in the returned resource list. In case of a REST custom method,\n// other definitions may be used. Where the mask applies will be\n// clearly documented together with its declaration in the API.  In\n// any case, the effect on the returned resource/resources is required\n// behavior for APIs.\n//\n// # Field Masks in Update Operations\n//\n// A field mask in update operations specifies which fields of the\n// targeted resource are going to be updated. The API is required\n// to only change the values of the fields as specified in the mask\n// and leave the others untouched. If a resource is passed in to\n// describe the updated values, the API ignores the values of all\n// fields not covered by the mask.\n//\n// If a repeated field is specified for an update operation, new values will\n// be appended to the existing repeated field in the target resource. Note that\n// a repeated field is only allowed in the last position of a `paths` string.\n//\n// If a sub-message is specified in the last position of the field mask for an\n// update operation, then new value will be merged into the existing sub-message\n// in the target resource.\n//\n// For example, given the target message:\n//\n//     f {\n//       b {\n//         d: 1\n//         x: 2\n//       }\n//       c: [1]\n//     }\n//\n// And an update message:\n//\n//     f {\n//       b {\n//         d: 10\n//       }\n//       c: [2]\n//     }\n//\n// then if the field mask is:\n//\n//  paths: [\"f.b\", \"f.c\"]\n//\n// then the result will be:\n//\n//     f {\n//       b {\n//         d: 10\n//         x: 2\n//       }\n//       c: [1, 2]\n//     }\n//\n// An implementation may provide options to override this default behavior for\n// repeated and message fields.\n//\n// In order to reset a field's value to the default, the field must\n// be in the mask and set to the default value in the provided resource.\n// Hence, in order to reset all fields of a resource, provide a default\n// instance of the resource and set all fields in the mask, or do\n// not provide a mask as described below.\n//\n// If a field mask is not present on update, the operation applies to\n// all fields (as if a field mask of all fields has been specified).\n// Note that in the presence of schema evolution, this may mean that\n// fields the client does not know and has therefore not filled into\n// the request will be reset to their default. If this is unwanted\n// behavior, a specific service may require a client to always specify\n// a field mask, producing an error if not.\n//\n// As with get operations, the location of the resource which\n// describes the updated values in the request message depends on the\n// operation kind. In any case, the effect of the field mask is\n// required to be honored by the API.\n//\n// ## Considerations for HTTP REST\n//\n// The HTTP kind of an update operation which uses a field mask must\n// be set to PATCH instead of PUT in order to satisfy HTTP semantics\n// (PUT must only be used for full updates).\n//\n// # JSON Encoding of Field Masks\n//\n// In JSON, a field mask is encoded as a single string where paths are\n// separated by a comma. Fields name in each path are converted\n// to/from lower-camel naming conventions.\n//\n// As an example, consider the following message declarations:\n//\n//     message Profile {\n//       User user = 1;\n//       Photo photo = 2;\n//     }\n//     message User {\n//       string display_name = 1;\n//       string address = 2;\n//     }\n//\n// In proto a field mask for `Profile` may look as such:\n//\n//     mask {\n//       paths: \"user.display_name\"\n//       paths: \"photo\"\n//     }\n//\n// In JSON, the same mask is represented as below:\n//\n//     {\n//       mask: \"user.displayName,photo\"\n//     }\n//\n// # Field Masks and Oneof Fields\n//\n// Field masks treat fields in oneofs just as regular fields. Consider the\n// following message:\n//\n//     message SampleMessage {\n//       oneof test_oneof {\n//         string name = 4;\n//         SubMessage sub_message = 9;\n//       }\n//     }\n//\n// The field mask can be:\n//\n//     mask {\n//       paths: \"name\"\n//     }\n//\n// Or:\n//\n//     mask {\n//       paths: \"sub_message\"\n//     }\n//\n// Note that oneof type names (\"test_oneof\" in this case) cannot be used in\n// paths.\n//\n// ## Field Mask Verification\n//\n// The implementation of any API method which has a FieldMask type field in the\n// request should verify the included field paths, and return an\n// `INVALID_ARGUMENT` error if any path is unmappable.\nmessage FieldMask {\n  // The set of field mask paths.\n  repeated string paths = 1;\n}\n","size_bytes":8185},"build/extracted-include-protos/test/google/api/logging.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"LoggingProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Logging configuration of the service.\n//\n// The following example shows how to configure logs to be sent to the\n// producer and consumer projects. In the example, the `activity_history`\n// log is sent to both the producer and consumer projects, whereas the\n// `purchase_history` log is only sent to the producer project.\n//\n//     monitored_resources:\n//     - type: library.googleapis.com/branch\n//       labels:\n//       - key: /city\n//         description: The city where the library branch is located in.\n//       - key: /name\n//         description: The name of the branch.\n//     logs:\n//     - name: activity_history\n//       labels:\n//       - key: /customer_id\n//     - name: purchase_history\n//     logging:\n//       producer_destinations:\n//       - monitored_resource: library.googleapis.com/branch\n//         logs:\n//         - activity_history\n//         - purchase_history\n//       consumer_destinations:\n//       - monitored_resource: library.googleapis.com/branch\n//         logs:\n//         - activity_history\nmessage Logging {\n  // Configuration of a specific logging destination (the producer project\n  // or the consumer project).\n  message LoggingDestination {\n    // The monitored resource type. The type must be defined in the\n    // [Service.monitored_resources][google.api.Service.monitored_resources]\n    // section.\n    string monitored_resource = 3;\n\n    // Names of the logs to be sent to this destination. Each name must\n    // be defined in the [Service.logs][google.api.Service.logs] section. If the\n    // log name is not a domain scoped name, it will be automatically prefixed\n    // with the service name followed by \"/\".\n    repeated string logs = 1;\n  }\n\n  // Logging configurations for sending logs to the producer project.\n  // There can be multiple producer destinations, each one must have a\n  // different monitored resource type. A log can be used in at most\n  // one producer destination.\n  repeated LoggingDestination producer_destinations = 1;\n\n  // Logging configurations for sending logs to the consumer project.\n  // There can be multiple consumer destinations, each one must have a\n  // different monitored resource type. A log can be used in at most\n  // one consumer destination.\n  repeated LoggingDestination consumer_destinations = 2;\n}\n","size_bytes":3174},"build/extracted-include-protos/test/google/api/httpbody.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/any.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/api/httpbody;httpbody\";\noption java_multiple_files = true;\noption java_outer_classname = \"HttpBodyProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Message that represents an arbitrary HTTP body. It should only be used for\n// payload formats that can't be represented as JSON, such as raw binary or\n// an HTML page.\n//\n//\n// This message can be used both in streaming and non-streaming API methods in\n// the request as well as the response.\n//\n// It can be used as a top-level request field, which is convenient if one\n// wants to extract parameters from either the URL or HTTP template into the\n// request fields and also want access to the raw HTTP body.\n//\n// Example:\n//\n//     message GetResourceRequest {\n//       // A unique request id.\n//       string request_id = 1;\n//\n//       // The raw HTTP body is bound to this field.\n//       google.api.HttpBody http_body = 2;\n//\n//     }\n//\n//     service ResourceService {\n//       rpc GetResource(GetResourceRequest)\n//         returns (google.api.HttpBody);\n//       rpc UpdateResource(google.api.HttpBody)\n//         returns (google.protobuf.Empty);\n//\n//     }\n//\n// Example with streaming methods:\n//\n//     service CaldavService {\n//       rpc GetCalendar(stream google.api.HttpBody)\n//         returns (stream google.api.HttpBody);\n//       rpc UpdateCalendar(stream google.api.HttpBody)\n//         returns (stream google.api.HttpBody);\n//\n//     }\n//\n// Use of this type only changes how the request and response bodies are\n// handled, all other features will continue to work unchanged.\nmessage HttpBody {\n  // The HTTP Content-Type header value specifying the content type of the body.\n  string content_type = 1;\n\n  // The HTTP request/response body as raw binary.\n  bytes data = 2;\n\n  // Application specific response metadata. Must be set in the first response\n  // for streaming APIs.\n  repeated google.protobuf.Any extensions = 3;\n}\n","size_bytes":2693},"build/resources/main/styles.css":{"content":"/* ============================================================================\n   SPIKETRADE - APPLE-INSPIRED PROFESSIONAL DESIGN\n   Minimalist greyscale palette with single accent color\n   ============================================================================ */\n\n/* PROFESSIONAL GREYSCALE PALETTE (Apple-inspired)\n   Background:      #0B0D0F  (Deepest charcoal)\n   Panels:          #15181D  (Panel background)\n   Elevated Cards:  #1F232A  (Card surfaces)\n   Dividers:        #262A32  (Subtle borders)\n   Primary Text:    #F5F5F7  (High contrast white)\n   Secondary Text:  #9DA3AD  (Medium grey)\n   Muted Text:      #6F7680  (Low emphasis)\n   Accent Blue:     #5AC8FA  (Active controls - use sparingly)\n   Highlight:       #3A3F47  (Hover/focus states)\n*/\n\n.root {\n    -fx-background-color: #0B0D0F;\n    -fx-font-family: \"SF Pro Display\", \"Segoe UI\", \"Inter\", \"Helvetica Neue\", Arial, sans-serif;\n}\n\n/* ============================================================================\n   HEADER - Clean and minimal\n   ============================================================================ */\n.header {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-width: 0 0 1 0;\n    -fx-padding: 20;\n}\n\n/* ============================================================================\n   STATUS INDICATORS - Subtle state communication\n   ============================================================================ */\n.status-online {\n    -fx-text-fill: #F5F5F7;\n    -fx-font-weight: 600;\n}\n\n.status-offline {\n    -fx-text-fill: #6F7680;\n    -fx-font-weight: 600;\n}\n\n.status-trading {\n    -fx-text-fill: #5AC8FA;\n    -fx-font-weight: 600;\n}\n\n/* ============================================================================\n   BUTTONS - Minimal with subtle depth\n   ============================================================================ */\n.rounded-button {\n    -fx-background-color: #3A3F47;\n    -fx-text-fill: #F5F5F7;\n    -fx-background-radius: 8;\n    -fx-border-radius: 8;\n    -fx-padding: 10 20;\n    -fx-font-size: 13px;\n    -fx-font-weight: 500;\n    -fx-cursor: hand;\n}\n\n.rounded-button:hover {\n    -fx-background-color: #4A4F57;\n}\n\n.rounded-button:pressed {\n    -fx-background-color: #2A2F37;\n}\n\n/* Active/Success Button */\n.button-green {\n    -fx-background-color: #5AC8FA;\n    -fx-text-fill: #0B0D0F;\n    -fx-background-radius: 8;\n    -fx-border-radius: 8;\n    -fx-padding: 10 20;\n    -fx-font-weight: 600;\n    -fx-font-size: 13px;\n    -fx-cursor: hand;\n}\n\n.button-green:hover {\n    -fx-background-color: #6CCEFF;\n}\n\n/* Danger/Stop Button */\n.button-red {\n    -fx-background-color: #3A3F47;\n    -fx-text-fill: #9DA3AD;\n    -fx-background-radius: 8;\n    -fx-border-radius: 8;\n    -fx-border-color: #262A32;\n    -fx-border-width: 1;\n    -fx-padding: 10 20;\n    -fx-font-weight: 600;\n    -fx-font-size: 13px;\n    -fx-cursor: hand;\n}\n\n.button-red:hover {\n    -fx-background-color: #4A4F57;\n    -fx-text-fill: #F5F5F7;\n}\n\n/* ============================================================================\n   TAB PANE - Clean interface\n   ============================================================================ */\n.tab-pane {\n    -fx-background-color: transparent;\n    -fx-border-color: transparent;\n}\n\n.tab-pane .tab-header-area {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-width: 0 0 1 0;\n}\n\n.tab-pane .tab-header-area .tab-header-background {\n    -fx-background-color: #15181D;\n}\n\n.tab-pane .tab {\n    -fx-background-color: transparent;\n    -fx-background-radius: 0;\n    -fx-padding: 14 24;\n    -fx-font-size: 13px;\n    -fx-font-weight: 500;\n    -fx-border-width: 0 0 2 0;\n    -fx-border-color: transparent;\n}\n\n.tab-pane .tab:hover {\n    -fx-background-color: rgba(58, 63, 71, 0.3);\n}\n\n.tab-pane .tab:selected {\n    -fx-background-color: rgba(58, 63, 71, 0.4);\n    -fx-border-color: #5AC8FA;\n    -fx-border-width: 0 0 2 0;\n}\n\n.tab-pane .tab-label {\n    -fx-text-fill: #9DA3AD;\n    -fx-font-size: 13px;\n}\n\n.tab-pane .tab:selected .tab-label {\n    -fx-text-fill: #F5F5F7;\n    -fx-font-weight: 600;\n}\n\n/* ============================================================================\n   CARDS & PANELS - Elevated surfaces\n   ============================================================================ */\n.section-card {\n    -fx-background-color: #1F232A;\n    -fx-background-radius: 12;\n    -fx-border-color: #262A32;\n    -fx-border-radius: 12;\n    -fx-border-width: 1;\n    -fx-padding: 20;\n}\n\n.section-card:hover {\n    -fx-border-color: #3A3F47;\n}\n\n/* ============================================================================\n   TITLED PANE - Collapsible sections\n   ============================================================================ */\n.titled-pane {\n    -fx-background-color: #1F232A;\n    -fx-border-color: #262A32;\n    -fx-border-width: 1;\n    -fx-border-radius: 8;\n}\n\n.titled-pane > .title {\n    -fx-background-color: #3A3F47;\n    -fx-text-fill: #F5F5F7;\n    -fx-font-size: 13px;\n    -fx-font-weight: 600;\n    -fx-background-radius: 8 8 0 0;\n    -fx-padding: 12 16;\n}\n\n.titled-pane > .title:hover {\n    -fx-background-color: #4A4F57;\n}\n\n.titled-pane > .content {\n    -fx-background-color: #1F232A;\n    -fx-border-color: transparent;\n    -fx-padding: 16;\n}\n\n/* ============================================================================\n   LABELS - Typography hierarchy\n   ============================================================================ */\n.label-header {\n    -fx-font-size: 22px;\n    -fx-font-weight: 600;\n    -fx-text-fill: #F5F5F7;\n}\n\n.label-subheader {\n    -fx-font-size: 15px;\n    -fx-font-weight: 600;\n    -fx-text-fill: #F5F5F7;\n}\n\n.label-normal {\n    -fx-font-size: 13px;\n    -fx-text-fill: #9DA3AD;\n}\n\n.label-muted {\n    -fx-font-size: 12px;\n    -fx-text-fill: #6F7680;\n}\n\n/* ============================================================================\n   TEXT FIELDS - Clean input controls\n   ============================================================================ */\n.text-field {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-radius: 6;\n    -fx-background-radius: 6;\n    -fx-padding: 8 12;\n    -fx-font-size: 13px;\n    -fx-text-fill: #F5F5F7;\n    -fx-prompt-text-fill: #6F7680;\n}\n\n.text-field:focused {\n    -fx-border-color: #5AC8FA;\n    -fx-border-width: 1;\n}\n\n/* ============================================================================\n   TABLES - Professional data display\n   ============================================================================ */\n.table-view {\n    -fx-background-color: #1F232A;\n    -fx-border-color: #262A32;\n    -fx-border-width: 1;\n    -fx-border-radius: 8;\n    -fx-background-radius: 8;\n}\n\n.table-view .column-header {\n    -fx-background-color: #15181D;\n    -fx-text-fill: #9DA3AD;\n    -fx-font-weight: 600;\n    -fx-font-size: 12px;\n    -fx-padding: 10;\n    -fx-border-color: #262A32;\n}\n\n.table-view .column-header-background {\n    -fx-background-color: #15181D;\n}\n\n.table-view .table-cell {\n    -fx-text-fill: #F5F5F7;\n    -fx-font-size: 12px;\n    -fx-padding: 8 10;\n    -fx-border-color: #262A32;\n    -fx-font-family: \"SF Mono\", \"Consolas\", \"Monaco\", monospace;\n}\n\n.table-row-cell {\n    -fx-background-color: transparent;\n}\n\n.table-row-cell:odd {\n    -fx-background-color: rgba(38, 42, 50, 0.3);\n}\n\n.table-row-cell:selected {\n    -fx-background-color: rgba(90, 200, 250, 0.15);\n    -fx-text-fill: #F5F5F7;\n}\n\n.table-row-cell:hover {\n    -fx-background-color: rgba(58, 63, 71, 0.4);\n}\n\n/* ============================================================================\n   SCROLL BARS - Minimal design\n   ============================================================================ */\n.scroll-bar {\n    -fx-background-color: transparent;\n}\n\n.scroll-bar .thumb {\n    -fx-background-color: #3A3F47;\n    -fx-background-radius: 4;\n}\n\n.scroll-bar .thumb:hover {\n    -fx-background-color: #4A4F57;\n}\n\n.scroll-bar .increment-button,\n.scroll-bar .decrement-button {\n    -fx-background-color: transparent;\n    -fx-padding: 0;\n}\n\n/* ============================================================================\n   CHECKBOXES - Modern toggle style\n   ============================================================================ */\n.check-box {\n    -fx-text-fill: #9DA3AD;\n    -fx-font-size: 13px;\n}\n\n.check-box .box {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-radius: 4;\n    -fx-border-width: 1;\n}\n\n.check-box:hover .box {\n    -fx-border-color: #3A3F47;\n}\n\n.check-box:selected .box {\n    -fx-background-color: #5AC8FA;\n    -fx-border-color: #5AC8FA;\n}\n\n.check-box:selected .mark {\n    -fx-background-color: #0B0D0F;\n    -fx-shape: \"M 0 4 L 4 8 L 10 0\";\n}\n\n/* ============================================================================\n   SLIDERS - Clean track design\n   ============================================================================ */\n.slider .track {\n    -fx-background-color: #262A32;\n    -fx-background-radius: 4;\n    -fx-pref-height: 4;\n}\n\n.slider .thumb {\n    -fx-background-color: #F5F5F7;\n    -fx-background-radius: 10;\n    -fx-pref-width: 18;\n    -fx-pref-height: 18;\n}\n\n.slider .thumb:hover {\n    -fx-background-color: #5AC8FA;\n    -fx-scale-x: 1.1;\n    -fx-scale-y: 1.1;\n}\n\n.slider .thumb:pressed {\n    -fx-scale-x: 1.15;\n    -fx-scale-y: 1.15;\n}\n\n/* ============================================================================\n   COMBO BOX - Dropdown styling\n   ============================================================================ */\n.combo-box {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-radius: 6;\n    -fx-background-radius: 6;\n}\n\n.combo-box:hover {\n    -fx-border-color: #3A3F47;\n}\n\n.combo-box .list-cell {\n    -fx-background-color: #1F232A;\n    -fx-text-fill: #9DA3AD;\n}\n\n.combo-box .list-cell:hover {\n    -fx-background-color: #3A3F47;\n    -fx-text-fill: #F5F5F7;\n}\n\n/* ============================================================================\n   STATUS BAR - Bottom info strip\n   ============================================================================ */\n.status-bar {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-width: 1 0 0 0;\n    -fx-padding: 8 20;\n}\n\n/* ============================================================================\n   FINANCIAL DATA - Subtle state indication with typography\n   ============================================================================ */\n.profit-positive {\n    -fx-text-fill: #F5F5F7;\n    -fx-font-weight: 600;\n    -fx-font-family: \"SF Mono\", \"Consolas\", \"Monaco\", monospace;\n}\n\n.profit-negative {\n    -fx-text-fill: #9DA3AD;\n    -fx-font-weight: 600;\n    -fx-font-family: \"SF Mono\", \"Consolas\", \"Monaco\", monospace;\n}\n\n/* ============================================================================\n   WARNING & INFO - Single accent color for alerts\n   ============================================================================ */\n.warning-text {\n    -fx-text-fill: #9DA3AD;\n    -fx-font-weight: 500;\n}\n\n.info-text {\n    -fx-text-fill: #F5F5F7;\n    -fx-font-weight: 500;\n}\n\n/* ============================================================================\n   SEPARATORS\n   ============================================================================ */\n.separator {\n    -fx-background-color: #262A32;\n}\n\n.separator .line {\n    -fx-border-color: #262A32;\n}\n\n/* ============================================================================\n   SPINNER CONTROLS\n   ============================================================================ */\n.spinner {\n    -fx-background-color: #15181D;\n    -fx-border-color: #262A32;\n    -fx-border-radius: 6;\n}\n\n.spinner .text-field {\n    -fx-background-color: #15181D;\n    -fx-text-fill: #F5F5F7;\n}\n\n.spinner .increment-arrow-button,\n.spinner .decrement-arrow-button {\n    -fx-background-color: #262A32;\n}\n\n.spinner .increment-arrow-button:hover,\n.spinner .decrement-arrow-button:hover {\n    -fx-background-color: #3A3F47;\n}\n\n/* ============================================================================\n   TOOLTIP - Hover information\n   ============================================================================ */\n.tooltip {\n    -fx-background-color: #1F232A;\n    -fx-text-fill: #F5F5F7;\n    -fx-border-color: #262A32;\n    -fx-border-width: 1;\n    -fx-border-radius: 6;\n    -fx-background-radius: 6;\n    -fx-padding: 6 10;\n    -fx-font-size: 12px;\n}\n","size_bytes":12373},"src/main/java/com/spiketrade/model/BacktestTrade.java":{"content":"package com.spiketrade.model;\n\nimport java.time.LocalDateTime;\n\npublic class BacktestTrade {\n    private String symbol;\n    private String entryTime;\n    private String exitTime;\n    private Double entryPrice;\n    private Double exitPrice;\n    private Integer shares;\n    private Double profitLoss;\n    private Double profitLossPercent;\n    private String exitReason;\n    private Double predictedGainTarget;\n    private Integer predictedTimeToTarget;\n    private Integer actualTimeToTarget;\n    private Double predictionAccuracyPercent;\n    \n    public BacktestTrade() {\n        this.symbol = \"\";\n        this.entryTime = \"\";\n        this.exitTime = \"\";\n        this.entryPrice = 0.0;\n        this.exitPrice = 0.0;\n        this.shares = 0;\n        this.profitLoss = 0.0;\n        this.profitLossPercent = 0.0;\n        this.exitReason = \"\";\n        this.predictedGainTarget = 0.0;\n        this.predictedTimeToTarget = -1;\n        this.actualTimeToTarget = -1;\n        this.predictionAccuracyPercent = 0.0;\n    }\n    \n    public BacktestTrade(String entryTime, String exitTime, Double entryPrice, Double exitPrice, \n                        Integer shares, Double profitLoss, Double profitLossPercent, String exitReason) {\n        this.entryTime = entryTime;\n        this.exitTime = exitTime;\n        this.entryPrice = entryPrice;\n        this.exitPrice = exitPrice;\n        this.shares = shares;\n        this.profitLoss = profitLoss;\n        this.profitLossPercent = profitLossPercent;\n        this.exitReason = exitReason;\n        this.predictedGainTarget = 0.0;\n        this.predictedTimeToTarget = -1;\n        this.actualTimeToTarget = -1;\n        this.predictionAccuracyPercent = 0.0;\n    }\n    \n    public BacktestTrade(String entryTime, String exitTime, Double entryPrice, Double exitPrice, \n                        Integer shares, Double profitLoss, Double profitLossPercent, String exitReason,\n                        Double predictedGainTarget, Integer predictedTimeToTarget, \n                        Integer actualTimeToTarget, Double predictionAccuracyPercent) {\n        this.entryTime = entryTime;\n        this.exitTime = exitTime;\n        this.entryPrice = entryPrice;\n        this.exitPrice = exitPrice;\n        this.shares = shares;\n        this.profitLoss = profitLoss;\n        this.profitLossPercent = profitLossPercent;\n        this.exitReason = exitReason;\n        this.predictedGainTarget = predictedGainTarget;\n        this.predictedTimeToTarget = predictedTimeToTarget;\n        this.actualTimeToTarget = actualTimeToTarget;\n        this.predictionAccuracyPercent = predictionAccuracyPercent;\n    }\n    \n    public String getSymbol() { return symbol; }\n    public void setSymbol(String symbol) { this.symbol = symbol; }\n    \n    public String getEntryTime() { return entryTime; }\n    public void setEntryTime(String entryTime) { this.entryTime = entryTime; }\n    public void setEntryTime(LocalDateTime entryTime) { this.entryTime = entryTime.toString(); }\n    \n    public String getExitTime() { return exitTime; }\n    public void setExitTime(String exitTime) { this.exitTime = exitTime; }\n    public void setExitTime(LocalDateTime exitTime) { this.exitTime = exitTime.toString(); }\n    \n    public Double getEntryPrice() { return entryPrice; }\n    public void setEntryPrice(Double entryPrice) { this.entryPrice = entryPrice; }\n    \n    public Double getExitPrice() { return exitPrice; }\n    public void setExitPrice(Double exitPrice) { this.exitPrice = exitPrice; }\n    \n    public Integer getShares() { return shares; }\n    public Integer getQuantity() { return shares; }\n    public void setQuantity(Integer quantity) { this.shares = quantity; }\n    \n    public Double getProfitLoss() { return profitLoss; }\n    public void setProfitLoss(Double profitLoss) { this.profitLoss = profitLoss; }\n    \n    public Double getProfitLossPercent() { return profitLossPercent; }\n    public Double getProfitPct() { return profitLossPercent; }\n    public void setProfitPct(Double profitPct) { this.profitLossPercent = profitPct; }\n    \n    public String getExitReason() { return exitReason; }\n    public Double getPredictedGainTarget() { return predictedGainTarget; }\n    public Integer getPredictedTimeToTarget() { return predictedTimeToTarget; }\n    public Integer getActualTimeToTarget() { return actualTimeToTarget; }\n    public Double getPredictionAccuracyPercent() { return predictionAccuracyPercent; }\n}\n","size_bytes":4416},"build/extracted-include-protos/main/google/protobuf/any.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption go_package = \"google.golang.org/protobuf/types/known/anypb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"AnyProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\n\n// `Any` contains an arbitrary serialized protocol buffer message along with a\n// URL that describes the type of the serialized message.\n//\n// Protobuf library provides support to pack/unpack Any values in the form\n// of utility functions or additional generated methods of the Any type.\n//\n// Example 1: Pack and unpack a message in C++.\n//\n//     Foo foo = ...;\n//     Any any;\n//     any.PackFrom(foo);\n//     ...\n//     if (any.UnpackTo(&foo)) {\n//       ...\n//     }\n//\n// Example 2: Pack and unpack a message in Java.\n//\n//     Foo foo = ...;\n//     Any any = Any.pack(foo);\n//     ...\n//     if (any.is(Foo.class)) {\n//       foo = any.unpack(Foo.class);\n//     }\n//     // or ...\n//     if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n//       foo = any.unpack(Foo.getDefaultInstance());\n//     }\n//\n//  Example 3: Pack and unpack a message in Python.\n//\n//     foo = Foo(...)\n//     any = Any()\n//     any.Pack(foo)\n//     ...\n//     if any.Is(Foo.DESCRIPTOR):\n//       any.Unpack(foo)\n//       ...\n//\n//  Example 4: Pack and unpack a message in Go\n//\n//      foo := &pb.Foo{...}\n//      any, err := anypb.New(foo)\n//      if err != nil {\n//        ...\n//      }\n//      ...\n//      foo := &pb.Foo{}\n//      if err := any.UnmarshalTo(foo); err != nil {\n//        ...\n//      }\n//\n// The pack methods provided by protobuf library will by default use\n// 'type.googleapis.com/full.type.name' as the type URL and the unpack\n// methods only use the fully qualified type name after the last '/'\n// in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n// name \"y.z\".\n//\n// JSON\n// ====\n// The JSON representation of an `Any` value uses the regular\n// representation of the deserialized, embedded message, with an\n// additional field `@type` which contains the type URL. Example:\n//\n//     package google.profile;\n//     message Person {\n//       string first_name = 1;\n//       string last_name = 2;\n//     }\n//\n//     {\n//       \"@type\": \"type.googleapis.com/google.profile.Person\",\n//       \"firstName\": <string>,\n//       \"lastName\": <string>\n//     }\n//\n// If the embedded message type is well-known and has a custom JSON\n// representation, that representation will be embedded adding a field\n// `value` which holds the custom JSON in addition to the `@type`\n// field. Example (for message [google.protobuf.Duration][]):\n//\n//     {\n//       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n//       \"value\": \"1.212s\"\n//     }\n//\nmessage Any {\n  // A URL/resource name that uniquely identifies the type of the serialized\n  // protocol buffer message. This string must contain at least\n  // one \"/\" character. The last segment of the URL's path must represent\n  // the fully qualified name of the type (as in\n  // `path/google.protobuf.Duration`). The name should be in a canonical form\n  // (e.g., leading \".\" is not accepted).\n  //\n  // In practice, teams usually precompile into the binary all types that they\n  // expect it to use in the context of Any. However, for URLs which use the\n  // scheme `http`, `https`, or no scheme, one can optionally set up a type\n  // server that maps type URLs to message definitions as follows:\n  //\n  // * If no scheme is provided, `https` is assumed.\n  // * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  //   value in binary format, or produce an error.\n  // * Applications are allowed to cache lookup results based on the\n  //   URL, or have them precompiled into a binary to avoid any\n  //   lookup. Therefore, binary compatibility needs to be preserved\n  //   on changes to types. (Use versioned type names to manage\n  //   breaking changes.)\n  //\n  // Note: this functionality is not currently available in the official\n  // protobuf release, and it is not used for type URLs beginning with\n  // type.googleapis.com. As of May 2023, there are no widely used type server\n  // implementations and no plans to implement one.\n  //\n  // Schemes other than `http`, `https` (or the empty scheme) might be\n  // used with implementation specific semantics.\n  //\n  string type_url = 1;\n\n  // Must be a valid serialized protocol buffer of the above specified type.\n  bytes value = 2;\n}\n","size_bytes":6154},"src/main/java/com/spiketrade/repository/BacktestRepository.java":{"content":"package com.spiketrade.repository;\n\nimport com.spiketrade.model.BacktestTrade;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.sql.DataSource;\nimport java.sql.*;\nimport java.time.LocalDateTime;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class BacktestRepository {\n    private static final Logger logger = LoggerFactory.getLogger(BacktestRepository.class);\n    private final DataSource dataSource;\n    \n    public BacktestRepository(DataSource dataSource) {\n        this.dataSource = dataSource;\n        initializeTables();\n    }\n    \n    private void initializeTables() {\n        String createRunsTable = \"\"\"\n            CREATE TABLE IF NOT EXISTS backtest_runs (\n                id SERIAL PRIMARY KEY,\n                symbol VARCHAR(20) NOT NULL,\n                start_date DATE NOT NULL,\n                end_date DATE NOT NULL,\n                initial_capital DECIMAL(15, 2) NOT NULL,\n                final_capital DECIMAL(15, 2),\n                total_trades INTEGER,\n                winning_trades INTEGER,\n                win_rate DECIMAL(5, 4),\n                total_profit DECIMAL(15, 2),\n                max_drawdown DECIMAL(15, 2),\n                sharpe_ratio DECIMAL(10, 4),\n                config_json TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\";\n        \n        String createTradesTable = \"\"\"\n            CREATE TABLE IF NOT EXISTS backtest_trades (\n                id SERIAL PRIMARY KEY,\n                run_id INTEGER REFERENCES backtest_runs(id) ON DELETE CASCADE,\n                symbol VARCHAR(20) NOT NULL,\n                entry_price DECIMAL(10, 2) NOT NULL,\n                exit_price DECIMAL(10, 2) NOT NULL,\n                quantity INTEGER NOT NULL,\n                entry_time TIMESTAMP NOT NULL,\n                exit_time TIMESTAMP NOT NULL,\n                profit_loss DECIMAL(10, 2) NOT NULL,\n                profit_pct DECIMAL(10, 4) NOT NULL,\n                hold_time_minutes INTEGER\n            )\n        \"\"\";\n        \n        try (Connection conn = dataSource.getConnection();\n             Statement stmt = conn.createStatement()) {\n            stmt.execute(createRunsTable);\n            stmt.execute(createTradesTable);\n            logger.info(\"Backtest tables initialized\");\n        } catch (SQLException e) {\n            logger.error(\"Failed to initialize backtest tables\", e);\n        }\n    }\n    \n    public int saveBacktestRun(String symbol, LocalDateTime startDate, LocalDateTime endDate,\n                              double initialCapital, double finalCapital, int totalTrades,\n                              int winningTrades, double winRate, double totalProfit,\n                              double maxDrawdown, double sharpeRatio, String configJson) {\n        String sql = \"\"\"\n            INSERT INTO backtest_runs (symbol, start_date, end_date, initial_capital, \n                                      final_capital, total_trades, winning_trades, win_rate,\n                                      total_profit, max_drawdown, sharpe_ratio, config_json)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n            RETURNING id\n        \"\"\";\n        \n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            \n            pstmt.setString(1, symbol);\n            pstmt.setTimestamp(2, Timestamp.valueOf(startDate));\n            pstmt.setTimestamp(3, Timestamp.valueOf(endDate));\n            pstmt.setDouble(4, initialCapital);\n            pstmt.setDouble(5, finalCapital);\n            pstmt.setInt(6, totalTrades);\n            pstmt.setInt(7, winningTrades);\n            pstmt.setDouble(8, winRate);\n            pstmt.setDouble(9, totalProfit);\n            pstmt.setDouble(10, maxDrawdown);\n            pstmt.setDouble(11, sharpeRatio);\n            pstmt.setString(12, configJson);\n            \n            ResultSet rs = pstmt.executeQuery();\n            if (rs.next()) {\n                int runId = rs.getInt(1);\n                logger.info(\"Saved backtest run with ID: {}\", runId);\n                return runId;\n            }\n            \n        } catch (SQLException e) {\n            logger.error(\"Failed to save backtest run\", e);\n        }\n        \n        return -1;\n    }\n    \n    public void saveBacktestTrade(int runId, BacktestTrade trade) {\n        String sql = \"\"\"\n            INSERT INTO backtest_trades (run_id, symbol, entry_price, exit_price, quantity,\n                                        entry_time, exit_time, profit_loss, profit_pct, hold_time_minutes)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\";\n        \n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            \n            pstmt.setInt(1, runId);\n            pstmt.setString(2, trade.getSymbol());\n            pstmt.setDouble(3, trade.getEntryPrice());\n            pstmt.setDouble(4, trade.getExitPrice());\n            pstmt.setInt(5, trade.getQuantity());\n            pstmt.setTimestamp(6, Timestamp.valueOf(trade.getEntryTime()));\n            pstmt.setTimestamp(7, Timestamp.valueOf(trade.getExitTime()));\n            pstmt.setDouble(8, trade.getProfitLoss());\n            pstmt.setDouble(9, trade.getProfitPct());\n            pstmt.setInt(10, 0);\n            \n            pstmt.executeUpdate();\n            \n        } catch (SQLException e) {\n            logger.error(\"Failed to save backtest trade\", e);\n        }\n    }\n    \n    public List<BacktestTrade> findTradesByRunId(int runId) {\n        String sql = \"SELECT * FROM backtest_trades WHERE run_id = ? ORDER BY entry_time\";\n        List<BacktestTrade> trades = new ArrayList<>();\n        \n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            \n            pstmt.setInt(1, runId);\n            ResultSet rs = pstmt.executeQuery();\n            \n            while (rs.next()) {\n                trades.add(mapResultSetToTrade(rs));\n            }\n            \n        } catch (SQLException e) {\n            logger.error(\"Failed to fetch backtest trades for run: {}\", runId, e);\n        }\n        \n        return trades;\n    }\n    \n    private BacktestTrade mapResultSetToTrade(ResultSet rs) throws SQLException {\n        BacktestTrade trade = new BacktestTrade();\n        trade.setSymbol(rs.getString(\"symbol\"));\n        trade.setEntryPrice(rs.getDouble(\"entry_price\"));\n        trade.setExitPrice(rs.getDouble(\"exit_price\"));\n        trade.setQuantity(rs.getInt(\"quantity\"));\n        trade.setEntryTime(rs.getTimestamp(\"entry_time\").toLocalDateTime());\n        trade.setExitTime(rs.getTimestamp(\"exit_time\").toLocalDateTime());\n        trade.setProfitLoss(rs.getDouble(\"profit_loss\"));\n        trade.setProfitPct(rs.getDouble(\"profit_pct\"));\n        return trade;\n    }\n}\n","size_bytes":6908},"build/extracted-include-protos/test/google/protobuf/wrappers.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Wrappers for primitive (non-message) types. These types are useful\n// for embedding primitives in the `google.protobuf.Any` type and for places\n// where we need to distinguish between the absence of a primitive\n// typed field and its default value.\n//\n// These wrappers have no meaningful use within repeated fields as they lack\n// the ability to detect presence on individual elements.\n// These wrappers have no meaningful use within a map or a oneof since\n// individual entries of a map or fields of a oneof can already detect presence.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/protobuf/types/known/wrapperspb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"WrappersProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\n\n// Wrapper message for `double`.\n//\n// The JSON representation for `DoubleValue` is JSON number.\nmessage DoubleValue {\n  // The double value.\n  double value = 1;\n}\n\n// Wrapper message for `float`.\n//\n// The JSON representation for `FloatValue` is JSON number.\nmessage FloatValue {\n  // The float value.\n  float value = 1;\n}\n\n// Wrapper message for `int64`.\n//\n// The JSON representation for `Int64Value` is JSON string.\nmessage Int64Value {\n  // The int64 value.\n  int64 value = 1;\n}\n\n// Wrapper message for `uint64`.\n//\n// The JSON representation for `UInt64Value` is JSON string.\nmessage UInt64Value {\n  // The uint64 value.\n  uint64 value = 1;\n}\n\n// Wrapper message for `int32`.\n//\n// The JSON representation for `Int32Value` is JSON number.\nmessage Int32Value {\n  // The int32 value.\n  int32 value = 1;\n}\n\n// Wrapper message for `uint32`.\n//\n// The JSON representation for `UInt32Value` is JSON number.\nmessage UInt32Value {\n  // The uint32 value.\n  uint32 value = 1;\n}\n\n// Wrapper message for `bool`.\n//\n// The JSON representation for `BoolValue` is JSON `true` and `false`.\nmessage BoolValue {\n  // The bool value.\n  bool value = 1;\n}\n\n// Wrapper message for `string`.\n//\n// The JSON representation for `StringValue` is JSON string.\nmessage StringValue {\n  // The string value.\n  string value = 1;\n}\n\n// Wrapper message for `bytes`.\n//\n// The JSON representation for `BytesValue` is JSON string.\nmessage BytesValue {\n  // The bytes value.\n  bytes value = 1;\n}\n","size_bytes":4044},"src/main/java/com/spiketrade/config/DatabaseConfig.java":{"content":"package com.spiketrade.config;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.sql.DataSource;\n\npublic class DatabaseConfig {\n    private static final Logger logger = LoggerFactory.getLogger(DatabaseConfig.class);\n    private static HikariDataSource dataSource;\n    \n    public static DataSource getDataSource() {\n        if (dataSource == null) {\n            synchronized (DatabaseConfig.class) {\n                if (dataSource == null) {\n                    dataSource = createDataSource();\n                }\n            }\n        }\n        return dataSource;\n    }\n    \n    private static HikariDataSource createDataSource() {\n        String jdbcUrl = System.getenv(\"DATABASE_URL\");\n        if (jdbcUrl == null || jdbcUrl.isEmpty()) {\n            jdbcUrl = \"jdbc:postgresql://localhost:5432/spiketrade\";\n            logger.warn(\"DATABASE_URL not set, using default: {}\", jdbcUrl);\n        }\n        \n        HikariConfig config = new HikariConfig();\n        config.setJdbcUrl(jdbcUrl);\n        config.setUsername(System.getenv().getOrDefault(\"PGUSER\", \"postgres\"));\n        config.setPassword(System.getenv().getOrDefault(\"PGPASSWORD\", \"\"));\n        config.setMaximumPoolSize(10);\n        config.setMinimumIdle(2);\n        config.setConnectionTimeout(30000);\n        config.setIdleTimeout(600000);\n        config.setMaxLifetime(1800000);\n        config.setAutoCommit(true);\n        config.addDataSourceProperty(\"cachePrepStmts\", \"true\");\n        config.addDataSourceProperty(\"prepStmtCacheSize\", \"250\");\n        config.addDataSourceProperty(\"prepStmtCacheSqlLimit\", \"2048\");\n        \n        logger.info(\"Initializing database connection pool\");\n        return new HikariDataSource(config);\n    }\n    \n    public static void shutdown() {\n        if (dataSource != null) {\n            dataSource.close();\n            logger.info(\"Database connection pool closed\");\n        }\n    }\n}\n","size_bytes":1991},"src/main/java/com/spiketrade/backend/SellWarning.java":{"content":"package com.spiketrade.backend;\n\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SellWarning {\n    public Instant timestamp;\n    public String symbol;\n    public double price;\n    public double warningProbability;\n    public IndicatorsData indicators;\n    public List<SpikeRecord> spikes;\n    public String reason;\n    \n    public SellWarning() {\n        this.timestamp = Instant.now();\n        this.indicators = new IndicatorsData();\n        this.spikes = new ArrayList<>();\n        this.warningProbability = 0.0;\n        this.price = 0.0;\n    }\n}\n","size_bytes":592},"build/extracted-include-protos/test/google/protobuf/any.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption go_package = \"google.golang.org/protobuf/types/known/anypb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"AnyProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\n\n// `Any` contains an arbitrary serialized protocol buffer message along with a\n// URL that describes the type of the serialized message.\n//\n// Protobuf library provides support to pack/unpack Any values in the form\n// of utility functions or additional generated methods of the Any type.\n//\n// Example 1: Pack and unpack a message in C++.\n//\n//     Foo foo = ...;\n//     Any any;\n//     any.PackFrom(foo);\n//     ...\n//     if (any.UnpackTo(&foo)) {\n//       ...\n//     }\n//\n// Example 2: Pack and unpack a message in Java.\n//\n//     Foo foo = ...;\n//     Any any = Any.pack(foo);\n//     ...\n//     if (any.is(Foo.class)) {\n//       foo = any.unpack(Foo.class);\n//     }\n//     // or ...\n//     if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n//       foo = any.unpack(Foo.getDefaultInstance());\n//     }\n//\n//  Example 3: Pack and unpack a message in Python.\n//\n//     foo = Foo(...)\n//     any = Any()\n//     any.Pack(foo)\n//     ...\n//     if any.Is(Foo.DESCRIPTOR):\n//       any.Unpack(foo)\n//       ...\n//\n//  Example 4: Pack and unpack a message in Go\n//\n//      foo := &pb.Foo{...}\n//      any, err := anypb.New(foo)\n//      if err != nil {\n//        ...\n//      }\n//      ...\n//      foo := &pb.Foo{}\n//      if err := any.UnmarshalTo(foo); err != nil {\n//        ...\n//      }\n//\n// The pack methods provided by protobuf library will by default use\n// 'type.googleapis.com/full.type.name' as the type URL and the unpack\n// methods only use the fully qualified type name after the last '/'\n// in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n// name \"y.z\".\n//\n// JSON\n// ====\n// The JSON representation of an `Any` value uses the regular\n// representation of the deserialized, embedded message, with an\n// additional field `@type` which contains the type URL. Example:\n//\n//     package google.profile;\n//     message Person {\n//       string first_name = 1;\n//       string last_name = 2;\n//     }\n//\n//     {\n//       \"@type\": \"type.googleapis.com/google.profile.Person\",\n//       \"firstName\": <string>,\n//       \"lastName\": <string>\n//     }\n//\n// If the embedded message type is well-known and has a custom JSON\n// representation, that representation will be embedded adding a field\n// `value` which holds the custom JSON in addition to the `@type`\n// field. Example (for message [google.protobuf.Duration][]):\n//\n//     {\n//       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n//       \"value\": \"1.212s\"\n//     }\n//\nmessage Any {\n  // A URL/resource name that uniquely identifies the type of the serialized\n  // protocol buffer message. This string must contain at least\n  // one \"/\" character. The last segment of the URL's path must represent\n  // the fully qualified name of the type (as in\n  // `path/google.protobuf.Duration`). The name should be in a canonical form\n  // (e.g., leading \".\" is not accepted).\n  //\n  // In practice, teams usually precompile into the binary all types that they\n  // expect it to use in the context of Any. However, for URLs which use the\n  // scheme `http`, `https`, or no scheme, one can optionally set up a type\n  // server that maps type URLs to message definitions as follows:\n  //\n  // * If no scheme is provided, `https` is assumed.\n  // * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  //   value in binary format, or produce an error.\n  // * Applications are allowed to cache lookup results based on the\n  //   URL, or have them precompiled into a binary to avoid any\n  //   lookup. Therefore, binary compatibility needs to be preserved\n  //   on changes to types. (Use versioned type names to manage\n  //   breaking changes.)\n  //\n  // Note: this functionality is not currently available in the official\n  // protobuf release, and it is not used for type URLs beginning with\n  // type.googleapis.com. As of May 2023, there are no widely used type server\n  // implementations and no plans to implement one.\n  //\n  // Schemes other than `http`, `https` (or the empty scheme) might be\n  // used with implementation specific semantics.\n  //\n  string type_url = 1;\n\n  // Must be a valid serialized protocol buffer of the above specified type.\n  bytes value = 2;\n}\n","size_bytes":6154},"build/extracted-include-protos/test/google/api/http.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/api/annotations;annotations\";\noption java_multiple_files = true;\noption java_outer_classname = \"HttpProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Defines the HTTP configuration for an API service. It contains a list of\n// [HttpRule][google.api.HttpRule], each specifying the mapping of an RPC method\n// to one or more HTTP REST API methods.\nmessage Http {\n  // A list of HTTP configuration rules that apply to individual API methods.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated HttpRule rules = 1;\n\n  // When set to true, URL path parameters will be fully URI-decoded except in\n  // cases of single segment matches in reserved expansion, where \"%2F\" will be\n  // left encoded.\n  //\n  // The default behavior is to not decode RFC 6570 reserved characters in multi\n  // segment matches.\n  bool fully_decode_reserved_expansion = 2;\n}\n\n// # gRPC Transcoding\n//\n// gRPC Transcoding is a feature for mapping between a gRPC method and one or\n// more HTTP REST endpoints. It allows developers to build a single API service\n// that supports both gRPC APIs and REST APIs. Many systems, including [Google\n// APIs](https://github.com/googleapis/googleapis),\n// [Cloud Endpoints](https://cloud.google.com/endpoints), [gRPC\n// Gateway](https://github.com/grpc-ecosystem/grpc-gateway),\n// and [Envoy](https://github.com/envoyproxy/envoy) proxy support this feature\n// and use it for large scale production services.\n//\n// `HttpRule` defines the schema of the gRPC/REST mapping. The mapping specifies\n// how different portions of the gRPC request message are mapped to the URL\n// path, URL query parameters, and HTTP request body. It also controls how the\n// gRPC response message is mapped to the HTTP response body. `HttpRule` is\n// typically specified as an `google.api.http` annotation on the gRPC method.\n//\n// Each mapping specifies a URL path template and an HTTP method. The path\n// template may refer to one or more fields in the gRPC request message, as long\n// as each field is a non-repeated field with a primitive (non-message) type.\n// The path template controls how fields of the request message are mapped to\n// the URL path.\n//\n// Example:\n//\n//     service Messaging {\n//       rpc GetMessage(GetMessageRequest) returns (Message) {\n//         option (google.api.http) = {\n//             get: \"/v1/{name=messages/*}\"\n//         };\n//       }\n//     }\n//     message GetMessageRequest {\n//       string name = 1; // Mapped to URL path.\n//     }\n//     message Message {\n//       string text = 1; // The resource content.\n//     }\n//\n// This enables an HTTP REST to gRPC mapping as below:\n//\n// HTTP | gRPC\n// -----|-----\n// `GET /v1/messages/123456`  | `GetMessage(name: \"messages/123456\")`\n//\n// Any fields in the request message which are not bound by the path template\n// automatically become HTTP query parameters if there is no HTTP request body.\n// For example:\n//\n//     service Messaging {\n//       rpc GetMessage(GetMessageRequest) returns (Message) {\n//         option (google.api.http) = {\n//             get:\"/v1/messages/{message_id}\"\n//         };\n//       }\n//     }\n//     message GetMessageRequest {\n//       message SubMessage {\n//         string subfield = 1;\n//       }\n//       string message_id = 1; // Mapped to URL path.\n//       int64 revision = 2;    // Mapped to URL query parameter `revision`.\n//       SubMessage sub = 3;    // Mapped to URL query parameter `sub.subfield`.\n//     }\n//\n// This enables a HTTP JSON to RPC mapping as below:\n//\n// HTTP | gRPC\n// -----|-----\n// `GET /v1/messages/123456?revision=2&sub.subfield=foo` |\n// `GetMessage(message_id: \"123456\" revision: 2 sub: SubMessage(subfield:\n// \"foo\"))`\n//\n// Note that fields which are mapped to URL query parameters must have a\n// primitive type or a repeated primitive type or a non-repeated message type.\n// In the case of a repeated type, the parameter can be repeated in the URL\n// as `...?param=A&param=B`. In the case of a message type, each field of the\n// message is mapped to a separate parameter, such as\n// `...?foo.a=A&foo.b=B&foo.c=C`.\n//\n// For HTTP methods that allow a request body, the `body` field\n// specifies the mapping. Consider a REST update method on the\n// message resource collection:\n//\n//     service Messaging {\n//       rpc UpdateMessage(UpdateMessageRequest) returns (Message) {\n//         option (google.api.http) = {\n//           patch: \"/v1/messages/{message_id}\"\n//           body: \"message\"\n//         };\n//       }\n//     }\n//     message UpdateMessageRequest {\n//       string message_id = 1; // mapped to the URL\n//       Message message = 2;   // mapped to the body\n//     }\n//\n// The following HTTP JSON to RPC mapping is enabled, where the\n// representation of the JSON in the request body is determined by\n// protos JSON encoding:\n//\n// HTTP | gRPC\n// -----|-----\n// `PATCH /v1/messages/123456 { \"text\": \"Hi!\" }` | `UpdateMessage(message_id:\n// \"123456\" message { text: \"Hi!\" })`\n//\n// The special name `*` can be used in the body mapping to define that\n// every field not bound by the path template should be mapped to the\n// request body.  This enables the following alternative definition of\n// the update method:\n//\n//     service Messaging {\n//       rpc UpdateMessage(Message) returns (Message) {\n//         option (google.api.http) = {\n//           patch: \"/v1/messages/{message_id}\"\n//           body: \"*\"\n//         };\n//       }\n//     }\n//     message Message {\n//       string message_id = 1;\n//       string text = 2;\n//     }\n//\n//\n// The following HTTP JSON to RPC mapping is enabled:\n//\n// HTTP | gRPC\n// -----|-----\n// `PATCH /v1/messages/123456 { \"text\": \"Hi!\" }` | `UpdateMessage(message_id:\n// \"123456\" text: \"Hi!\")`\n//\n// Note that when using `*` in the body mapping, it is not possible to\n// have HTTP parameters, as all fields not bound by the path end in\n// the body. This makes this option more rarely used in practice when\n// defining REST APIs. The common usage of `*` is in custom methods\n// which don't use the URL at all for transferring data.\n//\n// It is possible to define multiple HTTP methods for one RPC by using\n// the `additional_bindings` option. Example:\n//\n//     service Messaging {\n//       rpc GetMessage(GetMessageRequest) returns (Message) {\n//         option (google.api.http) = {\n//           get: \"/v1/messages/{message_id}\"\n//           additional_bindings {\n//             get: \"/v1/users/{user_id}/messages/{message_id}\"\n//           }\n//         };\n//       }\n//     }\n//     message GetMessageRequest {\n//       string message_id = 1;\n//       string user_id = 2;\n//     }\n//\n// This enables the following two alternative HTTP JSON to RPC mappings:\n//\n// HTTP | gRPC\n// -----|-----\n// `GET /v1/messages/123456` | `GetMessage(message_id: \"123456\")`\n// `GET /v1/users/me/messages/123456` | `GetMessage(user_id: \"me\" message_id:\n// \"123456\")`\n//\n// ## Rules for HTTP mapping\n//\n// 1. Leaf request fields (recursive expansion nested messages in the request\n//    message) are classified into three categories:\n//    - Fields referred by the path template. They are passed via the URL path.\n//    - Fields referred by the [HttpRule.body][google.api.HttpRule.body]. They\n//    are passed via the HTTP\n//      request body.\n//    - All other fields are passed via the URL query parameters, and the\n//      parameter name is the field path in the request message. A repeated\n//      field can be represented as multiple query parameters under the same\n//      name.\n//  2. If [HttpRule.body][google.api.HttpRule.body] is \"*\", there is no URL\n//  query parameter, all fields\n//     are passed via URL path and HTTP request body.\n//  3. If [HttpRule.body][google.api.HttpRule.body] is omitted, there is no HTTP\n//  request body, all\n//     fields are passed via URL path and URL query parameters.\n//\n// ### Path template syntax\n//\n//     Template = \"/\" Segments [ Verb ] ;\n//     Segments = Segment { \"/\" Segment } ;\n//     Segment  = \"*\" | \"**\" | LITERAL | Variable ;\n//     Variable = \"{\" FieldPath [ \"=\" Segments ] \"}\" ;\n//     FieldPath = IDENT { \".\" IDENT } ;\n//     Verb     = \":\" LITERAL ;\n//\n// The syntax `*` matches a single URL path segment. The syntax `**` matches\n// zero or more URL path segments, which must be the last part of the URL path\n// except the `Verb`.\n//\n// The syntax `Variable` matches part of the URL path as specified by its\n// template. A variable template must not contain other variables. If a variable\n// matches a single path segment, its template may be omitted, e.g. `{var}`\n// is equivalent to `{var=*}`.\n//\n// The syntax `LITERAL` matches literal text in the URL path. If the `LITERAL`\n// contains any reserved character, such characters should be percent-encoded\n// before the matching.\n//\n// If a variable contains exactly one path segment, such as `\"{var}\"` or\n// `\"{var=*}\"`, when such a variable is expanded into a URL path on the client\n// side, all characters except `[-_.~0-9a-zA-Z]` are percent-encoded. The\n// server side does the reverse decoding. Such variables show up in the\n// [Discovery\n// Document](https://developers.google.com/discovery/v1/reference/apis) as\n// `{var}`.\n//\n// If a variable contains multiple path segments, such as `\"{var=foo/*}\"`\n// or `\"{var=**}\"`, when such a variable is expanded into a URL path on the\n// client side, all characters except `[-_.~/0-9a-zA-Z]` are percent-encoded.\n// The server side does the reverse decoding, except \"%2F\" and \"%2f\" are left\n// unchanged. Such variables show up in the\n// [Discovery\n// Document](https://developers.google.com/discovery/v1/reference/apis) as\n// `{+var}`.\n//\n// ## Using gRPC API Service Configuration\n//\n// gRPC API Service Configuration (service config) is a configuration language\n// for configuring a gRPC service to become a user-facing product. The\n// service config is simply the YAML representation of the `google.api.Service`\n// proto message.\n//\n// As an alternative to annotating your proto file, you can configure gRPC\n// transcoding in your service config YAML files. You do this by specifying a\n// `HttpRule` that maps the gRPC method to a REST endpoint, achieving the same\n// effect as the proto annotation. This can be particularly useful if you\n// have a proto that is reused in multiple services. Note that any transcoding\n// specified in the service config will override any matching transcoding\n// configuration in the proto.\n//\n// Example:\n//\n//     http:\n//       rules:\n//         # Selects a gRPC method and applies HttpRule to it.\n//         - selector: example.v1.Messaging.GetMessage\n//           get: /v1/messages/{message_id}/{sub.subfield}\n//\n// ## Special notes\n//\n// When gRPC Transcoding is used to map a gRPC to JSON REST endpoints, the\n// proto to JSON conversion must follow the [proto3\n// specification](https://developers.google.com/protocol-buffers/docs/proto3#json).\n//\n// While the single segment variable follows the semantics of\n// [RFC 6570](https://tools.ietf.org/html/rfc6570) Section 3.2.2 Simple String\n// Expansion, the multi segment variable **does not** follow RFC 6570 Section\n// 3.2.3 Reserved Expansion. The reason is that the Reserved Expansion\n// does not expand special characters like `?` and `#`, which would lead\n// to invalid URLs. As the result, gRPC Transcoding uses a custom encoding\n// for multi segment variables.\n//\n// The path variables **must not** refer to any repeated or mapped field,\n// because client libraries are not capable of handling such variable expansion.\n//\n// The path variables **must not** capture the leading \"/\" character. The reason\n// is that the most common use case \"{var}\" does not capture the leading \"/\"\n// character. For consistency, all path variables must share the same behavior.\n//\n// Repeated message fields must not be mapped to URL query parameters, because\n// no client library can support such complicated mapping.\n//\n// If an API needs to use a JSON array for request or response body, it can map\n// the request or response body to a repeated field. However, some gRPC\n// Transcoding implementations may not support this feature.\nmessage HttpRule {\n  // Selects a method to which this rule applies.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // Determines the URL pattern is matched by this rules. This pattern can be\n  // used with any of the {get|put|post|delete|patch} methods. A custom method\n  // can be defined using the 'custom' field.\n  oneof pattern {\n    // Maps to HTTP GET. Used for listing and getting information about\n    // resources.\n    string get = 2;\n\n    // Maps to HTTP PUT. Used for replacing a resource.\n    string put = 3;\n\n    // Maps to HTTP POST. Used for creating a resource or performing an action.\n    string post = 4;\n\n    // Maps to HTTP DELETE. Used for deleting a resource.\n    string delete = 5;\n\n    // Maps to HTTP PATCH. Used for updating a resource.\n    string patch = 6;\n\n    // The custom pattern is used for specifying an HTTP method that is not\n    // included in the `pattern` field, such as HEAD, or \"*\" to leave the\n    // HTTP method unspecified for this rule. The wild-card rule is useful\n    // for services that provide content to Web (HTML) clients.\n    CustomHttpPattern custom = 8;\n  }\n\n  // The name of the request field whose value is mapped to the HTTP request\n  // body, or `*` for mapping all request fields not captured by the path\n  // pattern to the HTTP body, or omitted for not having any HTTP request body.\n  //\n  // NOTE: the referred field must be present at the top-level of the request\n  // message type.\n  string body = 7;\n\n  // Optional. The name of the response field whose value is mapped to the HTTP\n  // response body. When omitted, the entire response message will be used\n  // as the HTTP response body.\n  //\n  // NOTE: The referred field must be present at the top-level of the response\n  // message type.\n  string response_body = 12;\n\n  // Additional HTTP bindings for the selector. Nested bindings must\n  // not contain an `additional_bindings` field themselves (that is,\n  // the nesting may only be one level deep).\n  repeated HttpRule additional_bindings = 11;\n}\n\n// A custom pattern is used for defining custom HTTP verb.\nmessage CustomHttpPattern {\n  // The name of this custom HTTP verb.\n  string kind = 1;\n\n  // The path matched by this custom verb.\n  string path = 2;\n}\n","size_bytes":15159},"build/extracted-include-protos/test/google/type/expr.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption go_package = \"google.golang.org/genproto/googleapis/type/expr;expr\";\noption java_multiple_files = true;\noption java_outer_classname = \"ExprProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a textual expression in the Common Expression Language (CEL)\n// syntax. CEL is a C-like expression language. The syntax and semantics of CEL\n// are documented at https://github.com/google/cel-spec.\n//\n// Example (Comparison):\n//\n//     title: \"Summary size limit\"\n//     description: \"Determines if a summary is less than 100 chars\"\n//     expression: \"document.summary.size() < 100\"\n//\n// Example (Equality):\n//\n//     title: \"Requestor is owner\"\n//     description: \"Determines if requestor is the document owner\"\n//     expression: \"document.owner == request.auth.claims.email\"\n//\n// Example (Logic):\n//\n//     title: \"Public documents\"\n//     description: \"Determine whether the document should be publicly visible\"\n//     expression: \"document.type != 'private' && document.type != 'internal'\"\n//\n// Example (Data Manipulation):\n//\n//     title: \"Notification string\"\n//     description: \"Create a notification string with a timestamp.\"\n//     expression: \"'New message received at ' + string(document.create_time)\"\n//\n// The exact variables and functions that may be referenced within an expression\n// are determined by the service that evaluates it. See the service\n// documentation for additional information.\nmessage Expr {\n  // Textual representation of an expression in Common Expression Language\n  // syntax.\n  string expression = 1;\n\n  // Optional. Title for the expression, i.e. a short string describing\n  // its purpose. This can be used e.g. in UIs which allow to enter the\n  // expression.\n  string title = 2;\n\n  // Optional. Description of the expression. This is a longer text which\n  // describes the expression, e.g. when hovered over it in a UI.\n  string description = 3;\n\n  // Optional. String indicating the location of the expression for error\n  // reporting, e.g. a file name and a position in the file.\n  string location = 4;\n}\n","size_bytes":2730},"build/extracted-include-protos/test/google/logging/type/http_request.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.logging.type;\n\nimport \"google/protobuf/duration.proto\";\n\noption csharp_namespace = \"Google.Cloud.Logging.Type\";\noption go_package = \"google.golang.org/genproto/googleapis/logging/type;ltype\";\noption java_multiple_files = true;\noption java_outer_classname = \"HttpRequestProto\";\noption java_package = \"com.google.logging.type\";\noption php_namespace = \"Google\\\\Cloud\\\\Logging\\\\Type\";\noption ruby_package = \"Google::Cloud::Logging::Type\";\n\n// A common proto for logging HTTP requests. Only contains semantics\n// defined by the HTTP specification. Product-specific logging\n// information MUST be defined in a separate message.\nmessage HttpRequest {\n  // The request method. Examples: `\"GET\"`, `\"HEAD\"`, `\"PUT\"`, `\"POST\"`.\n  string request_method = 1;\n\n  // The scheme (http, https), the host name, the path and the query\n  // portion of the URL that was requested.\n  // Example: `\"http://example.com/some/info?color=red\"`.\n  string request_url = 2;\n\n  // The size of the HTTP request message in bytes, including the request\n  // headers and the request body.\n  int64 request_size = 3;\n\n  // The response code indicating the status of response.\n  // Examples: 200, 404.\n  int32 status = 4;\n\n  // The size of the HTTP response message sent back to the client, in bytes,\n  // including the response headers and the response body.\n  int64 response_size = 5;\n\n  // The user agent sent by the client. Example:\n  // `\"Mozilla/4.0 (compatible; MSIE 6.0; Windows 98; Q312461; .NET\n  // CLR 1.0.3705)\"`.\n  string user_agent = 6;\n\n  // The IP address (IPv4 or IPv6) of the client that issued the HTTP\n  // request. This field can include port information. Examples:\n  // `\"192.168.1.1\"`, `\"10.0.0.1:80\"`, `\"FE80::0202:B3FF:FE1E:8329\"`.\n  string remote_ip = 7;\n\n  // The IP address (IPv4 or IPv6) of the origin server that the request was\n  // sent to. This field can include port information. Examples:\n  // `\"192.168.1.1\"`, `\"10.0.0.1:80\"`, `\"FE80::0202:B3FF:FE1E:8329\"`.\n  string server_ip = 13;\n\n  // The referer URL of the request, as defined in\n  // [HTTP/1.1 Header Field\n  // Definitions](https://datatracker.ietf.org/doc/html/rfc2616#section-14.36).\n  string referer = 8;\n\n  // The request processing latency on the server, from the time the request was\n  // received until the response was sent.\n  google.protobuf.Duration latency = 14;\n\n  // Whether or not a cache lookup was attempted.\n  bool cache_lookup = 11;\n\n  // Whether or not an entity was served from cache\n  // (with or without validation).\n  bool cache_hit = 9;\n\n  // Whether or not the response was validated with the origin server before\n  // being served from cache. This field is only meaningful if `cache_hit` is\n  // True.\n  bool cache_validated_with_origin_server = 10;\n\n  // The number of HTTP response bytes inserted into cache. Set only when a\n  // cache fill was attempted.\n  int64 cache_fill_bytes = 12;\n\n  // Protocol used for the request. Examples: \"HTTP/1.1\", \"HTTP/2\", \"websocket\"\n  string protocol = 15;\n}\n","size_bytes":3601},"build/extracted-include-protos/test/google/api/backend.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"BackendProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Backend` defines the backend configuration for a service.\nmessage Backend {\n  // A list of API backend rules that apply to individual API methods.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated BackendRule rules = 1;\n}\n\n// A backend rule provides configuration for an individual API element.\nmessage BackendRule {\n  // Path Translation specifies how to combine the backend address with the\n  // request path in order to produce the appropriate forwarding URL for the\n  // request.\n  //\n  // Path Translation is applicable only to HTTP-based backends. Backends which\n  // do not accept requests over HTTP/HTTPS should leave `path_translation`\n  // unspecified.\n  enum PathTranslation {\n    PATH_TRANSLATION_UNSPECIFIED = 0;\n\n    // Use the backend address as-is, with no modification to the path. If the\n    // URL pattern contains variables, the variable names and values will be\n    // appended to the query string. If a query string parameter and a URL\n    // pattern variable have the same name, this may result in duplicate keys in\n    // the query string.\n    //\n    // # Examples\n    //\n    // Given the following operation config:\n    //\n    //     Method path:        /api/company/{cid}/user/{uid}\n    //     Backend address:    https://example.cloudfunctions.net/getUser\n    //\n    // Requests to the following request paths will call the backend at the\n    // translated path:\n    //\n    //     Request path: /api/company/widgetworks/user/johndoe\n    //     Translated:\n    //     https://example.cloudfunctions.net/getUser?cid=widgetworks&uid=johndoe\n    //\n    //     Request path: /api/company/widgetworks/user/johndoe?timezone=EST\n    //     Translated:\n    //     https://example.cloudfunctions.net/getUser?timezone=EST&cid=widgetworks&uid=johndoe\n    CONSTANT_ADDRESS = 1;\n\n    // The request path will be appended to the backend address.\n    //\n    // # Examples\n    //\n    // Given the following operation config:\n    //\n    //     Method path:        /api/company/{cid}/user/{uid}\n    //     Backend address:    https://example.appspot.com\n    //\n    // Requests to the following request paths will call the backend at the\n    // translated path:\n    //\n    //     Request path: /api/company/widgetworks/user/johndoe\n    //     Translated:\n    //     https://example.appspot.com/api/company/widgetworks/user/johndoe\n    //\n    //     Request path: /api/company/widgetworks/user/johndoe?timezone=EST\n    //     Translated:\n    //     https://example.appspot.com/api/company/widgetworks/user/johndoe?timezone=EST\n    APPEND_PATH_TO_ADDRESS = 2;\n  }\n\n  // Selects the methods to which this rule applies.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // The address of the API backend.\n  //\n  // The scheme is used to determine the backend protocol and security.\n  // The following schemes are accepted:\n  //\n  //    SCHEME        PROTOCOL    SECURITY\n  //    http://       HTTP        None\n  //    https://      HTTP        TLS\n  //    grpc://       gRPC        None\n  //    grpcs://      gRPC        TLS\n  //\n  // It is recommended to explicitly include a scheme. Leaving out the scheme\n  // may cause constrasting behaviors across platforms.\n  //\n  // If the port is unspecified, the default is:\n  // - 80 for schemes without TLS\n  // - 443 for schemes with TLS\n  //\n  // For HTTP backends, use [protocol][google.api.BackendRule.protocol]\n  // to specify the protocol version.\n  string address = 2;\n\n  // The number of seconds to wait for a response from a request. The default\n  // varies based on the request protocol and deployment environment.\n  double deadline = 3;\n\n  // Deprecated, do not use.\n  double min_deadline = 4 [deprecated = true];\n\n  // The number of seconds to wait for the completion of a long running\n  // operation. The default is no deadline.\n  double operation_deadline = 5;\n\n  PathTranslation path_translation = 6;\n\n  // Authentication settings used by the backend.\n  //\n  // These are typically used to provide service management functionality to\n  // a backend served on a publicly-routable URL. The `authentication`\n  // details should match the authentication behavior used by the backend.\n  //\n  // For example, specifying `jwt_audience` implies that the backend expects\n  // authentication via a JWT.\n  //\n  // When authentication is unspecified, the resulting behavior is the same\n  // as `disable_auth` set to `true`.\n  //\n  // Refer to https://developers.google.com/identity/protocols/OpenIDConnect for\n  // JWT ID token.\n  oneof authentication {\n    // The JWT audience is used when generating a JWT ID token for the backend.\n    // This ID token will be added in the HTTP \"authorization\" header, and sent\n    // to the backend.\n    string jwt_audience = 7;\n\n    // When disable_auth is true, a JWT ID token won't be generated and the\n    // original \"Authorization\" HTTP header will be preserved. If the header is\n    // used to carry the original token and is expected by the backend, this\n    // field must be set to true to preserve the header.\n    bool disable_auth = 8;\n  }\n\n  // The protocol used for sending a request to the backend.\n  // The supported values are \"http/1.1\" and \"h2\".\n  //\n  // The default value is inferred from the scheme in the\n  // [address][google.api.BackendRule.address] field:\n  //\n  //    SCHEME        PROTOCOL\n  //    http://       http/1.1\n  //    https://      http/1.1\n  //    grpc://       h2\n  //    grpcs://      h2\n  //\n  // For secure HTTP backends (https://) that support HTTP/2, set this field\n  // to \"h2\" for improved performance.\n  //\n  // Configuring this field to non-default values is only supported for secure\n  // HTTP backends. This field will be ignored for all other backends.\n  //\n  // See\n  // https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids\n  // for more details on the supported values.\n  string protocol = 9;\n\n  // The map between request protocol and the backend address.\n  map<string, BackendRule> overrides_by_request_protocol = 10;\n}\n","size_bytes":7014},"build/extracted-include-protos/test/google/api/service.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/api/auth.proto\";\nimport \"google/api/backend.proto\";\nimport \"google/api/billing.proto\";\nimport \"google/api/client.proto\";\nimport \"google/api/context.proto\";\nimport \"google/api/control.proto\";\nimport \"google/api/documentation.proto\";\nimport \"google/api/endpoint.proto\";\nimport \"google/api/http.proto\";\nimport \"google/api/log.proto\";\nimport \"google/api/logging.proto\";\nimport \"google/api/metric.proto\";\nimport \"google/api/monitored_resource.proto\";\nimport \"google/api/monitoring.proto\";\nimport \"google/api/quota.proto\";\nimport \"google/api/source_info.proto\";\nimport \"google/api/system_parameter.proto\";\nimport \"google/api/usage.proto\";\nimport \"google/protobuf/api.proto\";\nimport \"google/protobuf/type.proto\";\nimport \"google/protobuf/wrappers.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"ServiceProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Service` is the root object of Google API service configuration (service\n// config). It describes the basic information about a logical service,\n// such as the service name and the user-facing title, and delegates other\n// aspects to sub-sections. Each sub-section is either a proto message or a\n// repeated proto message that configures a specific aspect, such as auth.\n// For more information, see each proto message definition.\n//\n// Example:\n//\n//     type: google.api.Service\n//     name: calendar.googleapis.com\n//     title: Google Calendar API\n//     apis:\n//     - name: google.calendar.v3.Calendar\n//\n//     visibility:\n//       rules:\n//       - selector: \"google.calendar.v3.*\"\n//         restriction: PREVIEW\n//     backend:\n//       rules:\n//       - selector: \"google.calendar.v3.*\"\n//         address: calendar.example.com\n//\n//     authentication:\n//       providers:\n//       - id: google_calendar_auth\n//         jwks_uri: https://www.googleapis.com/oauth2/v1/certs\n//         issuer: https://securetoken.google.com\n//       rules:\n//       - selector: \"*\"\n//         requirements:\n//           provider_id: google_calendar_auth\nmessage Service {\n  // The service name, which is a DNS-like logical identifier for the\n  // service, such as `calendar.googleapis.com`. The service name\n  // typically goes through DNS verification to make sure the owner\n  // of the service also owns the DNS name.\n  string name = 1;\n\n  // The product title for this service, it is the name displayed in Google\n  // Cloud Console.\n  string title = 2;\n\n  // The Google project that owns this service.\n  string producer_project_id = 22;\n\n  // A unique ID for a specific instance of this message, typically assigned\n  // by the client for tracking purpose. Must be no longer than 63 characters\n  // and only lower case letters, digits, '.', '_' and '-' are allowed. If\n  // empty, the server may choose to generate one instead.\n  string id = 33;\n\n  // A list of API interfaces exported by this service. Only the `name` field\n  // of the [google.protobuf.Api][google.protobuf.Api] needs to be provided by\n  // the configuration author, as the remaining fields will be derived from the\n  // IDL during the normalization process. It is an error to specify an API\n  // interface here which cannot be resolved against the associated IDL files.\n  repeated google.protobuf.Api apis = 3;\n\n  // A list of all proto message types included in this API service.\n  // Types referenced directly or indirectly by the `apis` are automatically\n  // included.  Messages which are not referenced but shall be included, such as\n  // types used by the `google.protobuf.Any` type, should be listed here by\n  // name by the configuration author. Example:\n  //\n  //     types:\n  //     - name: google.protobuf.Int32\n  repeated google.protobuf.Type types = 4;\n\n  // A list of all enum types included in this API service.  Enums referenced\n  // directly or indirectly by the `apis` are automatically included.  Enums\n  // which are not referenced but shall be included should be listed here by\n  // name by the configuration author. Example:\n  //\n  //     enums:\n  //     - name: google.someapi.v1.SomeEnum\n  repeated google.protobuf.Enum enums = 5;\n\n  // Additional API documentation.\n  Documentation documentation = 6;\n\n  // API backend configuration.\n  Backend backend = 8;\n\n  // HTTP configuration.\n  Http http = 9;\n\n  // Quota configuration.\n  Quota quota = 10;\n\n  // Auth configuration.\n  Authentication authentication = 11;\n\n  // Context configuration.\n  Context context = 12;\n\n  // Configuration controlling usage of this service.\n  Usage usage = 15;\n\n  // Configuration for network endpoints.  If this is empty, then an endpoint\n  // with the same name as the service is automatically generated to service all\n  // defined APIs.\n  repeated Endpoint endpoints = 18;\n\n  // Configuration for the service control plane.\n  Control control = 21;\n\n  // Defines the logs used by this service.\n  repeated LogDescriptor logs = 23;\n\n  // Defines the metrics used by this service.\n  repeated MetricDescriptor metrics = 24;\n\n  // Defines the monitored resources used by this service. This is required\n  // by the [Service.monitoring][google.api.Service.monitoring] and\n  // [Service.logging][google.api.Service.logging] configurations.\n  repeated MonitoredResourceDescriptor monitored_resources = 25;\n\n  // Billing configuration.\n  Billing billing = 26;\n\n  // Logging configuration.\n  Logging logging = 27;\n\n  // Monitoring configuration.\n  Monitoring monitoring = 28;\n\n  // System parameter configuration.\n  SystemParameters system_parameters = 29;\n\n  // Output only. The source information for this configuration if available.\n  SourceInfo source_info = 37;\n\n  // Settings for [Google Cloud Client\n  // libraries](https://cloud.google.com/apis/docs/cloud-client-libraries)\n  // generated from APIs defined as protocol buffers.\n  Publishing publishing = 45;\n\n  // Obsolete. Do not use.\n  //\n  // This field has no semantic meaning. The service config compiler always\n  // sets this field to `3`.\n  google.protobuf.UInt32Value config_version = 20;\n}\n","size_bytes":6762},"build/extracted-include-protos/main/google/api/consumer.proto":{"content":"// Copyright 2016 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"ConsumerProto\";\noption java_package = \"com.google.api\";\n\n// A descriptor for defining project properties for a service. One service may\n// have many consumer projects, and the service may want to behave differently\n// depending on some properties on the project. For example, a project may be\n// associated with a school, or a business, or a government agency, a business\n// type property on the project may affect how a service responds to the client.\n// This descriptor defines which properties are allowed to be set on a project.\n//\n// Example:\n//\n//    project_properties:\n//      properties:\n//      - name: NO_WATERMARK\n//        type: BOOL\n//        description: Allows usage of the API without watermarks.\n//      - name: EXTENDED_TILE_CACHE_PERIOD\n//        type: INT64\nmessage ProjectProperties {\n  // List of per consumer project-specific properties.\n  repeated Property properties = 1;\n}\n\n// Defines project properties.\n//\n// API services can define properties that can be assigned to consumer projects\n// so that backends can perform response customization without having to make\n// additional calls or maintain additional storage. For example, Maps API\n// defines properties that controls map tile cache period, or whether to embed a\n// watermark in a result.\n//\n// These values can be set via API producer console. Only API providers can\n// define and set these properties.\nmessage Property {\n  // Supported data type of the property values\n  enum PropertyType {\n    // The type is unspecified, and will result in an error.\n    UNSPECIFIED = 0;\n\n    // The type is `int64`.\n    INT64 = 1;\n\n    // The type is `bool`.\n    BOOL = 2;\n\n    // The type is `string`.\n    STRING = 3;\n\n    // The type is 'double'.\n    DOUBLE = 4;\n  }\n\n  // The name of the property (a.k.a key).\n  string name = 1;\n\n  // The type of this property.\n  PropertyType type = 2;\n\n  // The description of the property\n  string description = 3;\n}\n","size_bytes":2717},"build/extracted-include-protos/test/google/type/interval.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\nimport \"google/protobuf/timestamp.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/interval;interval\";\noption java_multiple_files = true;\noption java_outer_classname = \"IntervalProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a time interval, encoded as a Timestamp start (inclusive) and a\n// Timestamp end (exclusive).\n//\n// The start must be less than or equal to the end.\n// When the start equals the end, the interval is empty (matches no time).\n// When both start and end are unspecified, the interval matches any time.\nmessage Interval {\n  // Optional. Inclusive start of the interval.\n  //\n  // If specified, a Timestamp matching this interval will have to be the same\n  // or after the start.\n  google.protobuf.Timestamp start_time = 1;\n\n  // Optional. Exclusive end of the interval.\n  //\n  // If specified, a Timestamp matching this interval will have to be before the\n  // end.\n  google.protobuf.Timestamp end_time = 2;\n}\n","size_bytes":1667},"src/main/java/com/spiketrade/service/NotificationService.java":{"content":"package com.spiketrade.service;\n\nimport javafx.application.Platform;\nimport javafx.scene.control.Alert;\nimport javax.swing.SwingUtilities;\nimport java.awt.*;\nimport java.awt.TrayIcon.MessageType;\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class NotificationService {\n    \n    private TrayIcon trayIcon;\n    private boolean systemTrayAvailable = false;\n    private boolean useModalFallback = false;\n    private boolean windowsToastAvailable = false;\n    private String powershellScriptPath = null;\n    private ExecutorService notificationExecutor;\n    \n    // Configuration file path\n    private static final String CONFIG_FILE_NAME = \"notification-config.properties\";\n    private static final String DEFAULT_CONFIG_PATH = \"config/\" + CONFIG_FILE_NAME;\n    \n    // Email configuration\n    private String emailSender = null;\n    private String emailPassword = null;\n    private String emailRecipient = null;\n    private boolean emailConfigured = false;\n    \n    // SMS configuration\n    private String twilioAccountSid = null;\n    private String twilioAuthToken = null;\n    private String twilioFromNumber = null;\n    private String twilioToNumber = null;\n    private boolean smsConfigured = false;\n    \n    public NotificationService() {\n        notificationExecutor = Executors.newSingleThreadExecutor(r -> {\n            Thread t = new Thread(r, \"NotificationService-Thread\");\n            t.setDaemon(true);\n            return t;\n        });\n    }\n    \n    public void initialize() {\n        // Load configuration from properties file\n        loadConfigurationFromFile();\n        \n        // First, check for Windows Toast notification support (PowerShell-based, like Python's win10toast)\n        detectWindowsToastSupport();\n        \n        // CRITICAL FIX: SystemTray MUST be initialized on AWT Event Dispatch Thread, NOT JavaFX thread!\n        SwingUtilities.invokeLater(() -> {\n            System.out.println(\" Initializing notification system...\");\n            \n            if (windowsToastAvailable) {\n                System.out.println(\" Windows Toast notifications available (PowerShell-based)\");\n                System.out.println(\"    Modern Windows 10/11 toast notifications will be used\");\n            }\n            \n            if (!SystemTray.isSupported()) {\n                System.out.println(\" SystemTray not supported on this platform - using modal fallback\");\n                useModalFallback = true;\n                systemTrayAvailable = false;\n                return;\n            }\n            \n            try {\n                Image image = null;\n                \n                try {\n                    java.net.URL iconUrl = getClass().getResource(\"/icon.png\");\n                    if (iconUrl != null) {\n                        image = Toolkit.getDefaultToolkit().createImage(iconUrl);\n                        System.out.println(\" Loaded icon from /icon.png\");\n                    } else {\n                        System.out.println(\" Icon resource /icon.png not found - using default icon\");\n                        image = createDefaultIcon();\n                    }\n                } catch (Exception iconException) {\n                    System.err.println(\" Failed to load icon: \" + iconException.getMessage());\n                    image = createDefaultIcon();\n                }\n                \n                if (image == null) {\n                    image = createDefaultIcon();\n                }\n                \n                trayIcon = new TrayIcon(image, \"SpikeTrade Professional\");\n                trayIcon.setImageAutoSize(true);\n                trayIcon.setToolTip(\"SpikeTrade Professional\");\n                \n                SystemTray.getSystemTray().add(trayIcon);\n                systemTrayAvailable = true;\n                useModalFallback = false;\n                if (!windowsToastAvailable) {\n                    System.out.println(\" System Tray notifications active (balloon style)\");\n                } else {\n                    System.out.println(\" System Tray initialized as fallback for Toast notifications\");\n                }\n                \n            } catch (AWTException e) {\n                System.err.println(\" Failed to initialize system tray: \" + e.getMessage());\n                e.printStackTrace();\n                useModalFallback = true;\n                systemTrayAvailable = false;\n            } catch (HeadlessException e) {\n                System.err.println(\" Headless environment detected - using modal fallback\");\n                useModalFallback = true;\n                systemTrayAvailable = false;\n            } catch (Exception e) {\n                System.err.println(\" Unexpected error during system tray initialization: \" + e.getMessage());\n                e.printStackTrace();\n                useModalFallback = true;\n                systemTrayAvailable = false;\n            }\n        });\n    }\n    \n    /**\n     * Load configuration from properties file\n     * Looks for config file in:\n     * 1. Current directory\n     * 2. User home directory/.spiketrade/\n     * 3. config/ subdirectory\n     * 4. Resources folder\n     */\n    private void loadConfigurationFromFile() {\n        Properties props = new Properties();\n        Path configPath = null;\n        \n        // Try multiple locations for the config file\n        Path[] searchPaths = {\n            Paths.get(CONFIG_FILE_NAME),                                    // Current directory\n            Paths.get(System.getProperty(\"user.home\"), \".spiketrade\", CONFIG_FILE_NAME), // User home\n            Paths.get(DEFAULT_CONFIG_PATH),                                 // config subdirectory\n            Paths.get(\"src/main/resources\", CONFIG_FILE_NAME)              // Resources (development)\n        };\n        \n        // Find the first existing config file\n        for (Path path : searchPaths) {\n            if (Files.exists(path)) {\n                configPath = path;\n                break;\n            }\n        }\n        \n        if (configPath == null) {\n            // Try loading from classpath resources\n            try (InputStream resourceStream = getClass().getResourceAsStream(\"/\" + CONFIG_FILE_NAME)) {\n                if (resourceStream != null) {\n                    props.load(resourceStream);\n                    System.out.println(\" Configuration loaded from classpath resource\");\n                } else {\n                    System.out.println(\" No configuration file found. Creating template...\");\n                    createTemplateConfigFile();\n                    return;\n                }\n            } catch (IOException e) {\n                System.err.println(\" Failed to load configuration from resources: \" + e.getMessage());\n                createTemplateConfigFile();\n                return;\n            }\n        } else {\n            // Load from file system\n            try (InputStream input = Files.newInputStream(configPath)) {\n                props.load(input);\n                System.out.println(\" Configuration loaded from: \" + configPath.toAbsolutePath());\n            } catch (IOException e) {\n                System.err.println(\" Failed to load configuration file: \" + e.getMessage());\n                createTemplateConfigFile();\n                return;\n            }\n        }\n        \n        // Load email configuration\n        String emailUsername = props.getProperty(\"email.username\");\n        String emailPassword = props.getProperty(\"email.password\");\n        String emailRecipient = props.getProperty(\"email.recipient\");\n        \n        if (emailUsername != null && !emailUsername.trim().isEmpty() &&\n            emailPassword != null && !emailPassword.trim().isEmpty() &&\n            emailRecipient != null && !emailRecipient.trim().isEmpty()) {\n            \n            configureEmail(emailUsername.trim(), emailPassword.trim(), emailRecipient.trim());\n            System.out.println(\" Email configuration loaded from file\");\n            System.out.println(\"   Sender: \" + emailUsername);\n            System.out.println(\"   Recipient: \" + emailRecipient);\n        } else {\n            System.out.println(\" Email configuration incomplete or missing\");\n            System.out.println(\"   Required properties: email.username, email.password, email.recipient\");\n        }\n        \n        // Load SMS configuration\n        String smsAccountSid = props.getProperty(\"twilio.account.sid\");\n        String smsAuthToken = props.getProperty(\"twilio.auth.token\");\n        String smsFromNumber = props.getProperty(\"twilio.from.number\");\n        String smsToNumber = props.getProperty(\"twilio.to.number\");\n        \n        if (smsAccountSid != null && !smsAccountSid.trim().isEmpty() &&\n            smsAuthToken != null && !smsAuthToken.trim().isEmpty() &&\n            smsFromNumber != null && !smsFromNumber.trim().isEmpty() &&\n            smsToNumber != null && !smsToNumber.trim().isEmpty()) {\n            \n            configureSMS(smsAccountSid.trim(), smsAuthToken.trim(), \n                        smsFromNumber.trim(), smsToNumber.trim());\n            System.out.println(\" SMS configuration loaded from file\");\n            System.out.println(\"   From: \" + smsFromNumber);\n            System.out.println(\"   To: \" + smsToNumber);\n        } else {\n            System.out.println(\" SMS configuration incomplete or missing\");\n            System.out.println(\"   Required properties: twilio.account.sid, twilio.auth.token, twilio.from.number, twilio.to.number\");\n        }\n    }\n    /**\n     * Create a template configuration file with example values\n     */\n    private void createTemplateConfigFile() {\n        String template = \"\"\"\n            # SpikeTrade Notification Configuration\n            # =====================================\n            # This file contains configuration for email and SMS notifications.\n            # Fill in your credentials below to enable notifications.\n            \n            # Email Configuration (Gmail example)\n            # ------------------------------------\n            # For Gmail, you need to use an App Password instead of your regular password\n            # Enable 2-factor authentication and generate an App Password at:\n            # https://myaccount.google.com/apppasswords\n            \n            email.username=your-email@gmail.com\n            email.password=your-app-password\n            email.recipient=recipient@example.com\n            \n            # SMS Configuration (Twilio)\n            # ---------------------------\n            # Sign up for a Twilio account at https://www.twilio.com\n            # Get your credentials from the Twilio Console\n            \n            twilio.account.sid=your-account-sid\n            twilio.auth.token=your-auth-token\n            twilio.from.number=+1234567890\n            twilio.to.number=+0987654321\n            \n            # Note: Leave values empty or remove lines to disable specific features\n            \"\"\";\n        \n        try {\n            // Try to create in current directory first\n            Path configPath = Paths.get(CONFIG_FILE_NAME);\n            Files.writeString(configPath, template);\n            System.out.println(\" Template configuration file created: \" + configPath.toAbsolutePath());\n            System.out.println(\" Please edit \" + CONFIG_FILE_NAME + \" with your credentials and restart the application.\");\n        } catch (IOException e) {\n            // Try user home directory as fallback\n            try {\n                Path userConfigDir = Paths.get(System.getProperty(\"user.home\"), \".spiketrade\");\n                Files.createDirectories(userConfigDir);\n                Path userConfigPath = userConfigDir.resolve(CONFIG_FILE_NAME);\n                Files.writeString(userConfigPath, template);\n                System.out.println(\" Template configuration file created: \" + userConfigPath.toAbsolutePath());\n                System.out.println(\" Please edit the file with your credentials and restart the application.\");\n            } catch (IOException e2) {\n                System.err.println(\" Failed to create template configuration file: \" + e2.getMessage());\n                System.out.println(\" Please create \" + CONFIG_FILE_NAME + \" manually with the following content:\");\n                System.out.println(template);\n            }\n        }\n    }\n    \n    /**\n     * Reload configuration from file (useful for runtime updates)\n     */\n    public void reloadConfiguration() {\n        System.out.println(\" Reloading configuration...\");\n        loadConfigurationFromFile();\n    }\n    \n    /**\n     * Update email configuration, preserving password if new password is null/empty\n     */\n    public void updateEmailConfiguration(String sender, String password, String recipient) {\n        // Validate non-secret fields\n        if (sender == null || sender.trim().isEmpty()) {\n            System.err.println(\" Cannot update email: sender cannot be empty\");\n            return;\n        }\n        if (recipient == null || recipient.trim().isEmpty()) {\n            System.err.println(\" Cannot update email: recipient cannot be empty\");\n            return;\n        }\n        \n        // If password is null or empty, keep existing password\n        String passwordToUse = emailPassword;  // Keep current\n        if (password != null && !password.trim().isEmpty()) {\n            passwordToUse = password.trim();  // Use new password\n        }\n        \n        // Validate that we have a password (either existing or new)\n        if (passwordToUse == null || passwordToUse.trim().isEmpty()) {\n            System.err.println(\" Cannot update email: password is required and not configured\");\n            return;\n        }\n        \n        configureEmail(sender.trim(), passwordToUse, recipient.trim());\n    }\n    \n    /**\n     * Update SMS configuration, preserving auth token if new token is null/empty\n     */\n    public void updateSMSConfiguration(String accountSid, String authToken, String fromNumber, String toNumber) {\n        // Validate non-secret fields\n        if (accountSid == null || accountSid.trim().isEmpty()) {\n            System.err.println(\" Cannot update SMS: account SID cannot be empty\");\n            return;\n        }\n        if (fromNumber == null || fromNumber.trim().isEmpty()) {\n            System.err.println(\" Cannot update SMS: from number cannot be empty\");\n            return;\n        }\n        if (toNumber == null || toNumber.trim().isEmpty()) {\n            System.err.println(\" Cannot update SMS: to number cannot be empty\");\n            return;\n        }\n        \n        // If auth token is null or empty, keep existing token\n        String tokenToUse = twilioAuthToken;  // Keep current\n        if (authToken != null && !authToken.trim().isEmpty()) {\n            tokenToUse = authToken.trim();  // Use new token\n        }\n        \n        // Validate that we have an auth token (either existing or new)\n        if (tokenToUse == null || tokenToUse.trim().isEmpty()) {\n            System.err.println(\" Cannot update SMS: auth token is required and not configured\");\n            return;\n        }\n        \n        configureSMS(accountSid.trim(), tokenToUse, fromNumber.trim(), toNumber.trim());\n    }\n    \n    /**\n     * Save current configuration to properties file\n     */\n    public void saveConfigurationToFile() {\n        Properties props = new Properties();\n        \n        // Add email configuration if available\n        if (emailSender != null && !emailSender.isEmpty()) {\n            props.setProperty(\"email.username\", emailSender);\n        }\n        if (emailPassword != null && !emailPassword.isEmpty()) {\n            props.setProperty(\"email.password\", emailPassword);\n        }\n        if (emailRecipient != null && !emailRecipient.isEmpty()) {\n            props.setProperty(\"email.recipient\", emailRecipient);\n        }\n        \n        // Add SMS configuration if available\n        if (twilioAccountSid != null && !twilioAccountSid.isEmpty()) {\n            props.setProperty(\"twilio.account.sid\", twilioAccountSid);\n        }\n        if (twilioAuthToken != null && !twilioAuthToken.isEmpty()) {\n            props.setProperty(\"twilio.auth.token\", twilioAuthToken);\n        }\n        if (twilioFromNumber != null && !twilioFromNumber.isEmpty()) {\n            props.setProperty(\"twilio.from.number\", twilioFromNumber);\n        }\n        if (twilioToNumber != null && !twilioToNumber.isEmpty()) {\n            props.setProperty(\"twilio.to.number\", twilioToNumber);\n        }\n        \n        // Try to save to current directory first\n        Path configPath = Paths.get(CONFIG_FILE_NAME);\n        try (OutputStream output = Files.newOutputStream(configPath)) {\n            props.store(output, \"SpikeTrade Notification Configuration - Auto-generated\");\n            System.out.println(\" Configuration saved to: \" + configPath.toAbsolutePath());\n        } catch (IOException e) {\n            // Try user home directory as fallback\n            try {\n                Path userConfigDir = Paths.get(System.getProperty(\"user.home\"), \".spiketrade\");\n                Files.createDirectories(userConfigDir);\n                Path userConfigPath = userConfigDir.resolve(CONFIG_FILE_NAME);\n                try (OutputStream output = Files.newOutputStream(userConfigPath)) {\n                    props.store(output, \"SpikeTrade Notification Configuration - Auto-generated\");\n                    System.out.println(\" Configuration saved to: \" + userConfigPath.toAbsolutePath());\n                }\n            } catch (IOException e2) {\n                System.err.println(\" Failed to save configuration: \" + e2.getMessage());\n            }\n        }\n    }\n    \n    private void detectWindowsToastSupport() {\n        try {\n            String os = System.getProperty(\"os.name\").toLowerCase();\n            if (!os.contains(\"windows\")) {\n                System.out.println(\" Not running on Windows - Toast notifications unavailable\");\n                windowsToastAvailable = false;\n                return;\n            }\n            \n            if (!isPowerShellAvailable()) {\n                System.out.println(\" PowerShell not available - Toast notifications unavailable\");\n                windowsToastAvailable = false;\n                return;\n            }\n            \n            powershellScriptPath = extractPowerShellScript();\n            if (powershellScriptPath == null) {\n                System.out.println(\" PowerShell script not found - Toast notifications unavailable\");\n                windowsToastAvailable = false;\n                return;\n            }\n            \n            // CRITICAL: Test toast notification with actual script execution (like Python's import test)\n            System.out.println(\" Testing Windows Toast notification capability...\");\n            boolean testSuccess = testToastNotification();\n            if (!testSuccess) {\n                System.out.println(\" Toast notification test failed - falling back to SystemTray\");\n                windowsToastAvailable = false;\n                return;\n            }\n            \n            windowsToastAvailable = true;\n            System.out.println(\" Windows Toast notification support verified and active\");\n            \n        } catch (Exception e) {\n            System.err.println(\" Error detecting Windows Toast support: \" + e.getMessage());\n            windowsToastAvailable = false;\n        }\n    }\n    \n    private boolean testToastNotification() {\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\n                \"powershell.exe\",\n                \"-NoProfile\",\n                \"-ExecutionPolicy\", \"Bypass\",\n                \"-File\", powershellScriptPath,\n                \"-Title\", \"SpikeTrade\",\n                \"-Message\", \"Notification system initialized\",\n                \"-Duration\", \"5\"\n            );\n            \n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n            \n            // Capture output for debugging\n            StringBuilder output = new StringBuilder();\n            try (BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    output.append(line).append(\"\\n\");\n                    if (line.contains(\"ERROR\") || line.contains(\"Exception\")) {\n                                                System.err.println(\"Toast test error: \" + line);\n                    }\n                }\n            }\n            \n            // FIX: PowerShell toast scripts stay running while displaying the toast (normal behavior)\n            // Wait briefly - if script exits immediately with error, that's a failure\n            // If still running after 2 seconds, that means toast is showing = success\n            boolean completed = process.waitFor(2, TimeUnit.SECONDS);\n            \n            if (completed) {\n                int exitCode = process.exitValue();\n                if (exitCode == 0) {\n                    System.out.println(\" Toast notification test PASSED\");\n                    return true;\n                } else {\n                    System.err.println(\" Toast notification test FAILED (exit code: \" + exitCode + \")\");\n                    if (output.length() > 0) {\n                        System.err.println(\"Output: \" + output.toString());\n                    }\n                    return false;\n                }\n            } else {\n                // Script still running = toast is displaying = SUCCESS\n                System.out.println(\" Toast notification test PASSED (toast displaying)\");\n                // Clean up the process in background\n                new Thread(() -> {\n                    try {\n                        process.waitFor(10, TimeUnit.SECONDS);\n                        if (process.isAlive()) {\n                            process.destroy();\n                        }\n                    } catch (Exception ignored) {}\n                }).start();\n                return true;\n            }\n            \n        } catch (Exception e) {\n            System.err.println(\" Toast notification test exception: \" + e.getMessage());\n            return false;\n        }\n    }\n    \n    private boolean isPowerShellAvailable() {\n        try {\n            Process process = new ProcessBuilder(\"powershell.exe\", \"-Command\", \"echo test\")\n                    .redirectErrorStream(true)\n                    .start();\n            boolean exited = process.waitFor(5, TimeUnit.SECONDS);\n            return exited && process.exitValue() == 0;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    \n    private String extractPowerShellScript() {\n        try {\n            InputStream scriptStream = getClass().getResourceAsStream(\"/Show-ToastNotification.ps1\");\n            if (scriptStream == null) {\n                Path currentPath = Paths.get(\"src/main/resources/Show-ToastNotification.ps1\");\n                if (Files.exists(currentPath)) {\n                    return currentPath.toAbsolutePath().toString();\n                }\n                return null;\n            }\n            \n            Path tempScript = Files.createTempFile(\"Show-ToastNotification\", \".ps1\");\n            tempScript.toFile().deleteOnExit();\n            \n            try (OutputStream out = Files.newOutputStream(tempScript)) {\n                byte[] buffer = new byte[8192];\n                int bytesRead;\n                while ((bytesRead = scriptStream.read(buffer)) != -1) {\n                    out.write(buffer, 0, bytesRead);\n                }\n            }\n            \n            return tempScript.toAbsolutePath().toString();\n            \n        } catch (Exception e) {\n            System.err.println(\" Failed to extract PowerShell script: \" + e.getMessage());\n            return null;\n        }\n    }\n    \n    private Image createDefaultIcon() {\n        int size = 16;\n        java.awt.image.BufferedImage img = new java.awt.image.BufferedImage(\n            size, size, java.awt.image.BufferedImage.TYPE_INT_ARGB\n        );\n        Graphics2D g = img.createGraphics();\n        g.setColor(new Color(59, 90, 125));\n        g.fillRect(0, 0, size, size);\n        g.setColor(Color.WHITE);\n        g.fillOval(4, 4, 8, 8);\n        g.dispose();\n        return img;\n    }\n    \n    public void showBuySignal(String symbol, double price, double probability, String details) {\n        String title = \" BUY SIGNAL: \" + symbol;\n        String message = String.format(\"Price: $%.2f | Probability: %.1f%%\", price, probability * 100);\n        \n        if (details != null && !details.isEmpty()) {\n            message += \"\\n\" + details;\n        }\n        \n        showNotification(title, message, MessageType.INFO);\n    }\n    \n    public void showSellSignal(String symbol, double price, double profit, String reason) {\n        String title = \" SELL SIGNAL: \" + symbol;\n        String message = String.format(\"Price: $%.2f | Profit: $%.2f\\nReason: %s\", price, profit, reason);\n        \n        showNotification(title, message, MessageType.INFO);\n    }\n    \n    public void showSellWarning(String symbol, double price, double warningProbability, String reason) {\n        String title = \" SELL WARNING: \" + symbol;\n        String message = String.format(\"Price: $%.2f | Warning: %.1f%%\\nReason: %s\", \n                                      price, warningProbability * 100, reason);\n        \n        showNotification(title, message, MessageType.WARNING);\n    }\n    \n    public void alertCritical(String title, String message) {\n        Platform.runLater(() -> {\n            Alert alert = new Alert(Alert.AlertType.ERROR);\n            alert.setTitle(title);\n            alert.setHeaderText(null);\n            alert.setContentText(message);\n            alert.show();\n            System.err.println(\" CRITICAL ALERT: \" + title + \" - \" + message);\n        });\n    }\n    \n    private void showNotification(String title, String message, MessageType type) {\n        notificationExecutor.submit(() -> {\n            boolean toastShown = false;\n            boolean trayShown = false;\n            boolean modalShown = false;\n            \n            // Try Windows Toast first (like Python's win10toast approach)\n            if (windowsToastAvailable && powershellScriptPath != null) {\n                toastShown = showWindowsToast(title, message, 15);\n                if (toastShown) {\n                    System.out.println(\" Windows Toast notification displayed: \" + title);\n                }\n            }\n            \n            // If toast failed or unavailable, show SystemTray\n            if (!toastShown && systemTrayAvailable && trayIcon != null) {\n                SwingUtilities.invokeLater(() -> {\n                    try {\n                        trayIcon.displayMessage(title, message, type);\n                        System.out.println(\" System Tray notification displayed: \" + title);\n                    } catch (Exception e) {\n                        System.err.println(\" Failed to display system tray notification: \" + e.getMessage());\n                        e.printStackTrace();\n                        systemTrayAvailable = false;\n                        useModalFallback = true;\n                        showModalFallback(title, message, type);\n                    }\n                });\n                trayShown = true;\n            } else if (!toastShown && !systemTrayAvailable) {\n                // Final fallback to modal dialog\n                if (!useModalFallback) {\n                    System.out.println(\" System tray not available - enabling modal fallback\");\n                    useModalFallback = true;\n                }\n                showModalFallback(title, message, type);\n                modalShown = true;\n            }\n            \n            // ALWAYS send email if configured (don't skip!)\n            if (isEmailConfigured()) {\n                sendEmail(title, message);\n            }\n            \n            // ALWAYS send SMS if configured (don't skip!)\n            if (isSMSConfigured()) {\n                sendSMS(message);\n            }\n            \n            // Log if all channels failed\n            if (!toastShown && !trayShown && !modalShown) {\n                System.err.println(\" ALL NOTIFICATION CHANNELS FAILED for: \" + title);\n            }\n        });\n    }\n    \n    private boolean showWindowsToast(String title, String message, int duration) {\n        try {\n            // Escape quotes in title and message\n            String escapedTitle = title.replace(\"\\\"\", \"`\\\"\").replace(\"'\", \"''\");\n            String escapedMessage = message.replace(\"\\\"\", \"`\\\"\").replace(\"'\", \"''\");\n            \n            // Build PowerShell command (like Python's threading.Thread approach)\n            ProcessBuilder processBuilder = new ProcessBuilder(\n                \"powershell.exe\",\n                \"-NoProfile\",\n                \"-ExecutionPolicy\", \"Bypass\",\n                \"-File\", powershellScriptPath,\n                \"-Title\", escapedTitle,\n                \"-Message\", escapedMessage,\n                \"-Duration\", String.valueOf(duration)\n            );\n            \n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n            \n            // Read output asynchronously (don't block)\n            new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(\n                        new InputStreamReader(process.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        if (line.contains(\"ERROR\") || line.contains(\"Exception\")) {\n                            System.err.println(\"PowerShell Toast Error: \" + line);\n                        }\n                    }\n                } catch (IOException e) {\n                    // Ignore - notification may have completed\n                }\n            }, \"PowerShell-Toast-Reader\").start();\n            \n            // Wait briefly to check if script starts successfully\n            boolean completed = process.waitFor(2, TimeUnit.SECONDS);\n            if (completed && process.exitValue() == 0) {\n                return true;\n            } else if (!completed) {\n                // Script is still running (normal for toast display)\n                return true;\n            }\n            \n            return false;\n            \n        } catch (Exception e) {\n            System.err.println(\" Windows Toast notification error: \" + e.getMessage());\n            return false;\n        }\n    }\n    \n    private void showModalFallback(String title, String message, MessageType type) {\n        Platform.runLater(() -> {\n            Alert.AlertType alertType;\n            switch (type) {\n                case WARNING:\n                    alertType = Alert.AlertType.WARNING;\n                    break;\n                case ERROR:\n                    alertType = Alert.AlertType.ERROR;\n                    break;\n                default:\n                    alertType = Alert.AlertType.INFORMATION;\n                    break;\n            }\n            \n            Alert alert = new Alert(alertType);\n            alert.setTitle(title);\n            alert.setHeaderText(null);\n            alert.setContentText(message);\n            alert.show();\n        });\n    }\n    \n    public void shutdown() {\n        if (trayIcon != null && systemTrayAvailable) {\n            try {\n                SystemTray.getSystemTray().remove(trayIcon);\n                System.out.println(\" System tray icon removed\");\n            } catch (Exception e) {\n                System.err.println(\" Error removing tray icon: \" + e.getMessage());\n            }\n        }\n        \n        if (notificationExecutor != null) {\n            notificationExecutor.shutdown();\n        }\n    }\n    \n    public boolean isSystemTrayAvailable() {\n        return systemTrayAvailable;\n    }\n    \n    public boolean isWindowsToastAvailable() {\n        return windowsToastAvailable;\n    }\n    \n    // Email configuration methods\n    public void configureEmail(String sender, String password, String recipient) {\n        this.emailSender = sender;\n        this.emailPassword = password;\n        this.emailRecipient = recipient;\n        this.emailConfigured = sender != null && !sender.isEmpty() && \n                               password != null && !password.isEmpty() &&\n                               recipient != null && !recipient.isEmpty();\n        System.out.println(\" Email configured: \" + emailConfigured);\n    }\n    \n    public boolean isEmailConfigured() {\n        return emailConfigured;\n    }\n    \n    public String getEmailSender() {\n        return emailSender != null ? emailSender : \"\";\n    }\n    \n    public String getEmailRecipient() {\n        return emailRecipient != null ? emailRecipient : \"\";\n    }\n    \n    public boolean sendEmail(String subject, String body) {\n        if (!emailConfigured) {\n            System.err.println(\" Email not configured - cannot send\");\n            return false;\n        }\n        \n        notificationExecutor.submit(() -> {\n            try {\n                System.out.println(\" Attempting to send email: \" + subject);\n                java.util.Properties props = new java.util.Properties();\n                props.put(\"mail.smtp.auth\", \"true\");\n                props.put(\"mail.smtp.starttls.enable\", \"true\");\n                props.put(\"mail.smtp.host\", \"smtp.gmail.com\");\n                props.put(\"mail.smtp.port\", \"587\");\n                \n                javax.mail.Session session = javax.mail.Session.getInstance(props,\n                    new javax.mail.Authenticator() {\n                        protected javax.mail.PasswordAuthentication getPasswordAuthentication() {\n                            return new javax.mail.PasswordAuthentication(emailSender, emailPassword);\n                        }\n                    });\n                \n                javax.mail.Message message = new javax.mail.internet.MimeMessage(session);\n                message.setFrom(new javax.mail.internet.InternetAddress(emailSender));\n                message.setRecipients(javax.mail.Message.RecipientType.TO,\n                    javax.mail.internet.InternetAddress.parse(emailRecipient));\n                message.setSubject(subject);\n                message.setText(body);\n                \n                javax.mail.Transport.send(message);\n                System.out.println(\" Email sent successfully: \" + subject);\n                \n            } catch (Exception e) {\n                System.err.println(\" Email send error: \" + e.getMessage());\n                e.printStackTrace();\n            }\n        });\n        \n        return true;\n    }\n    \n    // SMS configuration methods\n    public void configureSMS(String accountSid, String authToken, String fromNumber, String toNumber) {\n        this.twilioAccountSid = accountSid;\n        this.twilioAuthToken = authToken;\n        this.twilioFromNumber = fromNumber;\n        this.twilioToNumber = toNumber;\n                this.smsConfigured = accountSid != null && !accountSid.isEmpty() &&\n                            authToken != null && !authToken.isEmpty() &&\n                            fromNumber != null && !fromNumber.isEmpty() &&\n                            toNumber != null && !toNumber.isEmpty();\n        System.out.println(\" SMS configured: \" + smsConfigured);\n    }\n    \n    public boolean isSMSConfigured() {\n        return smsConfigured;\n    }\n    \n    public String getTwilioAccountSid() {\n        return twilioAccountSid != null ? twilioAccountSid : \"\";\n    }\n    \n    public String getTwilioFromNumber() {\n        return twilioFromNumber != null ? twilioFromNumber : \"\";\n    }\n    \n    public String getTwilioToNumber() {\n        return twilioToNumber != null ? twilioToNumber : \"\";\n    }\n    \n    public boolean sendSMS(String message) {\n        if (!smsConfigured) {\n            System.err.println(\" SMS not configured - cannot send\");\n            return false;\n        }\n        \n        notificationExecutor.submit(() -> {\n            try {\n                System.out.println(\" Attempting to send SMS: \" + message.substring(0, Math.min(50, message.length())));\n                \n                com.twilio.Twilio.init(twilioAccountSid, twilioAuthToken);\n                com.twilio.rest.api.v2010.account.Message twilioMessage = \n                    com.twilio.rest.api.v2010.account.Message.creator(\n                        new com.twilio.type.PhoneNumber(twilioToNumber),\n                        new com.twilio.type.PhoneNumber(twilioFromNumber),\n                        message\n                    ).create();\n                \n                System.out.println(\" SMS sent successfully. SID: \" + twilioMessage.getSid());\n                \n            } catch (Exception e) {\n                System.err.println(\" SMS send error: \" + e.getMessage());\n                e.printStackTrace();\n            }\n        });\n        \n        return true;\n    }\n    \n    // Test notification - sends realistic buy/sell/warning signal examples\n    public void sendTestNotification() {\n        System.out.println(\"\\n ========== SENDING TEST NOTIFICATIONS ==========\");\n        System.out.println(\"Sending realistic signal notifications to test all channels...\\n\");\n        \n        // 1. Test BUY SIGNAL\n        System.out.println(\" Sending test BUY SIGNAL notification...\");\n        showBuySignal(\"AAPL\", 175.50, 0.78, \n                     \"Test buy signal with strong momentum indicators\");\n        \n        // Small delay between notifications to avoid overwhelming\n        try { Thread.sleep(500); } catch (InterruptedException e) {}\n        \n        // 2. Test SELL SIGNAL  \n        System.out.println(\" Sending test SELL SIGNAL notification...\");\n        showSellSignal(\"TSLA\", 245.80, 12.50,\n                      \"Test sell signal - target profit reached\");\n        \n        try { Thread.sleep(500); } catch (InterruptedException e) {}\n        \n        // 3. Test SELL WARNING\n        System.out.println(\" Sending test SELL WARNING notification...\");\n        showSellWarning(\"NVDA\", 520.25, 0.85,\n                       \"Test warning - momentum weakening, consider exit\");\n        \n        System.out.println(\"\\n Test notifications sent successfully!\");\n        System.out.println(\"Check your notification channels:\");\n        System.out.println(\"  - Windows Toast: \" + (windowsToastAvailable ? \" Enabled\" : \" Not available\"));\n        System.out.println(\"  - Email: \" + (emailConfigured ? \" Configured\" : \" Not configured\"));\n        System.out.println(\"  - SMS: \" + (smsConfigured ? \" Configured\" : \" Not configured\"));\n        System.out.println(\"========================================\\n\");\n    }\n}","size_bytes":39329},"build/extracted-include-protos/main/google/api/endpoint.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"EndpointProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Endpoint` describes a network address of a service that serves a set of\n// APIs. It is commonly known as a service endpoint. A service may expose\n// any number of service endpoints, and all service endpoints share the same\n// service definition, such as quota limits and monitoring metrics.\n//\n// Example:\n//\n//     type: google.api.Service\n//     name: library-example.googleapis.com\n//     endpoints:\n//       # Declares network address `https://library-example.googleapis.com`\n//       # for service `library-example.googleapis.com`. The `https` scheme\n//       # is implicit for all service endpoints. Other schemes may be\n//       # supported in the future.\n//     - name: library-example.googleapis.com\n//       allow_cors: false\n//     - name: content-staging-library-example.googleapis.com\n//       # Allows HTTP OPTIONS calls to be passed to the API frontend, for it\n//       # to decide whether the subsequent cross-origin request is allowed\n//       # to proceed.\n//       allow_cors: true\nmessage Endpoint {\n  // The canonical name of this endpoint.\n  string name = 1;\n\n  // Unimplemented. Dot not use.\n  //\n  // DEPRECATED: This field is no longer supported. Instead of using aliases,\n  // please specify multiple [google.api.Endpoint][google.api.Endpoint] for each\n  // of the intended aliases.\n  //\n  // Additional names that this endpoint will be hosted on.\n  repeated string aliases = 2 [deprecated = true];\n\n  // The specification of an Internet routable address of API frontend that will\n  // handle requests to this [API\n  // Endpoint](https://cloud.google.com/apis/design/glossary). It should be\n  // either a valid IPv4 address or a fully-qualified domain name. For example,\n  // \"8.8.8.8\" or \"myservice.appspot.com\".\n  string target = 101;\n\n  // Allowing\n  // [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing), aka\n  // cross-domain traffic, would allow the backends served from this endpoint to\n  // receive and respond to HTTP OPTIONS requests. The response will be used by\n  // the browser to determine whether the subsequent cross-origin request is\n  // allowed to proceed.\n  bool allow_cors = 5;\n}\n","size_bytes":3028},"build/extracted-include-protos/main/google/api/quota.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"QuotaProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Quota configuration helps to achieve fairness and budgeting in service\n// usage.\n//\n// The metric based quota configuration works this way:\n// - The service configuration defines a set of metrics.\n// - For API calls, the quota.metric_rules maps methods to metrics with\n//   corresponding costs.\n// - The quota.limits defines limits on the metrics, which will be used for\n//   quota checks at runtime.\n//\n// An example quota configuration in yaml format:\n//\n//    quota:\n//      limits:\n//\n//      - name: apiWriteQpsPerProject\n//        metric: library.googleapis.com/write_calls\n//        unit: \"1/min/{project}\"  # rate limit for consumer projects\n//        values:\n//          STANDARD: 10000\n//\n//\n//      (The metric rules bind all methods to the read_calls metric,\n//       except for the UpdateBook and DeleteBook methods. These two methods\n//       are mapped to the write_calls metric, with the UpdateBook method\n//       consuming at twice rate as the DeleteBook method.)\n//      metric_rules:\n//      - selector: \"*\"\n//        metric_costs:\n//          library.googleapis.com/read_calls: 1\n//      - selector: google.example.library.v1.LibraryService.UpdateBook\n//        metric_costs:\n//          library.googleapis.com/write_calls: 2\n//      - selector: google.example.library.v1.LibraryService.DeleteBook\n//        metric_costs:\n//          library.googleapis.com/write_calls: 1\n//\n//  Corresponding Metric definition:\n//\n//      metrics:\n//      - name: library.googleapis.com/read_calls\n//        display_name: Read requests\n//        metric_kind: DELTA\n//        value_type: INT64\n//\n//      - name: library.googleapis.com/write_calls\n//        display_name: Write requests\n//        metric_kind: DELTA\n//        value_type: INT64\n//\n//\nmessage Quota {\n  // List of QuotaLimit definitions for the service.\n  repeated QuotaLimit limits = 3;\n\n  // List of MetricRule definitions, each one mapping a selected method to one\n  // or more metrics.\n  repeated MetricRule metric_rules = 4;\n}\n\n// Bind API methods to metrics. Binding a method to a metric causes that\n// metric's configured quota behaviors to apply to the method call.\nmessage MetricRule {\n  // Selects the methods to which this rule applies.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // Metrics to update when the selected methods are called, and the associated\n  // cost applied to each metric.\n  //\n  // The key of the map is the metric name, and the values are the amount\n  // increased for the metric against which the quota limits are defined.\n  // The value must not be negative.\n  map<string, int64> metric_costs = 2;\n}\n\n// `QuotaLimit` defines a specific limit that applies over a specified duration\n// for a limit type. There can be at most one limit for a duration and limit\n// type combination defined within a `QuotaGroup`.\nmessage QuotaLimit {\n  // Name of the quota limit.\n  //\n  // The name must be provided, and it must be unique within the service. The\n  // name can only include alphanumeric characters as well as '-'.\n  //\n  // The maximum length of the limit name is 64 characters.\n  string name = 6;\n\n  // Optional. User-visible, extended description for this quota limit.\n  // Should be used only when more context is needed to understand this limit\n  // than provided by the limit's display name (see: `display_name`).\n  string description = 2;\n\n  // Default number of tokens that can be consumed during the specified\n  // duration. This is the number of tokens assigned when a client\n  // application developer activates the service for his/her project.\n  //\n  // Specifying a value of 0 will block all requests. This can be used if you\n  // are provisioning quota to selected consumers and blocking others.\n  // Similarly, a value of -1 will indicate an unlimited quota. No other\n  // negative values are allowed.\n  //\n  // Used by group-based quotas only.\n  int64 default_limit = 3;\n\n  // Maximum number of tokens that can be consumed during the specified\n  // duration. Client application developers can override the default limit up\n  // to this maximum. If specified, this value cannot be set to a value less\n  // than the default limit. If not specified, it is set to the default limit.\n  //\n  // To allow clients to apply overrides with no upper bound, set this to -1,\n  // indicating unlimited maximum quota.\n  //\n  // Used by group-based quotas only.\n  int64 max_limit = 4;\n\n  // Free tier value displayed in the Developers Console for this limit.\n  // The free tier is the number of tokens that will be subtracted from the\n  // billed amount when billing is enabled.\n  // This field can only be set on a limit with duration \"1d\", in a billable\n  // group; it is invalid on any other limit. If this field is not set, it\n  // defaults to 0, indicating that there is no free tier for this service.\n  //\n  // Used by group-based quotas only.\n  int64 free_tier = 7;\n\n  // Duration of this limit in textual notation. Must be \"100s\" or \"1d\".\n  //\n  // Used by group-based quotas only.\n  string duration = 5;\n\n  // The name of the metric this quota limit applies to. The quota limits with\n  // the same metric will be checked together during runtime. The metric must be\n  // defined within the service config.\n  string metric = 8;\n\n  // Specify the unit of the quota limit. It uses the same syntax as\n  // [Metric.unit][]. The supported unit kinds are determined by the quota\n  // backend system.\n  //\n  // Here are some examples:\n  // * \"1/min/{project}\" for quota per minute per project.\n  //\n  // Note: the order of unit components is insignificant.\n  // The \"1\" at the beginning is required to follow the metric unit syntax.\n  string unit = 9;\n\n  // Tiered limit values. You must specify this as a key:value pair, with an\n  // integer value that is the maximum number of requests allowed for the\n  // specified unit. Currently only STANDARD is supported.\n  map<string, int64> values = 10;\n\n  // User-visible display name for this limit.\n  // Optional. If not set, the UI will provide a default display name based on\n  // the quota configuration. This field can be used to override the default\n  // display name generated from the configuration.\n  string display_name = 12;\n}\n","size_bytes":7138},"build/extracted-include-protos/test/google/type/datetime.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\nimport \"google/protobuf/duration.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/datetime;datetime\";\noption java_multiple_files = true;\noption java_outer_classname = \"DateTimeProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents civil time (or occasionally physical time).\n//\n// This type can represent a civil time in one of a few possible ways:\n//\n//  * When utc_offset is set and time_zone is unset: a civil time on a calendar\n//    day with a particular offset from UTC.\n//  * When time_zone is set and utc_offset is unset: a civil time on a calendar\n//    day in a particular time zone.\n//  * When neither time_zone nor utc_offset is set: a civil time on a calendar\n//    day in local time.\n//\n// The date is relative to the Proleptic Gregorian Calendar.\n//\n// If year is 0, the DateTime is considered not to have a specific year. month\n// and day must have valid, non-zero values.\n//\n// This type may also be used to represent a physical time if all the date and\n// time fields are set and either case of the `time_offset` oneof is set.\n// Consider using `Timestamp` message for physical time instead. If your use\n// case also would like to store the user's timezone, that can be done in\n// another field.\n//\n// This type is more flexible than some applications may want. Make sure to\n// document and validate your application's limitations.\nmessage DateTime {\n  // Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a\n  // datetime without a year.\n  int32 year = 1;\n\n  // Required. Month of year. Must be from 1 to 12.\n  int32 month = 2;\n\n  // Required. Day of month. Must be from 1 to 31 and valid for the year and\n  // month.\n  int32 day = 3;\n\n  // Required. Hours of day in 24 hour format. Should be from 0 to 23. An API\n  // may choose to allow the value \"24:00:00\" for scenarios like business\n  // closing time.\n  int32 hours = 4;\n\n  // Required. Minutes of hour of day. Must be from 0 to 59.\n  int32 minutes = 5;\n\n  // Required. Seconds of minutes of the time. Must normally be from 0 to 59. An\n  // API may allow the value 60 if it allows leap-seconds.\n  int32 seconds = 6;\n\n  // Required. Fractions of seconds in nanoseconds. Must be from 0 to\n  // 999,999,999.\n  int32 nanos = 7;\n\n  // Optional. Specifies either the UTC offset or the time zone of the DateTime.\n  // Choose carefully between them, considering that time zone data may change\n  // in the future (for example, a country modifies their DST start/end dates,\n  // and future DateTimes in the affected range had already been stored).\n  // If omitted, the DateTime is considered to be in local time.\n  oneof time_offset {\n    // UTC offset. Must be whole seconds, between -18 hours and +18 hours.\n    // For example, a UTC offset of -4:00 would be represented as\n    // { seconds: -14400 }.\n    google.protobuf.Duration utc_offset = 8;\n\n    // Time zone.\n    TimeZone time_zone = 9;\n  }\n}\n\n// Represents a time zone from the\n// [IANA Time Zone Database](https://www.iana.org/time-zones).\nmessage TimeZone {\n  // IANA Time Zone Database time zone, e.g. \"America/New_York\".\n  string id = 1;\n\n  // Optional. IANA Time Zone Database version number, e.g. \"2019a\".\n  string version = 2;\n}\n","size_bytes":3905},"build/extracted-include-protos/test/google/rpc/code.proto":{"content":"// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.rpc;\n\noption go_package = \"google.golang.org/genproto/googleapis/rpc/code;code\";\noption java_multiple_files = true;\noption java_outer_classname = \"CodeProto\";\noption java_package = \"com.google.rpc\";\noption objc_class_prefix = \"RPC\";\n\n// The canonical error codes for gRPC APIs.\n//\n//\n// Sometimes multiple error codes may apply.  Services should return\n// the most specific error code that applies.  For example, prefer\n// `OUT_OF_RANGE` over `FAILED_PRECONDITION` if both codes apply.\n// Similarly prefer `NOT_FOUND` or `ALREADY_EXISTS` over `FAILED_PRECONDITION`.\nenum Code {\n  // Not an error; returned on success.\n  //\n  // HTTP Mapping: 200 OK\n  OK = 0;\n\n  // The operation was cancelled, typically by the caller.\n  //\n  // HTTP Mapping: 499 Client Closed Request\n  CANCELLED = 1;\n\n  // Unknown error.  For example, this error may be returned when\n  // a `Status` value received from another address space belongs to\n  // an error space that is not known in this address space.  Also\n  // errors raised by APIs that do not return enough error information\n  // may be converted to this error.\n  //\n  // HTTP Mapping: 500 Internal Server Error\n  UNKNOWN = 2;\n\n  // The client specified an invalid argument.  Note that this differs\n  // from `FAILED_PRECONDITION`.  `INVALID_ARGUMENT` indicates arguments\n  // that are problematic regardless of the state of the system\n  // (e.g., a malformed file name).\n  //\n  // HTTP Mapping: 400 Bad Request\n  INVALID_ARGUMENT = 3;\n\n  // The deadline expired before the operation could complete. For operations\n  // that change the state of the system, this error may be returned\n  // even if the operation has completed successfully.  For example, a\n  // successful response from a server could have been delayed long\n  // enough for the deadline to expire.\n  //\n  // HTTP Mapping: 504 Gateway Timeout\n  DEADLINE_EXCEEDED = 4;\n\n  // Some requested entity (e.g., file or directory) was not found.\n  //\n  // Note to server developers: if a request is denied for an entire class\n  // of users, such as gradual feature rollout or undocumented allowlist,\n  // `NOT_FOUND` may be used. If a request is denied for some users within\n  // a class of users, such as user-based access control, `PERMISSION_DENIED`\n  // must be used.\n  //\n  // HTTP Mapping: 404 Not Found\n  NOT_FOUND = 5;\n\n  // The entity that a client attempted to create (e.g., file or directory)\n  // already exists.\n  //\n  // HTTP Mapping: 409 Conflict\n  ALREADY_EXISTS = 6;\n\n  // The caller does not have permission to execute the specified\n  // operation. `PERMISSION_DENIED` must not be used for rejections\n  // caused by exhausting some resource (use `RESOURCE_EXHAUSTED`\n  // instead for those errors). `PERMISSION_DENIED` must not be\n  // used if the caller can not be identified (use `UNAUTHENTICATED`\n  // instead for those errors). This error code does not imply the\n  // request is valid or the requested entity exists or satisfies\n  // other pre-conditions.\n  //\n  // HTTP Mapping: 403 Forbidden\n  PERMISSION_DENIED = 7;\n\n  // The request does not have valid authentication credentials for the\n  // operation.\n  //\n  // HTTP Mapping: 401 Unauthorized\n  UNAUTHENTICATED = 16;\n\n  // Some resource has been exhausted, perhaps a per-user quota, or\n  // perhaps the entire file system is out of space.\n  //\n  // HTTP Mapping: 429 Too Many Requests\n  RESOURCE_EXHAUSTED = 8;\n\n  // The operation was rejected because the system is not in a state\n  // required for the operation's execution.  For example, the directory\n  // to be deleted is non-empty, an rmdir operation is applied to\n  // a non-directory, etc.\n  //\n  // Service implementors can use the following guidelines to decide\n  // between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`:\n  //  (a) Use `UNAVAILABLE` if the client can retry just the failing call.\n  //  (b) Use `ABORTED` if the client should retry at a higher level. For\n  //      example, when a client-specified test-and-set fails, indicating the\n  //      client should restart a read-modify-write sequence.\n  //  (c) Use `FAILED_PRECONDITION` if the client should not retry until\n  //      the system state has been explicitly fixed. For example, if an \"rmdir\"\n  //      fails because the directory is non-empty, `FAILED_PRECONDITION`\n  //      should be returned since the client should not retry unless\n  //      the files are deleted from the directory.\n  //\n  // HTTP Mapping: 400 Bad Request\n  FAILED_PRECONDITION = 9;\n\n  // The operation was aborted, typically due to a concurrency issue such as\n  // a sequencer check failure or transaction abort.\n  //\n  // See the guidelines above for deciding between `FAILED_PRECONDITION`,\n  // `ABORTED`, and `UNAVAILABLE`.\n  //\n  // HTTP Mapping: 409 Conflict\n  ABORTED = 10;\n\n  // The operation was attempted past the valid range.  E.g., seeking or\n  // reading past end-of-file.\n  //\n  // Unlike `INVALID_ARGUMENT`, this error indicates a problem that may\n  // be fixed if the system state changes. For example, a 32-bit file\n  // system will generate `INVALID_ARGUMENT` if asked to read at an\n  // offset that is not in the range [0,2^32-1], but it will generate\n  // `OUT_OF_RANGE` if asked to read from an offset past the current\n  // file size.\n  //\n  // There is a fair bit of overlap between `FAILED_PRECONDITION` and\n  // `OUT_OF_RANGE`.  We recommend using `OUT_OF_RANGE` (the more specific\n  // error) when it applies so that callers who are iterating through\n  // a space can easily look for an `OUT_OF_RANGE` error to detect when\n  // they are done.\n  //\n  // HTTP Mapping: 400 Bad Request\n  OUT_OF_RANGE = 11;\n\n  // The operation is not implemented or is not supported/enabled in this\n  // service.\n  //\n  // HTTP Mapping: 501 Not Implemented\n  UNIMPLEMENTED = 12;\n\n  // Internal errors.  This means that some invariants expected by the\n  // underlying system have been broken.  This error code is reserved\n  // for serious errors.\n  //\n  // HTTP Mapping: 500 Internal Server Error\n  INTERNAL = 13;\n\n  // The service is currently unavailable.  This is most likely a\n  // transient condition, which can be corrected by retrying with\n  // a backoff. Note that it is not always safe to retry\n  // non-idempotent operations.\n  //\n  // See the guidelines above for deciding between `FAILED_PRECONDITION`,\n  // `ABORTED`, and `UNAVAILABLE`.\n  //\n  // HTTP Mapping: 503 Service Unavailable\n  UNAVAILABLE = 14;\n\n  // Unrecoverable data loss or corruption.\n  //\n  // HTTP Mapping: 500 Internal Server Error\n  DATA_LOSS = 15;\n}\n","size_bytes":7138},"build/extracted-include-protos/test/google/api/metric.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/api/label.proto\";\nimport \"google/api/launch_stage.proto\";\nimport \"google/protobuf/duration.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/metric;metric\";\noption java_multiple_files = true;\noption java_outer_classname = \"MetricProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Defines a metric type and its schema. Once a metric descriptor is created,\n// deleting or altering it stops data collection and makes the metric type's\n// existing data unusable.\n//\nmessage MetricDescriptor {\n  // The kind of measurement. It describes how the data is reported.\n  // For information on setting the start time and end time based on\n  // the MetricKind, see [TimeInterval][google.monitoring.v3.TimeInterval].\n  enum MetricKind {\n    // Do not use this default value.\n    METRIC_KIND_UNSPECIFIED = 0;\n\n    // An instantaneous measurement of a value.\n    GAUGE = 1;\n\n    // The change in a value during a time interval.\n    DELTA = 2;\n\n    // A value accumulated over a time interval.  Cumulative\n    // measurements in a time series should have the same start time\n    // and increasing end times, until an event resets the cumulative\n    // value to zero and sets a new start time for the following\n    // points.\n    CUMULATIVE = 3;\n  }\n\n  // The value type of a metric.\n  enum ValueType {\n    // Do not use this default value.\n    VALUE_TYPE_UNSPECIFIED = 0;\n\n    // The value is a boolean.\n    // This value type can be used only if the metric kind is `GAUGE`.\n    BOOL = 1;\n\n    // The value is a signed 64-bit integer.\n    INT64 = 2;\n\n    // The value is a double precision floating point number.\n    DOUBLE = 3;\n\n    // The value is a text string.\n    // This value type can be used only if the metric kind is `GAUGE`.\n    STRING = 4;\n\n    // The value is a [`Distribution`][google.api.Distribution].\n    DISTRIBUTION = 5;\n\n    // The value is money.\n    MONEY = 6;\n  }\n\n  // Additional annotations that can be used to guide the usage of a metric.\n  message MetricDescriptorMetadata {\n    // Deprecated. Must use the\n    // [MetricDescriptor.launch_stage][google.api.MetricDescriptor.launch_stage]\n    // instead.\n    LaunchStage launch_stage = 1 [deprecated = true];\n\n    // The sampling period of metric data points. For metrics which are written\n    // periodically, consecutive data points are stored at this time interval,\n    // excluding data loss due to errors. Metrics with a higher granularity have\n    // a smaller sampling period.\n    google.protobuf.Duration sample_period = 2;\n\n    // The delay of data points caused by ingestion. Data points older than this\n    // age are guaranteed to be ingested and available to be read, excluding\n    // data loss due to errors.\n    google.protobuf.Duration ingest_delay = 3;\n  }\n\n  // The resource name of the metric descriptor.\n  string name = 1;\n\n  // The metric type, including its DNS name prefix. The type is not\n  // URL-encoded. All user-defined metric types have the DNS name\n  // `custom.googleapis.com` or `external.googleapis.com`. Metric types should\n  // use a natural hierarchical grouping. For example:\n  //\n  //     \"custom.googleapis.com/invoice/paid/amount\"\n  //     \"external.googleapis.com/prometheus/up\"\n  //     \"appengine.googleapis.com/http/server/response_latencies\"\n  string type = 8;\n\n  // The set of labels that can be used to describe a specific\n  // instance of this metric type. For example, the\n  // `appengine.googleapis.com/http/server/response_latencies` metric\n  // type has a label for the HTTP response code, `response_code`, so\n  // you can look at latencies for successful responses or just\n  // for responses that failed.\n  repeated LabelDescriptor labels = 2;\n\n  // Whether the metric records instantaneous values, changes to a value, etc.\n  // Some combinations of `metric_kind` and `value_type` might not be supported.\n  MetricKind metric_kind = 3;\n\n  // Whether the measurement is an integer, a floating-point number, etc.\n  // Some combinations of `metric_kind` and `value_type` might not be supported.\n  ValueType value_type = 4;\n\n  // The units in which the metric value is reported. It is only applicable\n  // if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit`\n  // defines the representation of the stored metric values.\n  //\n  // Different systems might scale the values to be more easily displayed (so a\n  // value of `0.02kBy` _might_ be displayed as `20By`, and a value of\n  // `3523kBy` _might_ be displayed as `3.5MBy`). However, if the `unit` is\n  // `kBy`, then the value of the metric is always in thousands of bytes, no\n  // matter how it might be displayed.\n  //\n  // If you want a custom metric to record the exact number of CPU-seconds used\n  // by a job, you can create an `INT64 CUMULATIVE` metric whose `unit` is\n  // `s{CPU}` (or equivalently `1s{CPU}` or just `s`). If the job uses 12,005\n  // CPU-seconds, then the value is written as `12005`.\n  //\n  // Alternatively, if you want a custom metric to record data in a more\n  // granular way, you can create a `DOUBLE CUMULATIVE` metric whose `unit` is\n  // `ks{CPU}`, and then write the value `12.005` (which is `12005/1000`),\n  // or use `Kis{CPU}` and write `11.723` (which is `12005/1024`).\n  //\n  // The supported units are a subset of [The Unified Code for Units of\n  // Measure](https://unitsofmeasure.org/ucum.html) standard:\n  //\n  // **Basic units (UNIT)**\n  //\n  // * `bit`   bit\n  // * `By`    byte\n  // * `s`     second\n  // * `min`   minute\n  // * `h`     hour\n  // * `d`     day\n  // * `1`     dimensionless\n  //\n  // **Prefixes (PREFIX)**\n  //\n  // * `k`     kilo    (10^3)\n  // * `M`     mega    (10^6)\n  // * `G`     giga    (10^9)\n  // * `T`     tera    (10^12)\n  // * `P`     peta    (10^15)\n  // * `E`     exa     (10^18)\n  // * `Z`     zetta   (10^21)\n  // * `Y`     yotta   (10^24)\n  //\n  // * `m`     milli   (10^-3)\n  // * `u`     micro   (10^-6)\n  // * `n`     nano    (10^-9)\n  // * `p`     pico    (10^-12)\n  // * `f`     femto   (10^-15)\n  // * `a`     atto    (10^-18)\n  // * `z`     zepto   (10^-21)\n  // * `y`     yocto   (10^-24)\n  //\n  // * `Ki`    kibi    (2^10)\n  // * `Mi`    mebi    (2^20)\n  // * `Gi`    gibi    (2^30)\n  // * `Ti`    tebi    (2^40)\n  // * `Pi`    pebi    (2^50)\n  //\n  // **Grammar**\n  //\n  // The grammar also includes these connectors:\n  //\n  // * `/`    division or ratio (as an infix operator). For examples,\n  //          `kBy/{email}` or `MiBy/10ms` (although you should almost never\n  //          have `/s` in a metric `unit`; rates should always be computed at\n  //          query time from the underlying cumulative or delta value).\n  // * `.`    multiplication or composition (as an infix operator). For\n  //          examples, `GBy.d` or `k{watt}.h`.\n  //\n  // The grammar for a unit is as follows:\n  //\n  //     Expression = Component { \".\" Component } { \"/\" Component } ;\n  //\n  //     Component = ( [ PREFIX ] UNIT | \"%\" ) [ Annotation ]\n  //               | Annotation\n  //               | \"1\"\n  //               ;\n  //\n  //     Annotation = \"{\" NAME \"}\" ;\n  //\n  // Notes:\n  //\n  // * `Annotation` is just a comment if it follows a `UNIT`. If the annotation\n  //    is used alone, then the unit is equivalent to `1`. For examples,\n  //    `{request}/s == 1/s`, `By{transmitted}/s == By/s`.\n  // * `NAME` is a sequence of non-blank printable ASCII characters not\n  //    containing `{` or `}`.\n  // * `1` represents a unitary [dimensionless\n  //    unit](https://en.wikipedia.org/wiki/Dimensionless_quantity) of 1, such\n  //    as in `1/s`. It is typically used when none of the basic units are\n  //    appropriate. For example, \"new users per day\" can be represented as\n  //    `1/d` or `{new-users}/d` (and a metric value `5` would mean \"5 new\n  //    users). Alternatively, \"thousands of page views per day\" would be\n  //    represented as `1000/d` or `k1/d` or `k{page_views}/d` (and a metric\n  //    value of `5.3` would mean \"5300 page views per day\").\n  // * `%` represents dimensionless value of 1/100, and annotates values giving\n  //    a percentage (so the metric values are typically in the range of 0..100,\n  //    and a metric value `3` means \"3 percent\").\n  // * `10^2.%` indicates a metric contains a ratio, typically in the range\n  //    0..1, that will be multiplied by 100 and displayed as a percentage\n  //    (so a metric value `0.03` means \"3 percent\").\n  string unit = 5;\n\n  // A detailed description of the metric, which can be used in documentation.\n  string description = 6;\n\n  // A concise name for the metric, which can be displayed in user interfaces.\n  // Use sentence case without an ending period, for example \"Request count\".\n  // This field is optional but it is recommended to be set for any metrics\n  // associated with user-visible concepts, such as Quota.\n  string display_name = 7;\n\n  // Optional. Metadata which can be used to guide usage of the metric.\n  MetricDescriptorMetadata metadata = 10;\n\n  // Optional. The launch stage of the metric definition.\n  LaunchStage launch_stage = 12;\n\n  // Read-only. If present, then a [time\n  // series][google.monitoring.v3.TimeSeries], which is identified partially by\n  // a metric type and a\n  // [MonitoredResourceDescriptor][google.api.MonitoredResourceDescriptor], that\n  // is associated with this metric type can only be associated with one of the\n  // monitored resource types listed here.\n  repeated string monitored_resource_types = 13;\n}\n\n// A specific metric, identified by specifying values for all of the\n// labels of a [`MetricDescriptor`][google.api.MetricDescriptor].\nmessage Metric {\n  // An existing metric type, see\n  // [google.api.MetricDescriptor][google.api.MetricDescriptor]. For example,\n  // `custom.googleapis.com/invoice/paid/amount`.\n  string type = 3;\n\n  // The set of label values that uniquely identify this metric. All\n  // labels listed in the `MetricDescriptor` must be assigned values.\n  map<string, string> labels = 2;\n}\n","size_bytes":10605},"build/extracted-include-protos/main/google/api/config_change.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/configchange;configchange\";\noption java_multiple_files = true;\noption java_outer_classname = \"ConfigChangeProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Output generated from semantically comparing two versions of a service\n// configuration.\n//\n// Includes detailed information about a field that have changed with\n// applicable advice about potential consequences for the change, such as\n// backwards-incompatibility.\nmessage ConfigChange {\n  // Object hierarchy path to the change, with levels separated by a '.'\n  // character. For repeated fields, an applicable unique identifier field is\n  // used for the index (usually selector, name, or id). For maps, the term\n  // 'key' is used. If the field has no unique identifier, the numeric index\n  // is used.\n  // Examples:\n  // - visibility.rules[selector==\"google.LibraryService.ListBooks\"].restriction\n  // - quota.metric_rules[selector==\"google\"].metric_costs[key==\"reads\"].value\n  // - logging.producer_destinations[0]\n  string element = 1;\n\n  // Value of the changed object in the old Service configuration,\n  // in JSON format. This field will not be populated if ChangeType == ADDED.\n  string old_value = 2;\n\n  // Value of the changed object in the new Service configuration,\n  // in JSON format. This field will not be populated if ChangeType == REMOVED.\n  string new_value = 3;\n\n  // The type for this change, either ADDED, REMOVED, or MODIFIED.\n  ChangeType change_type = 4;\n\n  // Collection of advice provided for this change, useful for determining the\n  // possible impact of this change.\n  repeated Advice advices = 5;\n}\n\n// Generated advice about this change, used for providing more\n// information about how a change will affect the existing service.\nmessage Advice {\n  // Useful description for why this advice was applied and what actions should\n  // be taken to mitigate any implied risks.\n  string description = 2;\n}\n\n// Classifies set of possible modifications to an object in the service\n// configuration.\nenum ChangeType {\n  // No value was provided.\n  CHANGE_TYPE_UNSPECIFIED = 0;\n\n  // The changed object exists in the 'new' service configuration, but not\n  // in the 'old' service configuration.\n  ADDED = 1;\n\n  // The changed object exists in the 'old' service configuration, but not\n  // in the 'new' service configuration.\n  REMOVED = 2;\n\n  // The changed object exists in both service configurations, but its value\n  // is different.\n  MODIFIED = 3;\n}\n","size_bytes":3166},"build/extracted-include-protos/main/google/api/monitoring.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"MonitoringProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Monitoring configuration of the service.\n//\n// The example below shows how to configure monitored resources and metrics\n// for monitoring. In the example, a monitored resource and two metrics are\n// defined. The `library.googleapis.com/book/returned_count` metric is sent\n// to both producer and consumer projects, whereas the\n// `library.googleapis.com/book/num_overdue` metric is only sent to the\n// consumer project.\n//\n//     monitored_resources:\n//     - type: library.googleapis.com/Branch\n//       display_name: \"Library Branch\"\n//       description: \"A branch of a library.\"\n//       launch_stage: GA\n//       labels:\n//       - key: resource_container\n//         description: \"The Cloud container (ie. project id) for the Branch.\"\n//       - key: location\n//         description: \"The location of the library branch.\"\n//       - key: branch_id\n//         description: \"The id of the branch.\"\n//     metrics:\n//     - name: library.googleapis.com/book/returned_count\n//       display_name: \"Books Returned\"\n//       description: \"The count of books that have been returned.\"\n//       launch_stage: GA\n//       metric_kind: DELTA\n//       value_type: INT64\n//       unit: \"1\"\n//       labels:\n//       - key: customer_id\n//         description: \"The id of the customer.\"\n//     - name: library.googleapis.com/book/num_overdue\n//       display_name: \"Books Overdue\"\n//       description: \"The current number of overdue books.\"\n//       launch_stage: GA\n//       metric_kind: GAUGE\n//       value_type: INT64\n//       unit: \"1\"\n//       labels:\n//       - key: customer_id\n//         description: \"The id of the customer.\"\n//     monitoring:\n//       producer_destinations:\n//       - monitored_resource: library.googleapis.com/Branch\n//         metrics:\n//         - library.googleapis.com/book/returned_count\n//       consumer_destinations:\n//       - monitored_resource: library.googleapis.com/Branch\n//         metrics:\n//         - library.googleapis.com/book/returned_count\n//         - library.googleapis.com/book/num_overdue\nmessage Monitoring {\n  // Configuration of a specific monitoring destination (the producer project\n  // or the consumer project).\n  message MonitoringDestination {\n    // The monitored resource type. The type must be defined in\n    // [Service.monitored_resources][google.api.Service.monitored_resources]\n    // section.\n    string monitored_resource = 1;\n\n    // Types of the metrics to report to this monitoring destination.\n    // Each type must be defined in\n    // [Service.metrics][google.api.Service.metrics] section.\n    repeated string metrics = 2;\n  }\n\n  // Monitoring configurations for sending metrics to the producer project.\n  // There can be multiple producer destinations. A monitored resource type may\n  // appear in multiple monitoring destinations if different aggregations are\n  // needed for different sets of metrics associated with that monitored\n  // resource type. A monitored resource and metric pair may only be used once\n  // in the Monitoring configuration.\n  repeated MonitoringDestination producer_destinations = 1;\n\n  // Monitoring configurations for sending metrics to the consumer project.\n  // There can be multiple consumer destinations. A monitored resource type may\n  // appear in multiple monitoring destinations if different aggregations are\n  // needed for different sets of metrics associated with that monitored\n  // resource type. A monitored resource and metric pair may only be used once\n  // in the Monitoring configuration.\n  repeated MonitoringDestination consumer_destinations = 2;\n}\n","size_bytes":4457},"build/extracted-include-protos/main/google/protobuf/api.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\nimport \"google/protobuf/source_context.proto\";\nimport \"google/protobuf/type.proto\";\n\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"ApiProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\noption go_package = \"google.golang.org/protobuf/types/known/apipb\";\n\n// Api is a light-weight descriptor for an API Interface.\n//\n// Interfaces are also described as \"protocol buffer services\" in some contexts,\n// such as by the \"service\" keyword in a .proto file, but they are different\n// from API Services, which represent a concrete implementation of an interface\n// as opposed to simply a description of methods and bindings. They are also\n// sometimes simply referred to as \"APIs\" in other contexts, such as the name of\n// this message itself. See https://cloud.google.com/apis/design/glossary for\n// detailed terminology.\nmessage Api {\n  // The fully qualified name of this interface, including package name\n  // followed by the interface's simple name.\n  string name = 1;\n\n  // The methods of this interface, in unspecified order.\n  repeated Method methods = 2;\n\n  // Any metadata attached to the interface.\n  repeated Option options = 3;\n\n  // A version string for this interface. If specified, must have the form\n  // `major-version.minor-version`, as in `1.10`. If the minor version is\n  // omitted, it defaults to zero. If the entire version field is empty, the\n  // major version is derived from the package name, as outlined below. If the\n  // field is not empty, the version in the package name will be verified to be\n  // consistent with what is provided here.\n  //\n  // The versioning schema uses [semantic\n  // versioning](http://semver.org) where the major version number\n  // indicates a breaking change and the minor version an additive,\n  // non-breaking change. Both version numbers are signals to users\n  // what to expect from different versions, and should be carefully\n  // chosen based on the product plan.\n  //\n  // The major version is also reflected in the package name of the\n  // interface, which must end in `v<major-version>`, as in\n  // `google.feature.v1`. For major versions 0 and 1, the suffix can\n  // be omitted. Zero major versions must only be used for\n  // experimental, non-GA interfaces.\n  //\n  string version = 4;\n\n  // Source context for the protocol buffer service represented by this\n  // message.\n  SourceContext source_context = 5;\n\n  // Included interfaces. See [Mixin][].\n  repeated Mixin mixins = 6;\n\n  // The source syntax of the service.\n  Syntax syntax = 7;\n}\n\n// Method represents a method of an API interface.\nmessage Method {\n  // The simple name of this method.\n  string name = 1;\n\n  // A URL of the input message type.\n  string request_type_url = 2;\n\n  // If true, the request is streamed.\n  bool request_streaming = 3;\n\n  // The URL of the output message type.\n  string response_type_url = 4;\n\n  // If true, the response is streamed.\n  bool response_streaming = 5;\n\n  // Any metadata attached to the method.\n  repeated Option options = 6;\n\n  // The source syntax of this method.\n  Syntax syntax = 7;\n}\n\n// Declares an API Interface to be included in this interface. The including\n// interface must redeclare all the methods from the included interface, but\n// documentation and options are inherited as follows:\n//\n// - If after comment and whitespace stripping, the documentation\n//   string of the redeclared method is empty, it will be inherited\n//   from the original method.\n//\n// - Each annotation belonging to the service config (http,\n//   visibility) which is not set in the redeclared method will be\n//   inherited.\n//\n// - If an http annotation is inherited, the path pattern will be\n//   modified as follows. Any version prefix will be replaced by the\n//   version of the including interface plus the [root][] path if\n//   specified.\n//\n// Example of a simple mixin:\n//\n//     package google.acl.v1;\n//     service AccessControl {\n//       // Get the underlying ACL object.\n//       rpc GetAcl(GetAclRequest) returns (Acl) {\n//         option (google.api.http).get = \"/v1/{resource=**}:getAcl\";\n//       }\n//     }\n//\n//     package google.storage.v2;\n//     service Storage {\n//       rpc GetAcl(GetAclRequest) returns (Acl);\n//\n//       // Get a data record.\n//       rpc GetData(GetDataRequest) returns (Data) {\n//         option (google.api.http).get = \"/v2/{resource=**}\";\n//       }\n//     }\n//\n// Example of a mixin configuration:\n//\n//     apis:\n//     - name: google.storage.v2.Storage\n//       mixins:\n//       - name: google.acl.v1.AccessControl\n//\n// The mixin construct implies that all methods in `AccessControl` are\n// also declared with same name and request/response types in\n// `Storage`. A documentation generator or annotation processor will\n// see the effective `Storage.GetAcl` method after inherting\n// documentation and annotations as follows:\n//\n//     service Storage {\n//       // Get the underlying ACL object.\n//       rpc GetAcl(GetAclRequest) returns (Acl) {\n//         option (google.api.http).get = \"/v2/{resource=**}:getAcl\";\n//       }\n//       ...\n//     }\n//\n// Note how the version in the path pattern changed from `v1` to `v2`.\n//\n// If the `root` field in the mixin is specified, it should be a\n// relative path under which inherited HTTP paths are placed. Example:\n//\n//     apis:\n//     - name: google.storage.v2.Storage\n//       mixins:\n//       - name: google.acl.v1.AccessControl\n//         root: acls\n//\n// This implies the following inherited HTTP annotation:\n//\n//     service Storage {\n//       // Get the underlying ACL object.\n//       rpc GetAcl(GetAclRequest) returns (Acl) {\n//         option (google.api.http).get = \"/v2/acls/{resource=**}:getAcl\";\n//       }\n//       ...\n//     }\nmessage Mixin {\n  // The fully qualified name of the interface which is included.\n  string name = 1;\n\n  // If non-empty specifies a path under which inherited HTTP paths\n  // are rooted.\n  string root = 2;\n}\n","size_bytes":7728},"build/extracted-include-protos/main/google/api/context.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"ContextProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Context` defines which contexts an API requests.\n//\n// Example:\n//\n//     context:\n//       rules:\n//       - selector: \"*\"\n//         requested:\n//         - google.rpc.context.ProjectContext\n//         - google.rpc.context.OriginContext\n//\n// The above specifies that all methods in the API request\n// `google.rpc.context.ProjectContext` and\n// `google.rpc.context.OriginContext`.\n//\n// Available context types are defined in package\n// `google.rpc.context`.\n//\n// This also provides mechanism to allowlist any protobuf message extension that\n// can be sent in grpc metadata using x-goog-ext-<extension_id>-bin and\n// x-goog-ext-<extension_id>-jspb format. For example, list any service\n// specific protobuf types that can appear in grpc metadata as follows in your\n// yaml file:\n//\n// Example:\n//\n//     context:\n//       rules:\n//        - selector: \"google.example.library.v1.LibraryService.CreateBook\"\n//          allowed_request_extensions:\n//          - google.foo.v1.NewExtension\n//          allowed_response_extensions:\n//          - google.foo.v1.NewExtension\n//\n// You can also specify extension ID instead of fully qualified extension name\n// here.\nmessage Context {\n  // A list of RPC context rules that apply to individual API methods.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated ContextRule rules = 1;\n}\n\n// A context rule provides information about the context for an individual API\n// element.\nmessage ContextRule {\n  // Selects the methods to which this rule applies.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // A list of full type names of requested contexts.\n  repeated string requested = 2;\n\n  // A list of full type names of provided contexts.\n  repeated string provided = 3;\n\n  // A list of full type names or extension IDs of extensions allowed in grpc\n  // side channel from client to backend.\n  repeated string allowed_request_extensions = 4;\n\n  // A list of full type names or extension IDs of extensions allowed in grpc\n  // side channel from backend to client.\n  repeated string allowed_response_extensions = 5;\n}\n","size_bytes":3067},"build/extracted-include-protos/test/google/api/log.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/api/label.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"LogProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// A description of a log type. Example in YAML format:\n//\n//     - name: library.googleapis.com/activity_history\n//       description: The history of borrowing and returning library items.\n//       display_name: Activity\n//       labels:\n//       - key: /customer_id\n//         description: Identifier of a library customer\nmessage LogDescriptor {\n  // The name of the log. It must be less than 512 characters long and can\n  // include the following characters: upper- and lower-case alphanumeric\n  // characters [A-Za-z0-9], and punctuation characters including\n  // slash, underscore, hyphen, period [/_-.].\n  string name = 1;\n\n  // The set of labels that are available to describe a specific log entry.\n  // Runtime requests that contain labels not specified here are\n  // considered invalid.\n  repeated LabelDescriptor labels = 2;\n\n  // A human-readable description of this log. This information appears in\n  // the documentation and can contain details.\n  string description = 3;\n\n  // The human-readable name for this log. This information appears on\n  // the user interface and should be concise.\n  string display_name = 4;\n}\n","size_bytes":2043},"src/main/java/com/spiketrade/backend/SpikeLabeler.java":{"content":"package com.spiketrade.backend;\n\npublic class SpikeLabeler {\n    \n    public void labelSpike(SpikeRecord spike, double futurePrice) {\n        double profitPct = ((futurePrice - spike.priceAtSpike) / spike.priceAtSpike) * 100.0;\n        spike.outcomeProfitable = profitPct > 0.5;\n        spike.outcomeScore = profitPct;\n    }\n    \n    public boolean wasSpikeProfitable(SpikeRecord spike, double entryPrice, double exitPrice) {\n        double profitPct = ((exitPrice - entryPrice) / entryPrice) * 100.0;\n        return profitPct > 0.5;\n    }\n}\n","size_bytes":542},"build/extracted-include-protos/test/google/api/routing.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/descriptor.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/annotations;annotations\";\noption java_multiple_files = true;\noption java_outer_classname = \"RoutingProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\nextend google.protobuf.MethodOptions {\n  // See RoutingRule.\n  google.api.RoutingRule routing = 72295729;\n}\n\n// Specifies the routing information that should be sent along with the request\n// in the form of routing header.\n// **NOTE:** All service configuration rules follow the \"last one wins\" order.\n//\n// The examples below will apply to an RPC which has the following request type:\n//\n// Message Definition:\n//\n//     message Request {\n//       // The name of the Table\n//       // Values can be of the following formats:\n//       // - `projects/<project>/tables/<table>`\n//       // - `projects/<project>/instances/<instance>/tables/<table>`\n//       // - `region/<region>/zones/<zone>/tables/<table>`\n//       string table_name = 1;\n//\n//       // This value specifies routing for replication.\n//       // It can be in the following formats:\n//       // - `profiles/<profile_id>`\n//       // - a legacy `profile_id` that can be any string\n//       string app_profile_id = 2;\n//     }\n//\n// Example message:\n//\n//     {\n//       table_name: projects/proj_foo/instances/instance_bar/table/table_baz,\n//       app_profile_id: profiles/prof_qux\n//     }\n//\n// The routing header consists of one or multiple key-value pairs. Every key\n// and value must be percent-encoded, and joined together in the format of\n// `key1=value1&key2=value2`.\n// In the examples below I am skipping the percent-encoding for readablity.\n//\n// Example 1\n//\n// Extracting a field from the request to put into the routing header\n// unchanged, with the key equal to the field name.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // Take the `app_profile_id`.\n//       routing_parameters {\n//         field: \"app_profile_id\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params: app_profile_id=profiles/prof_qux\n//\n// Example 2\n//\n// Extracting a field from the request to put into the routing header\n// unchanged, with the key different from the field name.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // Take the `app_profile_id`, but name it `routing_id` in the header.\n//       routing_parameters {\n//         field: \"app_profile_id\"\n//         path_template: \"{routing_id=**}\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params: routing_id=profiles/prof_qux\n//\n// Example 3\n//\n// Extracting a field from the request to put into the routing\n// header, while matching a path template syntax on the field's value.\n//\n// NB: it is more useful to send nothing than to send garbage for the purpose\n// of dynamic routing, since garbage pollutes cache. Thus the matching.\n//\n// Sub-example 3a\n//\n// The field matches the template.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // Take the `table_name`, if it's well-formed (with project-based\n//       // syntax).\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{table_name=projects/*/instances/*/**}\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params:\n//     table_name=projects/proj_foo/instances/instance_bar/table/table_baz\n//\n// Sub-example 3b\n//\n// The field does not match the template.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // Take the `table_name`, if it's well-formed (with region-based\n//       // syntax).\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{table_name=regions/*/zones/*/**}\"\n//       }\n//     };\n//\n// result:\n//\n//     <no routing header will be sent>\n//\n// Sub-example 3c\n//\n// Multiple alternative conflictingly named path templates are\n// specified. The one that matches is used to construct the header.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // Take the `table_name`, if it's well-formed, whether\n//       // using the region- or projects-based syntax.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{table_name=regions/*/zones/*/**}\"\n//       }\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{table_name=projects/*/instances/*/**}\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params:\n//     table_name=projects/proj_foo/instances/instance_bar/table/table_baz\n//\n// Example 4\n//\n// Extracting a single routing header key-value pair by matching a\n// template syntax on (a part of) a single request field.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // Take just the project id from the `table_name` field.\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{routing_id=projects/*}/**\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params: routing_id=projects/proj_foo\n//\n// Example 5\n//\n// Extracting a single routing header key-value pair by matching\n// several conflictingly named path templates on (parts of) a single request\n// field. The last template to match \"wins\" the conflict.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // If the `table_name` does not have instances information,\n//       // take just the project id for routing.\n//       // Otherwise take project + instance.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{routing_id=projects/*}/**\"\n//       }\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{routing_id=projects/*/instances/*}/**\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params:\n//     routing_id=projects/proj_foo/instances/instance_bar\n//\n// Example 6\n//\n// Extracting multiple routing header key-value pairs by matching\n// several non-conflicting path templates on (parts of) a single request field.\n//\n// Sub-example 6a\n//\n// Make the templates strict, so that if the `table_name` does not\n// have an instance information, nothing is sent.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // The routing code needs two keys instead of one composite\n//       // but works only for the tables with the \"project-instance\" name\n//       // syntax.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{project_id=projects/*}/instances/*/**\"\n//       }\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"projects/*/{instance_id=instances/*}/**\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params:\n//     project_id=projects/proj_foo&instance_id=instances/instance_bar\n//\n// Sub-example 6b\n//\n// Make the templates loose, so that if the `table_name` does not\n// have an instance information, just the project id part is sent.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // The routing code wants two keys instead of one composite\n//       // but will work with just the `project_id` for tables without\n//       // an instance in the `table_name`.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{project_id=projects/*}/**\"\n//       }\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"projects/*/{instance_id=instances/*}/**\"\n//       }\n//     };\n//\n// result (is the same as 6a for our example message because it has the instance\n// information):\n//\n//     x-goog-request-params:\n//     project_id=projects/proj_foo&instance_id=instances/instance_bar\n//\n// Example 7\n//\n// Extracting multiple routing header key-value pairs by matching\n// several path templates on multiple request fields.\n//\n// NB: note that here there is no way to specify sending nothing if one of the\n// fields does not match its template. E.g. if the `table_name` is in the wrong\n// format, the `project_id` will not be sent, but the `routing_id` will be.\n// The backend routing code has to be aware of that and be prepared to not\n// receive a full complement of keys if it expects multiple.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // The routing needs both `project_id` and `routing_id`\n//       // (from the `app_profile_id` field) for routing.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{project_id=projects/*}/**\"\n//       }\n//       routing_parameters {\n//         field: \"app_profile_id\"\n//         path_template: \"{routing_id=**}\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params:\n//     project_id=projects/proj_foo&routing_id=profiles/prof_qux\n//\n// Example 8\n//\n// Extracting a single routing header key-value pair by matching\n// several conflictingly named path templates on several request fields. The\n// last template to match \"wins\" the conflict.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // The `routing_id` can be a project id or a region id depending on\n//       // the table name format, but only if the `app_profile_id` is not set.\n//       // If `app_profile_id` is set it should be used instead.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{routing_id=projects/*}/**\"\n//       }\n//       routing_parameters {\n//          field: \"table_name\"\n//          path_template: \"{routing_id=regions/*}/**\"\n//       }\n//       routing_parameters {\n//         field: \"app_profile_id\"\n//         path_template: \"{routing_id=**}\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params: routing_id=profiles/prof_qux\n//\n// Example 9\n//\n// Bringing it all together.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // For routing both `table_location` and a `routing_id` are needed.\n//       //\n//       // table_location can be either an instance id or a region+zone id.\n//       //\n//       // For `routing_id`, take the value of `app_profile_id`\n//       // - If it's in the format `profiles/<profile_id>`, send\n//       // just the `<profile_id>` part.\n//       // - If it's any other literal, send it as is.\n//       // If the `app_profile_id` is empty, and the `table_name` starts with\n//       // the project_id, send that instead.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"projects/*/{table_location=instances/*}/tables/*\"\n//       }\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{table_location=regions/*/zones/*}/tables/*\"\n//       }\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{routing_id=projects/*}/**\"\n//       }\n//       routing_parameters {\n//         field: \"app_profile_id\"\n//         path_template: \"{routing_id=**}\"\n//       }\n//       routing_parameters {\n//         field: \"app_profile_id\"\n//         path_template: \"profiles/{routing_id=*}\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params:\n//     table_location=instances/instance_bar&routing_id=prof_qux\nmessage RoutingRule {\n  // A collection of Routing Parameter specifications.\n  // **NOTE:** If multiple Routing Parameters describe the same key\n  // (via the `path_template` field or via the `field` field when\n  // `path_template` is not provided), \"last one wins\" rule\n  // determines which Parameter gets used.\n  // See the examples for more details.\n  repeated RoutingParameter routing_parameters = 2;\n}\n\n// A projection from an input message to the GRPC or REST header.\nmessage RoutingParameter {\n  // A request field to extract the header key-value pair from.\n  string field = 1;\n\n  // A pattern matching the key-value field. Optional.\n  // If not specified, the whole field specified in the `field` field will be\n  // taken as value, and its name used as key. If specified, it MUST contain\n  // exactly one named segment (along with any number of unnamed segments) The\n  // pattern will be matched over the field specified in the `field` field, then\n  // if the match is successful:\n  // - the name of the single named segment will be used as a header name,\n  // - the match value of the segment will be used as a header value;\n  // if the match is NOT successful, nothing will be sent.\n  //\n  // Example:\n  //\n  //               -- This is a field in the request message\n  //              |   that the header value will be extracted from.\n  //              |\n  //              |                     -- This is the key name in the\n  //              |                    |   routing header.\n  //              V                    |\n  //     field: \"table_name\"           v\n  //     path_template: \"projects/*/{table_location=instances/*}/tables/*\"\n  //                                                ^            ^\n  //                                                |            |\n  //       In the {} brackets is the pattern that --             |\n  //       specifies what to extract from the                    |\n  //       field as a value to be sent.                          |\n  //                                                             |\n  //      The string in the field must match the whole pattern --\n  //      before brackets, inside brackets, after brackets.\n  //\n  // When looking at this specific example, we can see that:\n  // - A key-value pair with the key `table_location`\n  //   and the value matching `instances/*` should be added\n  //   to the x-goog-request-params routing header.\n  // - The value is extracted from the request message's `table_name` field\n  //   if it matches the full pattern specified:\n  //   `projects/*/instances/*/tables/*`.\n  //\n  // **NB:** If the `path_template` field is not provided, the key name is\n  // equal to the field name, and the whole field should be sent as a value.\n  // This makes the pattern for the field and the value functionally equivalent\n  // to `**`, and the configuration\n  //\n  //     {\n  //       field: \"table_name\"\n  //     }\n  //\n  // is a functionally equivalent shorthand to:\n  //\n  //     {\n  //       field: \"table_name\"\n  //       path_template: \"{table_name=**}\"\n  //     }\n  //\n  // See Example 1 for more details.\n  string path_template = 2;\n}\n","size_bytes":14929},"src/main/java/com/spiketrade/backend/ConnectionStatus.java":{"content":"package com.spiketrade.backend;\n\nimport java.time.Instant;\n\npublic class ConnectionStatus {\n    public ConnectionState state;\n    public boolean usingFallback;\n    public String fallbackReason;\n    public int consecutiveFailures;\n    public Instant lastSuccessfulRequest;\n    public Stats stats;\n    \n    public static class Stats {\n        public int questradeRequests = 0;\n        public int questradeFailures = 0;\n        public int yahooRequests = 0;\n        public int yahooFailures = 0;\n        public int failovers = 0;\n        public int reconnections = 0;\n    }\n    \n    public ConnectionStatus() {\n        this.state = ConnectionState.DISCONNECTED;\n        this.usingFallback = false;\n        this.fallbackReason = \"\";\n        this.consecutiveFailures = 0;\n        this.lastSuccessfulRequest = Instant.now();\n        this.stats = new Stats();\n    }\n}\n","size_bytes":861},"build/extracted-include-protos/main/google/type/decimal.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/decimal;decimal\";\noption java_multiple_files = true;\noption java_outer_classname = \"DecimalProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// A representation of a decimal value, such as 2.5. Clients may convert values\n// into language-native decimal formats, such as Java's [BigDecimal][] or\n// Python's [decimal.Decimal][].\n//\n// [BigDecimal]:\n// https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html\n// [decimal.Decimal]: https://docs.python.org/3/library/decimal.html\nmessage Decimal {\n  // The decimal value, as a string.\n  //\n  // The string representation consists of an optional sign, `+` (`U+002B`)\n  // or `-` (`U+002D`), followed by a sequence of zero or more decimal digits\n  // (\"the integer\"), optionally followed by a fraction, optionally followed\n  // by an exponent.\n  //\n  // The fraction consists of a decimal point followed by zero or more decimal\n  // digits. The string must contain at least one digit in either the integer\n  // or the fraction. The number formed by the sign, the integer and the\n  // fraction is referred to as the significand.\n  //\n  // The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`)\n  // followed by one or more decimal digits.\n  //\n  // Services **should** normalize decimal values before storing them by:\n  //\n  //   - Removing an explicitly-provided `+` sign (`+2.5` -> `2.5`).\n  //   - Replacing a zero-length integer value with `0` (`.5` -> `0.5`).\n  //   - Coercing the exponent character to lower-case (`2.5E8` -> `2.5e8`).\n  //   - Removing an explicitly-provided zero exponent (`2.5e0` -> `2.5`).\n  //\n  // Services **may** perform additional normalization based on its own needs\n  // and the internal decimal implementation selected, such as shifting the\n  // decimal point and exponent value together (example: `2.5e-1` <-> `0.25`).\n  // Additionally, services **may** preserve trailing zeroes in the fraction\n  // to indicate increased precision, but are not required to do so.\n  //\n  // Note that only the `.` character is supported to divide the integer\n  // and the fraction; `,` **should not** be supported regardless of locale.\n  // Additionally, thousand separators **should not** be supported. If a\n  // service does support them, values **must** be normalized.\n  //\n  // The ENBF grammar is:\n  //\n  //     DecimalString =\n  //       [Sign] Significand [Exponent];\n  //\n  //     Sign = '+' | '-';\n  //\n  //     Significand =\n  //       Digits ['.'] [Digits] | [Digits] '.' Digits;\n  //\n  //     Exponent = ('e' | 'E') [Sign] Digits;\n  //\n  //     Digits = { '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' };\n  //\n  // Services **should** clearly document the range of supported values, the\n  // maximum supported precision (total number of digits), and, if applicable,\n  // the scale (number of digits after the decimal point), as well as how it\n  // behaves when receiving out-of-bounds values.\n  //\n  // Services **may** choose to accept values passed as input even when the\n  // value has a higher precision or scale than the service supports, and\n  // **should** round the value to fit the supported scale. Alternatively, the\n  // service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC)\n  // if precision would be lost.\n  //\n  // Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in\n  // gRPC) if the service receives a value outside of the supported range.\n  string value = 1;\n}\n","size_bytes":4213},"build/extracted-include-protos/main/google/api/error_reason.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/error_reason;error_reason\";\noption java_multiple_files = true;\noption java_outer_classname = \"ErrorReasonProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Defines the supported values for `google.rpc.ErrorInfo.reason` for the\n// `googleapis.com` error domain. This error domain is reserved for [Service\n// Infrastructure](https://cloud.google.com/service-infrastructure/docs/overview).\n// For each error info of this domain, the metadata key \"service\" refers to the\n// logical identifier of an API service, such as \"pubsub.googleapis.com\". The\n// \"consumer\" refers to the entity that consumes an API Service. It typically is\n// a Google project that owns the client application or the server resource,\n// such as \"projects/123\". Other metadata keys are specific to each error\n// reason. For more information, see the definition of the specific error\n// reason.\nenum ErrorReason {\n  // Do not use this default value.\n  ERROR_REASON_UNSPECIFIED = 0;\n\n  // The request is calling a disabled service for a consumer.\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" contacting\n  // \"pubsub.googleapis.com\" service which is disabled:\n  //\n  //     { \"reason\": \"SERVICE_DISABLED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"pubsub.googleapis.com\"\n  //       }\n  //     }\n  //\n  // This response indicates the \"pubsub.googleapis.com\" has been disabled in\n  // \"projects/123\".\n  SERVICE_DISABLED = 1;\n\n  // The request whose associated billing account is disabled.\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to contact\n  // \"pubsub.googleapis.com\" service because the associated billing account is\n  // disabled:\n  //\n  //     { \"reason\": \"BILLING_DISABLED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"pubsub.googleapis.com\"\n  //       }\n  //     }\n  //\n  // This response indicates the billing account associated has been disabled.\n  BILLING_DISABLED = 2;\n\n  // The request is denied because the provided [API\n  // key](https://cloud.google.com/docs/authentication/api-keys) is invalid. It\n  // may be in a bad format, cannot be found, or has been expired).\n  //\n  // Example of an ErrorInfo when the request is contacting\n  // \"storage.googleapis.com\" service with an invalid API key:\n  //\n  //     { \"reason\": \"API_KEY_INVALID\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //       }\n  //     }\n  API_KEY_INVALID = 3;\n\n  // The request is denied because it violates [API key API\n  // restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_api_restrictions).\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to call the\n  // \"storage.googleapis.com\" service because this service is restricted in the\n  // API key:\n  //\n  //     { \"reason\": \"API_KEY_SERVICE_BLOCKED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  API_KEY_SERVICE_BLOCKED = 4;\n\n  // The request is denied because it violates [API key HTTP\n  // restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_http_restrictions).\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to call\n  // \"storage.googleapis.com\" service because the http referrer of the request\n  // violates API key HTTP restrictions:\n  //\n  //     { \"reason\": \"API_KEY_HTTP_REFERRER_BLOCKED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\",\n  //       }\n  //     }\n  API_KEY_HTTP_REFERRER_BLOCKED = 7;\n\n  // The request is denied because it violates [API key IP address\n  // restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_application_restrictions).\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to call\n  // \"storage.googleapis.com\" service because the caller IP of the request\n  // violates API key IP address restrictions:\n  //\n  //     { \"reason\": \"API_KEY_IP_ADDRESS_BLOCKED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\",\n  //       }\n  //     }\n  API_KEY_IP_ADDRESS_BLOCKED = 8;\n\n  // The request is denied because it violates [API key Android application\n  // restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_application_restrictions).\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to call\n  // \"storage.googleapis.com\" service because the request from the Android apps\n  // violates the API key Android application restrictions:\n  //\n  //     { \"reason\": \"API_KEY_ANDROID_APP_BLOCKED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  API_KEY_ANDROID_APP_BLOCKED = 9;\n\n  // The request is denied because it violates [API key iOS application\n  // restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_application_restrictions).\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to call\n  // \"storage.googleapis.com\" service because the request from the iOS apps\n  // violates the API key iOS application restrictions:\n  //\n  //     { \"reason\": \"API_KEY_IOS_APP_BLOCKED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  API_KEY_IOS_APP_BLOCKED = 13;\n\n  // The request is denied because there is not enough rate quota for the\n  // consumer.\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to contact\n  // \"pubsub.googleapis.com\" service because consumer's rate quota usage has\n  // reached the maximum value set for the quota limit\n  // \"ReadsPerMinutePerProject\" on the quota metric\n  // \"pubsub.googleapis.com/read_requests\":\n  //\n  //     { \"reason\": \"RATE_LIMIT_EXCEEDED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"pubsub.googleapis.com\",\n  //         \"quota_metric\": \"pubsub.googleapis.com/read_requests\",\n  //         \"quota_limit\": \"ReadsPerMinutePerProject\"\n  //       }\n  //     }\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" checks quota on\n  // the service \"dataflow.googleapis.com\" and hits the organization quota\n  // limit \"DefaultRequestsPerMinutePerOrganization\" on the metric\n  // \"dataflow.googleapis.com/default_requests\".\n  //\n  //     { \"reason\": \"RATE_LIMIT_EXCEEDED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"dataflow.googleapis.com\",\n  //         \"quota_metric\": \"dataflow.googleapis.com/default_requests\",\n  //         \"quota_limit\": \"DefaultRequestsPerMinutePerOrganization\"\n  //       }\n  //     }\n  RATE_LIMIT_EXCEEDED = 5;\n\n  // The request is denied because there is not enough resource quota for the\n  // consumer.\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to contact\n  // \"compute.googleapis.com\" service because consumer's resource quota usage\n  // has reached the maximum value set for the quota limit \"VMsPerProject\"\n  // on the quota metric \"compute.googleapis.com/vms\":\n  //\n  //     { \"reason\": \"RESOURCE_QUOTA_EXCEEDED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"compute.googleapis.com\",\n  //         \"quota_metric\": \"compute.googleapis.com/vms\",\n  //         \"quota_limit\": \"VMsPerProject\"\n  //       }\n  //     }\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" checks resource\n  // quota on the service \"dataflow.googleapis.com\" and hits the organization\n  // quota limit \"jobs-per-organization\" on the metric\n  // \"dataflow.googleapis.com/job_count\".\n  //\n  //     { \"reason\": \"RESOURCE_QUOTA_EXCEEDED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"dataflow.googleapis.com\",\n  //         \"quota_metric\": \"dataflow.googleapis.com/job_count\",\n  //         \"quota_limit\": \"jobs-per-organization\"\n  //       }\n  //     }\n  RESOURCE_QUOTA_EXCEEDED = 6;\n\n  // The request whose associated billing account address is in a tax restricted\n  // location, violates the local tax restrictions when creating resources in\n  // the restricted region.\n  //\n  // Example of an ErrorInfo when creating the Cloud Storage Bucket in the\n  // container \"projects/123\" under a tax restricted region\n  // \"locations/asia-northeast3\":\n  //\n  //     { \"reason\": \"LOCATION_TAX_POLICY_VIOLATED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"location\": \"locations/asia-northeast3\"\n  //       }\n  //     }\n  //\n  // This response indicates creating the Cloud Storage Bucket in\n  // \"locations/asia-northeast3\" violates the location tax restriction.\n  LOCATION_TAX_POLICY_VIOLATED = 10;\n\n  // The request is denied because the caller does not have required permission\n  // on the user project \"projects/123\" or the user project is invalid. For more\n  // information, check the [userProject System\n  // Parameters](https://cloud.google.com/apis/docs/system-parameters).\n  //\n  // Example of an ErrorInfo when the caller is calling Cloud Storage service\n  // with insufficient permissions on the user project:\n  //\n  //     { \"reason\": \"USER_PROJECT_DENIED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  USER_PROJECT_DENIED = 11;\n\n  // The request is denied because the consumer \"projects/123\" is suspended due\n  // to Terms of Service(Tos) violations. Check [Project suspension\n  // guidelines](https://cloud.google.com/resource-manager/docs/project-suspension-guidelines)\n  // for more information.\n  //\n  // Example of an ErrorInfo when calling Cloud Storage service with the\n  // suspended consumer \"projects/123\":\n  //\n  //     { \"reason\": \"CONSUMER_SUSPENDED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  CONSUMER_SUSPENDED = 12;\n\n  // The request is denied because the associated consumer is invalid. It may be\n  // in a bad format, cannot be found, or have been deleted.\n  //\n  // Example of an ErrorInfo when calling Cloud Storage service with the\n  // invalid consumer \"projects/123\":\n  //\n  //     { \"reason\": \"CONSUMER_INVALID\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  CONSUMER_INVALID = 14;\n\n  // The request is denied because it violates [VPC Service\n  // Controls](https://cloud.google.com/vpc-service-controls/docs/overview).\n  // The 'uid' field is a random generated identifier that customer can use it\n  // to search the audit log for a request rejected by VPC Service Controls. For\n  // more information, please refer [VPC Service Controls\n  // Troubleshooting](https://cloud.google.com/vpc-service-controls/docs/troubleshooting#unique-id)\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to call\n  // Cloud Storage service because the request is prohibited by the VPC Service\n  // Controls.\n  //\n  //     { \"reason\": \"SECURITY_POLICY_VIOLATED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"uid\": \"123456789abcde\",\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  SECURITY_POLICY_VIOLATED = 15;\n\n  // The request is denied because the provided access token has expired.\n  //\n  // Example of an ErrorInfo when the request is calling Cloud Storage service\n  // with an expired access token:\n  //\n  //     { \"reason\": \"ACCESS_TOKEN_EXPIRED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\"\n  //       }\n  //     }\n  ACCESS_TOKEN_EXPIRED = 16;\n\n  // The request is denied because the provided access token doesn't have at\n  // least one of the acceptable scopes required for the API. Please check\n  // [OAuth 2.0 Scopes for Google\n  // APIs](https://developers.google.com/identity/protocols/oauth2/scopes) for\n  // the list of the OAuth 2.0 scopes that you might need to request to access\n  // the API.\n  //\n  // Example of an ErrorInfo when the request is calling Cloud Storage service\n  // with an access token that is missing required scopes:\n  //\n  //     { \"reason\": \"ACCESS_TOKEN_SCOPE_INSUFFICIENT\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\"\n  //       }\n  //     }\n  ACCESS_TOKEN_SCOPE_INSUFFICIENT = 17;\n\n  // The request is denied because the account associated with the provided\n  // access token is in an invalid state, such as disabled or deleted.\n  // For more information, see https://cloud.google.com/docs/authentication.\n  //\n  // Warning: For privacy reasons, the server may not be able to disclose the\n  // email address for some accounts. The client MUST NOT depend on the\n  // availability of the `email` attribute.\n  //\n  // Example of an ErrorInfo when the request is to the Cloud Storage API with\n  // an access token that is associated with a disabled or deleted [service\n  // account](http://cloud/iam/docs/service-accounts):\n  //\n  //     { \"reason\": \"ACCOUNT_STATE_INVALID\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\",\n  //         \"email\": \"user@123.iam.gserviceaccount.com\"\n  //       }\n  //     }\n  ACCOUNT_STATE_INVALID = 18;\n\n  // The request is denied because the type of the provided access token is not\n  // supported by the API being called.\n  //\n  // Example of an ErrorInfo when the request is to the Cloud Storage API with\n  // an unsupported token type.\n  //\n  //     { \"reason\": \"ACCESS_TOKEN_TYPE_UNSUPPORTED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\"\n  //       }\n  //     }\n  ACCESS_TOKEN_TYPE_UNSUPPORTED = 19;\n\n  // The request is denied because the request doesn't have any authentication\n  // credentials. For more information regarding the supported authentication\n  // strategies for Google Cloud APIs, see\n  // https://cloud.google.com/docs/authentication.\n  //\n  // Example of an ErrorInfo when the request is to the Cloud Storage API\n  // without any authentication credentials.\n  //\n  //     { \"reason\": \"CREDENTIALS_MISSING\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\"\n  //       }\n  //     }\n  CREDENTIALS_MISSING = 20;\n\n  // The request is denied because the provided project owning the resource\n  // which acts as the [API\n  // consumer](https://cloud.google.com/apis/design/glossary#api_consumer) is\n  // invalid. It may be in a bad format or empty.\n  //\n  // Example of an ErrorInfo when the request is to the Cloud Functions API,\n  // but the offered resource project in the request in a bad format which can't\n  // perform the ListFunctions method.\n  //\n  //     { \"reason\": \"RESOURCE_PROJECT_INVALID\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"cloudfunctions.googleapis.com\",\n  //         \"method\":\n  //         \"google.cloud.functions.v1.CloudFunctionsService.ListFunctions\"\n  //       }\n  //     }\n  RESOURCE_PROJECT_INVALID = 21;\n\n  // The request is denied because the provided session cookie is missing,\n  // invalid or failed to decode.\n  //\n  // Example of an ErrorInfo when the request is calling Cloud Storage service\n  // with a SID cookie which can't be decoded.\n  //\n  //     { \"reason\": \"SESSION_COOKIE_INVALID\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\",\n  //         \"cookie\": \"SID\"\n  //       }\n  //     }\n  SESSION_COOKIE_INVALID = 23;\n\n  // The request is denied because the user is from a Google Workspace customer\n  // that blocks their users from accessing a particular service.\n  //\n  // Example scenario: https://support.google.com/a/answer/9197205?hl=en\n  //\n  // Example of an ErrorInfo when access to Google Cloud Storage service is\n  // blocked by the Google Workspace administrator:\n  //\n  //     { \"reason\": \"USER_BLOCKED_BY_ADMIN\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"storage.googleapis.com\",\n  //         \"method\": \"google.storage.v1.Storage.GetObject\",\n  //       }\n  //     }\n  USER_BLOCKED_BY_ADMIN = 24;\n\n  // The request is denied because the resource service usage is restricted\n  // by administrators according to the organization policy constraint.\n  // For more information see\n  // https://cloud.google.com/resource-manager/docs/organization-policy/restricting-services.\n  //\n  // Example of an ErrorInfo when access to Google Cloud Storage service is\n  // restricted by Resource Usage Restriction policy:\n  //\n  //     { \"reason\": \"RESOURCE_USAGE_RESTRICTION_VIOLATED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/project-123\",\n  //         \"service\": \"storage.googleapis.com\"\n  //       }\n  //     }\n  RESOURCE_USAGE_RESTRICTION_VIOLATED = 25;\n\n  // Unimplemented. Do not use.\n  //\n  // The request is denied because it contains unsupported system parameters in\n  // URL query parameters or HTTP headers. For more information,\n  // see https://cloud.google.com/apis/docs/system-parameters\n  //\n  // Example of an ErrorInfo when access \"pubsub.googleapis.com\" service with\n  // a request header of \"x-goog-user-ip\":\n  //\n  //     { \"reason\": \"SYSTEM_PARAMETER_UNSUPPORTED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"service\": \"pubsub.googleapis.com\"\n  //         \"parameter\": \"x-goog-user-ip\"\n  //       }\n  //     }\n  SYSTEM_PARAMETER_UNSUPPORTED = 26;\n\n  // The request is denied because it violates Org Restriction: the requested\n  // resource does not belong to allowed organizations specified in\n  // \"X-Goog-Allowed-Resources\" header.\n  //\n  // Example of an ErrorInfo when accessing a GCP resource that is restricted by\n  // Org Restriction for \"pubsub.googleapis.com\" service.\n  //\n  // {\n  //   reason: \"ORG_RESTRICTION_VIOLATION\"\n  //   domain: \"googleapis.com\"\n  //   metadata {\n  //     \"consumer\":\"projects/123456\"\n  //     \"service\": \"pubsub.googleapis.com\"\n  //   }\n  // }\n  ORG_RESTRICTION_VIOLATION = 27;\n\n  // The request is denied because \"X-Goog-Allowed-Resources\" header is in a bad\n  // format.\n  //\n  // Example of an ErrorInfo when\n  // accessing \"pubsub.googleapis.com\" service with an invalid\n  // \"X-Goog-Allowed-Resources\" request header.\n  //\n  // {\n  //   reason: \"ORG_RESTRICTION_HEADER_INVALID\"\n  //   domain: \"googleapis.com\"\n  //   metadata {\n  //     \"consumer\":\"projects/123456\"\n  //     \"service\": \"pubsub.googleapis.com\"\n  //   }\n  // }\n  ORG_RESTRICTION_HEADER_INVALID = 28;\n\n  // Unimplemented. Do not use.\n  //\n  // The request is calling a service that is not visible to the consumer.\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" contacting\n  //  \"pubsub.googleapis.com\" service which is not visible to the consumer.\n  //\n  //     { \"reason\": \"SERVICE_NOT_VISIBLE\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"pubsub.googleapis.com\"\n  //       }\n  //     }\n  //\n  // This response indicates the \"pubsub.googleapis.com\" is not visible to\n  // \"projects/123\" (or it may not exist).\n  SERVICE_NOT_VISIBLE = 29;\n\n  // The request is related to a project for which GCP access is suspended.\n  //\n  // Example of an ErrorInfo when the consumer \"projects/123\" fails to contact\n  // \"pubsub.googleapis.com\" service because GCP access is suspended:\n  //\n  //     { \"reason\": \"GCP_SUSPENDED\",\n  //       \"domain\": \"googleapis.com\",\n  //       \"metadata\": {\n  //         \"consumer\": \"projects/123\",\n  //         \"service\": \"pubsub.googleapis.com\"\n  //       }\n  //     }\n  //\n  // This response indicates the associated GCP account has been suspended.\n  GCP_SUSPENDED = 30;\n}\n","size_bytes":21934},"build/extracted-include-protos/test/google/protobuf/field_mask.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"FieldMaskProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\noption go_package = \"google.golang.org/protobuf/types/known/fieldmaskpb\";\noption cc_enable_arenas = true;\n\n// `FieldMask` represents a set of symbolic field paths, for example:\n//\n//     paths: \"f.a\"\n//     paths: \"f.b.d\"\n//\n// Here `f` represents a field in some root message, `a` and `b`\n// fields in the message found in `f`, and `d` a field found in the\n// message in `f.b`.\n//\n// Field masks are used to specify a subset of fields that should be\n// returned by a get operation or modified by an update operation.\n// Field masks also have a custom JSON encoding (see below).\n//\n// # Field Masks in Projections\n//\n// When used in the context of a projection, a response message or\n// sub-message is filtered by the API to only contain those fields as\n// specified in the mask. For example, if the mask in the previous\n// example is applied to a response message as follows:\n//\n//     f {\n//       a : 22\n//       b {\n//         d : 1\n//         x : 2\n//       }\n//       y : 13\n//     }\n//     z: 8\n//\n// The result will not contain specific values for fields x,y and z\n// (their value will be set to the default, and omitted in proto text\n// output):\n//\n//\n//     f {\n//       a : 22\n//       b {\n//         d : 1\n//       }\n//     }\n//\n// A repeated field is not allowed except at the last position of a\n// paths string.\n//\n// If a FieldMask object is not present in a get operation, the\n// operation applies to all fields (as if a FieldMask of all fields\n// had been specified).\n//\n// Note that a field mask does not necessarily apply to the\n// top-level response message. In case of a REST get operation, the\n// field mask applies directly to the response, but in case of a REST\n// list operation, the mask instead applies to each individual message\n// in the returned resource list. In case of a REST custom method,\n// other definitions may be used. Where the mask applies will be\n// clearly documented together with its declaration in the API.  In\n// any case, the effect on the returned resource/resources is required\n// behavior for APIs.\n//\n// # Field Masks in Update Operations\n//\n// A field mask in update operations specifies which fields of the\n// targeted resource are going to be updated. The API is required\n// to only change the values of the fields as specified in the mask\n// and leave the others untouched. If a resource is passed in to\n// describe the updated values, the API ignores the values of all\n// fields not covered by the mask.\n//\n// If a repeated field is specified for an update operation, new values will\n// be appended to the existing repeated field in the target resource. Note that\n// a repeated field is only allowed in the last position of a `paths` string.\n//\n// If a sub-message is specified in the last position of the field mask for an\n// update operation, then new value will be merged into the existing sub-message\n// in the target resource.\n//\n// For example, given the target message:\n//\n//     f {\n//       b {\n//         d: 1\n//         x: 2\n//       }\n//       c: [1]\n//     }\n//\n// And an update message:\n//\n//     f {\n//       b {\n//         d: 10\n//       }\n//       c: [2]\n//     }\n//\n// then if the field mask is:\n//\n//  paths: [\"f.b\", \"f.c\"]\n//\n// then the result will be:\n//\n//     f {\n//       b {\n//         d: 10\n//         x: 2\n//       }\n//       c: [1, 2]\n//     }\n//\n// An implementation may provide options to override this default behavior for\n// repeated and message fields.\n//\n// In order to reset a field's value to the default, the field must\n// be in the mask and set to the default value in the provided resource.\n// Hence, in order to reset all fields of a resource, provide a default\n// instance of the resource and set all fields in the mask, or do\n// not provide a mask as described below.\n//\n// If a field mask is not present on update, the operation applies to\n// all fields (as if a field mask of all fields has been specified).\n// Note that in the presence of schema evolution, this may mean that\n// fields the client does not know and has therefore not filled into\n// the request will be reset to their default. If this is unwanted\n// behavior, a specific service may require a client to always specify\n// a field mask, producing an error if not.\n//\n// As with get operations, the location of the resource which\n// describes the updated values in the request message depends on the\n// operation kind. In any case, the effect of the field mask is\n// required to be honored by the API.\n//\n// ## Considerations for HTTP REST\n//\n// The HTTP kind of an update operation which uses a field mask must\n// be set to PATCH instead of PUT in order to satisfy HTTP semantics\n// (PUT must only be used for full updates).\n//\n// # JSON Encoding of Field Masks\n//\n// In JSON, a field mask is encoded as a single string where paths are\n// separated by a comma. Fields name in each path are converted\n// to/from lower-camel naming conventions.\n//\n// As an example, consider the following message declarations:\n//\n//     message Profile {\n//       User user = 1;\n//       Photo photo = 2;\n//     }\n//     message User {\n//       string display_name = 1;\n//       string address = 2;\n//     }\n//\n// In proto a field mask for `Profile` may look as such:\n//\n//     mask {\n//       paths: \"user.display_name\"\n//       paths: \"photo\"\n//     }\n//\n// In JSON, the same mask is represented as below:\n//\n//     {\n//       mask: \"user.displayName,photo\"\n//     }\n//\n// # Field Masks and Oneof Fields\n//\n// Field masks treat fields in oneofs just as regular fields. Consider the\n// following message:\n//\n//     message SampleMessage {\n//       oneof test_oneof {\n//         string name = 4;\n//         SubMessage sub_message = 9;\n//       }\n//     }\n//\n// The field mask can be:\n//\n//     mask {\n//       paths: \"name\"\n//     }\n//\n// Or:\n//\n//     mask {\n//       paths: \"sub_message\"\n//     }\n//\n// Note that oneof type names (\"test_oneof\" in this case) cannot be used in\n// paths.\n//\n// ## Field Mask Verification\n//\n// The implementation of any API method which has a FieldMask type field in the\n// request should verify the included field paths, and return an\n// `INVALID_ARGUMENT` error if any path is unmappable.\nmessage FieldMask {\n  // The set of field mask paths.\n  repeated string paths = 1;\n}\n","size_bytes":8185},"src/main/java/com/spiketrade/model/OptimizationResult.java":{"content":"package com.spiketrade.model;\n\nimport java.util.Map;\n\npublic class OptimizationResult {\n    private double totalProfit;\n    private double winRate;\n    private int totalTrades;\n    private Map<String, Object> settings;\n    private String signalRulesConfig;\n    \n    private double validationProfit = 0.0;\n    private double validationWinRate = 0.0;\n    private int validationTradeCount = 0;\n    \n    public OptimizationResult(double totalProfit, double winRate, int totalTrades, \n                             Map<String, Object> settings, String signalRulesConfig) {\n        this.totalProfit = totalProfit;\n        this.winRate = winRate;\n        this.totalTrades = totalTrades;\n        this.settings = settings;\n        this.signalRulesConfig = signalRulesConfig;\n    }\n    \n    public double getTotalProfit() { return totalProfit; }\n    public double getWinRate() { return winRate; }\n    public int getTotalTrades() { return totalTrades; }\n    public int getTradeCount() { return totalTrades; }\n    public Map<String, Object> getSettings() { return settings; }\n    public String getSignalRulesConfig() { return signalRulesConfig; }\n    \n    public double getValidationProfit() { return validationProfit; }\n    public void setValidationProfit(double validationProfit) { this.validationProfit = validationProfit; }\n    public double getValidationWinRate() { return validationWinRate; }\n    public void setValidationWinRate(double validationWinRate) { this.validationWinRate = validationWinRate; }\n    public int getValidationTradeCount() { return validationTradeCount; }\n    public void setValidationTradeCount(int validationTradeCount) { this.validationTradeCount = validationTradeCount; }\n}\n","size_bytes":1693},"build/extracted-include-protos/main/google/api/launch_stage.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api;api\";\noption java_multiple_files = true;\noption java_outer_classname = \"LaunchStageProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// The launch stage as defined by [Google Cloud Platform\n// Launch Stages](https://cloud.google.com/terms/launch-stages).\nenum LaunchStage {\n  // Do not use this default value.\n  LAUNCH_STAGE_UNSPECIFIED = 0;\n\n  // The feature is not yet implemented. Users can not use it.\n  UNIMPLEMENTED = 6;\n\n  // Prelaunch features are hidden from users and are only visible internally.\n  PRELAUNCH = 7;\n\n  // Early Access features are limited to a closed group of testers. To use\n  // these features, you must sign up in advance and sign a Trusted Tester\n  // agreement (which includes confidentiality provisions). These features may\n  // be unstable, changed in backward-incompatible ways, and are not\n  // guaranteed to be released.\n  EARLY_ACCESS = 1;\n\n  // Alpha is a limited availability test for releases before they are cleared\n  // for widespread use. By Alpha, all significant design issues are resolved\n  // and we are in the process of verifying functionality. Alpha customers\n  // need to apply for access, agree to applicable terms, and have their\n  // projects allowlisted. Alpha releases don't have to be feature complete,\n  // no SLAs are provided, and there are no technical support obligations, but\n  // they will be far enough along that customers can actually use them in\n  // test environments or for limited-use tests -- just like they would in\n  // normal production cases.\n  ALPHA = 2;\n\n  // Beta is the point at which we are ready to open a release for any\n  // customer to use. There are no SLA or technical support obligations in a\n  // Beta release. Products will be complete from a feature perspective, but\n  // may have some open outstanding issues. Beta releases are suitable for\n  // limited production use cases.\n  BETA = 3;\n\n  // GA features are open to all developers and are considered stable and\n  // fully qualified for production use.\n  GA = 4;\n\n  // Deprecated features are scheduled to be shut down and removed. For more\n  // information, see the \"Deprecation Policy\" section of our [Terms of\n  // Service](https://cloud.google.com/terms/)\n  // and the [Google Cloud Platform Subject to the Deprecation\n  // Policy](https://cloud.google.com/terms/deprecation) documentation.\n  DEPRECATED = 5;\n}\n","size_bytes":3083},"build/extracted-include-protos/test/google/api/label.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/api/label;label\";\noption java_multiple_files = true;\noption java_outer_classname = \"LabelProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// A description of a label.\nmessage LabelDescriptor {\n  // Value types that can be used as label values.\n  enum ValueType {\n    // A variable-length string. This is the default.\n    STRING = 0;\n\n    // Boolean; true or false.\n    BOOL = 1;\n\n    // A 64-bit signed integer.\n    INT64 = 2;\n  }\n\n  // The label key.\n  string key = 1;\n\n  // The type of data that can be assigned to the label.\n  ValueType value_type = 2;\n\n  // A human-readable description for the label.\n  string description = 3;\n}\n","size_bytes":1389},"src/main/java/com/spiketrade/model/TickerData.java":{"content":"package com.spiketrade.model;\n\npublic class TickerData {\n    private String symbol;\n    private Double price;\n    private Double probability;\n    private String position;\n    private String profitLoss;\n    private Double rsi;\n    private Double priceRoc;\n    private Double volumeRoc;\n    private Double obvRoc;\n    private Double mfi;\n    private Double bollingerPosition;\n    private Double percentB;\n    private Double vwap;\n    private Double atr;\n    \n    private Double macdHistogram;\n    private Double ema9;\n    private Double ema20;\n    private Double ema50;\n    private Double stochK;\n    private Double stochD;\n    private Double rvol;\n    private Boolean volumeSpike;\n    \n    public TickerData(String symbol, Double price) {\n        this.symbol = symbol;\n        this.price = price;\n        this.probability = 0.0;\n        this.position = \"\";\n        this.profitLoss = \"\";\n        this.rsi = 0.0;\n        this.priceRoc = 0.0;\n        this.volumeRoc = 0.0;\n        this.obvRoc = 0.0;\n        this.mfi = 0.0;\n        this.bollingerPosition = 0.0;\n        this.percentB = 0.0;\n        this.vwap = 0.0;\n        this.atr = 0.0;\n        this.macdHistogram = 0.0;\n        this.ema9 = 0.0;\n        this.ema20 = 0.0;\n        this.ema50 = 0.0;\n        this.stochK = 0.0;\n        this.stochD = 0.0;\n        this.rvol = 0.0;\n        this.volumeSpike = false;\n    }\n    \n    public TickerData(String symbol, Double price, Double probability, String position, String profitLoss,\n                     Double rsi, Double priceRoc, Double volumeRoc, Double obvRoc, Double mfi, \n                     Double bollingerPosition, Double percentB, Double vwap, Double atr,\n                     Double macdHistogram, Double ema9, Double ema20, Double ema50,\n                     Double stochK, Double stochD, Double rvol, Boolean volumeSpike) {\n        this.symbol = symbol;\n        this.price = price;\n        this.probability = probability;\n        this.position = position;\n        this.profitLoss = profitLoss;\n        this.rsi = rsi;\n        this.priceRoc = priceRoc;\n        this.volumeRoc = volumeRoc;\n        this.obvRoc = obvRoc;\n        this.mfi = mfi;\n        this.bollingerPosition = bollingerPosition;\n        this.percentB = percentB;\n        this.vwap = vwap;\n        this.atr = atr;\n        this.macdHistogram = macdHistogram;\n        this.ema9 = ema9;\n        this.ema20 = ema20;\n        this.ema50 = ema50;\n        this.stochK = stochK;\n        this.stochD = stochD;\n        this.rvol = rvol;\n        this.volumeSpike = volumeSpike;\n    }\n    \n    public String getSymbol() { return symbol; }\n    \n    public Double getPrice() { return price; }\n    public void setCurrentPrice(Double price) { this.price = price; }\n    \n    public Double getProbability() { return probability; }\n    public void setSignalProbability(Double probability) { this.probability = probability; }\n    \n    public String getPosition() { return position; }\n    public String getProfitLoss() { return profitLoss; }\n    \n    public Double getRsi() { return rsi; }\n    public void setRsi(Double rsi) { this.rsi = rsi; }\n    \n    public Double getPriceRoc() { return priceRoc; }\n    public void setPriceRoc(Double priceRoc) { this.priceRoc = priceRoc; }\n    \n    public Double getVolumeRoc() { return volumeRoc; }\n    public void setVolumeRoc(Double volumeRoc) { this.volumeRoc = volumeRoc; }\n    public void setVolume(Double volume) { }\n    \n    public Double getObvRoc() { return obvRoc; }\n    public void setObvRoc(Double obvRoc) { this.obvRoc = obvRoc; }\n    \n    public Double getMfi() { return mfi; }\n    public void setMfi(Double mfi) { this.mfi = mfi; }\n    \n    public Double getBollingerPosition() { return bollingerPosition; }\n    public void setBollingerPosition(Double bollingerPosition) { this.bollingerPosition = bollingerPosition; }\n    \n    public Double getPercentB() { return percentB; }\n    public void setPercentB(Double percentB) { this.percentB = percentB; }\n    \n    public Double getVwap() { return vwap; }\n    public void setVwap(Double vwap) { this.vwap = vwap; }\n    \n    public Double getAtr() { return atr; }\n    public void setAtr(Double atr) { this.atr = atr; }\n    \n    public Double getMacdHistogram() { return macdHistogram; }\n    public void setMacdHistogram(Double macdHistogram) { this.macdHistogram = macdHistogram; }\n    \n    public Double getEma9() { return ema9; }\n    public void setEma9(Double ema9) { this.ema9 = ema9; }\n    \n    public Double getEma20() { return ema20; }\n    public void setEma20(Double ema20) { this.ema20 = ema20; }\n    \n    public Double getEma50() { return ema50; }\n    public void setEma50(Double ema50) { this.ema50 = ema50; }\n    \n    public Double getStochK() { return stochK; }\n    public void setStochK(Double stochK) { this.stochK = stochK; }\n    \n    public Double getStochD() { return stochD; }\n    public void setStochD(Double stochD) { this.stochD = stochD; }\n    \n    public Double getRvol() { return rvol; }\n    public void setRvol(Double rvol) { this.rvol = rvol; }\n    \n    public Boolean getVolumeSpike() { return volumeSpike; }\n    public void setVolumeSpike(Boolean volumeSpike) { this.volumeSpike = volumeSpike; }\n}\n","size_bytes":5178},"build/extracted-include-protos/main/google/api/annotations.proto":{"content":"// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/api/http.proto\";\nimport \"google/protobuf/descriptor.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/annotations;annotations\";\noption java_multiple_files = true;\noption java_outer_classname = \"AnnotationsProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\nextend google.protobuf.MethodOptions {\n  // See `HttpRule`.\n  HttpRule http = 72295728;\n}\n","size_bytes":1045},"src/main/java/com/spiketrade/backend/Trade.java":{"content":"package com.spiketrade.backend;\n\nimport java.time.Instant;\n\npublic class Trade {\n    public String symbol;\n    public double entryPrice;\n    public double exitPrice;\n    public int shares;\n    public Instant entryTime;\n    public Instant exitTime;\n    public double profitLoss;\n    public double profitLossPct;\n    public boolean isOpen;\n    \n    public double predictedGainTarget;\n    public int predictedTimeToTargetMinutes;\n    public double predictionConfidence;\n    \n    public Trade() {\n        this.isOpen = true;\n        this.entryTime = Instant.now();\n        this.predictedGainTarget = 0.0;\n        this.predictedTimeToTargetMinutes = -1;\n        this.predictionConfidence = 0.0;\n    }\n}\n","size_bytes":698},"build/extracted-include-protos/main/google/cloud/extended_operations.proto":{"content":"// Copyright 2021 Google LLC.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// This file contains custom annotations that are used by GAPIC generators to\n// handle Long Running Operation methods (LRO) that are NOT compliant with\n// https://google.aip.dev/151. These annotations are public for technical\n// reasons only. Please DO NOT USE them in your protos.\nsyntax = \"proto3\";\n\npackage google.cloud;\n\nimport \"google/protobuf/descriptor.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/cloud/extendedops;extendedops\";\noption java_multiple_files = true;\noption java_outer_classname = \"ExtendedOperationsProto\";\noption java_package = \"com.google.cloud\";\noption objc_class_prefix = \"GAPI\";\n\n// FieldOptions to match corresponding fields in the initial request,\n// polling request and operation response messages.\n//\n// Example:\n//\n// In an API-specific operation message:\n//\n//     message MyOperation {\n//       string http_error_message = 1 [(operation_field) = ERROR_MESSAGE];\n//       int32 http_error_status_code = 2 [(operation_field) = ERROR_CODE];\n//       string id = 3 [(operation_field) = NAME];\n//       Status status = 4 [(operation_field) = STATUS];\n//     }\n//\n// In a polling request message (the one which is used to poll for an LRO\n// status):\n//\n//     message MyPollingRequest {\n//       string operation = 1 [(operation_response_field) = \"id\"];\n//       string project = 2;\n//       string region = 3;\n//     }\n//\n// In an initial request message (the one which starts an LRO):\n//\n//    message MyInitialRequest {\n//      string my_project = 2 [(operation_request_field) = \"project\"];\n//      string my_region = 3 [(operation_request_field) = \"region\"];\n//    }\n//\nextend google.protobuf.FieldOptions {\n  // A field annotation that maps fields in an API-specific Operation object to\n  // their standard counterparts in google.longrunning.Operation. See\n  // OperationResponseMapping enum definition.\n  OperationResponseMapping operation_field = 1149;\n\n  // A field annotation that maps fields in the initial request message\n  // (the one which started the LRO) to their counterparts in the polling\n  // request message. For non-standard LRO, the polling response may be missing\n  // some of the information needed to make a subsequent polling request. The\n  // missing information (for example, project or region ID) is contained in the\n  // fields of the initial request message that this annotation must be applied\n  // to. The string value of the annotation corresponds to the name of the\n  // counterpart field in the polling request message that the annotated field's\n  // value will be copied to.\n  string operation_request_field = 1150;\n\n  // A field annotation that maps fields in the polling request message to their\n  // counterparts in the initial and/or polling response message. The initial\n  // and the polling methods return an API-specific Operation object. Some of\n  // the fields from that response object must be reused in the subsequent\n  // request (like operation name/ID) to fully identify the polled operation.\n  // This annotation must be applied to the fields in the polling request\n  // message, the string value of the annotation must correspond to the name of\n  // the counterpart field in the Operation response object whose value will be\n  // copied to the annotated field.\n  string operation_response_field = 1151;\n}\n\n// MethodOptions to identify the actual service and method used for operation\n// status polling.\n//\n// Example:\n//\n// In a method, which starts an LRO:\n//\n//     service MyService {\n//       rpc Foo(MyInitialRequest) returns (MyOperation) {\n//         option (operation_service) = \"MyPollingService\";\n//       }\n//     }\n//\n// In a polling method:\n//\n//     service MyPollingService {\n//       rpc Get(MyPollingRequest) returns (MyOperation) {\n//         option (operation_polling_method) = true;\n//       }\n//     }\nextend google.protobuf.MethodOptions {\n  // A method annotation that maps an LRO method (the one which starts an LRO)\n  // to the service, which will be used to poll for the operation status. The\n  // annotation must be applied to the method which starts an LRO, the string\n  // value of the annotation must correspond to the name of the service used to\n  // poll for the operation status.\n  string operation_service = 1249;\n\n  // A method annotation that marks methods that can be used for polling\n  // operation status (e.g. the MyPollingService.Get(MyPollingRequest) method).\n  bool operation_polling_method = 1250;\n}\n\n// An enum to be used to mark the essential (for polling) fields in an\n// API-specific Operation object. A custom Operation object may contain many\n// different fields, but only few of them are essential to conduct a successful\n// polling process.\nenum OperationResponseMapping {\n  // Do not use.\n  UNDEFINED = 0;\n\n  // A field in an API-specific (custom) Operation object which carries the same\n  // meaning as google.longrunning.Operation.name.\n  NAME = 1;\n\n  // A field in an API-specific (custom) Operation object which carries the same\n  // meaning as google.longrunning.Operation.done. If the annotated field is of\n  // an enum type, `annotated_field_name == EnumType.DONE` semantics should be\n  // equivalent to `Operation.done == true`. If the annotated field is of type\n  // boolean, then it should follow the same semantics as Operation.done.\n  // Otherwise, a non-empty value should be treated as `Operation.done == true`.\n  STATUS = 2;\n\n  // A field in an API-specific (custom) Operation object which carries the same\n  // meaning as google.longrunning.Operation.error.code.\n  ERROR_CODE = 3;\n\n  // A field in an API-specific (custom) Operation object which carries the same\n  // meaning as google.longrunning.Operation.error.message.\n  ERROR_MESSAGE = 4;\n}","size_bytes":6308},"build/extracted-include-protos/test/google/protobuf/duration.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/protobuf/types/known/durationpb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"DurationProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\n\n// A Duration represents a signed, fixed-length span of time represented\n// as a count of seconds and fractions of seconds at nanosecond\n// resolution. It is independent of any calendar and concepts like \"day\"\n// or \"month\". It is related to Timestamp in that the difference between\n// two Timestamp values is a Duration and it can be added or subtracted\n// from a Timestamp. Range is approximately +-10,000 years.\n//\n// # Examples\n//\n// Example 1: Compute Duration from two Timestamps in pseudo code.\n//\n//     Timestamp start = ...;\n//     Timestamp end = ...;\n//     Duration duration = ...;\n//\n//     duration.seconds = end.seconds - start.seconds;\n//     duration.nanos = end.nanos - start.nanos;\n//\n//     if (duration.seconds < 0 && duration.nanos > 0) {\n//       duration.seconds += 1;\n//       duration.nanos -= 1000000000;\n//     } else if (duration.seconds > 0 && duration.nanos < 0) {\n//       duration.seconds -= 1;\n//       duration.nanos += 1000000000;\n//     }\n//\n// Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.\n//\n//     Timestamp start = ...;\n//     Duration duration = ...;\n//     Timestamp end = ...;\n//\n//     end.seconds = start.seconds + duration.seconds;\n//     end.nanos = start.nanos + duration.nanos;\n//\n//     if (end.nanos < 0) {\n//       end.seconds -= 1;\n//       end.nanos += 1000000000;\n//     } else if (end.nanos >= 1000000000) {\n//       end.seconds += 1;\n//       end.nanos -= 1000000000;\n//     }\n//\n// Example 3: Compute Duration from datetime.timedelta in Python.\n//\n//     td = datetime.timedelta(days=3, minutes=10)\n//     duration = Duration()\n//     duration.FromTimedelta(td)\n//\n// # JSON Mapping\n//\n// In JSON format, the Duration type is encoded as a string rather than an\n// object, where the string ends in the suffix \"s\" (indicating seconds) and\n// is preceded by the number of seconds, with nanoseconds expressed as\n// fractional seconds. For example, 3 seconds with 0 nanoseconds should be\n// encoded in JSON format as \"3s\", while 3 seconds and 1 nanosecond should\n// be expressed in JSON format as \"3.000000001s\", and 3 seconds and 1\n// microsecond should be expressed in JSON format as \"3.000001s\".\n//\nmessage Duration {\n  // Signed seconds of the span of time. Must be from -315,576,000,000\n  // to +315,576,000,000 inclusive. Note: these bounds are computed from:\n  // 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years\n  int64 seconds = 1;\n\n  // Signed fractions of a second at nanosecond resolution of the span\n  // of time. Durations less than one second are represented with a 0\n  // `seconds` field and a positive or negative `nanos` field. For durations\n  // of one second or more, a non-zero value for the `nanos` field must be\n  // of the same sign as the `seconds` field. Must be from -999,999,999\n  // to +999,999,999 inclusive.\n  int32 nanos = 2;\n}\n","size_bytes":4892},"build/extracted-include-protos/test/google/type/fraction.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption go_package = \"google.golang.org/genproto/googleapis/type/fraction;fraction\";\noption java_multiple_files = true;\noption java_outer_classname = \"FractionProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a fraction in terms of a numerator divided by a denominator.\nmessage Fraction {\n  // The numerator in the fraction, e.g. 2 in 2/3.\n  int64 numerator = 1;\n\n  // The value by which the numerator is divided, e.g. 3 in 2/3. Must be\n  // positive.\n  int64 denominator = 2;\n}\n","size_bytes":1156},"build/extracted-include-protos/main/google/api/routing.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/descriptor.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/annotations;annotations\";\noption java_multiple_files = true;\noption java_outer_classname = \"RoutingProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\nextend google.protobuf.MethodOptions {\n  // See RoutingRule.\n  google.api.RoutingRule routing = 72295729;\n}\n\n// Specifies the routing information that should be sent along with the request\n// in the form of routing header.\n// **NOTE:** All service configuration rules follow the \"last one wins\" order.\n//\n// The examples below will apply to an RPC which has the following request type:\n//\n// Message Definition:\n//\n//     message Request {\n//       // The name of the Table\n//       // Values can be of the following formats:\n//       // - `projects/<project>/tables/<table>`\n//       // - `projects/<project>/instances/<instance>/tables/<table>`\n//       // - `region/<region>/zones/<zone>/tables/<table>`\n//       string table_name = 1;\n//\n//       // This value specifies routing for replication.\n//       // It can be in the following formats:\n//       // - `profiles/<profile_id>`\n//       // - a legacy `profile_id` that can be any string\n//       string app_profile_id = 2;\n//     }\n//\n// Example message:\n//\n//     {\n//       table_name: projects/proj_foo/instances/instance_bar/table/table_baz,\n//       app_profile_id: profiles/prof_qux\n//     }\n//\n// The routing header consists of one or multiple key-value pairs. Every key\n// and value must be percent-encoded, and joined together in the format of\n// `key1=value1&key2=value2`.\n// In the examples below I am skipping the percent-encoding for readablity.\n//\n// Example 1\n//\n// Extracting a field from the request to put into the routing header\n// unchanged, with the key equal to the field name.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // Take the `app_profile_id`.\n//       routing_parameters {\n//         field: \"app_profile_id\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params: app_profile_id=profiles/prof_qux\n//\n// Example 2\n//\n// Extracting a field from the request to put into the routing header\n// unchanged, with the key different from the field name.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // Take the `app_profile_id`, but name it `routing_id` in the header.\n//       routing_parameters {\n//         field: \"app_profile_id\"\n//         path_template: \"{routing_id=**}\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params: routing_id=profiles/prof_qux\n//\n// Example 3\n//\n// Extracting a field from the request to put into the routing\n// header, while matching a path template syntax on the field's value.\n//\n// NB: it is more useful to send nothing than to send garbage for the purpose\n// of dynamic routing, since garbage pollutes cache. Thus the matching.\n//\n// Sub-example 3a\n//\n// The field matches the template.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // Take the `table_name`, if it's well-formed (with project-based\n//       // syntax).\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{table_name=projects/*/instances/*/**}\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params:\n//     table_name=projects/proj_foo/instances/instance_bar/table/table_baz\n//\n// Sub-example 3b\n//\n// The field does not match the template.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // Take the `table_name`, if it's well-formed (with region-based\n//       // syntax).\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{table_name=regions/*/zones/*/**}\"\n//       }\n//     };\n//\n// result:\n//\n//     <no routing header will be sent>\n//\n// Sub-example 3c\n//\n// Multiple alternative conflictingly named path templates are\n// specified. The one that matches is used to construct the header.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // Take the `table_name`, if it's well-formed, whether\n//       // using the region- or projects-based syntax.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{table_name=regions/*/zones/*/**}\"\n//       }\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{table_name=projects/*/instances/*/**}\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params:\n//     table_name=projects/proj_foo/instances/instance_bar/table/table_baz\n//\n// Example 4\n//\n// Extracting a single routing header key-value pair by matching a\n// template syntax on (a part of) a single request field.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // Take just the project id from the `table_name` field.\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{routing_id=projects/*}/**\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params: routing_id=projects/proj_foo\n//\n// Example 5\n//\n// Extracting a single routing header key-value pair by matching\n// several conflictingly named path templates on (parts of) a single request\n// field. The last template to match \"wins\" the conflict.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // If the `table_name` does not have instances information,\n//       // take just the project id for routing.\n//       // Otherwise take project + instance.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{routing_id=projects/*}/**\"\n//       }\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{routing_id=projects/*/instances/*}/**\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params:\n//     routing_id=projects/proj_foo/instances/instance_bar\n//\n// Example 6\n//\n// Extracting multiple routing header key-value pairs by matching\n// several non-conflicting path templates on (parts of) a single request field.\n//\n// Sub-example 6a\n//\n// Make the templates strict, so that if the `table_name` does not\n// have an instance information, nothing is sent.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // The routing code needs two keys instead of one composite\n//       // but works only for the tables with the \"project-instance\" name\n//       // syntax.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{project_id=projects/*}/instances/*/**\"\n//       }\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"projects/*/{instance_id=instances/*}/**\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params:\n//     project_id=projects/proj_foo&instance_id=instances/instance_bar\n//\n// Sub-example 6b\n//\n// Make the templates loose, so that if the `table_name` does not\n// have an instance information, just the project id part is sent.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // The routing code wants two keys instead of one composite\n//       // but will work with just the `project_id` for tables without\n//       // an instance in the `table_name`.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{project_id=projects/*}/**\"\n//       }\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"projects/*/{instance_id=instances/*}/**\"\n//       }\n//     };\n//\n// result (is the same as 6a for our example message because it has the instance\n// information):\n//\n//     x-goog-request-params:\n//     project_id=projects/proj_foo&instance_id=instances/instance_bar\n//\n// Example 7\n//\n// Extracting multiple routing header key-value pairs by matching\n// several path templates on multiple request fields.\n//\n// NB: note that here there is no way to specify sending nothing if one of the\n// fields does not match its template. E.g. if the `table_name` is in the wrong\n// format, the `project_id` will not be sent, but the `routing_id` will be.\n// The backend routing code has to be aware of that and be prepared to not\n// receive a full complement of keys if it expects multiple.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // The routing needs both `project_id` and `routing_id`\n//       // (from the `app_profile_id` field) for routing.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{project_id=projects/*}/**\"\n//       }\n//       routing_parameters {\n//         field: \"app_profile_id\"\n//         path_template: \"{routing_id=**}\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params:\n//     project_id=projects/proj_foo&routing_id=profiles/prof_qux\n//\n// Example 8\n//\n// Extracting a single routing header key-value pair by matching\n// several conflictingly named path templates on several request fields. The\n// last template to match \"wins\" the conflict.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // The `routing_id` can be a project id or a region id depending on\n//       // the table name format, but only if the `app_profile_id` is not set.\n//       // If `app_profile_id` is set it should be used instead.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{routing_id=projects/*}/**\"\n//       }\n//       routing_parameters {\n//          field: \"table_name\"\n//          path_template: \"{routing_id=regions/*}/**\"\n//       }\n//       routing_parameters {\n//         field: \"app_profile_id\"\n//         path_template: \"{routing_id=**}\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params: routing_id=profiles/prof_qux\n//\n// Example 9\n//\n// Bringing it all together.\n//\n// annotation:\n//\n//     option (google.api.routing) = {\n//       // For routing both `table_location` and a `routing_id` are needed.\n//       //\n//       // table_location can be either an instance id or a region+zone id.\n//       //\n//       // For `routing_id`, take the value of `app_profile_id`\n//       // - If it's in the format `profiles/<profile_id>`, send\n//       // just the `<profile_id>` part.\n//       // - If it's any other literal, send it as is.\n//       // If the `app_profile_id` is empty, and the `table_name` starts with\n//       // the project_id, send that instead.\n//\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"projects/*/{table_location=instances/*}/tables/*\"\n//       }\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{table_location=regions/*/zones/*}/tables/*\"\n//       }\n//       routing_parameters {\n//         field: \"table_name\"\n//         path_template: \"{routing_id=projects/*}/**\"\n//       }\n//       routing_parameters {\n//         field: \"app_profile_id\"\n//         path_template: \"{routing_id=**}\"\n//       }\n//       routing_parameters {\n//         field: \"app_profile_id\"\n//         path_template: \"profiles/{routing_id=*}\"\n//       }\n//     };\n//\n// result:\n//\n//     x-goog-request-params:\n//     table_location=instances/instance_bar&routing_id=prof_qux\nmessage RoutingRule {\n  // A collection of Routing Parameter specifications.\n  // **NOTE:** If multiple Routing Parameters describe the same key\n  // (via the `path_template` field or via the `field` field when\n  // `path_template` is not provided), \"last one wins\" rule\n  // determines which Parameter gets used.\n  // See the examples for more details.\n  repeated RoutingParameter routing_parameters = 2;\n}\n\n// A projection from an input message to the GRPC or REST header.\nmessage RoutingParameter {\n  // A request field to extract the header key-value pair from.\n  string field = 1;\n\n  // A pattern matching the key-value field. Optional.\n  // If not specified, the whole field specified in the `field` field will be\n  // taken as value, and its name used as key. If specified, it MUST contain\n  // exactly one named segment (along with any number of unnamed segments) The\n  // pattern will be matched over the field specified in the `field` field, then\n  // if the match is successful:\n  // - the name of the single named segment will be used as a header name,\n  // - the match value of the segment will be used as a header value;\n  // if the match is NOT successful, nothing will be sent.\n  //\n  // Example:\n  //\n  //               -- This is a field in the request message\n  //              |   that the header value will be extracted from.\n  //              |\n  //              |                     -- This is the key name in the\n  //              |                    |   routing header.\n  //              V                    |\n  //     field: \"table_name\"           v\n  //     path_template: \"projects/*/{table_location=instances/*}/tables/*\"\n  //                                                ^            ^\n  //                                                |            |\n  //       In the {} brackets is the pattern that --             |\n  //       specifies what to extract from the                    |\n  //       field as a value to be sent.                          |\n  //                                                             |\n  //      The string in the field must match the whole pattern --\n  //      before brackets, inside brackets, after brackets.\n  //\n  // When looking at this specific example, we can see that:\n  // - A key-value pair with the key `table_location`\n  //   and the value matching `instances/*` should be added\n  //   to the x-goog-request-params routing header.\n  // - The value is extracted from the request message's `table_name` field\n  //   if it matches the full pattern specified:\n  //   `projects/*/instances/*/tables/*`.\n  //\n  // **NB:** If the `path_template` field is not provided, the key name is\n  // equal to the field name, and the whole field should be sent as a value.\n  // This makes the pattern for the field and the value functionally equivalent\n  // to `**`, and the configuration\n  //\n  //     {\n  //       field: \"table_name\"\n  //     }\n  //\n  // is a functionally equivalent shorthand to:\n  //\n  //     {\n  //       field: \"table_name\"\n  //       path_template: \"{table_name=**}\"\n  //     }\n  //\n  // See Example 1 for more details.\n  string path_template = 2;\n}\n","size_bytes":14929},"build/extracted-include-protos/test/google/api/monitored_resource.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/api/label.proto\";\nimport \"google/api/launch_stage.proto\";\nimport \"google/protobuf/struct.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/api/monitoredres;monitoredres\";\noption java_multiple_files = true;\noption java_outer_classname = \"MonitoredResourceProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// An object that describes the schema of a\n// [MonitoredResource][google.api.MonitoredResource] object using a type name\n// and a set of labels.  For example, the monitored resource descriptor for\n// Google Compute Engine VM instances has a type of\n// `\"gce_instance\"` and specifies the use of the labels `\"instance_id\"` and\n// `\"zone\"` to identify particular VM instances.\n//\n// Different APIs can support different monitored resource types. APIs generally\n// provide a `list` method that returns the monitored resource descriptors used\n// by the API.\n//\nmessage MonitoredResourceDescriptor {\n  // Optional. The resource name of the monitored resource descriptor:\n  // `\"projects/{project_id}/monitoredResourceDescriptors/{type}\"` where\n  // {type} is the value of the `type` field in this object and\n  // {project_id} is a project ID that provides API-specific context for\n  // accessing the type.  APIs that do not use project information can use the\n  // resource name format `\"monitoredResourceDescriptors/{type}\"`.\n  string name = 5;\n\n  // Required. The monitored resource type. For example, the type\n  // `\"cloudsql_database\"` represents databases in Google Cloud SQL.\n  //  For a list of types, see [Monitoring resource\n  //  types](https://cloud.google.com/monitoring/api/resources)\n  // and [Logging resource\n  // types](https://cloud.google.com/logging/docs/api/v2/resource-list).\n  string type = 1;\n\n  // Optional. A concise name for the monitored resource type that might be\n  // displayed in user interfaces. It should be a Title Cased Noun Phrase,\n  // without any article or other determiners. For example,\n  // `\"Google Cloud SQL Database\"`.\n  string display_name = 2;\n\n  // Optional. A detailed description of the monitored resource type that might\n  // be used in documentation.\n  string description = 3;\n\n  // Required. A set of labels used to describe instances of this monitored\n  // resource type. For example, an individual Google Cloud SQL database is\n  // identified by values for the labels `\"database_id\"` and `\"zone\"`.\n  repeated LabelDescriptor labels = 4;\n\n  // Optional. The launch stage of the monitored resource definition.\n  LaunchStage launch_stage = 7;\n}\n\n// An object representing a resource that can be used for monitoring, logging,\n// billing, or other purposes. Examples include virtual machine instances,\n// databases, and storage devices such as disks. The `type` field identifies a\n// [MonitoredResourceDescriptor][google.api.MonitoredResourceDescriptor] object\n// that describes the resource's schema. Information in the `labels` field\n// identifies the actual resource and its attributes according to the schema.\n// For example, a particular Compute Engine VM instance could be represented by\n// the following object, because the\n// [MonitoredResourceDescriptor][google.api.MonitoredResourceDescriptor] for\n// `\"gce_instance\"` has labels\n// `\"project_id\"`, `\"instance_id\"` and `\"zone\"`:\n//\n//     { \"type\": \"gce_instance\",\n//       \"labels\": { \"project_id\": \"my-project\",\n//                   \"instance_id\": \"12345678901234\",\n//                   \"zone\": \"us-central1-a\" }}\nmessage MonitoredResource {\n  // Required. The monitored resource type. This field must match\n  // the `type` field of a\n  // [MonitoredResourceDescriptor][google.api.MonitoredResourceDescriptor]\n  // object. For example, the type of a Compute Engine VM instance is\n  // `gce_instance`. Some descriptors include the service name in the type; for\n  // example, the type of a Datastream stream is\n  // `datastream.googleapis.com/Stream`.\n  string type = 1;\n\n  // Required. Values for all of the labels listed in the associated monitored\n  // resource descriptor. For example, Compute Engine VM instances use the\n  // labels `\"project_id\"`, `\"instance_id\"`, and `\"zone\"`.\n  map<string, string> labels = 2;\n}\n\n// Auxiliary metadata for a [MonitoredResource][google.api.MonitoredResource]\n// object. [MonitoredResource][google.api.MonitoredResource] objects contain the\n// minimum set of information to uniquely identify a monitored resource\n// instance. There is some other useful auxiliary metadata. Monitoring and\n// Logging use an ingestion pipeline to extract metadata for cloud resources of\n// all types, and store the metadata in this message.\nmessage MonitoredResourceMetadata {\n  // Output only. Values for predefined system metadata labels.\n  // System labels are a kind of metadata extracted by Google, including\n  // \"machine_image\", \"vpc\", \"subnet_id\",\n  // \"security_group\", \"name\", etc.\n  // System label values can be only strings, Boolean values, or a list of\n  // strings. For example:\n  //\n  //     { \"name\": \"my-test-instance\",\n  //       \"security_group\": [\"a\", \"b\", \"c\"],\n  //       \"spot_instance\": false }\n  google.protobuf.Struct system_labels = 1;\n\n  // Output only. A map of user-defined metadata labels.\n  map<string, string> user_labels = 2;\n}\n","size_bytes":5921},"src/main/java/com/spiketrade/backend/ConnectionState.java":{"content":"package com.spiketrade.backend;\n\npublic enum ConnectionState {\n    CONNECTED,\n    DISCONNECTED,\n    DEGRADED,\n    FAILED\n}\n","size_bytes":123},"build/resources/main/market_data.proto":{"content":"syntax = \"proto3\";\n\npackage spiketrade.proto;\n\noption java_package = \"com.spiketrade.proto\";\noption java_outer_classname = \"MarketDataProto\";\n\n// Indicators data - Extended to include all technical indicators for continuous quote updates\nmessage IndicatorsData {\n  // Basic indicators\n  double rsi = 1;\n  double price_roc = 2;\n  double volume_roc = 3;\n  double volume = 4;\n  double obv = 5;\n  double mfi = 6;\n  double bollinger_position = 7;\n  double percent_b = 8;\n  double vwap = 9;\n  \n  // ROC (Rate of Change) indicators\n  double rsi_roc = 10;\n  double obv_roc = 11;\n  double mfi_roc = 12;\n  double bollinger_pos_roc = 13;\n  double percent_b_roc = 14;\n  double vwap_roc = 15;\n  \n  // MACD (Moving Average Convergence Divergence)\n  double macd_line = 16;\n  double macd_signal = 17;\n  double macd_histogram = 18;\n  \n  // EMA (Exponential Moving Average) - multiple periods\n  double ema_9 = 19;\n  double ema_20 = 20;\n  double ema_50 = 21;\n  \n  // Stochastic Oscillator\n  double stoch_k = 22;\n  double stoch_d = 23;\n  \n  // Relative Volume\n  double rvol = 24;\n  \n  // Volume Spike Detection\n  bool volume_spike = 25;\n  double volume_ratio = 26;\n  \n  // ATR (Average True Range)\n  double atr = 27;\n  \n  // Bollinger Band values (for completeness)\n  double bollinger_upper = 28;\n  double bollinger_lower = 29;\n}\n\n// Market data message\nmessage Quote {\n  string symbol = 1;\n  double price = 2;\n  int64 volume = 3;\n  double bid = 4;\n  double ask = 5; // NOTE: The next available field number is 7, not 5 or 6.\n  int64 timestamp_ms = 6;\n\n  // Individual indicator fields (legacy - deprecated, use indicators field instead)\n  double rsi = 7;\n  double price_roc = 8;\n  double volume_roc = 9;\n  double obv = 10;\n  double mfi = 11;\n  double bollinger_position = 12;\n  double percent_b = 13;\n  double vwap = 14;\n  \n  // Full indicators data (includes all technical indicators)\n  optional IndicatorsData indicators = 15;\n  \n  // Buy signal probability (0.0 to 1.0) - continuously calculated\n  optional double signal_probability = 16;\n  \n  // ATR for quick access\n  optional double atr = 17;\n}\n\n// OHLCV candle data\nmessage Candle {\n  int64 timestamp_ms = 1;\n  double open = 2;\n  double high = 3;\n  double low = 4;\n  double close = 5;\n  int64 volume = 6;\n}\n\n// Historical market data request\nmessage HistoricalDataRequest {\n  string symbol = 1;\n  int32 interval_minutes = 2;\n  int32 num_bars = 3;\n}\n\n// Historical market data response\nmessage HistoricalDataResponse {\n  string symbol = 1;\n  repeated Candle candles = 2;\n  string error_message = 3;\n}\n\n// Real-time quote stream\nmessage QuoteStreamRequest {\n  repeated string symbols = 1;\n}\n\n// Connection status\nmessage ConnectionStatus {\n  enum State {\n    DISCONNECTED = 0;\n    CONNECTED = 1;\n    DEGRADED = 2;\n    FAILED = 3;\n  }\n  State state = 1;\n  bool using_fallback = 2;\n  string fallback_reason = 3;\n  int32 consecutive_failures = 4;\n}\n","size_bytes":2882},"build/extracted-include-protos/test/google/type/calendar_period.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption go_package = \"google.golang.org/genproto/googleapis/type/calendarperiod;calendarperiod\";\noption java_multiple_files = true;\noption java_outer_classname = \"CalendarPeriodProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// A `CalendarPeriod` represents the abstract concept of a time period that has\n// a canonical start. Grammatically, \"the start of the current\n// `CalendarPeriod`.\" All calendar times begin at midnight UTC.\nenum CalendarPeriod {\n  // Undefined period, raises an error.\n  CALENDAR_PERIOD_UNSPECIFIED = 0;\n\n  // A day.\n  DAY = 1;\n\n  // A week. Weeks begin on Monday, following\n  // [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date).\n  WEEK = 2;\n\n  // A fortnight. The first calendar fortnight of the year begins at the start\n  // of week 1 according to\n  // [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date).\n  FORTNIGHT = 3;\n\n  // A month.\n  MONTH = 4;\n\n  // A quarter. Quarters start on dates 1-Jan, 1-Apr, 1-Jul, and 1-Oct of each\n  // year.\n  QUARTER = 5;\n\n  // A half-year. Half-years start on dates 1-Jan and 1-Jul.\n  HALF = 6;\n\n  // A year.\n  YEAR = 7;\n}\n","size_bytes":1762},"build/extracted-include-protos/main/google/api/source_info.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/any.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"SourceInfoProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Source information used to create a Service Config\nmessage SourceInfo {\n  // All files used during config generation.\n  repeated google.protobuf.Any source_files = 1;\n}\n","size_bytes":1091},"src/main/java/com/spiketrade/SpikeTradeMain.java":{"content":"package com.spiketrade;\n\nimport com.spiketrade.backend.BackendServer;\nimport javafx.application.Application;\n\npublic class SpikeTradeMain {\n    public static void main(String[] args) {\n        // Configure JavaFX for software rendering to avoid GLIBC compatibility issues\n        System.setProperty(\"prism.order\", \"sw\");\n        System.setProperty(\"prism.verbose\", \"true\");\n        System.setProperty(\"javafx.verbose\", \"true\");\n        \n        System.out.println(\"=== SpikeTrade Professional ===\");\n        System.out.println(\"100% Java Application\");\n        System.out.println(\"Version: 2.0.0\");\n        System.out.println(\"JavaFX Rendering: Software (SW) mode\");\n        System.out.println();\n        \n        Thread backendThread = new Thread(() -> {\n            try {\n                System.out.println(\"Starting backend gRPC server...\");\n                BackendServer.main(new String[0]);\n            } catch (Exception e) {\n                System.err.println(\"Backend server error: \" + e.getMessage());\n                e.printStackTrace();\n            }\n        });\n        backendThread.setDaemon(false);\n        backendThread.setName(\"BackendServer\");\n        backendThread.start();\n        \n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        \n        System.out.println(\"Starting JavaFX GUI...\");\n        Application.launch(SpikeTradeApp.class, args);\n    }\n}\n","size_bytes":1475},"src/main/java/com/spiketrade/service/IndicatorCacheService.java":{"content":"package com.spiketrade.service;\n\nimport com.spiketrade.util.CacheManager;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\npublic class IndicatorCacheService {\n    private static final Logger logger = LoggerFactory.getLogger(IndicatorCacheService.class);\n    private final CacheManager cache;\n    \n    public IndicatorCacheService() {\n        this.cache = new CacheManager(300);\n    }\n    \n    public Double getZScore(String symbol, String indicator, int period) {\n        String key = String.format(\"zscore:%s:%s:%d\", symbol, indicator, period);\n        return cache.get(key);\n    }\n    \n    public void cacheZScore(String symbol, String indicator, int period, double value) {\n        String key = String.format(\"zscore:%s:%s:%d\", symbol, indicator, period);\n        cache.put(key, value, 60000);\n    }\n    \n    public Double getMovingAverage(String symbol, String type, int period) {\n        String key = String.format(\"ma:%s:%s:%d\", symbol, type, period);\n        return cache.get(key);\n    }\n    \n    public void cacheMovingAverage(String symbol, String type, int period, double value) {\n        String key = String.format(\"ma:%s:%s:%d\", symbol, type, period);\n        cache.put(key, value, 30000);\n    }\n    \n    public Double getRSI(String symbol, int period) {\n        String key = String.format(\"rsi:%s:%d\", symbol, period);\n        return cache.get(key);\n    }\n    \n    public void cacheRSI(String symbol, int period, double value) {\n        String key = String.format(\"rsi:%s:%d\", symbol, period);\n        cache.put(key, value, 15000);\n    }\n    \n    public void invalidateSymbol(String symbol) {\n        logger.debug(\"Invalidating cache for symbol: {}\", symbol);\n        cache.invalidateAll();\n    }\n    \n    public int getCacheSize() {\n        return cache.size();\n    }\n}\n","size_bytes":1818},"src/main/java/com/spiketrade/backend/Quote.java":{"content":"package com.spiketrade.backend;\n\nimport java.time.Instant;\n\npublic class Quote {\n    public String symbol;\n    public double price;\n    public long volume;\n    public double bid;\n    public double ask;\n    public Instant timestamp;\n    \n    public Quote() {\n        this.timestamp = Instant.now();\n    }\n}\n","size_bytes":306},"build/extracted-include-protos/test/google/api/context.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"ContextProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// `Context` defines which contexts an API requests.\n//\n// Example:\n//\n//     context:\n//       rules:\n//       - selector: \"*\"\n//         requested:\n//         - google.rpc.context.ProjectContext\n//         - google.rpc.context.OriginContext\n//\n// The above specifies that all methods in the API request\n// `google.rpc.context.ProjectContext` and\n// `google.rpc.context.OriginContext`.\n//\n// Available context types are defined in package\n// `google.rpc.context`.\n//\n// This also provides mechanism to allowlist any protobuf message extension that\n// can be sent in grpc metadata using x-goog-ext-<extension_id>-bin and\n// x-goog-ext-<extension_id>-jspb format. For example, list any service\n// specific protobuf types that can appear in grpc metadata as follows in your\n// yaml file:\n//\n// Example:\n//\n//     context:\n//       rules:\n//        - selector: \"google.example.library.v1.LibraryService.CreateBook\"\n//          allowed_request_extensions:\n//          - google.foo.v1.NewExtension\n//          allowed_response_extensions:\n//          - google.foo.v1.NewExtension\n//\n// You can also specify extension ID instead of fully qualified extension name\n// here.\nmessage Context {\n  // A list of RPC context rules that apply to individual API methods.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated ContextRule rules = 1;\n}\n\n// A context rule provides information about the context for an individual API\n// element.\nmessage ContextRule {\n  // Selects the methods to which this rule applies.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // A list of full type names of requested contexts.\n  repeated string requested = 2;\n\n  // A list of full type names of provided contexts.\n  repeated string provided = 3;\n\n  // A list of full type names or extension IDs of extensions allowed in grpc\n  // side channel from client to backend.\n  repeated string allowed_request_extensions = 4;\n\n  // A list of full type names or extension IDs of extensions allowed in grpc\n  // side channel from backend to client.\n  repeated string allowed_response_extensions = 5;\n}\n","size_bytes":3067},"build/extracted-include-protos/test/google/longrunning/operations.proto":{"content":"// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.longrunning;\n\nimport \"google/api/annotations.proto\";\nimport \"google/api/client.proto\";\nimport \"google/protobuf/any.proto\";\nimport \"google/protobuf/duration.proto\";\nimport \"google/protobuf/empty.proto\";\nimport \"google/rpc/status.proto\";\nimport \"google/protobuf/descriptor.proto\";\n\noption cc_enable_arenas = true;\noption csharp_namespace = \"Google.LongRunning\";\noption go_package = \"cloud.google.com/go/longrunning/autogen/longrunningpb;longrunningpb\";\noption java_multiple_files = true;\noption java_outer_classname = \"OperationsProto\";\noption java_package = \"com.google.longrunning\";\noption php_namespace = \"Google\\\\LongRunning\";\n\nextend google.protobuf.MethodOptions {\n  // Additional information regarding long-running operations.\n  // In particular, this specifies the types that are returned from\n  // long-running operations.\n  //\n  // Required for methods that return `google.longrunning.Operation`; invalid\n  // otherwise.\n  google.longrunning.OperationInfo operation_info = 1049;\n}\n\n// Manages long-running operations with an API service.\n//\n// When an API method normally takes long time to complete, it can be designed\n// to return [Operation][google.longrunning.Operation] to the client, and the client can use this\n// interface to receive the real response asynchronously by polling the\n// operation resource, or pass the operation resource to another API (such as\n// Google Cloud Pub/Sub API) to receive the response.  Any API service that\n// returns long-running operations should implement the `Operations` interface\n// so developers can have a consistent client experience.\nservice Operations {\n  option (google.api.default_host) = \"longrunning.googleapis.com\";\n\n  // Lists operations that match the specified filter in the request. If the\n  // server doesn't support this method, it returns `UNIMPLEMENTED`.\n  //\n  // NOTE: the `name` binding allows API services to override the binding\n  // to use different resource name schemes, such as `users/*/operations`. To\n  // override the binding, API services can add a binding such as\n  // `\"/v1/{name=users/*}/operations\"` to their service configuration.\n  // For backwards compatibility, the default name includes the operations\n  // collection id, however overriding users must ensure the name binding\n  // is the parent resource, without the operations collection id.\n  rpc ListOperations(ListOperationsRequest) returns (ListOperationsResponse) {\n    option (google.api.http) = {\n      get: \"/v1/{name=operations}\"\n    };\n    option (google.api.method_signature) = \"name,filter\";\n  }\n\n  // Gets the latest state of a long-running operation.  Clients can use this\n  // method to poll the operation result at intervals as recommended by the API\n  // service.\n  rpc GetOperation(GetOperationRequest) returns (Operation) {\n    option (google.api.http) = {\n      get: \"/v1/{name=operations/**}\"\n    };\n    option (google.api.method_signature) = \"name\";\n  }\n\n  // Deletes a long-running operation. This method indicates that the client is\n  // no longer interested in the operation result. It does not cancel the\n  // operation. If the server doesn't support this method, it returns\n  // `google.rpc.Code.UNIMPLEMENTED`.\n  rpc DeleteOperation(DeleteOperationRequest) returns (google.protobuf.Empty) {\n    option (google.api.http) = {\n      delete: \"/v1/{name=operations/**}\"\n    };\n    option (google.api.method_signature) = \"name\";\n  }\n\n  // Starts asynchronous cancellation on a long-running operation.  The server\n  // makes a best effort to cancel the operation, but success is not\n  // guaranteed.  If the server doesn't support this method, it returns\n  // `google.rpc.Code.UNIMPLEMENTED`.  Clients can use\n  // [Operations.GetOperation][google.longrunning.Operations.GetOperation] or\n  // other methods to check whether the cancellation succeeded or whether the\n  // operation completed despite cancellation. On successful cancellation,\n  // the operation is not deleted; instead, it becomes an operation with\n  // an [Operation.error][google.longrunning.Operation.error] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,\n  // corresponding to `Code.CANCELLED`.\n  rpc CancelOperation(CancelOperationRequest) returns (google.protobuf.Empty) {\n    option (google.api.http) = {\n      post: \"/v1/{name=operations/**}:cancel\"\n      body: \"*\"\n    };\n    option (google.api.method_signature) = \"name\";\n  }\n\n  // Waits until the specified long-running operation is done or reaches at most\n  // a specified timeout, returning the latest state.  If the operation is\n  // already done, the latest state is immediately returned.  If the timeout\n  // specified is greater than the default HTTP/RPC timeout, the HTTP/RPC\n  // timeout is used.  If the server does not support this method, it returns\n  // `google.rpc.Code.UNIMPLEMENTED`.\n  // Note that this method is on a best-effort basis.  It may return the latest\n  // state before the specified timeout (including immediately), meaning even an\n  // immediate response is no guarantee that the operation is done.\n  rpc WaitOperation(WaitOperationRequest) returns (Operation) {\n  }\n}\n\n// This resource represents a long-running operation that is the result of a\n// network API call.\nmessage Operation {\n  // The server-assigned name, which is only unique within the same service that\n  // originally returns it. If you use the default HTTP mapping, the\n  // `name` should be a resource name ending with `operations/{unique_id}`.\n  string name = 1;\n\n  // Service-specific metadata associated with the operation.  It typically\n  // contains progress information and common metadata such as create time.\n  // Some services might not provide such metadata.  Any method that returns a\n  // long-running operation should document the metadata type, if any.\n  google.protobuf.Any metadata = 2;\n\n  // If the value is `false`, it means the operation is still in progress.\n  // If `true`, the operation is completed, and either `error` or `response` is\n  // available.\n  bool done = 3;\n\n  // The operation result, which can be either an `error` or a valid `response`.\n  // If `done` == `false`, neither `error` nor `response` is set.\n  // If `done` == `true`, exactly one of `error` or `response` is set.\n  oneof result {\n    // The error result of the operation in case of failure or cancellation.\n    google.rpc.Status error = 4;\n\n    // The normal response of the operation in case of success.  If the original\n    // method returns no data on success, such as `Delete`, the response is\n    // `google.protobuf.Empty`.  If the original method is standard\n    // `Get`/`Create`/`Update`, the response should be the resource.  For other\n    // methods, the response should have the type `XxxResponse`, where `Xxx`\n    // is the original method name.  For example, if the original method name\n    // is `TakeSnapshot()`, the inferred response type is\n    // `TakeSnapshotResponse`.\n    google.protobuf.Any response = 5;\n  }\n}\n\n// The request message for [Operations.GetOperation][google.longrunning.Operations.GetOperation].\nmessage GetOperationRequest {\n  // The name of the operation resource.\n  string name = 1;\n}\n\n// The request message for [Operations.ListOperations][google.longrunning.Operations.ListOperations].\nmessage ListOperationsRequest {\n  // The name of the operation's parent resource.\n  string name = 4;\n\n  // The standard list filter.\n  string filter = 1;\n\n  // The standard list page size.\n  int32 page_size = 2;\n\n  // The standard list page token.\n  string page_token = 3;\n}\n\n// The response message for [Operations.ListOperations][google.longrunning.Operations.ListOperations].\nmessage ListOperationsResponse {\n  // A list of operations that matches the specified filter in the request.\n  repeated Operation operations = 1;\n\n  // The standard List next-page token.\n  string next_page_token = 2;\n}\n\n// The request message for [Operations.CancelOperation][google.longrunning.Operations.CancelOperation].\nmessage CancelOperationRequest {\n  // The name of the operation resource to be cancelled.\n  string name = 1;\n}\n\n// The request message for [Operations.DeleteOperation][google.longrunning.Operations.DeleteOperation].\nmessage DeleteOperationRequest {\n  // The name of the operation resource to be deleted.\n  string name = 1;\n}\n\n// The request message for [Operations.WaitOperation][google.longrunning.Operations.WaitOperation].\nmessage WaitOperationRequest {\n  // The name of the operation resource to wait on.\n  string name = 1;\n\n  // The maximum duration to wait before timing out. If left blank, the wait\n  // will be at most the time permitted by the underlying HTTP/RPC protocol.\n  // If RPC context deadline is also specified, the shorter one will be used.\n  google.protobuf.Duration timeout = 2;\n}\n\n// A message representing the message types used by a long-running operation.\n//\n// Example:\n//\n//   rpc LongRunningRecognize(LongRunningRecognizeRequest)\n//       returns (google.longrunning.Operation) {\n//     option (google.longrunning.operation_info) = {\n//       response_type: \"LongRunningRecognizeResponse\"\n//       metadata_type: \"LongRunningRecognizeMetadata\"\n//     };\n//   }\nmessage OperationInfo {\n  // Required. The message name of the primary return type for this\n  // long-running operation.\n  // This type will be used to deserialize the LRO's response.\n  //\n  // If the response is in a different package from the rpc, a fully-qualified\n  // message name must be used (e.g. `google.protobuf.Struct`).\n  //\n  // Note: Altering this value constitutes a breaking change.\n  string response_type = 1;\n\n  // Required. The message name of the metadata type for this long-running\n  // operation.\n  //\n  // If the response is in a different package from the rpc, a fully-qualified\n  // message name must be used (e.g. `google.protobuf.Struct`).\n  //\n  // Note: Altering this value constitutes a breaking change.\n  string metadata_type = 2;\n}\n","size_bytes":10513},"build/generated/source/proto/main/java/com/spiketrade/proto/SpikeSignalsProto.java":{"content":"// Generated by the protocol buffer compiler.  DO NOT EDIT!\n// source: spike_signals.proto\n\n// Protobuf Java Version: 3.25.1\npackage com.spiketrade.proto;\n\npublic final class SpikeSignalsProto {\n  private SpikeSignalsProto() {}\n  public static void registerAllExtensions(\n      com.google.protobuf.ExtensionRegistryLite registry) {\n  }\n\n  public static void registerAllExtensions(\n      com.google.protobuf.ExtensionRegistry registry) {\n    registerAllExtensions(\n        (com.google.protobuf.ExtensionRegistryLite) registry);\n  }\n  public interface IndicatorsOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.Indicators)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <pre>\n     * Legacy indicators (keep for backward compatibility)\n     * </pre>\n     *\n     * <code>double rsi = 1;</code>\n     * @return The rsi.\n     */\n    double getRsi();\n\n    /**\n     * <code>double obv = 2;</code>\n     * @return The obv.\n     */\n    double getObv();\n\n    /**\n     * <code>double mfi = 3;</code>\n     * @return The mfi.\n     */\n    double getMfi();\n\n    /**\n     * <code>double vwap = 4;</code>\n     * @return The vwap.\n     */\n    double getVwap();\n\n    /**\n     * <code>double bollinger_upper = 5;</code>\n     * @return The bollingerUpper.\n     */\n    double getBollingerUpper();\n\n    /**\n     * <code>double bollinger_lower = 6;</code>\n     * @return The bollingerLower.\n     */\n    double getBollingerLower();\n\n    /**\n     * <code>double bollinger_position = 7;</code>\n     * @return The bollingerPosition.\n     */\n    double getBollingerPosition();\n\n    /**\n     * <code>double percent_b = 8;</code>\n     * @return The percentB.\n     */\n    double getPercentB();\n\n    /**\n     * <code>double price_roc = 9;</code>\n     * @return The priceRoc.\n     */\n    double getPriceRoc();\n\n    /**\n     * <code>double rsi_roc = 10;</code>\n     * @return The rsiRoc.\n     */\n    double getRsiRoc();\n\n    /**\n     * <code>double obv_roc = 11;</code>\n     * @return The obvRoc.\n     */\n    double getObvRoc();\n\n    /**\n     * <code>double mfi_roc = 12;</code>\n     * @return The mfiRoc.\n     */\n    double getMfiRoc();\n\n    /**\n     * <code>double bollinger_pos_roc = 13;</code>\n     * @return The bollingerPosRoc.\n     */\n    double getBollingerPosRoc();\n\n    /**\n     * <code>double percent_b_roc = 14;</code>\n     * @return The percentBRoc.\n     */\n    double getPercentBRoc();\n\n    /**\n     * <code>double vwap_roc = 15;</code>\n     * @return The vwapRoc.\n     */\n    double getVwapRoc();\n\n    /**\n     * <code>double volume_roc = 16;</code>\n     * @return The volumeRoc.\n     */\n    double getVolumeRoc();\n\n    /**\n     * <pre>\n     * NEW INDICATORS for high volatility, low-priced stocks\n     * MACD (Moving Average Convergence Divergence)\n     * </pre>\n     *\n     * <code>double macd_line = 17;</code>\n     * @return The macdLine.\n     */\n    double getMacdLine();\n\n    /**\n     * <code>double macd_signal = 18;</code>\n     * @return The macdSignal.\n     */\n    double getMacdSignal();\n\n    /**\n     * <code>double macd_histogram = 19;</code>\n     * @return The macdHistogram.\n     */\n    double getMacdHistogram();\n\n    /**\n     * <pre>\n     * EMA (Exponential Moving Average) - multiple periods\n     * </pre>\n     *\n     * <code>double ema_9 = 20;</code>\n     * @return The ema9.\n     */\n    double getEma9();\n\n    /**\n     * <code>double ema_20 = 21;</code>\n     * @return The ema20.\n     */\n    double getEma20();\n\n    /**\n     * <code>double ema_50 = 22;</code>\n     * @return The ema50.\n     */\n    double getEma50();\n\n    /**\n     * <pre>\n     * Stochastic Oscillator\n     * </pre>\n     *\n     * <code>double stoch_k = 23;</code>\n     * @return The stochK.\n     */\n    double getStochK();\n\n    /**\n     * <pre>\n     * %D line (signal)\n     * </pre>\n     *\n     * <code>double stoch_d = 24;</code>\n     * @return The stochD.\n     */\n    double getStochD();\n\n    /**\n     * <pre>\n     * Relative Volume\n     * </pre>\n     *\n     * <code>double rvol = 25;</code>\n     * @return The rvol.\n     */\n    double getRvol();\n\n    /**\n     * <pre>\n     * Volume Spike Detection\n     * </pre>\n     *\n     * <code>bool volume_spike = 26;</code>\n     * @return The volumeSpike.\n     */\n    boolean getVolumeSpike();\n\n    /**\n     * <code>double volume_ratio = 27;</code>\n     * @return The volumeRatio.\n     */\n    double getVolumeRatio();\n\n    /**\n     * <pre>\n     * ATR (Average True Range) - volatility indicator\n     * </pre>\n     *\n     * <code>double atr = 28;</code>\n     * @return The atr.\n     */\n    double getAtr();\n  }\n  /**\n   * <pre>\n   * Technical indicators\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.Indicators}\n   */\n  public static final class Indicators extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.Indicators)\n      IndicatorsOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use Indicators.newBuilder() to construct.\n    private Indicators(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private Indicators() {\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new Indicators();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_Indicators_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_Indicators_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.SpikeSignalsProto.Indicators.class, com.spiketrade.proto.SpikeSignalsProto.Indicators.Builder.class);\n    }\n\n    public static final int RSI_FIELD_NUMBER = 1;\n    private double rsi_ = 0D;\n    /**\n     * <pre>\n     * Legacy indicators (keep for backward compatibility)\n     * </pre>\n     *\n     * <code>double rsi = 1;</code>\n     * @return The rsi.\n     */\n    @java.lang.Override\n    public double getRsi() {\n      return rsi_;\n    }\n\n    public static final int OBV_FIELD_NUMBER = 2;\n    private double obv_ = 0D;\n    /**\n     * <code>double obv = 2;</code>\n     * @return The obv.\n     */\n    @java.lang.Override\n    public double getObv() {\n      return obv_;\n    }\n\n    public static final int MFI_FIELD_NUMBER = 3;\n    private double mfi_ = 0D;\n    /**\n     * <code>double mfi = 3;</code>\n     * @return The mfi.\n     */\n    @java.lang.Override\n    public double getMfi() {\n      return mfi_;\n    }\n\n    public static final int VWAP_FIELD_NUMBER = 4;\n    private double vwap_ = 0D;\n    /**\n     * <code>double vwap = 4;</code>\n     * @return The vwap.\n     */\n    @java.lang.Override\n    public double getVwap() {\n      return vwap_;\n    }\n\n    public static final int BOLLINGER_UPPER_FIELD_NUMBER = 5;\n    private double bollingerUpper_ = 0D;\n    /**\n     * <code>double bollinger_upper = 5;</code>\n     * @return The bollingerUpper.\n     */\n    @java.lang.Override\n    public double getBollingerUpper() {\n      return bollingerUpper_;\n    }\n\n    public static final int BOLLINGER_LOWER_FIELD_NUMBER = 6;\n    private double bollingerLower_ = 0D;\n    /**\n     * <code>double bollinger_lower = 6;</code>\n     * @return The bollingerLower.\n     */\n    @java.lang.Override\n    public double getBollingerLower() {\n      return bollingerLower_;\n    }\n\n    public static final int BOLLINGER_POSITION_FIELD_NUMBER = 7;\n    private double bollingerPosition_ = 0D;\n    /**\n     * <code>double bollinger_position = 7;</code>\n     * @return The bollingerPosition.\n     */\n    @java.lang.Override\n    public double getBollingerPosition() {\n      return bollingerPosition_;\n    }\n\n    public static final int PERCENT_B_FIELD_NUMBER = 8;\n    private double percentB_ = 0D;\n    /**\n     * <code>double percent_b = 8;</code>\n     * @return The percentB.\n     */\n    @java.lang.Override\n    public double getPercentB() {\n      return percentB_;\n    }\n\n    public static final int PRICE_ROC_FIELD_NUMBER = 9;\n    private double priceRoc_ = 0D;\n    /**\n     * <code>double price_roc = 9;</code>\n     * @return The priceRoc.\n     */\n    @java.lang.Override\n    public double getPriceRoc() {\n      return priceRoc_;\n    }\n\n    public static final int RSI_ROC_FIELD_NUMBER = 10;\n    private double rsiRoc_ = 0D;\n    /**\n     * <code>double rsi_roc = 10;</code>\n     * @return The rsiRoc.\n     */\n    @java.lang.Override\n    public double getRsiRoc() {\n      return rsiRoc_;\n    }\n\n    public static final int OBV_ROC_FIELD_NUMBER = 11;\n    private double obvRoc_ = 0D;\n    /**\n     * <code>double obv_roc = 11;</code>\n     * @return The obvRoc.\n     */\n    @java.lang.Override\n    public double getObvRoc() {\n      return obvRoc_;\n    }\n\n    public static final int MFI_ROC_FIELD_NUMBER = 12;\n    private double mfiRoc_ = 0D;\n    /**\n     * <code>double mfi_roc = 12;</code>\n     * @return The mfiRoc.\n     */\n    @java.lang.Override\n    public double getMfiRoc() {\n      return mfiRoc_;\n    }\n\n    public static final int BOLLINGER_POS_ROC_FIELD_NUMBER = 13;\n    private double bollingerPosRoc_ = 0D;\n    /**\n     * <code>double bollinger_pos_roc = 13;</code>\n     * @return The bollingerPosRoc.\n     */\n    @java.lang.Override\n    public double getBollingerPosRoc() {\n      return bollingerPosRoc_;\n    }\n\n    public static final int PERCENT_B_ROC_FIELD_NUMBER = 14;\n    private double percentBRoc_ = 0D;\n    /**\n     * <code>double percent_b_roc = 14;</code>\n     * @return The percentBRoc.\n     */\n    @java.lang.Override\n    public double getPercentBRoc() {\n      return percentBRoc_;\n    }\n\n    public static final int VWAP_ROC_FIELD_NUMBER = 15;\n    private double vwapRoc_ = 0D;\n    /**\n     * <code>double vwap_roc = 15;</code>\n     * @return The vwapRoc.\n     */\n    @java.lang.Override\n    public double getVwapRoc() {\n      return vwapRoc_;\n    }\n\n    public static final int VOLUME_ROC_FIELD_NUMBER = 16;\n    private double volumeRoc_ = 0D;\n    /**\n     * <code>double volume_roc = 16;</code>\n     * @return The volumeRoc.\n     */\n    @java.lang.Override\n    public double getVolumeRoc() {\n      return volumeRoc_;\n    }\n\n    public static final int MACD_LINE_FIELD_NUMBER = 17;\n    private double macdLine_ = 0D;\n    /**\n     * <pre>\n     * NEW INDICATORS for high volatility, low-priced stocks\n     * MACD (Moving Average Convergence Divergence)\n     * </pre>\n     *\n     * <code>double macd_line = 17;</code>\n     * @return The macdLine.\n     */\n    @java.lang.Override\n    public double getMacdLine() {\n      return macdLine_;\n    }\n\n    public static final int MACD_SIGNAL_FIELD_NUMBER = 18;\n    private double macdSignal_ = 0D;\n    /**\n     * <code>double macd_signal = 18;</code>\n     * @return The macdSignal.\n     */\n    @java.lang.Override\n    public double getMacdSignal() {\n      return macdSignal_;\n    }\n\n    public static final int MACD_HISTOGRAM_FIELD_NUMBER = 19;\n    private double macdHistogram_ = 0D;\n    /**\n     * <code>double macd_histogram = 19;</code>\n     * @return The macdHistogram.\n     */\n    @java.lang.Override\n    public double getMacdHistogram() {\n      return macdHistogram_;\n    }\n\n    public static final int EMA_9_FIELD_NUMBER = 20;\n    private double ema9_ = 0D;\n    /**\n     * <pre>\n     * EMA (Exponential Moving Average) - multiple periods\n     * </pre>\n     *\n     * <code>double ema_9 = 20;</code>\n     * @return The ema9.\n     */\n    @java.lang.Override\n    public double getEma9() {\n      return ema9_;\n    }\n\n    public static final int EMA_20_FIELD_NUMBER = 21;\n    private double ema20_ = 0D;\n    /**\n     * <code>double ema_20 = 21;</code>\n     * @return The ema20.\n     */\n    @java.lang.Override\n    public double getEma20() {\n      return ema20_;\n    }\n\n    public static final int EMA_50_FIELD_NUMBER = 22;\n    private double ema50_ = 0D;\n    /**\n     * <code>double ema_50 = 22;</code>\n     * @return The ema50.\n     */\n    @java.lang.Override\n    public double getEma50() {\n      return ema50_;\n    }\n\n    public static final int STOCH_K_FIELD_NUMBER = 23;\n    private double stochK_ = 0D;\n    /**\n     * <pre>\n     * Stochastic Oscillator\n     * </pre>\n     *\n     * <code>double stoch_k = 23;</code>\n     * @return The stochK.\n     */\n    @java.lang.Override\n    public double getStochK() {\n      return stochK_;\n    }\n\n    public static final int STOCH_D_FIELD_NUMBER = 24;\n    private double stochD_ = 0D;\n    /**\n     * <pre>\n     * %D line (signal)\n     * </pre>\n     *\n     * <code>double stoch_d = 24;</code>\n     * @return The stochD.\n     */\n    @java.lang.Override\n    public double getStochD() {\n      return stochD_;\n    }\n\n    public static final int RVOL_FIELD_NUMBER = 25;\n    private double rvol_ = 0D;\n    /**\n     * <pre>\n     * Relative Volume\n     * </pre>\n     *\n     * <code>double rvol = 25;</code>\n     * @return The rvol.\n     */\n    @java.lang.Override\n    public double getRvol() {\n      return rvol_;\n    }\n\n    public static final int VOLUME_SPIKE_FIELD_NUMBER = 26;\n    private boolean volumeSpike_ = false;\n    /**\n     * <pre>\n     * Volume Spike Detection\n     * </pre>\n     *\n     * <code>bool volume_spike = 26;</code>\n     * @return The volumeSpike.\n     */\n    @java.lang.Override\n    public boolean getVolumeSpike() {\n      return volumeSpike_;\n    }\n\n    public static final int VOLUME_RATIO_FIELD_NUMBER = 27;\n    private double volumeRatio_ = 0D;\n    /**\n     * <code>double volume_ratio = 27;</code>\n     * @return The volumeRatio.\n     */\n    @java.lang.Override\n    public double getVolumeRatio() {\n      return volumeRatio_;\n    }\n\n    public static final int ATR_FIELD_NUMBER = 28;\n    private double atr_ = 0D;\n    /**\n     * <pre>\n     * ATR (Average True Range) - volatility indicator\n     * </pre>\n     *\n     * <code>double atr = 28;</code>\n     * @return The atr.\n     */\n    @java.lang.Override\n    public double getAtr() {\n      return atr_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (java.lang.Double.doubleToRawLongBits(rsi_) != 0) {\n        output.writeDouble(1, rsi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(obv_) != 0) {\n        output.writeDouble(2, obv_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(mfi_) != 0) {\n        output.writeDouble(3, mfi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(vwap_) != 0) {\n        output.writeDouble(4, vwap_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerUpper_) != 0) {\n        output.writeDouble(5, bollingerUpper_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerLower_) != 0) {\n        output.writeDouble(6, bollingerLower_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosition_) != 0) {\n        output.writeDouble(7, bollingerPosition_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(percentB_) != 0) {\n        output.writeDouble(8, percentB_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(priceRoc_) != 0) {\n        output.writeDouble(9, priceRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rsiRoc_) != 0) {\n        output.writeDouble(10, rsiRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(obvRoc_) != 0) {\n        output.writeDouble(11, obvRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(mfiRoc_) != 0) {\n        output.writeDouble(12, mfiRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosRoc_) != 0) {\n        output.writeDouble(13, bollingerPosRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(percentBRoc_) != 0) {\n        output.writeDouble(14, percentBRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(vwapRoc_) != 0) {\n        output.writeDouble(15, vwapRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeRoc_) != 0) {\n        output.writeDouble(16, volumeRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdLine_) != 0) {\n        output.writeDouble(17, macdLine_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdSignal_) != 0) {\n        output.writeDouble(18, macdSignal_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdHistogram_) != 0) {\n        output.writeDouble(19, macdHistogram_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema9_) != 0) {\n        output.writeDouble(20, ema9_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema20_) != 0) {\n        output.writeDouble(21, ema20_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema50_) != 0) {\n        output.writeDouble(22, ema50_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochK_) != 0) {\n        output.writeDouble(23, stochK_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochD_) != 0) {\n        output.writeDouble(24, stochD_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rvol_) != 0) {\n        output.writeDouble(25, rvol_);\n      }\n      if (volumeSpike_ != false) {\n        output.writeBool(26, volumeSpike_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeRatio_) != 0) {\n        output.writeDouble(27, volumeRatio_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(atr_) != 0) {\n        output.writeDouble(28, atr_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (java.lang.Double.doubleToRawLongBits(rsi_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(1, rsi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(obv_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(2, obv_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(mfi_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(3, mfi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(vwap_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(4, vwap_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerUpper_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(5, bollingerUpper_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerLower_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(6, bollingerLower_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosition_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(7, bollingerPosition_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(percentB_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(8, percentB_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(priceRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(9, priceRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rsiRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(10, rsiRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(obvRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(11, obvRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(mfiRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(12, mfiRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(13, bollingerPosRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(percentBRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(14, percentBRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(vwapRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(15, vwapRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(16, volumeRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdLine_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(17, macdLine_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdSignal_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(18, macdSignal_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdHistogram_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(19, macdHistogram_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema9_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(20, ema9_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema20_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(21, ema20_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema50_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(22, ema50_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochK_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(23, stochK_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochD_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(24, stochD_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rvol_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(25, rvol_);\n      }\n      if (volumeSpike_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(26, volumeSpike_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeRatio_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(27, volumeRatio_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(atr_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(28, atr_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.SpikeSignalsProto.Indicators)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.SpikeSignalsProto.Indicators other = (com.spiketrade.proto.SpikeSignalsProto.Indicators) obj;\n\n      if (java.lang.Double.doubleToLongBits(getRsi())\n          != java.lang.Double.doubleToLongBits(\n              other.getRsi())) return false;\n      if (java.lang.Double.doubleToLongBits(getObv())\n          != java.lang.Double.doubleToLongBits(\n              other.getObv())) return false;\n      if (java.lang.Double.doubleToLongBits(getMfi())\n          != java.lang.Double.doubleToLongBits(\n              other.getMfi())) return false;\n      if (java.lang.Double.doubleToLongBits(getVwap())\n          != java.lang.Double.doubleToLongBits(\n              other.getVwap())) return false;\n      if (java.lang.Double.doubleToLongBits(getBollingerUpper())\n          != java.lang.Double.doubleToLongBits(\n              other.getBollingerUpper())) return false;\n      if (java.lang.Double.doubleToLongBits(getBollingerLower())\n          != java.lang.Double.doubleToLongBits(\n              other.getBollingerLower())) return false;\n      if (java.lang.Double.doubleToLongBits(getBollingerPosition())\n          != java.lang.Double.doubleToLongBits(\n              other.getBollingerPosition())) return false;\n      if (java.lang.Double.doubleToLongBits(getPercentB())\n          != java.lang.Double.doubleToLongBits(\n              other.getPercentB())) return false;\n      if (java.lang.Double.doubleToLongBits(getPriceRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getPriceRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getRsiRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getRsiRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getObvRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getObvRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getMfiRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getMfiRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getBollingerPosRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getBollingerPosRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getPercentBRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getPercentBRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getVwapRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getVwapRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getVolumeRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getVolumeRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getMacdLine())\n          != java.lang.Double.doubleToLongBits(\n              other.getMacdLine())) return false;\n      if (java.lang.Double.doubleToLongBits(getMacdSignal())\n          != java.lang.Double.doubleToLongBits(\n              other.getMacdSignal())) return false;\n      if (java.lang.Double.doubleToLongBits(getMacdHistogram())\n          != java.lang.Double.doubleToLongBits(\n              other.getMacdHistogram())) return false;\n      if (java.lang.Double.doubleToLongBits(getEma9())\n          != java.lang.Double.doubleToLongBits(\n              other.getEma9())) return false;\n      if (java.lang.Double.doubleToLongBits(getEma20())\n          != java.lang.Double.doubleToLongBits(\n              other.getEma20())) return false;\n      if (java.lang.Double.doubleToLongBits(getEma50())\n          != java.lang.Double.doubleToLongBits(\n              other.getEma50())) return false;\n      if (java.lang.Double.doubleToLongBits(getStochK())\n          != java.lang.Double.doubleToLongBits(\n              other.getStochK())) return false;\n      if (java.lang.Double.doubleToLongBits(getStochD())\n          != java.lang.Double.doubleToLongBits(\n              other.getStochD())) return false;\n      if (java.lang.Double.doubleToLongBits(getRvol())\n          != java.lang.Double.doubleToLongBits(\n              other.getRvol())) return false;\n      if (getVolumeSpike()\n          != other.getVolumeSpike()) return false;\n      if (java.lang.Double.doubleToLongBits(getVolumeRatio())\n          != java.lang.Double.doubleToLongBits(\n              other.getVolumeRatio())) return false;\n      if (java.lang.Double.doubleToLongBits(getAtr())\n          != java.lang.Double.doubleToLongBits(\n              other.getAtr())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + RSI_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRsi()));\n      hash = (37 * hash) + OBV_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getObv()));\n      hash = (37 * hash) + MFI_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMfi()));\n      hash = (37 * hash) + VWAP_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVwap()));\n      hash = (37 * hash) + BOLLINGER_UPPER_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getBollingerUpper()));\n      hash = (37 * hash) + BOLLINGER_LOWER_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getBollingerLower()));\n      hash = (37 * hash) + BOLLINGER_POSITION_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getBollingerPosition()));\n      hash = (37 * hash) + PERCENT_B_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPercentB()));\n      hash = (37 * hash) + PRICE_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPriceRoc()));\n      hash = (37 * hash) + RSI_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRsiRoc()));\n      hash = (37 * hash) + OBV_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getObvRoc()));\n      hash = (37 * hash) + MFI_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMfiRoc()));\n      hash = (37 * hash) + BOLLINGER_POS_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getBollingerPosRoc()));\n      hash = (37 * hash) + PERCENT_B_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPercentBRoc()));\n      hash = (37 * hash) + VWAP_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVwapRoc()));\n      hash = (37 * hash) + VOLUME_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVolumeRoc()));\n      hash = (37 * hash) + MACD_LINE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMacdLine()));\n      hash = (37 * hash) + MACD_SIGNAL_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMacdSignal()));\n      hash = (37 * hash) + MACD_HISTOGRAM_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMacdHistogram()));\n      hash = (37 * hash) + EMA_9_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getEma9()));\n      hash = (37 * hash) + EMA_20_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getEma20()));\n      hash = (37 * hash) + EMA_50_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getEma50()));\n      hash = (37 * hash) + STOCH_K_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getStochK()));\n      hash = (37 * hash) + STOCH_D_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getStochD()));\n      hash = (37 * hash) + RVOL_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRvol()));\n      hash = (37 * hash) + VOLUME_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getVolumeSpike());\n      hash = (37 * hash) + VOLUME_RATIO_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVolumeRatio()));\n      hash = (37 * hash) + ATR_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getAtr()));\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.Indicators parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.Indicators parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.Indicators parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.Indicators parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.Indicators parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.Indicators parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.Indicators parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.Indicators parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.Indicators parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.Indicators parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.Indicators parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.Indicators parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.SpikeSignalsProto.Indicators prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Technical indicators\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.Indicators}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.Indicators)\n        com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_Indicators_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_Indicators_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.SpikeSignalsProto.Indicators.class, com.spiketrade.proto.SpikeSignalsProto.Indicators.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.SpikeSignalsProto.Indicators.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        rsi_ = 0D;\n        obv_ = 0D;\n        mfi_ = 0D;\n        vwap_ = 0D;\n        bollingerUpper_ = 0D;\n        bollingerLower_ = 0D;\n        bollingerPosition_ = 0D;\n        percentB_ = 0D;\n        priceRoc_ = 0D;\n        rsiRoc_ = 0D;\n        obvRoc_ = 0D;\n        mfiRoc_ = 0D;\n        bollingerPosRoc_ = 0D;\n        percentBRoc_ = 0D;\n        vwapRoc_ = 0D;\n        volumeRoc_ = 0D;\n        macdLine_ = 0D;\n        macdSignal_ = 0D;\n        macdHistogram_ = 0D;\n        ema9_ = 0D;\n        ema20_ = 0D;\n        ema50_ = 0D;\n        stochK_ = 0D;\n        stochD_ = 0D;\n        rvol_ = 0D;\n        volumeSpike_ = false;\n        volumeRatio_ = 0D;\n        atr_ = 0D;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_Indicators_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.Indicators getDefaultInstanceForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.Indicators build() {\n        com.spiketrade.proto.SpikeSignalsProto.Indicators result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.Indicators buildPartial() {\n        com.spiketrade.proto.SpikeSignalsProto.Indicators result = new com.spiketrade.proto.SpikeSignalsProto.Indicators(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.SpikeSignalsProto.Indicators result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.rsi_ = rsi_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.obv_ = obv_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.mfi_ = mfi_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.vwap_ = vwap_;\n        }\n        if (((from_bitField0_ & 0x00000010) != 0)) {\n          result.bollingerUpper_ = bollingerUpper_;\n        }\n        if (((from_bitField0_ & 0x00000020) != 0)) {\n          result.bollingerLower_ = bollingerLower_;\n        }\n        if (((from_bitField0_ & 0x00000040) != 0)) {\n          result.bollingerPosition_ = bollingerPosition_;\n        }\n        if (((from_bitField0_ & 0x00000080) != 0)) {\n          result.percentB_ = percentB_;\n        }\n        if (((from_bitField0_ & 0x00000100) != 0)) {\n          result.priceRoc_ = priceRoc_;\n        }\n        if (((from_bitField0_ & 0x00000200) != 0)) {\n          result.rsiRoc_ = rsiRoc_;\n        }\n        if (((from_bitField0_ & 0x00000400) != 0)) {\n          result.obvRoc_ = obvRoc_;\n        }\n        if (((from_bitField0_ & 0x00000800) != 0)) {\n          result.mfiRoc_ = mfiRoc_;\n        }\n        if (((from_bitField0_ & 0x00001000) != 0)) {\n          result.bollingerPosRoc_ = bollingerPosRoc_;\n        }\n        if (((from_bitField0_ & 0x00002000) != 0)) {\n          result.percentBRoc_ = percentBRoc_;\n        }\n        if (((from_bitField0_ & 0x00004000) != 0)) {\n          result.vwapRoc_ = vwapRoc_;\n        }\n        if (((from_bitField0_ & 0x00008000) != 0)) {\n          result.volumeRoc_ = volumeRoc_;\n        }\n        if (((from_bitField0_ & 0x00010000) != 0)) {\n          result.macdLine_ = macdLine_;\n        }\n        if (((from_bitField0_ & 0x00020000) != 0)) {\n          result.macdSignal_ = macdSignal_;\n        }\n        if (((from_bitField0_ & 0x00040000) != 0)) {\n          result.macdHistogram_ = macdHistogram_;\n        }\n        if (((from_bitField0_ & 0x00080000) != 0)) {\n          result.ema9_ = ema9_;\n        }\n        if (((from_bitField0_ & 0x00100000) != 0)) {\n          result.ema20_ = ema20_;\n        }\n        if (((from_bitField0_ & 0x00200000) != 0)) {\n          result.ema50_ = ema50_;\n        }\n        if (((from_bitField0_ & 0x00400000) != 0)) {\n          result.stochK_ = stochK_;\n        }\n        if (((from_bitField0_ & 0x00800000) != 0)) {\n          result.stochD_ = stochD_;\n        }\n        if (((from_bitField0_ & 0x01000000) != 0)) {\n          result.rvol_ = rvol_;\n        }\n        if (((from_bitField0_ & 0x02000000) != 0)) {\n          result.volumeSpike_ = volumeSpike_;\n        }\n        if (((from_bitField0_ & 0x04000000) != 0)) {\n          result.volumeRatio_ = volumeRatio_;\n        }\n        if (((from_bitField0_ & 0x08000000) != 0)) {\n          result.atr_ = atr_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.SpikeSignalsProto.Indicators) {\n          return mergeFrom((com.spiketrade.proto.SpikeSignalsProto.Indicators)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.SpikeSignalsProto.Indicators other) {\n        if (other == com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance()) return this;\n        if (other.getRsi() != 0D) {\n          setRsi(other.getRsi());\n        }\n        if (other.getObv() != 0D) {\n          setObv(other.getObv());\n        }\n        if (other.getMfi() != 0D) {\n          setMfi(other.getMfi());\n        }\n        if (other.getVwap() != 0D) {\n          setVwap(other.getVwap());\n        }\n        if (other.getBollingerUpper() != 0D) {\n          setBollingerUpper(other.getBollingerUpper());\n        }\n        if (other.getBollingerLower() != 0D) {\n          setBollingerLower(other.getBollingerLower());\n        }\n        if (other.getBollingerPosition() != 0D) {\n          setBollingerPosition(other.getBollingerPosition());\n        }\n        if (other.getPercentB() != 0D) {\n          setPercentB(other.getPercentB());\n        }\n        if (other.getPriceRoc() != 0D) {\n          setPriceRoc(other.getPriceRoc());\n        }\n        if (other.getRsiRoc() != 0D) {\n          setRsiRoc(other.getRsiRoc());\n        }\n        if (other.getObvRoc() != 0D) {\n          setObvRoc(other.getObvRoc());\n        }\n        if (other.getMfiRoc() != 0D) {\n          setMfiRoc(other.getMfiRoc());\n        }\n        if (other.getBollingerPosRoc() != 0D) {\n          setBollingerPosRoc(other.getBollingerPosRoc());\n        }\n        if (other.getPercentBRoc() != 0D) {\n          setPercentBRoc(other.getPercentBRoc());\n        }\n        if (other.getVwapRoc() != 0D) {\n          setVwapRoc(other.getVwapRoc());\n        }\n        if (other.getVolumeRoc() != 0D) {\n          setVolumeRoc(other.getVolumeRoc());\n        }\n        if (other.getMacdLine() != 0D) {\n          setMacdLine(other.getMacdLine());\n        }\n        if (other.getMacdSignal() != 0D) {\n          setMacdSignal(other.getMacdSignal());\n        }\n        if (other.getMacdHistogram() != 0D) {\n          setMacdHistogram(other.getMacdHistogram());\n        }\n        if (other.getEma9() != 0D) {\n          setEma9(other.getEma9());\n        }\n        if (other.getEma20() != 0D) {\n          setEma20(other.getEma20());\n        }\n        if (other.getEma50() != 0D) {\n          setEma50(other.getEma50());\n        }\n        if (other.getStochK() != 0D) {\n          setStochK(other.getStochK());\n        }\n        if (other.getStochD() != 0D) {\n          setStochD(other.getStochD());\n        }\n        if (other.getRvol() != 0D) {\n          setRvol(other.getRvol());\n        }\n        if (other.getVolumeSpike() != false) {\n          setVolumeSpike(other.getVolumeSpike());\n        }\n        if (other.getVolumeRatio() != 0D) {\n          setVolumeRatio(other.getVolumeRatio());\n        }\n        if (other.getAtr() != 0D) {\n          setAtr(other.getAtr());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 9: {\n                rsi_ = input.readDouble();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 9\n              case 17: {\n                obv_ = input.readDouble();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 17\n              case 25: {\n                mfi_ = input.readDouble();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 25\n              case 33: {\n                vwap_ = input.readDouble();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 33\n              case 41: {\n                bollingerUpper_ = input.readDouble();\n                bitField0_ |= 0x00000010;\n                break;\n              } // case 41\n              case 49: {\n                bollingerLower_ = input.readDouble();\n                bitField0_ |= 0x00000020;\n                break;\n              } // case 49\n              case 57: {\n                bollingerPosition_ = input.readDouble();\n                bitField0_ |= 0x00000040;\n                break;\n              } // case 57\n              case 65: {\n                percentB_ = input.readDouble();\n                bitField0_ |= 0x00000080;\n                break;\n              } // case 65\n              case 73: {\n                priceRoc_ = input.readDouble();\n                bitField0_ |= 0x00000100;\n                break;\n              } // case 73\n              case 81: {\n                rsiRoc_ = input.readDouble();\n                bitField0_ |= 0x00000200;\n                break;\n              } // case 81\n              case 89: {\n                obvRoc_ = input.readDouble();\n                bitField0_ |= 0x00000400;\n                break;\n              } // case 89\n              case 97: {\n                mfiRoc_ = input.readDouble();\n                bitField0_ |= 0x00000800;\n                break;\n              } // case 97\n              case 105: {\n                bollingerPosRoc_ = input.readDouble();\n                bitField0_ |= 0x00001000;\n                break;\n              } // case 105\n              case 113: {\n                percentBRoc_ = input.readDouble();\n                bitField0_ |= 0x00002000;\n                break;\n              } // case 113\n              case 121: {\n                vwapRoc_ = input.readDouble();\n                bitField0_ |= 0x00004000;\n                break;\n              } // case 121\n              case 129: {\n                volumeRoc_ = input.readDouble();\n                bitField0_ |= 0x00008000;\n                break;\n              } // case 129\n              case 137: {\n                macdLine_ = input.readDouble();\n                bitField0_ |= 0x00010000;\n                break;\n              } // case 137\n              case 145: {\n                macdSignal_ = input.readDouble();\n                bitField0_ |= 0x00020000;\n                break;\n              } // case 145\n              case 153: {\n                macdHistogram_ = input.readDouble();\n                bitField0_ |= 0x00040000;\n                break;\n              } // case 153\n              case 161: {\n                ema9_ = input.readDouble();\n                bitField0_ |= 0x00080000;\n                break;\n              } // case 161\n              case 169: {\n                ema20_ = input.readDouble();\n                bitField0_ |= 0x00100000;\n                break;\n              } // case 169\n              case 177: {\n                ema50_ = input.readDouble();\n                bitField0_ |= 0x00200000;\n                break;\n              } // case 177\n              case 185: {\n                stochK_ = input.readDouble();\n                bitField0_ |= 0x00400000;\n                break;\n              } // case 185\n              case 193: {\n                stochD_ = input.readDouble();\n                bitField0_ |= 0x00800000;\n                break;\n              } // case 193\n              case 201: {\n                rvol_ = input.readDouble();\n                bitField0_ |= 0x01000000;\n                break;\n              } // case 201\n              case 208: {\n                volumeSpike_ = input.readBool();\n                bitField0_ |= 0x02000000;\n                break;\n              } // case 208\n              case 217: {\n                volumeRatio_ = input.readDouble();\n                bitField0_ |= 0x04000000;\n                break;\n              } // case 217\n              case 225: {\n                atr_ = input.readDouble();\n                bitField0_ |= 0x08000000;\n                break;\n              } // case 225\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private double rsi_ ;\n      /**\n       * <pre>\n       * Legacy indicators (keep for backward compatibility)\n       * </pre>\n       *\n       * <code>double rsi = 1;</code>\n       * @return The rsi.\n       */\n      @java.lang.Override\n      public double getRsi() {\n        return rsi_;\n      }\n      /**\n       * <pre>\n       * Legacy indicators (keep for backward compatibility)\n       * </pre>\n       *\n       * <code>double rsi = 1;</code>\n       * @param value The rsi to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRsi(double value) {\n\n        rsi_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Legacy indicators (keep for backward compatibility)\n       * </pre>\n       *\n       * <code>double rsi = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRsi() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        rsi_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double obv_ ;\n      /**\n       * <code>double obv = 2;</code>\n       * @return The obv.\n       */\n      @java.lang.Override\n      public double getObv() {\n        return obv_;\n      }\n      /**\n       * <code>double obv = 2;</code>\n       * @param value The obv to set.\n       * @return This builder for chaining.\n       */\n      public Builder setObv(double value) {\n\n        obv_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double obv = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearObv() {\n        bitField0_ = (bitField0_ & ~0x00000002);\n        obv_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double mfi_ ;\n      /**\n       * <code>double mfi = 3;</code>\n       * @return The mfi.\n       */\n      @java.lang.Override\n      public double getMfi() {\n        return mfi_;\n      }\n      /**\n       * <code>double mfi = 3;</code>\n       * @param value The mfi to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMfi(double value) {\n\n        mfi_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double mfi = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMfi() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        mfi_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double vwap_ ;\n      /**\n       * <code>double vwap = 4;</code>\n       * @return The vwap.\n       */\n      @java.lang.Override\n      public double getVwap() {\n        return vwap_;\n      }\n      /**\n       * <code>double vwap = 4;</code>\n       * @param value The vwap to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVwap(double value) {\n\n        vwap_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double vwap = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVwap() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        vwap_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double bollingerUpper_ ;\n      /**\n       * <code>double bollinger_upper = 5;</code>\n       * @return The bollingerUpper.\n       */\n      @java.lang.Override\n      public double getBollingerUpper() {\n        return bollingerUpper_;\n      }\n      /**\n       * <code>double bollinger_upper = 5;</code>\n       * @param value The bollingerUpper to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBollingerUpper(double value) {\n\n        bollingerUpper_ = value;\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double bollinger_upper = 5;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBollingerUpper() {\n        bitField0_ = (bitField0_ & ~0x00000010);\n        bollingerUpper_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double bollingerLower_ ;\n      /**\n       * <code>double bollinger_lower = 6;</code>\n       * @return The bollingerLower.\n       */\n      @java.lang.Override\n      public double getBollingerLower() {\n        return bollingerLower_;\n      }\n      /**\n       * <code>double bollinger_lower = 6;</code>\n       * @param value The bollingerLower to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBollingerLower(double value) {\n\n        bollingerLower_ = value;\n        bitField0_ |= 0x00000020;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double bollinger_lower = 6;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBollingerLower() {\n        bitField0_ = (bitField0_ & ~0x00000020);\n        bollingerLower_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double bollingerPosition_ ;\n      /**\n       * <code>double bollinger_position = 7;</code>\n       * @return The bollingerPosition.\n       */\n      @java.lang.Override\n      public double getBollingerPosition() {\n        return bollingerPosition_;\n      }\n      /**\n       * <code>double bollinger_position = 7;</code>\n       * @param value The bollingerPosition to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBollingerPosition(double value) {\n\n        bollingerPosition_ = value;\n        bitField0_ |= 0x00000040;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double bollinger_position = 7;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBollingerPosition() {\n        bitField0_ = (bitField0_ & ~0x00000040);\n        bollingerPosition_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double percentB_ ;\n      /**\n       * <code>double percent_b = 8;</code>\n       * @return The percentB.\n       */\n      @java.lang.Override\n      public double getPercentB() {\n        return percentB_;\n      }\n      /**\n       * <code>double percent_b = 8;</code>\n       * @param value The percentB to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPercentB(double value) {\n\n        percentB_ = value;\n        bitField0_ |= 0x00000080;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double percent_b = 8;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPercentB() {\n        bitField0_ = (bitField0_ & ~0x00000080);\n        percentB_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double priceRoc_ ;\n      /**\n       * <code>double price_roc = 9;</code>\n       * @return The priceRoc.\n       */\n      @java.lang.Override\n      public double getPriceRoc() {\n        return priceRoc_;\n      }\n      /**\n       * <code>double price_roc = 9;</code>\n       * @param value The priceRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPriceRoc(double value) {\n\n        priceRoc_ = value;\n        bitField0_ |= 0x00000100;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double price_roc = 9;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPriceRoc() {\n        bitField0_ = (bitField0_ & ~0x00000100);\n        priceRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double rsiRoc_ ;\n      /**\n       * <code>double rsi_roc = 10;</code>\n       * @return The rsiRoc.\n       */\n      @java.lang.Override\n      public double getRsiRoc() {\n        return rsiRoc_;\n      }\n      /**\n       * <code>double rsi_roc = 10;</code>\n       * @param value The rsiRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRsiRoc(double value) {\n\n        rsiRoc_ = value;\n        bitField0_ |= 0x00000200;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double rsi_roc = 10;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRsiRoc() {\n        bitField0_ = (bitField0_ & ~0x00000200);\n        rsiRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double obvRoc_ ;\n      /**\n       * <code>double obv_roc = 11;</code>\n       * @return The obvRoc.\n       */\n      @java.lang.Override\n      public double getObvRoc() {\n        return obvRoc_;\n      }\n      /**\n       * <code>double obv_roc = 11;</code>\n       * @param value The obvRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setObvRoc(double value) {\n\n        obvRoc_ = value;\n        bitField0_ |= 0x00000400;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double obv_roc = 11;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearObvRoc() {\n        bitField0_ = (bitField0_ & ~0x00000400);\n        obvRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double mfiRoc_ ;\n      /**\n       * <code>double mfi_roc = 12;</code>\n       * @return The mfiRoc.\n       */\n      @java.lang.Override\n      public double getMfiRoc() {\n        return mfiRoc_;\n      }\n      /**\n       * <code>double mfi_roc = 12;</code>\n       * @param value The mfiRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMfiRoc(double value) {\n\n        mfiRoc_ = value;\n        bitField0_ |= 0x00000800;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double mfi_roc = 12;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMfiRoc() {\n        bitField0_ = (bitField0_ & ~0x00000800);\n        mfiRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double bollingerPosRoc_ ;\n      /**\n       * <code>double bollinger_pos_roc = 13;</code>\n       * @return The bollingerPosRoc.\n       */\n      @java.lang.Override\n      public double getBollingerPosRoc() {\n        return bollingerPosRoc_;\n      }\n      /**\n       * <code>double bollinger_pos_roc = 13;</code>\n       * @param value The bollingerPosRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBollingerPosRoc(double value) {\n\n        bollingerPosRoc_ = value;\n        bitField0_ |= 0x00001000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double bollinger_pos_roc = 13;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBollingerPosRoc() {\n        bitField0_ = (bitField0_ & ~0x00001000);\n        bollingerPosRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double percentBRoc_ ;\n      /**\n       * <code>double percent_b_roc = 14;</code>\n       * @return The percentBRoc.\n       */\n      @java.lang.Override\n      public double getPercentBRoc() {\n        return percentBRoc_;\n      }\n      /**\n       * <code>double percent_b_roc = 14;</code>\n       * @param value The percentBRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPercentBRoc(double value) {\n\n        percentBRoc_ = value;\n        bitField0_ |= 0x00002000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double percent_b_roc = 14;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPercentBRoc() {\n        bitField0_ = (bitField0_ & ~0x00002000);\n        percentBRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double vwapRoc_ ;\n      /**\n       * <code>double vwap_roc = 15;</code>\n       * @return The vwapRoc.\n       */\n      @java.lang.Override\n      public double getVwapRoc() {\n        return vwapRoc_;\n      }\n      /**\n       * <code>double vwap_roc = 15;</code>\n       * @param value The vwapRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVwapRoc(double value) {\n\n        vwapRoc_ = value;\n        bitField0_ |= 0x00004000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double vwap_roc = 15;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVwapRoc() {\n        bitField0_ = (bitField0_ & ~0x00004000);\n        vwapRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double volumeRoc_ ;\n      /**\n       * <code>double volume_roc = 16;</code>\n       * @return The volumeRoc.\n       */\n      @java.lang.Override\n      public double getVolumeRoc() {\n        return volumeRoc_;\n      }\n      /**\n       * <code>double volume_roc = 16;</code>\n       * @param value The volumeRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolumeRoc(double value) {\n\n        volumeRoc_ = value;\n        bitField0_ |= 0x00008000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double volume_roc = 16;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolumeRoc() {\n        bitField0_ = (bitField0_ & ~0x00008000);\n        volumeRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double macdLine_ ;\n      /**\n       * <pre>\n       * NEW INDICATORS for high volatility, low-priced stocks\n       * MACD (Moving Average Convergence Divergence)\n       * </pre>\n       *\n       * <code>double macd_line = 17;</code>\n       * @return The macdLine.\n       */\n      @java.lang.Override\n      public double getMacdLine() {\n        return macdLine_;\n      }\n      /**\n       * <pre>\n       * NEW INDICATORS for high volatility, low-priced stocks\n       * MACD (Moving Average Convergence Divergence)\n       * </pre>\n       *\n       * <code>double macd_line = 17;</code>\n       * @param value The macdLine to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMacdLine(double value) {\n\n        macdLine_ = value;\n        bitField0_ |= 0x00010000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * NEW INDICATORS for high volatility, low-priced stocks\n       * MACD (Moving Average Convergence Divergence)\n       * </pre>\n       *\n       * <code>double macd_line = 17;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMacdLine() {\n        bitField0_ = (bitField0_ & ~0x00010000);\n        macdLine_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double macdSignal_ ;\n      /**\n       * <code>double macd_signal = 18;</code>\n       * @return The macdSignal.\n       */\n      @java.lang.Override\n      public double getMacdSignal() {\n        return macdSignal_;\n      }\n      /**\n       * <code>double macd_signal = 18;</code>\n       * @param value The macdSignal to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMacdSignal(double value) {\n\n        macdSignal_ = value;\n        bitField0_ |= 0x00020000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double macd_signal = 18;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMacdSignal() {\n        bitField0_ = (bitField0_ & ~0x00020000);\n        macdSignal_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double macdHistogram_ ;\n      /**\n       * <code>double macd_histogram = 19;</code>\n       * @return The macdHistogram.\n       */\n      @java.lang.Override\n      public double getMacdHistogram() {\n        return macdHistogram_;\n      }\n      /**\n       * <code>double macd_histogram = 19;</code>\n       * @param value The macdHistogram to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMacdHistogram(double value) {\n\n        macdHistogram_ = value;\n        bitField0_ |= 0x00040000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double macd_histogram = 19;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMacdHistogram() {\n        bitField0_ = (bitField0_ & ~0x00040000);\n        macdHistogram_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double ema9_ ;\n      /**\n       * <pre>\n       * EMA (Exponential Moving Average) - multiple periods\n       * </pre>\n       *\n       * <code>double ema_9 = 20;</code>\n       * @return The ema9.\n       */\n      @java.lang.Override\n      public double getEma9() {\n        return ema9_;\n      }\n      /**\n       * <pre>\n       * EMA (Exponential Moving Average) - multiple periods\n       * </pre>\n       *\n       * <code>double ema_9 = 20;</code>\n       * @param value The ema9 to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEma9(double value) {\n\n        ema9_ = value;\n        bitField0_ |= 0x00080000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * EMA (Exponential Moving Average) - multiple periods\n       * </pre>\n       *\n       * <code>double ema_9 = 20;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEma9() {\n        bitField0_ = (bitField0_ & ~0x00080000);\n        ema9_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double ema20_ ;\n      /**\n       * <code>double ema_20 = 21;</code>\n       * @return The ema20.\n       */\n      @java.lang.Override\n      public double getEma20() {\n        return ema20_;\n      }\n      /**\n       * <code>double ema_20 = 21;</code>\n       * @param value The ema20 to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEma20(double value) {\n\n        ema20_ = value;\n        bitField0_ |= 0x00100000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double ema_20 = 21;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEma20() {\n        bitField0_ = (bitField0_ & ~0x00100000);\n        ema20_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double ema50_ ;\n      /**\n       * <code>double ema_50 = 22;</code>\n       * @return The ema50.\n       */\n      @java.lang.Override\n      public double getEma50() {\n        return ema50_;\n      }\n      /**\n       * <code>double ema_50 = 22;</code>\n       * @param value The ema50 to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEma50(double value) {\n\n        ema50_ = value;\n        bitField0_ |= 0x00200000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double ema_50 = 22;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEma50() {\n        bitField0_ = (bitField0_ & ~0x00200000);\n        ema50_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double stochK_ ;\n      /**\n       * <pre>\n       * Stochastic Oscillator\n       * </pre>\n       *\n       * <code>double stoch_k = 23;</code>\n       * @return The stochK.\n       */\n      @java.lang.Override\n      public double getStochK() {\n        return stochK_;\n      }\n      /**\n       * <pre>\n       * Stochastic Oscillator\n       * </pre>\n       *\n       * <code>double stoch_k = 23;</code>\n       * @param value The stochK to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStochK(double value) {\n\n        stochK_ = value;\n        bitField0_ |= 0x00400000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Stochastic Oscillator\n       * </pre>\n       *\n       * <code>double stoch_k = 23;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStochK() {\n        bitField0_ = (bitField0_ & ~0x00400000);\n        stochK_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double stochD_ ;\n      /**\n       * <pre>\n       * %D line (signal)\n       * </pre>\n       *\n       * <code>double stoch_d = 24;</code>\n       * @return The stochD.\n       */\n      @java.lang.Override\n      public double getStochD() {\n        return stochD_;\n      }\n      /**\n       * <pre>\n       * %D line (signal)\n       * </pre>\n       *\n       * <code>double stoch_d = 24;</code>\n       * @param value The stochD to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStochD(double value) {\n\n        stochD_ = value;\n        bitField0_ |= 0x00800000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * %D line (signal)\n       * </pre>\n       *\n       * <code>double stoch_d = 24;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStochD() {\n        bitField0_ = (bitField0_ & ~0x00800000);\n        stochD_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double rvol_ ;\n      /**\n       * <pre>\n       * Relative Volume\n       * </pre>\n       *\n       * <code>double rvol = 25;</code>\n       * @return The rvol.\n       */\n      @java.lang.Override\n      public double getRvol() {\n        return rvol_;\n      }\n      /**\n       * <pre>\n       * Relative Volume\n       * </pre>\n       *\n       * <code>double rvol = 25;</code>\n       * @param value The rvol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRvol(double value) {\n\n        rvol_ = value;\n        bitField0_ |= 0x01000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Relative Volume\n       * </pre>\n       *\n       * <code>double rvol = 25;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRvol() {\n        bitField0_ = (bitField0_ & ~0x01000000);\n        rvol_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private boolean volumeSpike_ ;\n      /**\n       * <pre>\n       * Volume Spike Detection\n       * </pre>\n       *\n       * <code>bool volume_spike = 26;</code>\n       * @return The volumeSpike.\n       */\n      @java.lang.Override\n      public boolean getVolumeSpike() {\n        return volumeSpike_;\n      }\n      /**\n       * <pre>\n       * Volume Spike Detection\n       * </pre>\n       *\n       * <code>bool volume_spike = 26;</code>\n       * @param value The volumeSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolumeSpike(boolean value) {\n\n        volumeSpike_ = value;\n        bitField0_ |= 0x02000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Volume Spike Detection\n       * </pre>\n       *\n       * <code>bool volume_spike = 26;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolumeSpike() {\n        bitField0_ = (bitField0_ & ~0x02000000);\n        volumeSpike_ = false;\n        onChanged();\n        return this;\n      }\n\n      private double volumeRatio_ ;\n      /**\n       * <code>double volume_ratio = 27;</code>\n       * @return The volumeRatio.\n       */\n      @java.lang.Override\n      public double getVolumeRatio() {\n        return volumeRatio_;\n      }\n      /**\n       * <code>double volume_ratio = 27;</code>\n       * @param value The volumeRatio to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolumeRatio(double value) {\n\n        volumeRatio_ = value;\n        bitField0_ |= 0x04000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double volume_ratio = 27;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolumeRatio() {\n        bitField0_ = (bitField0_ & ~0x04000000);\n        volumeRatio_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double atr_ ;\n      /**\n       * <pre>\n       * ATR (Average True Range) - volatility indicator\n       * </pre>\n       *\n       * <code>double atr = 28;</code>\n       * @return The atr.\n       */\n      @java.lang.Override\n      public double getAtr() {\n        return atr_;\n      }\n      /**\n       * <pre>\n       * ATR (Average True Range) - volatility indicator\n       * </pre>\n       *\n       * <code>double atr = 28;</code>\n       * @param value The atr to set.\n       * @return This builder for chaining.\n       */\n      public Builder setAtr(double value) {\n\n        atr_ = value;\n        bitField0_ |= 0x08000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * ATR (Average True Range) - volatility indicator\n       * </pre>\n       *\n       * <code>double atr = 28;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearAtr() {\n        bitField0_ = (bitField0_ & ~0x08000000);\n        atr_ = 0D;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.Indicators)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.Indicators)\n    private static final com.spiketrade.proto.SpikeSignalsProto.Indicators DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.SpikeSignalsProto.Indicators();\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.Indicators getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<Indicators>\n        PARSER = new com.google.protobuf.AbstractParser<Indicators>() {\n      @java.lang.Override\n      public Indicators parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<Indicators> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<Indicators> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.Indicators getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface IndicatorStreamRequestOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.IndicatorStreamRequest)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @return A list containing the symbols.\n     */\n    java.util.List<java.lang.String>\n        getSymbolsList();\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @return The count of symbols.\n     */\n    int getSymbolsCount();\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @param index The index of the element to return.\n     * @return The symbols at the given index.\n     */\n    java.lang.String getSymbols(int index);\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @param index The index of the value to return.\n     * @return The bytes of the symbols at the given index.\n     */\n    com.google.protobuf.ByteString\n        getSymbolsBytes(int index);\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.IndicatorStreamRequest}\n   */\n  public static final class IndicatorStreamRequest extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.IndicatorStreamRequest)\n      IndicatorStreamRequestOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use IndicatorStreamRequest.newBuilder() to construct.\n    private IndicatorStreamRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private IndicatorStreamRequest() {\n      symbols_ =\n          com.google.protobuf.LazyStringArrayList.emptyList();\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new IndicatorStreamRequest();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_IndicatorStreamRequest_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_IndicatorStreamRequest_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest.class, com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest.Builder.class);\n    }\n\n    public static final int SYMBOLS_FIELD_NUMBER = 1;\n    @SuppressWarnings(\"serial\")\n    private com.google.protobuf.LazyStringArrayList symbols_ =\n        com.google.protobuf.LazyStringArrayList.emptyList();\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @return A list containing the symbols.\n     */\n    public com.google.protobuf.ProtocolStringList\n        getSymbolsList() {\n      return symbols_;\n    }\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @return The count of symbols.\n     */\n    public int getSymbolsCount() {\n      return symbols_.size();\n    }\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @param index The index of the element to return.\n     * @return The symbols at the given index.\n     */\n    public java.lang.String getSymbols(int index) {\n      return symbols_.get(index);\n    }\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @param index The index of the value to return.\n     * @return The bytes of the symbols at the given index.\n     */\n    public com.google.protobuf.ByteString\n        getSymbolsBytes(int index) {\n      return symbols_.getByteString(index);\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      for (int i = 0; i < symbols_.size(); i++) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, symbols_.getRaw(i));\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      {\n        int dataSize = 0;\n        for (int i = 0; i < symbols_.size(); i++) {\n          dataSize += computeStringSizeNoTag(symbols_.getRaw(i));\n        }\n        size += dataSize;\n        size += 1 * getSymbolsList().size();\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest other = (com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest) obj;\n\n      if (!getSymbolsList()\n          .equals(other.getSymbolsList())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      if (getSymbolsCount() > 0) {\n        hash = (37 * hash) + SYMBOLS_FIELD_NUMBER;\n        hash = (53 * hash) + getSymbolsList().hashCode();\n      }\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.IndicatorStreamRequest}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.IndicatorStreamRequest)\n        com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequestOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_IndicatorStreamRequest_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_IndicatorStreamRequest_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest.class, com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        symbols_ =\n            com.google.protobuf.LazyStringArrayList.emptyList();\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_IndicatorStreamRequest_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest getDefaultInstanceForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest build() {\n        com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest buildPartial() {\n        com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest result = new com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          symbols_.makeImmutable();\n          result.symbols_ = symbols_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest) {\n          return mergeFrom((com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest other) {\n        if (other == com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest.getDefaultInstance()) return this;\n        if (!other.symbols_.isEmpty()) {\n          if (symbols_.isEmpty()) {\n            symbols_ = other.symbols_;\n            bitField0_ |= 0x00000001;\n          } else {\n            ensureSymbolsIsMutable();\n            symbols_.addAll(other.symbols_);\n          }\n          onChanged();\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 10: {\n                java.lang.String s = input.readStringRequireUtf8();\n                ensureSymbolsIsMutable();\n                symbols_.add(s);\n                break;\n              } // case 10\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private com.google.protobuf.LazyStringArrayList symbols_ =\n          com.google.protobuf.LazyStringArrayList.emptyList();\n      private void ensureSymbolsIsMutable() {\n        if (!symbols_.isModifiable()) {\n          symbols_ = new com.google.protobuf.LazyStringArrayList(symbols_);\n        }\n        bitField0_ |= 0x00000001;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @return A list containing the symbols.\n       */\n      public com.google.protobuf.ProtocolStringList\n          getSymbolsList() {\n        symbols_.makeImmutable();\n        return symbols_;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @return The count of symbols.\n       */\n      public int getSymbolsCount() {\n        return symbols_.size();\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param index The index of the element to return.\n       * @return The symbols at the given index.\n       */\n      public java.lang.String getSymbols(int index) {\n        return symbols_.get(index);\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param index The index of the value to return.\n       * @return The bytes of the symbols at the given index.\n       */\n      public com.google.protobuf.ByteString\n          getSymbolsBytes(int index) {\n        return symbols_.getByteString(index);\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param index The index to set the value at.\n       * @param value The symbols to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbols(\n          int index, java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        ensureSymbolsIsMutable();\n        symbols_.set(index, value);\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param value The symbols to add.\n       * @return This builder for chaining.\n       */\n      public Builder addSymbols(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        ensureSymbolsIsMutable();\n        symbols_.add(value);\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param values The symbols to add.\n       * @return This builder for chaining.\n       */\n      public Builder addAllSymbols(\n          java.lang.Iterable<java.lang.String> values) {\n        ensureSymbolsIsMutable();\n        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n            values, symbols_);\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSymbols() {\n        symbols_ =\n          com.google.protobuf.LazyStringArrayList.emptyList();\n        bitField0_ = (bitField0_ & ~0x00000001);;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param value The bytes of the symbols to add.\n       * @return This builder for chaining.\n       */\n      public Builder addSymbolsBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        ensureSymbolsIsMutable();\n        symbols_.add(value);\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.IndicatorStreamRequest)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.IndicatorStreamRequest)\n    private static final com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest();\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<IndicatorStreamRequest>\n        PARSER = new com.google.protobuf.AbstractParser<IndicatorStreamRequest>() {\n      @java.lang.Override\n      public IndicatorStreamRequest parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<IndicatorStreamRequest> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<IndicatorStreamRequest> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.IndicatorStreamRequest getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface IndicatorUpdateOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.IndicatorUpdate)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    java.lang.String getSymbol();\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    com.google.protobuf.ByteString\n        getSymbolBytes();\n\n    /**\n     * <code>double rsi = 2;</code>\n     * @return The rsi.\n     */\n    double getRsi();\n\n    /**\n     * <code>double price_roc = 3;</code>\n     * @return The priceRoc.\n     */\n    double getPriceRoc();\n\n    /**\n     * <code>double volume_roc = 4;</code>\n     * @return The volumeRoc.\n     */\n    double getVolumeRoc();\n\n    /**\n     * <code>double obv = 5;</code>\n     * @return The obv.\n     */\n    double getObv();\n\n    /**\n     * <code>double mfi = 6;</code>\n     * @return The mfi.\n     */\n    double getMfi();\n\n    /**\n     * <code>double bollinger_position = 7;</code>\n     * @return The bollingerPosition.\n     */\n    double getBollingerPosition();\n\n    /**\n     * <code>double percent_b = 8;</code>\n     * @return The percentB.\n     */\n    double getPercentB();\n\n    /**\n     * <code>double vwap = 9;</code>\n     * @return The vwap.\n     */\n    double getVwap();\n\n    /**\n     * <pre>\n     * NEW INDICATORS\n     * </pre>\n     *\n     * <code>double macd_histogram = 10;</code>\n     * @return The macdHistogram.\n     */\n    double getMacdHistogram();\n\n    /**\n     * <code>double ema_9 = 11;</code>\n     * @return The ema9.\n     */\n    double getEma9();\n\n    /**\n     * <code>double ema_20 = 12;</code>\n     * @return The ema20.\n     */\n    double getEma20();\n\n    /**\n     * <code>double ema_50 = 13;</code>\n     * @return The ema50.\n     */\n    double getEma50();\n\n    /**\n     * <code>double stoch_k = 14;</code>\n     * @return The stochK.\n     */\n    double getStochK();\n\n    /**\n     * <code>double stoch_d = 15;</code>\n     * @return The stochD.\n     */\n    double getStochD();\n\n    /**\n     * <code>double rvol = 16;</code>\n     * @return The rvol.\n     */\n    double getRvol();\n\n    /**\n     * <code>bool volume_spike = 17;</code>\n     * @return The volumeSpike.\n     */\n    boolean getVolumeSpike();\n\n    /**\n     * <code>double atr = 18;</code>\n     * @return The atr.\n     */\n    double getAtr();\n  }\n  /**\n   * Protobuf type {@code spiketrade.proto.IndicatorUpdate}\n   */\n  public static final class IndicatorUpdate extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.IndicatorUpdate)\n      IndicatorUpdateOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use IndicatorUpdate.newBuilder() to construct.\n    private IndicatorUpdate(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private IndicatorUpdate() {\n      symbol_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new IndicatorUpdate();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_IndicatorUpdate_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_IndicatorUpdate_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate.class, com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate.Builder.class);\n    }\n\n    public static final int SYMBOL_FIELD_NUMBER = 1;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object symbol_ = \"\";\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    @java.lang.Override\n    public java.lang.String getSymbol() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        symbol_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getSymbolBytes() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        symbol_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int RSI_FIELD_NUMBER = 2;\n    private double rsi_ = 0D;\n    /**\n     * <code>double rsi = 2;</code>\n     * @return The rsi.\n     */\n    @java.lang.Override\n    public double getRsi() {\n      return rsi_;\n    }\n\n    public static final int PRICE_ROC_FIELD_NUMBER = 3;\n    private double priceRoc_ = 0D;\n    /**\n     * <code>double price_roc = 3;</code>\n     * @return The priceRoc.\n     */\n    @java.lang.Override\n    public double getPriceRoc() {\n      return priceRoc_;\n    }\n\n    public static final int VOLUME_ROC_FIELD_NUMBER = 4;\n    private double volumeRoc_ = 0D;\n    /**\n     * <code>double volume_roc = 4;</code>\n     * @return The volumeRoc.\n     */\n    @java.lang.Override\n    public double getVolumeRoc() {\n      return volumeRoc_;\n    }\n\n    public static final int OBV_FIELD_NUMBER = 5;\n    private double obv_ = 0D;\n    /**\n     * <code>double obv = 5;</code>\n     * @return The obv.\n     */\n    @java.lang.Override\n    public double getObv() {\n      return obv_;\n    }\n\n    public static final int MFI_FIELD_NUMBER = 6;\n    private double mfi_ = 0D;\n    /**\n     * <code>double mfi = 6;</code>\n     * @return The mfi.\n     */\n    @java.lang.Override\n    public double getMfi() {\n      return mfi_;\n    }\n\n    public static final int BOLLINGER_POSITION_FIELD_NUMBER = 7;\n    private double bollingerPosition_ = 0D;\n    /**\n     * <code>double bollinger_position = 7;</code>\n     * @return The bollingerPosition.\n     */\n    @java.lang.Override\n    public double getBollingerPosition() {\n      return bollingerPosition_;\n    }\n\n    public static final int PERCENT_B_FIELD_NUMBER = 8;\n    private double percentB_ = 0D;\n    /**\n     * <code>double percent_b = 8;</code>\n     * @return The percentB.\n     */\n    @java.lang.Override\n    public double getPercentB() {\n      return percentB_;\n    }\n\n    public static final int VWAP_FIELD_NUMBER = 9;\n    private double vwap_ = 0D;\n    /**\n     * <code>double vwap = 9;</code>\n     * @return The vwap.\n     */\n    @java.lang.Override\n    public double getVwap() {\n      return vwap_;\n    }\n\n    public static final int MACD_HISTOGRAM_FIELD_NUMBER = 10;\n    private double macdHistogram_ = 0D;\n    /**\n     * <pre>\n     * NEW INDICATORS\n     * </pre>\n     *\n     * <code>double macd_histogram = 10;</code>\n     * @return The macdHistogram.\n     */\n    @java.lang.Override\n    public double getMacdHistogram() {\n      return macdHistogram_;\n    }\n\n    public static final int EMA_9_FIELD_NUMBER = 11;\n    private double ema9_ = 0D;\n    /**\n     * <code>double ema_9 = 11;</code>\n     * @return The ema9.\n     */\n    @java.lang.Override\n    public double getEma9() {\n      return ema9_;\n    }\n\n    public static final int EMA_20_FIELD_NUMBER = 12;\n    private double ema20_ = 0D;\n    /**\n     * <code>double ema_20 = 12;</code>\n     * @return The ema20.\n     */\n    @java.lang.Override\n    public double getEma20() {\n      return ema20_;\n    }\n\n    public static final int EMA_50_FIELD_NUMBER = 13;\n    private double ema50_ = 0D;\n    /**\n     * <code>double ema_50 = 13;</code>\n     * @return The ema50.\n     */\n    @java.lang.Override\n    public double getEma50() {\n      return ema50_;\n    }\n\n    public static final int STOCH_K_FIELD_NUMBER = 14;\n    private double stochK_ = 0D;\n    /**\n     * <code>double stoch_k = 14;</code>\n     * @return The stochK.\n     */\n    @java.lang.Override\n    public double getStochK() {\n      return stochK_;\n    }\n\n    public static final int STOCH_D_FIELD_NUMBER = 15;\n    private double stochD_ = 0D;\n    /**\n     * <code>double stoch_d = 15;</code>\n     * @return The stochD.\n     */\n    @java.lang.Override\n    public double getStochD() {\n      return stochD_;\n    }\n\n    public static final int RVOL_FIELD_NUMBER = 16;\n    private double rvol_ = 0D;\n    /**\n     * <code>double rvol = 16;</code>\n     * @return The rvol.\n     */\n    @java.lang.Override\n    public double getRvol() {\n      return rvol_;\n    }\n\n    public static final int VOLUME_SPIKE_FIELD_NUMBER = 17;\n    private boolean volumeSpike_ = false;\n    /**\n     * <code>bool volume_spike = 17;</code>\n     * @return The volumeSpike.\n     */\n    @java.lang.Override\n    public boolean getVolumeSpike() {\n      return volumeSpike_;\n    }\n\n    public static final int ATR_FIELD_NUMBER = 18;\n    private double atr_ = 0D;\n    /**\n     * <code>double atr = 18;</code>\n     * @return The atr.\n     */\n    @java.lang.Override\n    public double getAtr() {\n      return atr_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, symbol_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rsi_) != 0) {\n        output.writeDouble(2, rsi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(priceRoc_) != 0) {\n        output.writeDouble(3, priceRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeRoc_) != 0) {\n        output.writeDouble(4, volumeRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(obv_) != 0) {\n        output.writeDouble(5, obv_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(mfi_) != 0) {\n        output.writeDouble(6, mfi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosition_) != 0) {\n        output.writeDouble(7, bollingerPosition_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(percentB_) != 0) {\n        output.writeDouble(8, percentB_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(vwap_) != 0) {\n        output.writeDouble(9, vwap_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdHistogram_) != 0) {\n        output.writeDouble(10, macdHistogram_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema9_) != 0) {\n        output.writeDouble(11, ema9_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema20_) != 0) {\n        output.writeDouble(12, ema20_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema50_) != 0) {\n        output.writeDouble(13, ema50_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochK_) != 0) {\n        output.writeDouble(14, stochK_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochD_) != 0) {\n        output.writeDouble(15, stochD_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rvol_) != 0) {\n        output.writeDouble(16, rvol_);\n      }\n      if (volumeSpike_ != false) {\n        output.writeBool(17, volumeSpike_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(atr_) != 0) {\n        output.writeDouble(18, atr_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, symbol_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rsi_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(2, rsi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(priceRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(3, priceRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(4, volumeRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(obv_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(5, obv_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(mfi_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(6, mfi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosition_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(7, bollingerPosition_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(percentB_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(8, percentB_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(vwap_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(9, vwap_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdHistogram_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(10, macdHistogram_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema9_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(11, ema9_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema20_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(12, ema20_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema50_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(13, ema50_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochK_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(14, stochK_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochD_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(15, stochD_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rvol_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(16, rvol_);\n      }\n      if (volumeSpike_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(17, volumeSpike_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(atr_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(18, atr_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate other = (com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate) obj;\n\n      if (!getSymbol()\n          .equals(other.getSymbol())) return false;\n      if (java.lang.Double.doubleToLongBits(getRsi())\n          != java.lang.Double.doubleToLongBits(\n              other.getRsi())) return false;\n      if (java.lang.Double.doubleToLongBits(getPriceRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getPriceRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getVolumeRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getVolumeRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getObv())\n          != java.lang.Double.doubleToLongBits(\n              other.getObv())) return false;\n      if (java.lang.Double.doubleToLongBits(getMfi())\n          != java.lang.Double.doubleToLongBits(\n              other.getMfi())) return false;\n      if (java.lang.Double.doubleToLongBits(getBollingerPosition())\n          != java.lang.Double.doubleToLongBits(\n              other.getBollingerPosition())) return false;\n      if (java.lang.Double.doubleToLongBits(getPercentB())\n          != java.lang.Double.doubleToLongBits(\n              other.getPercentB())) return false;\n      if (java.lang.Double.doubleToLongBits(getVwap())\n          != java.lang.Double.doubleToLongBits(\n              other.getVwap())) return false;\n      if (java.lang.Double.doubleToLongBits(getMacdHistogram())\n          != java.lang.Double.doubleToLongBits(\n              other.getMacdHistogram())) return false;\n      if (java.lang.Double.doubleToLongBits(getEma9())\n          != java.lang.Double.doubleToLongBits(\n              other.getEma9())) return false;\n      if (java.lang.Double.doubleToLongBits(getEma20())\n          != java.lang.Double.doubleToLongBits(\n              other.getEma20())) return false;\n      if (java.lang.Double.doubleToLongBits(getEma50())\n          != java.lang.Double.doubleToLongBits(\n              other.getEma50())) return false;\n      if (java.lang.Double.doubleToLongBits(getStochK())\n          != java.lang.Double.doubleToLongBits(\n              other.getStochK())) return false;\n      if (java.lang.Double.doubleToLongBits(getStochD())\n          != java.lang.Double.doubleToLongBits(\n              other.getStochD())) return false;\n      if (java.lang.Double.doubleToLongBits(getRvol())\n          != java.lang.Double.doubleToLongBits(\n              other.getRvol())) return false;\n      if (getVolumeSpike()\n          != other.getVolumeSpike()) return false;\n      if (java.lang.Double.doubleToLongBits(getAtr())\n          != java.lang.Double.doubleToLongBits(\n              other.getAtr())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + SYMBOL_FIELD_NUMBER;\n      hash = (53 * hash) + getSymbol().hashCode();\n      hash = (37 * hash) + RSI_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRsi()));\n      hash = (37 * hash) + PRICE_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPriceRoc()));\n      hash = (37 * hash) + VOLUME_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVolumeRoc()));\n      hash = (37 * hash) + OBV_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getObv()));\n      hash = (37 * hash) + MFI_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMfi()));\n      hash = (37 * hash) + BOLLINGER_POSITION_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getBollingerPosition()));\n      hash = (37 * hash) + PERCENT_B_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPercentB()));\n      hash = (37 * hash) + VWAP_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVwap()));\n      hash = (37 * hash) + MACD_HISTOGRAM_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMacdHistogram()));\n      hash = (37 * hash) + EMA_9_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getEma9()));\n      hash = (37 * hash) + EMA_20_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getEma20()));\n      hash = (37 * hash) + EMA_50_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getEma50()));\n      hash = (37 * hash) + STOCH_K_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getStochK()));\n      hash = (37 * hash) + STOCH_D_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getStochD()));\n      hash = (37 * hash) + RVOL_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRvol()));\n      hash = (37 * hash) + VOLUME_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getVolumeSpike());\n      hash = (37 * hash) + ATR_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getAtr()));\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * Protobuf type {@code spiketrade.proto.IndicatorUpdate}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.IndicatorUpdate)\n        com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdateOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_IndicatorUpdate_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_IndicatorUpdate_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate.class, com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        symbol_ = \"\";\n        rsi_ = 0D;\n        priceRoc_ = 0D;\n        volumeRoc_ = 0D;\n        obv_ = 0D;\n        mfi_ = 0D;\n        bollingerPosition_ = 0D;\n        percentB_ = 0D;\n        vwap_ = 0D;\n        macdHistogram_ = 0D;\n        ema9_ = 0D;\n        ema20_ = 0D;\n        ema50_ = 0D;\n        stochK_ = 0D;\n        stochD_ = 0D;\n        rvol_ = 0D;\n        volumeSpike_ = false;\n        atr_ = 0D;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_IndicatorUpdate_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate getDefaultInstanceForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate build() {\n        com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate buildPartial() {\n        com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate result = new com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.symbol_ = symbol_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.rsi_ = rsi_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.priceRoc_ = priceRoc_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.volumeRoc_ = volumeRoc_;\n        }\n        if (((from_bitField0_ & 0x00000010) != 0)) {\n          result.obv_ = obv_;\n        }\n        if (((from_bitField0_ & 0x00000020) != 0)) {\n          result.mfi_ = mfi_;\n        }\n        if (((from_bitField0_ & 0x00000040) != 0)) {\n          result.bollingerPosition_ = bollingerPosition_;\n        }\n        if (((from_bitField0_ & 0x00000080) != 0)) {\n          result.percentB_ = percentB_;\n        }\n        if (((from_bitField0_ & 0x00000100) != 0)) {\n          result.vwap_ = vwap_;\n        }\n        if (((from_bitField0_ & 0x00000200) != 0)) {\n          result.macdHistogram_ = macdHistogram_;\n        }\n        if (((from_bitField0_ & 0x00000400) != 0)) {\n          result.ema9_ = ema9_;\n        }\n        if (((from_bitField0_ & 0x00000800) != 0)) {\n          result.ema20_ = ema20_;\n        }\n        if (((from_bitField0_ & 0x00001000) != 0)) {\n          result.ema50_ = ema50_;\n        }\n        if (((from_bitField0_ & 0x00002000) != 0)) {\n          result.stochK_ = stochK_;\n        }\n        if (((from_bitField0_ & 0x00004000) != 0)) {\n          result.stochD_ = stochD_;\n        }\n        if (((from_bitField0_ & 0x00008000) != 0)) {\n          result.rvol_ = rvol_;\n        }\n        if (((from_bitField0_ & 0x00010000) != 0)) {\n          result.volumeSpike_ = volumeSpike_;\n        }\n        if (((from_bitField0_ & 0x00020000) != 0)) {\n          result.atr_ = atr_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate) {\n          return mergeFrom((com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate other) {\n        if (other == com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate.getDefaultInstance()) return this;\n        if (!other.getSymbol().isEmpty()) {\n          symbol_ = other.symbol_;\n          bitField0_ |= 0x00000001;\n          onChanged();\n        }\n        if (other.getRsi() != 0D) {\n          setRsi(other.getRsi());\n        }\n        if (other.getPriceRoc() != 0D) {\n          setPriceRoc(other.getPriceRoc());\n        }\n        if (other.getVolumeRoc() != 0D) {\n          setVolumeRoc(other.getVolumeRoc());\n        }\n        if (other.getObv() != 0D) {\n          setObv(other.getObv());\n        }\n        if (other.getMfi() != 0D) {\n          setMfi(other.getMfi());\n        }\n        if (other.getBollingerPosition() != 0D) {\n          setBollingerPosition(other.getBollingerPosition());\n        }\n        if (other.getPercentB() != 0D) {\n          setPercentB(other.getPercentB());\n        }\n        if (other.getVwap() != 0D) {\n          setVwap(other.getVwap());\n        }\n        if (other.getMacdHistogram() != 0D) {\n          setMacdHistogram(other.getMacdHistogram());\n        }\n        if (other.getEma9() != 0D) {\n          setEma9(other.getEma9());\n        }\n        if (other.getEma20() != 0D) {\n          setEma20(other.getEma20());\n        }\n        if (other.getEma50() != 0D) {\n          setEma50(other.getEma50());\n        }\n        if (other.getStochK() != 0D) {\n          setStochK(other.getStochK());\n        }\n        if (other.getStochD() != 0D) {\n          setStochD(other.getStochD());\n        }\n        if (other.getRvol() != 0D) {\n          setRvol(other.getRvol());\n        }\n        if (other.getVolumeSpike() != false) {\n          setVolumeSpike(other.getVolumeSpike());\n        }\n        if (other.getAtr() != 0D) {\n          setAtr(other.getAtr());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 10: {\n                symbol_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 10\n              case 17: {\n                rsi_ = input.readDouble();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 17\n              case 25: {\n                priceRoc_ = input.readDouble();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 25\n              case 33: {\n                volumeRoc_ = input.readDouble();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 33\n              case 41: {\n                obv_ = input.readDouble();\n                bitField0_ |= 0x00000010;\n                break;\n              } // case 41\n              case 49: {\n                mfi_ = input.readDouble();\n                bitField0_ |= 0x00000020;\n                break;\n              } // case 49\n              case 57: {\n                bollingerPosition_ = input.readDouble();\n                bitField0_ |= 0x00000040;\n                break;\n              } // case 57\n              case 65: {\n                percentB_ = input.readDouble();\n                bitField0_ |= 0x00000080;\n                break;\n              } // case 65\n              case 73: {\n                vwap_ = input.readDouble();\n                bitField0_ |= 0x00000100;\n                break;\n              } // case 73\n              case 81: {\n                macdHistogram_ = input.readDouble();\n                bitField0_ |= 0x00000200;\n                break;\n              } // case 81\n              case 89: {\n                ema9_ = input.readDouble();\n                bitField0_ |= 0x00000400;\n                break;\n              } // case 89\n              case 97: {\n                ema20_ = input.readDouble();\n                bitField0_ |= 0x00000800;\n                break;\n              } // case 97\n              case 105: {\n                ema50_ = input.readDouble();\n                bitField0_ |= 0x00001000;\n                break;\n              } // case 105\n              case 113: {\n                stochK_ = input.readDouble();\n                bitField0_ |= 0x00002000;\n                break;\n              } // case 113\n              case 121: {\n                stochD_ = input.readDouble();\n                bitField0_ |= 0x00004000;\n                break;\n              } // case 121\n              case 129: {\n                rvol_ = input.readDouble();\n                bitField0_ |= 0x00008000;\n                break;\n              } // case 129\n              case 136: {\n                volumeSpike_ = input.readBool();\n                bitField0_ |= 0x00010000;\n                break;\n              } // case 136\n              case 145: {\n                atr_ = input.readDouble();\n                bitField0_ |= 0x00020000;\n                break;\n              } // case 145\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private java.lang.Object symbol_ = \"\";\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The symbol.\n       */\n      public java.lang.String getSymbol() {\n        java.lang.Object ref = symbol_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          symbol_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The bytes for symbol.\n       */\n      public com.google.protobuf.ByteString\n          getSymbolBytes() {\n        java.lang.Object ref = symbol_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          symbol_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbol(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSymbol() {\n        symbol_ = getDefaultInstance().getSymbol();\n        bitField0_ = (bitField0_ & ~0x00000001);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The bytes for symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbolBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n\n      private double rsi_ ;\n      /**\n       * <code>double rsi = 2;</code>\n       * @return The rsi.\n       */\n      @java.lang.Override\n      public double getRsi() {\n        return rsi_;\n      }\n      /**\n       * <code>double rsi = 2;</code>\n       * @param value The rsi to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRsi(double value) {\n\n        rsi_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double rsi = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRsi() {\n        bitField0_ = (bitField0_ & ~0x00000002);\n        rsi_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double priceRoc_ ;\n      /**\n       * <code>double price_roc = 3;</code>\n       * @return The priceRoc.\n       */\n      @java.lang.Override\n      public double getPriceRoc() {\n        return priceRoc_;\n      }\n      /**\n       * <code>double price_roc = 3;</code>\n       * @param value The priceRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPriceRoc(double value) {\n\n        priceRoc_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double price_roc = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPriceRoc() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        priceRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double volumeRoc_ ;\n      /**\n       * <code>double volume_roc = 4;</code>\n       * @return The volumeRoc.\n       */\n      @java.lang.Override\n      public double getVolumeRoc() {\n        return volumeRoc_;\n      }\n      /**\n       * <code>double volume_roc = 4;</code>\n       * @param value The volumeRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolumeRoc(double value) {\n\n        volumeRoc_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double volume_roc = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolumeRoc() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        volumeRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double obv_ ;\n      /**\n       * <code>double obv = 5;</code>\n       * @return The obv.\n       */\n      @java.lang.Override\n      public double getObv() {\n        return obv_;\n      }\n      /**\n       * <code>double obv = 5;</code>\n       * @param value The obv to set.\n       * @return This builder for chaining.\n       */\n      public Builder setObv(double value) {\n\n        obv_ = value;\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double obv = 5;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearObv() {\n        bitField0_ = (bitField0_ & ~0x00000010);\n        obv_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double mfi_ ;\n      /**\n       * <code>double mfi = 6;</code>\n       * @return The mfi.\n       */\n      @java.lang.Override\n      public double getMfi() {\n        return mfi_;\n      }\n      /**\n       * <code>double mfi = 6;</code>\n       * @param value The mfi to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMfi(double value) {\n\n        mfi_ = value;\n        bitField0_ |= 0x00000020;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double mfi = 6;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMfi() {\n        bitField0_ = (bitField0_ & ~0x00000020);\n        mfi_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double bollingerPosition_ ;\n      /**\n       * <code>double bollinger_position = 7;</code>\n       * @return The bollingerPosition.\n       */\n      @java.lang.Override\n      public double getBollingerPosition() {\n        return bollingerPosition_;\n      }\n      /**\n       * <code>double bollinger_position = 7;</code>\n       * @param value The bollingerPosition to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBollingerPosition(double value) {\n\n        bollingerPosition_ = value;\n        bitField0_ |= 0x00000040;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double bollinger_position = 7;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBollingerPosition() {\n        bitField0_ = (bitField0_ & ~0x00000040);\n        bollingerPosition_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double percentB_ ;\n      /**\n       * <code>double percent_b = 8;</code>\n       * @return The percentB.\n       */\n      @java.lang.Override\n      public double getPercentB() {\n        return percentB_;\n      }\n      /**\n       * <code>double percent_b = 8;</code>\n       * @param value The percentB to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPercentB(double value) {\n\n        percentB_ = value;\n        bitField0_ |= 0x00000080;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double percent_b = 8;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPercentB() {\n        bitField0_ = (bitField0_ & ~0x00000080);\n        percentB_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double vwap_ ;\n      /**\n       * <code>double vwap = 9;</code>\n       * @return The vwap.\n       */\n      @java.lang.Override\n      public double getVwap() {\n        return vwap_;\n      }\n      /**\n       * <code>double vwap = 9;</code>\n       * @param value The vwap to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVwap(double value) {\n\n        vwap_ = value;\n        bitField0_ |= 0x00000100;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double vwap = 9;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVwap() {\n        bitField0_ = (bitField0_ & ~0x00000100);\n        vwap_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double macdHistogram_ ;\n      /**\n       * <pre>\n       * NEW INDICATORS\n       * </pre>\n       *\n       * <code>double macd_histogram = 10;</code>\n       * @return The macdHistogram.\n       */\n      @java.lang.Override\n      public double getMacdHistogram() {\n        return macdHistogram_;\n      }\n      /**\n       * <pre>\n       * NEW INDICATORS\n       * </pre>\n       *\n       * <code>double macd_histogram = 10;</code>\n       * @param value The macdHistogram to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMacdHistogram(double value) {\n\n        macdHistogram_ = value;\n        bitField0_ |= 0x00000200;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * NEW INDICATORS\n       * </pre>\n       *\n       * <code>double macd_histogram = 10;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMacdHistogram() {\n        bitField0_ = (bitField0_ & ~0x00000200);\n        macdHistogram_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double ema9_ ;\n      /**\n       * <code>double ema_9 = 11;</code>\n       * @return The ema9.\n       */\n      @java.lang.Override\n      public double getEma9() {\n        return ema9_;\n      }\n      /**\n       * <code>double ema_9 = 11;</code>\n       * @param value The ema9 to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEma9(double value) {\n\n        ema9_ = value;\n        bitField0_ |= 0x00000400;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double ema_9 = 11;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEma9() {\n        bitField0_ = (bitField0_ & ~0x00000400);\n        ema9_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double ema20_ ;\n      /**\n       * <code>double ema_20 = 12;</code>\n       * @return The ema20.\n       */\n      @java.lang.Override\n      public double getEma20() {\n        return ema20_;\n      }\n      /**\n       * <code>double ema_20 = 12;</code>\n       * @param value The ema20 to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEma20(double value) {\n\n        ema20_ = value;\n        bitField0_ |= 0x00000800;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double ema_20 = 12;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEma20() {\n        bitField0_ = (bitField0_ & ~0x00000800);\n        ema20_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double ema50_ ;\n      /**\n       * <code>double ema_50 = 13;</code>\n       * @return The ema50.\n       */\n      @java.lang.Override\n      public double getEma50() {\n        return ema50_;\n      }\n      /**\n       * <code>double ema_50 = 13;</code>\n       * @param value The ema50 to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEma50(double value) {\n\n        ema50_ = value;\n        bitField0_ |= 0x00001000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double ema_50 = 13;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEma50() {\n        bitField0_ = (bitField0_ & ~0x00001000);\n        ema50_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double stochK_ ;\n      /**\n       * <code>double stoch_k = 14;</code>\n       * @return The stochK.\n       */\n      @java.lang.Override\n      public double getStochK() {\n        return stochK_;\n      }\n      /**\n       * <code>double stoch_k = 14;</code>\n       * @param value The stochK to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStochK(double value) {\n\n        stochK_ = value;\n        bitField0_ |= 0x00002000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double stoch_k = 14;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStochK() {\n        bitField0_ = (bitField0_ & ~0x00002000);\n        stochK_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double stochD_ ;\n      /**\n       * <code>double stoch_d = 15;</code>\n       * @return The stochD.\n       */\n      @java.lang.Override\n      public double getStochD() {\n        return stochD_;\n      }\n      /**\n       * <code>double stoch_d = 15;</code>\n       * @param value The stochD to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStochD(double value) {\n\n        stochD_ = value;\n        bitField0_ |= 0x00004000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double stoch_d = 15;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStochD() {\n        bitField0_ = (bitField0_ & ~0x00004000);\n        stochD_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double rvol_ ;\n      /**\n       * <code>double rvol = 16;</code>\n       * @return The rvol.\n       */\n      @java.lang.Override\n      public double getRvol() {\n        return rvol_;\n      }\n      /**\n       * <code>double rvol = 16;</code>\n       * @param value The rvol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRvol(double value) {\n\n        rvol_ = value;\n        bitField0_ |= 0x00008000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double rvol = 16;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRvol() {\n        bitField0_ = (bitField0_ & ~0x00008000);\n        rvol_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private boolean volumeSpike_ ;\n      /**\n       * <code>bool volume_spike = 17;</code>\n       * @return The volumeSpike.\n       */\n      @java.lang.Override\n      public boolean getVolumeSpike() {\n        return volumeSpike_;\n      }\n      /**\n       * <code>bool volume_spike = 17;</code>\n       * @param value The volumeSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolumeSpike(boolean value) {\n\n        volumeSpike_ = value;\n        bitField0_ |= 0x00010000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool volume_spike = 17;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolumeSpike() {\n        bitField0_ = (bitField0_ & ~0x00010000);\n        volumeSpike_ = false;\n        onChanged();\n        return this;\n      }\n\n      private double atr_ ;\n      /**\n       * <code>double atr = 18;</code>\n       * @return The atr.\n       */\n      @java.lang.Override\n      public double getAtr() {\n        return atr_;\n      }\n      /**\n       * <code>double atr = 18;</code>\n       * @param value The atr to set.\n       * @return This builder for chaining.\n       */\n      public Builder setAtr(double value) {\n\n        atr_ = value;\n        bitField0_ |= 0x00020000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double atr = 18;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearAtr() {\n        bitField0_ = (bitField0_ & ~0x00020000);\n        atr_ = 0D;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.IndicatorUpdate)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.IndicatorUpdate)\n    private static final com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate();\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<IndicatorUpdate>\n        PARSER = new com.google.protobuf.AbstractParser<IndicatorUpdate>() {\n      @java.lang.Override\n      public IndicatorUpdate parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<IndicatorUpdate> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<IndicatorUpdate> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.IndicatorUpdate getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface SpikeRecordOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.SpikeRecord)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>int64 timestamp_ms = 1;</code>\n     * @return The timestampMs.\n     */\n    long getTimestampMs();\n\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The symbol.\n     */\n    java.lang.String getSymbol();\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The bytes for symbol.\n     */\n    com.google.protobuf.ByteString\n        getSymbolBytes();\n\n    /**\n     * <code>string spike_type = 3;</code>\n     * @return The spikeType.\n     */\n    java.lang.String getSpikeType();\n    /**\n     * <code>string spike_type = 3;</code>\n     * @return The bytes for spikeType.\n     */\n    com.google.protobuf.ByteString\n        getSpikeTypeBytes();\n\n    /**\n     * <code>double magnitude = 4;</code>\n     * @return The magnitude.\n     */\n    double getMagnitude();\n\n    /**\n     * <code>int32 duration = 5;</code>\n     * @return The duration.\n     */\n    int getDuration();\n\n    /**\n     * <code>double price_at_spike = 6;</code>\n     * @return The priceAtSpike.\n     */\n    double getPriceAtSpike();\n\n    /**\n     * <code>int64 volume_at_spike = 7;</code>\n     * @return The volumeAtSpike.\n     */\n    long getVolumeAtSpike();\n\n    /**\n     * <code>double rsi_at_spike = 8;</code>\n     * @return The rsiAtSpike.\n     */\n    double getRsiAtSpike();\n\n    /**\n     * <code>double bollinger_position = 9;</code>\n     * @return The bollingerPosition.\n     */\n    double getBollingerPosition();\n\n    /**\n     * <code>double market_volatility = 10;</code>\n     * @return The marketVolatility.\n     */\n    double getMarketVolatility();\n\n    /**\n     * <code>int32 time_of_day = 11;</code>\n     * @return The timeOfDay.\n     */\n    int getTimeOfDay();\n\n    /**\n     * <code>int32 day_of_week = 12;</code>\n     * @return The dayOfWeek.\n     */\n    int getDayOfWeek();\n\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n     * @return Whether the indicators field is set.\n     */\n    boolean hasIndicators();\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n     * @return The indicators.\n     */\n    com.spiketrade.proto.SpikeSignalsProto.Indicators getIndicators();\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n     */\n    com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder getIndicatorsOrBuilder();\n\n    /**\n     * <code>bool outcome_profitable = 14;</code>\n     * @return The outcomeProfitable.\n     */\n    boolean getOutcomeProfitable();\n\n    /**\n     * <code>double outcome_score = 15;</code>\n     * @return The outcomeScore.\n     */\n    double getOutcomeScore();\n\n    /**\n     * <code>double statistical_z_score = 16;</code>\n     * @return The statisticalZScore.\n     */\n    double getStatisticalZScore();\n\n    /**\n     * <code>string trend_context = 17;</code>\n     * @return The trendContext.\n     */\n    java.lang.String getTrendContext();\n    /**\n     * <code>string trend_context = 17;</code>\n     * @return The bytes for trendContext.\n     */\n    com.google.protobuf.ByteString\n        getTrendContextBytes();\n\n    /**\n     * <code>double spike_quality_score = 18;</code>\n     * @return The spikeQualityScore.\n     */\n    double getSpikeQualityScore();\n\n    /**\n     * <code>bool is_root_spike = 19;</code>\n     * @return The isRootSpike.\n     */\n    boolean getIsRootSpike();\n\n    /**\n     * <code>double root_spike_score = 20;</code>\n     * @return The rootSpikeScore.\n     */\n    double getRootSpikeScore();\n\n    /**\n     * <code>bool used_for_signal = 21;</code>\n     * @return The usedForSignal.\n     */\n    boolean getUsedForSignal();\n  }\n  /**\n   * <pre>\n   * Spike record\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.SpikeRecord}\n   */\n  public static final class SpikeRecord extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.SpikeRecord)\n      SpikeRecordOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use SpikeRecord.newBuilder() to construct.\n    private SpikeRecord(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private SpikeRecord() {\n      symbol_ = \"\";\n      spikeType_ = \"\";\n      trendContext_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new SpikeRecord();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SpikeRecord_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SpikeRecord_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.class, com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.Builder.class);\n    }\n\n    private int bitField0_;\n    public static final int TIMESTAMP_MS_FIELD_NUMBER = 1;\n    private long timestampMs_ = 0L;\n    /**\n     * <code>int64 timestamp_ms = 1;</code>\n     * @return The timestampMs.\n     */\n    @java.lang.Override\n    public long getTimestampMs() {\n      return timestampMs_;\n    }\n\n    public static final int SYMBOL_FIELD_NUMBER = 2;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object symbol_ = \"\";\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The symbol.\n     */\n    @java.lang.Override\n    public java.lang.String getSymbol() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        symbol_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The bytes for symbol.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getSymbolBytes() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        symbol_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int SPIKE_TYPE_FIELD_NUMBER = 3;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object spikeType_ = \"\";\n    /**\n     * <code>string spike_type = 3;</code>\n     * @return The spikeType.\n     */\n    @java.lang.Override\n    public java.lang.String getSpikeType() {\n      java.lang.Object ref = spikeType_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        spikeType_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string spike_type = 3;</code>\n     * @return The bytes for spikeType.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getSpikeTypeBytes() {\n      java.lang.Object ref = spikeType_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        spikeType_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int MAGNITUDE_FIELD_NUMBER = 4;\n    private double magnitude_ = 0D;\n    /**\n     * <code>double magnitude = 4;</code>\n     * @return The magnitude.\n     */\n    @java.lang.Override\n    public double getMagnitude() {\n      return magnitude_;\n    }\n\n    public static final int DURATION_FIELD_NUMBER = 5;\n    private int duration_ = 0;\n    /**\n     * <code>int32 duration = 5;</code>\n     * @return The duration.\n     */\n    @java.lang.Override\n    public int getDuration() {\n      return duration_;\n    }\n\n    public static final int PRICE_AT_SPIKE_FIELD_NUMBER = 6;\n    private double priceAtSpike_ = 0D;\n    /**\n     * <code>double price_at_spike = 6;</code>\n     * @return The priceAtSpike.\n     */\n    @java.lang.Override\n    public double getPriceAtSpike() {\n      return priceAtSpike_;\n    }\n\n    public static final int VOLUME_AT_SPIKE_FIELD_NUMBER = 7;\n    private long volumeAtSpike_ = 0L;\n    /**\n     * <code>int64 volume_at_spike = 7;</code>\n     * @return The volumeAtSpike.\n     */\n    @java.lang.Override\n    public long getVolumeAtSpike() {\n      return volumeAtSpike_;\n    }\n\n    public static final int RSI_AT_SPIKE_FIELD_NUMBER = 8;\n    private double rsiAtSpike_ = 0D;\n    /**\n     * <code>double rsi_at_spike = 8;</code>\n     * @return The rsiAtSpike.\n     */\n    @java.lang.Override\n    public double getRsiAtSpike() {\n      return rsiAtSpike_;\n    }\n\n    public static final int BOLLINGER_POSITION_FIELD_NUMBER = 9;\n    private double bollingerPosition_ = 0D;\n    /**\n     * <code>double bollinger_position = 9;</code>\n     * @return The bollingerPosition.\n     */\n    @java.lang.Override\n    public double getBollingerPosition() {\n      return bollingerPosition_;\n    }\n\n    public static final int MARKET_VOLATILITY_FIELD_NUMBER = 10;\n    private double marketVolatility_ = 0D;\n    /**\n     * <code>double market_volatility = 10;</code>\n     * @return The marketVolatility.\n     */\n    @java.lang.Override\n    public double getMarketVolatility() {\n      return marketVolatility_;\n    }\n\n    public static final int TIME_OF_DAY_FIELD_NUMBER = 11;\n    private int timeOfDay_ = 0;\n    /**\n     * <code>int32 time_of_day = 11;</code>\n     * @return The timeOfDay.\n     */\n    @java.lang.Override\n    public int getTimeOfDay() {\n      return timeOfDay_;\n    }\n\n    public static final int DAY_OF_WEEK_FIELD_NUMBER = 12;\n    private int dayOfWeek_ = 0;\n    /**\n     * <code>int32 day_of_week = 12;</code>\n     * @return The dayOfWeek.\n     */\n    @java.lang.Override\n    public int getDayOfWeek() {\n      return dayOfWeek_;\n    }\n\n    public static final int INDICATORS_FIELD_NUMBER = 13;\n    private com.spiketrade.proto.SpikeSignalsProto.Indicators indicators_;\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n     * @return Whether the indicators field is set.\n     */\n    @java.lang.Override\n    public boolean hasIndicators() {\n      return ((bitField0_ & 0x00000001) != 0);\n    }\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n     * @return The indicators.\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.Indicators getIndicators() {\n      return indicators_ == null ? com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance() : indicators_;\n    }\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder getIndicatorsOrBuilder() {\n      return indicators_ == null ? com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance() : indicators_;\n    }\n\n    public static final int OUTCOME_PROFITABLE_FIELD_NUMBER = 14;\n    private boolean outcomeProfitable_ = false;\n    /**\n     * <code>bool outcome_profitable = 14;</code>\n     * @return The outcomeProfitable.\n     */\n    @java.lang.Override\n    public boolean getOutcomeProfitable() {\n      return outcomeProfitable_;\n    }\n\n    public static final int OUTCOME_SCORE_FIELD_NUMBER = 15;\n    private double outcomeScore_ = 0D;\n    /**\n     * <code>double outcome_score = 15;</code>\n     * @return The outcomeScore.\n     */\n    @java.lang.Override\n    public double getOutcomeScore() {\n      return outcomeScore_;\n    }\n\n    public static final int STATISTICAL_Z_SCORE_FIELD_NUMBER = 16;\n    private double statisticalZScore_ = 0D;\n    /**\n     * <code>double statistical_z_score = 16;</code>\n     * @return The statisticalZScore.\n     */\n    @java.lang.Override\n    public double getStatisticalZScore() {\n      return statisticalZScore_;\n    }\n\n    public static final int TREND_CONTEXT_FIELD_NUMBER = 17;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object trendContext_ = \"\";\n    /**\n     * <code>string trend_context = 17;</code>\n     * @return The trendContext.\n     */\n    @java.lang.Override\n    public java.lang.String getTrendContext() {\n      java.lang.Object ref = trendContext_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        trendContext_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string trend_context = 17;</code>\n     * @return The bytes for trendContext.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getTrendContextBytes() {\n      java.lang.Object ref = trendContext_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        trendContext_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int SPIKE_QUALITY_SCORE_FIELD_NUMBER = 18;\n    private double spikeQualityScore_ = 0D;\n    /**\n     * <code>double spike_quality_score = 18;</code>\n     * @return The spikeQualityScore.\n     */\n    @java.lang.Override\n    public double getSpikeQualityScore() {\n      return spikeQualityScore_;\n    }\n\n    public static final int IS_ROOT_SPIKE_FIELD_NUMBER = 19;\n    private boolean isRootSpike_ = false;\n    /**\n     * <code>bool is_root_spike = 19;</code>\n     * @return The isRootSpike.\n     */\n    @java.lang.Override\n    public boolean getIsRootSpike() {\n      return isRootSpike_;\n    }\n\n    public static final int ROOT_SPIKE_SCORE_FIELD_NUMBER = 20;\n    private double rootSpikeScore_ = 0D;\n    /**\n     * <code>double root_spike_score = 20;</code>\n     * @return The rootSpikeScore.\n     */\n    @java.lang.Override\n    public double getRootSpikeScore() {\n      return rootSpikeScore_;\n    }\n\n    public static final int USED_FOR_SIGNAL_FIELD_NUMBER = 21;\n    private boolean usedForSignal_ = false;\n    /**\n     * <code>bool used_for_signal = 21;</code>\n     * @return The usedForSignal.\n     */\n    @java.lang.Override\n    public boolean getUsedForSignal() {\n      return usedForSignal_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (timestampMs_ != 0L) {\n        output.writeInt64(1, timestampMs_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, symbol_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(spikeType_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, spikeType_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(magnitude_) != 0) {\n        output.writeDouble(4, magnitude_);\n      }\n      if (duration_ != 0) {\n        output.writeInt32(5, duration_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(priceAtSpike_) != 0) {\n        output.writeDouble(6, priceAtSpike_);\n      }\n      if (volumeAtSpike_ != 0L) {\n        output.writeInt64(7, volumeAtSpike_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rsiAtSpike_) != 0) {\n        output.writeDouble(8, rsiAtSpike_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosition_) != 0) {\n        output.writeDouble(9, bollingerPosition_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(marketVolatility_) != 0) {\n        output.writeDouble(10, marketVolatility_);\n      }\n      if (timeOfDay_ != 0) {\n        output.writeInt32(11, timeOfDay_);\n      }\n      if (dayOfWeek_ != 0) {\n        output.writeInt32(12, dayOfWeek_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        output.writeMessage(13, getIndicators());\n      }\n      if (outcomeProfitable_ != false) {\n        output.writeBool(14, outcomeProfitable_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(outcomeScore_) != 0) {\n        output.writeDouble(15, outcomeScore_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(statisticalZScore_) != 0) {\n        output.writeDouble(16, statisticalZScore_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(trendContext_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 17, trendContext_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeQualityScore_) != 0) {\n        output.writeDouble(18, spikeQualityScore_);\n      }\n      if (isRootSpike_ != false) {\n        output.writeBool(19, isRootSpike_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rootSpikeScore_) != 0) {\n        output.writeDouble(20, rootSpikeScore_);\n      }\n      if (usedForSignal_ != false) {\n        output.writeBool(21, usedForSignal_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (timestampMs_ != 0L) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt64Size(1, timestampMs_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, symbol_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(spikeType_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, spikeType_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(magnitude_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(4, magnitude_);\n      }\n      if (duration_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(5, duration_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(priceAtSpike_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(6, priceAtSpike_);\n      }\n      if (volumeAtSpike_ != 0L) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt64Size(7, volumeAtSpike_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rsiAtSpike_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(8, rsiAtSpike_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosition_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(9, bollingerPosition_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(marketVolatility_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(10, marketVolatility_);\n      }\n      if (timeOfDay_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(11, timeOfDay_);\n      }\n      if (dayOfWeek_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(12, dayOfWeek_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(13, getIndicators());\n      }\n      if (outcomeProfitable_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(14, outcomeProfitable_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(outcomeScore_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(15, outcomeScore_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(statisticalZScore_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(16, statisticalZScore_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(trendContext_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(17, trendContext_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeQualityScore_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(18, spikeQualityScore_);\n      }\n      if (isRootSpike_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(19, isRootSpike_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rootSpikeScore_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(20, rootSpikeScore_);\n      }\n      if (usedForSignal_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(21, usedForSignal_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.SpikeSignalsProto.SpikeRecord)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.SpikeSignalsProto.SpikeRecord other = (com.spiketrade.proto.SpikeSignalsProto.SpikeRecord) obj;\n\n      if (getTimestampMs()\n          != other.getTimestampMs()) return false;\n      if (!getSymbol()\n          .equals(other.getSymbol())) return false;\n      if (!getSpikeType()\n          .equals(other.getSpikeType())) return false;\n      if (java.lang.Double.doubleToLongBits(getMagnitude())\n          != java.lang.Double.doubleToLongBits(\n              other.getMagnitude())) return false;\n      if (getDuration()\n          != other.getDuration()) return false;\n      if (java.lang.Double.doubleToLongBits(getPriceAtSpike())\n          != java.lang.Double.doubleToLongBits(\n              other.getPriceAtSpike())) return false;\n      if (getVolumeAtSpike()\n          != other.getVolumeAtSpike()) return false;\n      if (java.lang.Double.doubleToLongBits(getRsiAtSpike())\n          != java.lang.Double.doubleToLongBits(\n              other.getRsiAtSpike())) return false;\n      if (java.lang.Double.doubleToLongBits(getBollingerPosition())\n          != java.lang.Double.doubleToLongBits(\n              other.getBollingerPosition())) return false;\n      if (java.lang.Double.doubleToLongBits(getMarketVolatility())\n          != java.lang.Double.doubleToLongBits(\n              other.getMarketVolatility())) return false;\n      if (getTimeOfDay()\n          != other.getTimeOfDay()) return false;\n      if (getDayOfWeek()\n          != other.getDayOfWeek()) return false;\n      if (hasIndicators() != other.hasIndicators()) return false;\n      if (hasIndicators()) {\n        if (!getIndicators()\n            .equals(other.getIndicators())) return false;\n      }\n      if (getOutcomeProfitable()\n          != other.getOutcomeProfitable()) return false;\n      if (java.lang.Double.doubleToLongBits(getOutcomeScore())\n          != java.lang.Double.doubleToLongBits(\n              other.getOutcomeScore())) return false;\n      if (java.lang.Double.doubleToLongBits(getStatisticalZScore())\n          != java.lang.Double.doubleToLongBits(\n              other.getStatisticalZScore())) return false;\n      if (!getTrendContext()\n          .equals(other.getTrendContext())) return false;\n      if (java.lang.Double.doubleToLongBits(getSpikeQualityScore())\n          != java.lang.Double.doubleToLongBits(\n              other.getSpikeQualityScore())) return false;\n      if (getIsRootSpike()\n          != other.getIsRootSpike()) return false;\n      if (java.lang.Double.doubleToLongBits(getRootSpikeScore())\n          != java.lang.Double.doubleToLongBits(\n              other.getRootSpikeScore())) return false;\n      if (getUsedForSignal()\n          != other.getUsedForSignal()) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + TIMESTAMP_MS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          getTimestampMs());\n      hash = (37 * hash) + SYMBOL_FIELD_NUMBER;\n      hash = (53 * hash) + getSymbol().hashCode();\n      hash = (37 * hash) + SPIKE_TYPE_FIELD_NUMBER;\n      hash = (53 * hash) + getSpikeType().hashCode();\n      hash = (37 * hash) + MAGNITUDE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMagnitude()));\n      hash = (37 * hash) + DURATION_FIELD_NUMBER;\n      hash = (53 * hash) + getDuration();\n      hash = (37 * hash) + PRICE_AT_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPriceAtSpike()));\n      hash = (37 * hash) + VOLUME_AT_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          getVolumeAtSpike());\n      hash = (37 * hash) + RSI_AT_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRsiAtSpike()));\n      hash = (37 * hash) + BOLLINGER_POSITION_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getBollingerPosition()));\n      hash = (37 * hash) + MARKET_VOLATILITY_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMarketVolatility()));\n      hash = (37 * hash) + TIME_OF_DAY_FIELD_NUMBER;\n      hash = (53 * hash) + getTimeOfDay();\n      hash = (37 * hash) + DAY_OF_WEEK_FIELD_NUMBER;\n      hash = (53 * hash) + getDayOfWeek();\n      if (hasIndicators()) {\n        hash = (37 * hash) + INDICATORS_FIELD_NUMBER;\n        hash = (53 * hash) + getIndicators().hashCode();\n      }\n      hash = (37 * hash) + OUTCOME_PROFITABLE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getOutcomeProfitable());\n      hash = (37 * hash) + OUTCOME_SCORE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getOutcomeScore()));\n      hash = (37 * hash) + STATISTICAL_Z_SCORE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getStatisticalZScore()));\n      hash = (37 * hash) + TREND_CONTEXT_FIELD_NUMBER;\n      hash = (53 * hash) + getTrendContext().hashCode();\n      hash = (37 * hash) + SPIKE_QUALITY_SCORE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getSpikeQualityScore()));\n      hash = (37 * hash) + IS_ROOT_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getIsRootSpike());\n      hash = (37 * hash) + ROOT_SPIKE_SCORE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRootSpikeScore()));\n      hash = (37 * hash) + USED_FOR_SIGNAL_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getUsedForSignal());\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.SpikeRecord parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SpikeRecord parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SpikeRecord parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SpikeRecord parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SpikeRecord parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SpikeRecord parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SpikeRecord parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SpikeRecord parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.SpikeRecord parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.SpikeRecord parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SpikeRecord parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SpikeRecord parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.SpikeSignalsProto.SpikeRecord prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Spike record\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.SpikeRecord}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.SpikeRecord)\n        com.spiketrade.proto.SpikeSignalsProto.SpikeRecordOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SpikeRecord_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SpikeRecord_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.class, com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.newBuilder()\n      private Builder() {\n        maybeForceBuilderInitialization();\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n        maybeForceBuilderInitialization();\n      }\n      private void maybeForceBuilderInitialization() {\n        if (com.google.protobuf.GeneratedMessageV3\n                .alwaysUseFieldBuilders) {\n          getIndicatorsFieldBuilder();\n        }\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        timestampMs_ = 0L;\n        symbol_ = \"\";\n        spikeType_ = \"\";\n        magnitude_ = 0D;\n        duration_ = 0;\n        priceAtSpike_ = 0D;\n        volumeAtSpike_ = 0L;\n        rsiAtSpike_ = 0D;\n        bollingerPosition_ = 0D;\n        marketVolatility_ = 0D;\n        timeOfDay_ = 0;\n        dayOfWeek_ = 0;\n        indicators_ = null;\n        if (indicatorsBuilder_ != null) {\n          indicatorsBuilder_.dispose();\n          indicatorsBuilder_ = null;\n        }\n        outcomeProfitable_ = false;\n        outcomeScore_ = 0D;\n        statisticalZScore_ = 0D;\n        trendContext_ = \"\";\n        spikeQualityScore_ = 0D;\n        isRootSpike_ = false;\n        rootSpikeScore_ = 0D;\n        usedForSignal_ = false;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SpikeRecord_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.SpikeRecord getDefaultInstanceForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.SpikeRecord build() {\n        com.spiketrade.proto.SpikeSignalsProto.SpikeRecord result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.SpikeRecord buildPartial() {\n        com.spiketrade.proto.SpikeSignalsProto.SpikeRecord result = new com.spiketrade.proto.SpikeSignalsProto.SpikeRecord(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.SpikeSignalsProto.SpikeRecord result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.timestampMs_ = timestampMs_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.symbol_ = symbol_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.spikeType_ = spikeType_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.magnitude_ = magnitude_;\n        }\n        if (((from_bitField0_ & 0x00000010) != 0)) {\n          result.duration_ = duration_;\n        }\n        if (((from_bitField0_ & 0x00000020) != 0)) {\n          result.priceAtSpike_ = priceAtSpike_;\n        }\n        if (((from_bitField0_ & 0x00000040) != 0)) {\n          result.volumeAtSpike_ = volumeAtSpike_;\n        }\n        if (((from_bitField0_ & 0x00000080) != 0)) {\n          result.rsiAtSpike_ = rsiAtSpike_;\n        }\n        if (((from_bitField0_ & 0x00000100) != 0)) {\n          result.bollingerPosition_ = bollingerPosition_;\n        }\n        if (((from_bitField0_ & 0x00000200) != 0)) {\n          result.marketVolatility_ = marketVolatility_;\n        }\n        if (((from_bitField0_ & 0x00000400) != 0)) {\n          result.timeOfDay_ = timeOfDay_;\n        }\n        if (((from_bitField0_ & 0x00000800) != 0)) {\n          result.dayOfWeek_ = dayOfWeek_;\n        }\n        int to_bitField0_ = 0;\n        if (((from_bitField0_ & 0x00001000) != 0)) {\n          result.indicators_ = indicatorsBuilder_ == null\n              ? indicators_\n              : indicatorsBuilder_.build();\n          to_bitField0_ |= 0x00000001;\n        }\n        if (((from_bitField0_ & 0x00002000) != 0)) {\n          result.outcomeProfitable_ = outcomeProfitable_;\n        }\n        if (((from_bitField0_ & 0x00004000) != 0)) {\n          result.outcomeScore_ = outcomeScore_;\n        }\n        if (((from_bitField0_ & 0x00008000) != 0)) {\n          result.statisticalZScore_ = statisticalZScore_;\n        }\n        if (((from_bitField0_ & 0x00010000) != 0)) {\n          result.trendContext_ = trendContext_;\n        }\n        if (((from_bitField0_ & 0x00020000) != 0)) {\n          result.spikeQualityScore_ = spikeQualityScore_;\n        }\n        if (((from_bitField0_ & 0x00040000) != 0)) {\n          result.isRootSpike_ = isRootSpike_;\n        }\n        if (((from_bitField0_ & 0x00080000) != 0)) {\n          result.rootSpikeScore_ = rootSpikeScore_;\n        }\n        if (((from_bitField0_ & 0x00100000) != 0)) {\n          result.usedForSignal_ = usedForSignal_;\n        }\n        result.bitField0_ |= to_bitField0_;\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.SpikeSignalsProto.SpikeRecord) {\n          return mergeFrom((com.spiketrade.proto.SpikeSignalsProto.SpikeRecord)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.SpikeSignalsProto.SpikeRecord other) {\n        if (other == com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.getDefaultInstance()) return this;\n        if (other.getTimestampMs() != 0L) {\n          setTimestampMs(other.getTimestampMs());\n        }\n        if (!other.getSymbol().isEmpty()) {\n          symbol_ = other.symbol_;\n          bitField0_ |= 0x00000002;\n          onChanged();\n        }\n        if (!other.getSpikeType().isEmpty()) {\n          spikeType_ = other.spikeType_;\n          bitField0_ |= 0x00000004;\n          onChanged();\n        }\n        if (other.getMagnitude() != 0D) {\n          setMagnitude(other.getMagnitude());\n        }\n        if (other.getDuration() != 0) {\n          setDuration(other.getDuration());\n        }\n        if (other.getPriceAtSpike() != 0D) {\n          setPriceAtSpike(other.getPriceAtSpike());\n        }\n        if (other.getVolumeAtSpike() != 0L) {\n          setVolumeAtSpike(other.getVolumeAtSpike());\n        }\n        if (other.getRsiAtSpike() != 0D) {\n          setRsiAtSpike(other.getRsiAtSpike());\n        }\n        if (other.getBollingerPosition() != 0D) {\n          setBollingerPosition(other.getBollingerPosition());\n        }\n        if (other.getMarketVolatility() != 0D) {\n          setMarketVolatility(other.getMarketVolatility());\n        }\n        if (other.getTimeOfDay() != 0) {\n          setTimeOfDay(other.getTimeOfDay());\n        }\n        if (other.getDayOfWeek() != 0) {\n          setDayOfWeek(other.getDayOfWeek());\n        }\n        if (other.hasIndicators()) {\n          mergeIndicators(other.getIndicators());\n        }\n        if (other.getOutcomeProfitable() != false) {\n          setOutcomeProfitable(other.getOutcomeProfitable());\n        }\n        if (other.getOutcomeScore() != 0D) {\n          setOutcomeScore(other.getOutcomeScore());\n        }\n        if (other.getStatisticalZScore() != 0D) {\n          setStatisticalZScore(other.getStatisticalZScore());\n        }\n        if (!other.getTrendContext().isEmpty()) {\n          trendContext_ = other.trendContext_;\n          bitField0_ |= 0x00010000;\n          onChanged();\n        }\n        if (other.getSpikeQualityScore() != 0D) {\n          setSpikeQualityScore(other.getSpikeQualityScore());\n        }\n        if (other.getIsRootSpike() != false) {\n          setIsRootSpike(other.getIsRootSpike());\n        }\n        if (other.getRootSpikeScore() != 0D) {\n          setRootSpikeScore(other.getRootSpikeScore());\n        }\n        if (other.getUsedForSignal() != false) {\n          setUsedForSignal(other.getUsedForSignal());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 8: {\n                timestampMs_ = input.readInt64();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 8\n              case 18: {\n                symbol_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 18\n              case 26: {\n                spikeType_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 26\n              case 33: {\n                magnitude_ = input.readDouble();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 33\n              case 40: {\n                duration_ = input.readInt32();\n                bitField0_ |= 0x00000010;\n                break;\n              } // case 40\n              case 49: {\n                priceAtSpike_ = input.readDouble();\n                bitField0_ |= 0x00000020;\n                break;\n              } // case 49\n              case 56: {\n                volumeAtSpike_ = input.readInt64();\n                bitField0_ |= 0x00000040;\n                break;\n              } // case 56\n              case 65: {\n                rsiAtSpike_ = input.readDouble();\n                bitField0_ |= 0x00000080;\n                break;\n              } // case 65\n              case 73: {\n                bollingerPosition_ = input.readDouble();\n                bitField0_ |= 0x00000100;\n                break;\n              } // case 73\n              case 81: {\n                marketVolatility_ = input.readDouble();\n                bitField0_ |= 0x00000200;\n                break;\n              } // case 81\n              case 88: {\n                timeOfDay_ = input.readInt32();\n                bitField0_ |= 0x00000400;\n                break;\n              } // case 88\n              case 96: {\n                dayOfWeek_ = input.readInt32();\n                bitField0_ |= 0x00000800;\n                break;\n              } // case 96\n              case 106: {\n                input.readMessage(\n                    getIndicatorsFieldBuilder().getBuilder(),\n                    extensionRegistry);\n                bitField0_ |= 0x00001000;\n                break;\n              } // case 106\n              case 112: {\n                outcomeProfitable_ = input.readBool();\n                bitField0_ |= 0x00002000;\n                break;\n              } // case 112\n              case 121: {\n                outcomeScore_ = input.readDouble();\n                bitField0_ |= 0x00004000;\n                break;\n              } // case 121\n              case 129: {\n                statisticalZScore_ = input.readDouble();\n                bitField0_ |= 0x00008000;\n                break;\n              } // case 129\n              case 138: {\n                trendContext_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00010000;\n                break;\n              } // case 138\n              case 145: {\n                spikeQualityScore_ = input.readDouble();\n                bitField0_ |= 0x00020000;\n                break;\n              } // case 145\n              case 152: {\n                isRootSpike_ = input.readBool();\n                bitField0_ |= 0x00040000;\n                break;\n              } // case 152\n              case 161: {\n                rootSpikeScore_ = input.readDouble();\n                bitField0_ |= 0x00080000;\n                break;\n              } // case 161\n              case 168: {\n                usedForSignal_ = input.readBool();\n                bitField0_ |= 0x00100000;\n                break;\n              } // case 168\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private long timestampMs_ ;\n      /**\n       * <code>int64 timestamp_ms = 1;</code>\n       * @return The timestampMs.\n       */\n      @java.lang.Override\n      public long getTimestampMs() {\n        return timestampMs_;\n      }\n      /**\n       * <code>int64 timestamp_ms = 1;</code>\n       * @param value The timestampMs to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTimestampMs(long value) {\n\n        timestampMs_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int64 timestamp_ms = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTimestampMs() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        timestampMs_ = 0L;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object symbol_ = \"\";\n      /**\n       * <code>string symbol = 2;</code>\n       * @return The symbol.\n       */\n      public java.lang.String getSymbol() {\n        java.lang.Object ref = symbol_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          symbol_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 2;</code>\n       * @return The bytes for symbol.\n       */\n      public com.google.protobuf.ByteString\n          getSymbolBytes() {\n        java.lang.Object ref = symbol_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          symbol_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 2;</code>\n       * @param value The symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbol(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        symbol_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSymbol() {\n        symbol_ = getDefaultInstance().getSymbol();\n        bitField0_ = (bitField0_ & ~0x00000002);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 2;</code>\n       * @param value The bytes for symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbolBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        symbol_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object spikeType_ = \"\";\n      /**\n       * <code>string spike_type = 3;</code>\n       * @return The spikeType.\n       */\n      public java.lang.String getSpikeType() {\n        java.lang.Object ref = spikeType_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          spikeType_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string spike_type = 3;</code>\n       * @return The bytes for spikeType.\n       */\n      public com.google.protobuf.ByteString\n          getSpikeTypeBytes() {\n        java.lang.Object ref = spikeType_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          spikeType_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string spike_type = 3;</code>\n       * @param value The spikeType to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSpikeType(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        spikeType_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string spike_type = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSpikeType() {\n        spikeType_ = getDefaultInstance().getSpikeType();\n        bitField0_ = (bitField0_ & ~0x00000004);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string spike_type = 3;</code>\n       * @param value The bytes for spikeType to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSpikeTypeBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        spikeType_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n\n      private double magnitude_ ;\n      /**\n       * <code>double magnitude = 4;</code>\n       * @return The magnitude.\n       */\n      @java.lang.Override\n      public double getMagnitude() {\n        return magnitude_;\n      }\n      /**\n       * <code>double magnitude = 4;</code>\n       * @param value The magnitude to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMagnitude(double value) {\n\n        magnitude_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double magnitude = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMagnitude() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        magnitude_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private int duration_ ;\n      /**\n       * <code>int32 duration = 5;</code>\n       * @return The duration.\n       */\n      @java.lang.Override\n      public int getDuration() {\n        return duration_;\n      }\n      /**\n       * <code>int32 duration = 5;</code>\n       * @param value The duration to set.\n       * @return This builder for chaining.\n       */\n      public Builder setDuration(int value) {\n\n        duration_ = value;\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 duration = 5;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearDuration() {\n        bitField0_ = (bitField0_ & ~0x00000010);\n        duration_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private double priceAtSpike_ ;\n      /**\n       * <code>double price_at_spike = 6;</code>\n       * @return The priceAtSpike.\n       */\n      @java.lang.Override\n      public double getPriceAtSpike() {\n        return priceAtSpike_;\n      }\n      /**\n       * <code>double price_at_spike = 6;</code>\n       * @param value The priceAtSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPriceAtSpike(double value) {\n\n        priceAtSpike_ = value;\n        bitField0_ |= 0x00000020;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double price_at_spike = 6;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPriceAtSpike() {\n        bitField0_ = (bitField0_ & ~0x00000020);\n        priceAtSpike_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private long volumeAtSpike_ ;\n      /**\n       * <code>int64 volume_at_spike = 7;</code>\n       * @return The volumeAtSpike.\n       */\n      @java.lang.Override\n      public long getVolumeAtSpike() {\n        return volumeAtSpike_;\n      }\n      /**\n       * <code>int64 volume_at_spike = 7;</code>\n       * @param value The volumeAtSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolumeAtSpike(long value) {\n\n        volumeAtSpike_ = value;\n        bitField0_ |= 0x00000040;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int64 volume_at_spike = 7;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolumeAtSpike() {\n        bitField0_ = (bitField0_ & ~0x00000040);\n        volumeAtSpike_ = 0L;\n        onChanged();\n        return this;\n      }\n\n      private double rsiAtSpike_ ;\n      /**\n       * <code>double rsi_at_spike = 8;</code>\n       * @return The rsiAtSpike.\n       */\n      @java.lang.Override\n      public double getRsiAtSpike() {\n        return rsiAtSpike_;\n      }\n      /**\n       * <code>double rsi_at_spike = 8;</code>\n       * @param value The rsiAtSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRsiAtSpike(double value) {\n\n        rsiAtSpike_ = value;\n        bitField0_ |= 0x00000080;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double rsi_at_spike = 8;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRsiAtSpike() {\n        bitField0_ = (bitField0_ & ~0x00000080);\n        rsiAtSpike_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double bollingerPosition_ ;\n      /**\n       * <code>double bollinger_position = 9;</code>\n       * @return The bollingerPosition.\n       */\n      @java.lang.Override\n      public double getBollingerPosition() {\n        return bollingerPosition_;\n      }\n      /**\n       * <code>double bollinger_position = 9;</code>\n       * @param value The bollingerPosition to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBollingerPosition(double value) {\n\n        bollingerPosition_ = value;\n        bitField0_ |= 0x00000100;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double bollinger_position = 9;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBollingerPosition() {\n        bitField0_ = (bitField0_ & ~0x00000100);\n        bollingerPosition_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double marketVolatility_ ;\n      /**\n       * <code>double market_volatility = 10;</code>\n       * @return The marketVolatility.\n       */\n      @java.lang.Override\n      public double getMarketVolatility() {\n        return marketVolatility_;\n      }\n      /**\n       * <code>double market_volatility = 10;</code>\n       * @param value The marketVolatility to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMarketVolatility(double value) {\n\n        marketVolatility_ = value;\n        bitField0_ |= 0x00000200;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double market_volatility = 10;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMarketVolatility() {\n        bitField0_ = (bitField0_ & ~0x00000200);\n        marketVolatility_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private int timeOfDay_ ;\n      /**\n       * <code>int32 time_of_day = 11;</code>\n       * @return The timeOfDay.\n       */\n      @java.lang.Override\n      public int getTimeOfDay() {\n        return timeOfDay_;\n      }\n      /**\n       * <code>int32 time_of_day = 11;</code>\n       * @param value The timeOfDay to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTimeOfDay(int value) {\n\n        timeOfDay_ = value;\n        bitField0_ |= 0x00000400;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 time_of_day = 11;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTimeOfDay() {\n        bitField0_ = (bitField0_ & ~0x00000400);\n        timeOfDay_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int dayOfWeek_ ;\n      /**\n       * <code>int32 day_of_week = 12;</code>\n       * @return The dayOfWeek.\n       */\n      @java.lang.Override\n      public int getDayOfWeek() {\n        return dayOfWeek_;\n      }\n      /**\n       * <code>int32 day_of_week = 12;</code>\n       * @param value The dayOfWeek to set.\n       * @return This builder for chaining.\n       */\n      public Builder setDayOfWeek(int value) {\n\n        dayOfWeek_ = value;\n        bitField0_ |= 0x00000800;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 day_of_week = 12;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearDayOfWeek() {\n        bitField0_ = (bitField0_ & ~0x00000800);\n        dayOfWeek_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private com.spiketrade.proto.SpikeSignalsProto.Indicators indicators_;\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.SpikeSignalsProto.Indicators, com.spiketrade.proto.SpikeSignalsProto.Indicators.Builder, com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder> indicatorsBuilder_;\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n       * @return Whether the indicators field is set.\n       */\n      public boolean hasIndicators() {\n        return ((bitField0_ & 0x00001000) != 0);\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n       * @return The indicators.\n       */\n      public com.spiketrade.proto.SpikeSignalsProto.Indicators getIndicators() {\n        if (indicatorsBuilder_ == null) {\n          return indicators_ == null ? com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance() : indicators_;\n        } else {\n          return indicatorsBuilder_.getMessage();\n        }\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n       */\n      public Builder setIndicators(com.spiketrade.proto.SpikeSignalsProto.Indicators value) {\n        if (indicatorsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          indicators_ = value;\n        } else {\n          indicatorsBuilder_.setMessage(value);\n        }\n        bitField0_ |= 0x00001000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n       */\n      public Builder setIndicators(\n          com.spiketrade.proto.SpikeSignalsProto.Indicators.Builder builderForValue) {\n        if (indicatorsBuilder_ == null) {\n          indicators_ = builderForValue.build();\n        } else {\n          indicatorsBuilder_.setMessage(builderForValue.build());\n        }\n        bitField0_ |= 0x00001000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n       */\n      public Builder mergeIndicators(com.spiketrade.proto.SpikeSignalsProto.Indicators value) {\n        if (indicatorsBuilder_ == null) {\n          if (((bitField0_ & 0x00001000) != 0) &&\n            indicators_ != null &&\n            indicators_ != com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance()) {\n            getIndicatorsBuilder().mergeFrom(value);\n          } else {\n            indicators_ = value;\n          }\n        } else {\n          indicatorsBuilder_.mergeFrom(value);\n        }\n        if (indicators_ != null) {\n          bitField0_ |= 0x00001000;\n          onChanged();\n        }\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n       */\n      public Builder clearIndicators() {\n        bitField0_ = (bitField0_ & ~0x00001000);\n        indicators_ = null;\n        if (indicatorsBuilder_ != null) {\n          indicatorsBuilder_.dispose();\n          indicatorsBuilder_ = null;\n        }\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n       */\n      public com.spiketrade.proto.SpikeSignalsProto.Indicators.Builder getIndicatorsBuilder() {\n        bitField0_ |= 0x00001000;\n        onChanged();\n        return getIndicatorsFieldBuilder().getBuilder();\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n       */\n      public com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder getIndicatorsOrBuilder() {\n        if (indicatorsBuilder_ != null) {\n          return indicatorsBuilder_.getMessageOrBuilder();\n        } else {\n          return indicators_ == null ?\n              com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance() : indicators_;\n        }\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 13;</code>\n       */\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.SpikeSignalsProto.Indicators, com.spiketrade.proto.SpikeSignalsProto.Indicators.Builder, com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder> \n          getIndicatorsFieldBuilder() {\n        if (indicatorsBuilder_ == null) {\n          indicatorsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<\n              com.spiketrade.proto.SpikeSignalsProto.Indicators, com.spiketrade.proto.SpikeSignalsProto.Indicators.Builder, com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder>(\n                  getIndicators(),\n                  getParentForChildren(),\n                  isClean());\n          indicators_ = null;\n        }\n        return indicatorsBuilder_;\n      }\n\n      private boolean outcomeProfitable_ ;\n      /**\n       * <code>bool outcome_profitable = 14;</code>\n       * @return The outcomeProfitable.\n       */\n      @java.lang.Override\n      public boolean getOutcomeProfitable() {\n        return outcomeProfitable_;\n      }\n      /**\n       * <code>bool outcome_profitable = 14;</code>\n       * @param value The outcomeProfitable to set.\n       * @return This builder for chaining.\n       */\n      public Builder setOutcomeProfitable(boolean value) {\n\n        outcomeProfitable_ = value;\n        bitField0_ |= 0x00002000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool outcome_profitable = 14;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearOutcomeProfitable() {\n        bitField0_ = (bitField0_ & ~0x00002000);\n        outcomeProfitable_ = false;\n        onChanged();\n        return this;\n      }\n\n      private double outcomeScore_ ;\n      /**\n       * <code>double outcome_score = 15;</code>\n       * @return The outcomeScore.\n       */\n      @java.lang.Override\n      public double getOutcomeScore() {\n        return outcomeScore_;\n      }\n      /**\n       * <code>double outcome_score = 15;</code>\n       * @param value The outcomeScore to set.\n       * @return This builder for chaining.\n       */\n      public Builder setOutcomeScore(double value) {\n\n        outcomeScore_ = value;\n        bitField0_ |= 0x00004000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double outcome_score = 15;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearOutcomeScore() {\n        bitField0_ = (bitField0_ & ~0x00004000);\n        outcomeScore_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double statisticalZScore_ ;\n      /**\n       * <code>double statistical_z_score = 16;</code>\n       * @return The statisticalZScore.\n       */\n      @java.lang.Override\n      public double getStatisticalZScore() {\n        return statisticalZScore_;\n      }\n      /**\n       * <code>double statistical_z_score = 16;</code>\n       * @param value The statisticalZScore to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStatisticalZScore(double value) {\n\n        statisticalZScore_ = value;\n        bitField0_ |= 0x00008000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double statistical_z_score = 16;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStatisticalZScore() {\n        bitField0_ = (bitField0_ & ~0x00008000);\n        statisticalZScore_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object trendContext_ = \"\";\n      /**\n       * <code>string trend_context = 17;</code>\n       * @return The trendContext.\n       */\n      public java.lang.String getTrendContext() {\n        java.lang.Object ref = trendContext_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          trendContext_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string trend_context = 17;</code>\n       * @return The bytes for trendContext.\n       */\n      public com.google.protobuf.ByteString\n          getTrendContextBytes() {\n        java.lang.Object ref = trendContext_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          trendContext_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string trend_context = 17;</code>\n       * @param value The trendContext to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTrendContext(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        trendContext_ = value;\n        bitField0_ |= 0x00010000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string trend_context = 17;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTrendContext() {\n        trendContext_ = getDefaultInstance().getTrendContext();\n        bitField0_ = (bitField0_ & ~0x00010000);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string trend_context = 17;</code>\n       * @param value The bytes for trendContext to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTrendContextBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        trendContext_ = value;\n        bitField0_ |= 0x00010000;\n        onChanged();\n        return this;\n      }\n\n      private double spikeQualityScore_ ;\n      /**\n       * <code>double spike_quality_score = 18;</code>\n       * @return The spikeQualityScore.\n       */\n      @java.lang.Override\n      public double getSpikeQualityScore() {\n        return spikeQualityScore_;\n      }\n      /**\n       * <code>double spike_quality_score = 18;</code>\n       * @param value The spikeQualityScore to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSpikeQualityScore(double value) {\n\n        spikeQualityScore_ = value;\n        bitField0_ |= 0x00020000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double spike_quality_score = 18;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSpikeQualityScore() {\n        bitField0_ = (bitField0_ & ~0x00020000);\n        spikeQualityScore_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private boolean isRootSpike_ ;\n      /**\n       * <code>bool is_root_spike = 19;</code>\n       * @return The isRootSpike.\n       */\n      @java.lang.Override\n      public boolean getIsRootSpike() {\n        return isRootSpike_;\n      }\n      /**\n       * <code>bool is_root_spike = 19;</code>\n       * @param value The isRootSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setIsRootSpike(boolean value) {\n\n        isRootSpike_ = value;\n        bitField0_ |= 0x00040000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool is_root_spike = 19;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearIsRootSpike() {\n        bitField0_ = (bitField0_ & ~0x00040000);\n        isRootSpike_ = false;\n        onChanged();\n        return this;\n      }\n\n      private double rootSpikeScore_ ;\n      /**\n       * <code>double root_spike_score = 20;</code>\n       * @return The rootSpikeScore.\n       */\n      @java.lang.Override\n      public double getRootSpikeScore() {\n        return rootSpikeScore_;\n      }\n      /**\n       * <code>double root_spike_score = 20;</code>\n       * @param value The rootSpikeScore to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRootSpikeScore(double value) {\n\n        rootSpikeScore_ = value;\n        bitField0_ |= 0x00080000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double root_spike_score = 20;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRootSpikeScore() {\n        bitField0_ = (bitField0_ & ~0x00080000);\n        rootSpikeScore_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private boolean usedForSignal_ ;\n      /**\n       * <code>bool used_for_signal = 21;</code>\n       * @return The usedForSignal.\n       */\n      @java.lang.Override\n      public boolean getUsedForSignal() {\n        return usedForSignal_;\n      }\n      /**\n       * <code>bool used_for_signal = 21;</code>\n       * @param value The usedForSignal to set.\n       * @return This builder for chaining.\n       */\n      public Builder setUsedForSignal(boolean value) {\n\n        usedForSignal_ = value;\n        bitField0_ |= 0x00100000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool used_for_signal = 21;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearUsedForSignal() {\n        bitField0_ = (bitField0_ & ~0x00100000);\n        usedForSignal_ = false;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.SpikeRecord)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.SpikeRecord)\n    private static final com.spiketrade.proto.SpikeSignalsProto.SpikeRecord DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.SpikeSignalsProto.SpikeRecord();\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.SpikeRecord getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<SpikeRecord>\n        PARSER = new com.google.protobuf.AbstractParser<SpikeRecord>() {\n      @java.lang.Override\n      public SpikeRecord parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<SpikeRecord> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<SpikeRecord> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.SpikeRecord getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface BuySignalOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.BuySignal)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>int64 timestamp_ms = 1;</code>\n     * @return The timestampMs.\n     */\n    long getTimestampMs();\n\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The symbol.\n     */\n    java.lang.String getSymbol();\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The bytes for symbol.\n     */\n    com.google.protobuf.ByteString\n        getSymbolBytes();\n\n    /**\n     * <code>double price = 3;</code>\n     * @return The price.\n     */\n    double getPrice();\n\n    /**\n     * <code>double signal_probability = 4;</code>\n     * @return The signalProbability.\n     */\n    double getSignalProbability();\n\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n     * @return Whether the indicators field is set.\n     */\n    boolean hasIndicators();\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n     * @return The indicators.\n     */\n    com.spiketrade.proto.SpikeSignalsProto.Indicators getIndicators();\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n     */\n    com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder getIndicatorsOrBuilder();\n\n    /**\n     * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n     */\n    java.util.List<com.spiketrade.proto.SpikeSignalsProto.SpikeRecord> \n        getSpikesList();\n    /**\n     * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n     */\n    com.spiketrade.proto.SpikeSignalsProto.SpikeRecord getSpikes(int index);\n    /**\n     * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n     */\n    int getSpikesCount();\n    /**\n     * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n     */\n    java.util.List<? extends com.spiketrade.proto.SpikeSignalsProto.SpikeRecordOrBuilder> \n        getSpikesOrBuilderList();\n    /**\n     * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n     */\n    com.spiketrade.proto.SpikeSignalsProto.SpikeRecordOrBuilder getSpikesOrBuilder(\n        int index);\n\n    /**\n     * <code>string reason = 7;</code>\n     * @return The reason.\n     */\n    java.lang.String getReason();\n    /**\n     * <code>string reason = 7;</code>\n     * @return The bytes for reason.\n     */\n    com.google.protobuf.ByteString\n        getReasonBytes();\n\n    /**\n     * <code>optional double predicted_gain_target = 8;</code>\n     * @return Whether the predictedGainTarget field is set.\n     */\n    boolean hasPredictedGainTarget();\n    /**\n     * <code>optional double predicted_gain_target = 8;</code>\n     * @return The predictedGainTarget.\n     */\n    double getPredictedGainTarget();\n\n    /**\n     * <code>optional int32 predicted_time_to_target_minutes = 9;</code>\n     * @return Whether the predictedTimeToTargetMinutes field is set.\n     */\n    boolean hasPredictedTimeToTargetMinutes();\n    /**\n     * <code>optional int32 predicted_time_to_target_minutes = 9;</code>\n     * @return The predictedTimeToTargetMinutes.\n     */\n    int getPredictedTimeToTargetMinutes();\n\n    /**\n     * <code>optional double prediction_confidence = 10;</code>\n     * @return Whether the predictionConfidence field is set.\n     */\n    boolean hasPredictionConfidence();\n    /**\n     * <code>optional double prediction_confidence = 10;</code>\n     * @return The predictionConfidence.\n     */\n    double getPredictionConfidence();\n\n    /**\n     * <code>optional string prediction_reasoning = 11;</code>\n     * @return Whether the predictionReasoning field is set.\n     */\n    boolean hasPredictionReasoning();\n    /**\n     * <code>optional string prediction_reasoning = 11;</code>\n     * @return The predictionReasoning.\n     */\n    java.lang.String getPredictionReasoning();\n    /**\n     * <code>optional string prediction_reasoning = 11;</code>\n     * @return The bytes for predictionReasoning.\n     */\n    com.google.protobuf.ByteString\n        getPredictionReasoningBytes();\n  }\n  /**\n   * <pre>\n   * Buy signal message\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.BuySignal}\n   */\n  public static final class BuySignal extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.BuySignal)\n      BuySignalOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use BuySignal.newBuilder() to construct.\n    private BuySignal(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private BuySignal() {\n      symbol_ = \"\";\n      spikes_ = java.util.Collections.emptyList();\n      reason_ = \"\";\n      predictionReasoning_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new BuySignal();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_BuySignal_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_BuySignal_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.SpikeSignalsProto.BuySignal.class, com.spiketrade.proto.SpikeSignalsProto.BuySignal.Builder.class);\n    }\n\n    private int bitField0_;\n    public static final int TIMESTAMP_MS_FIELD_NUMBER = 1;\n    private long timestampMs_ = 0L;\n    /**\n     * <code>int64 timestamp_ms = 1;</code>\n     * @return The timestampMs.\n     */\n    @java.lang.Override\n    public long getTimestampMs() {\n      return timestampMs_;\n    }\n\n    public static final int SYMBOL_FIELD_NUMBER = 2;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object symbol_ = \"\";\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The symbol.\n     */\n    @java.lang.Override\n    public java.lang.String getSymbol() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        symbol_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The bytes for symbol.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getSymbolBytes() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        symbol_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int PRICE_FIELD_NUMBER = 3;\n    private double price_ = 0D;\n    /**\n     * <code>double price = 3;</code>\n     * @return The price.\n     */\n    @java.lang.Override\n    public double getPrice() {\n      return price_;\n    }\n\n    public static final int SIGNAL_PROBABILITY_FIELD_NUMBER = 4;\n    private double signalProbability_ = 0D;\n    /**\n     * <code>double signal_probability = 4;</code>\n     * @return The signalProbability.\n     */\n    @java.lang.Override\n    public double getSignalProbability() {\n      return signalProbability_;\n    }\n\n    public static final int INDICATORS_FIELD_NUMBER = 5;\n    private com.spiketrade.proto.SpikeSignalsProto.Indicators indicators_;\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n     * @return Whether the indicators field is set.\n     */\n    @java.lang.Override\n    public boolean hasIndicators() {\n      return ((bitField0_ & 0x00000001) != 0);\n    }\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n     * @return The indicators.\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.Indicators getIndicators() {\n      return indicators_ == null ? com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance() : indicators_;\n    }\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder getIndicatorsOrBuilder() {\n      return indicators_ == null ? com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance() : indicators_;\n    }\n\n    public static final int SPIKES_FIELD_NUMBER = 6;\n    @SuppressWarnings(\"serial\")\n    private java.util.List<com.spiketrade.proto.SpikeSignalsProto.SpikeRecord> spikes_;\n    /**\n     * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n     */\n    @java.lang.Override\n    public java.util.List<com.spiketrade.proto.SpikeSignalsProto.SpikeRecord> getSpikesList() {\n      return spikes_;\n    }\n    /**\n     * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n     */\n    @java.lang.Override\n    public java.util.List<? extends com.spiketrade.proto.SpikeSignalsProto.SpikeRecordOrBuilder> \n        getSpikesOrBuilderList() {\n      return spikes_;\n    }\n    /**\n     * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n     */\n    @java.lang.Override\n    public int getSpikesCount() {\n      return spikes_.size();\n    }\n    /**\n     * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.SpikeRecord getSpikes(int index) {\n      return spikes_.get(index);\n    }\n    /**\n     * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.SpikeRecordOrBuilder getSpikesOrBuilder(\n        int index) {\n      return spikes_.get(index);\n    }\n\n    public static final int REASON_FIELD_NUMBER = 7;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object reason_ = \"\";\n    /**\n     * <code>string reason = 7;</code>\n     * @return The reason.\n     */\n    @java.lang.Override\n    public java.lang.String getReason() {\n      java.lang.Object ref = reason_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        reason_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string reason = 7;</code>\n     * @return The bytes for reason.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getReasonBytes() {\n      java.lang.Object ref = reason_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        reason_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int PREDICTED_GAIN_TARGET_FIELD_NUMBER = 8;\n    private double predictedGainTarget_ = 0D;\n    /**\n     * <code>optional double predicted_gain_target = 8;</code>\n     * @return Whether the predictedGainTarget field is set.\n     */\n    @java.lang.Override\n    public boolean hasPredictedGainTarget() {\n      return ((bitField0_ & 0x00000002) != 0);\n    }\n    /**\n     * <code>optional double predicted_gain_target = 8;</code>\n     * @return The predictedGainTarget.\n     */\n    @java.lang.Override\n    public double getPredictedGainTarget() {\n      return predictedGainTarget_;\n    }\n\n    public static final int PREDICTED_TIME_TO_TARGET_MINUTES_FIELD_NUMBER = 9;\n    private int predictedTimeToTargetMinutes_ = 0;\n    /**\n     * <code>optional int32 predicted_time_to_target_minutes = 9;</code>\n     * @return Whether the predictedTimeToTargetMinutes field is set.\n     */\n    @java.lang.Override\n    public boolean hasPredictedTimeToTargetMinutes() {\n      return ((bitField0_ & 0x00000004) != 0);\n    }\n    /**\n     * <code>optional int32 predicted_time_to_target_minutes = 9;</code>\n     * @return The predictedTimeToTargetMinutes.\n     */\n    @java.lang.Override\n    public int getPredictedTimeToTargetMinutes() {\n      return predictedTimeToTargetMinutes_;\n    }\n\n    public static final int PREDICTION_CONFIDENCE_FIELD_NUMBER = 10;\n    private double predictionConfidence_ = 0D;\n    /**\n     * <code>optional double prediction_confidence = 10;</code>\n     * @return Whether the predictionConfidence field is set.\n     */\n    @java.lang.Override\n    public boolean hasPredictionConfidence() {\n      return ((bitField0_ & 0x00000008) != 0);\n    }\n    /**\n     * <code>optional double prediction_confidence = 10;</code>\n     * @return The predictionConfidence.\n     */\n    @java.lang.Override\n    public double getPredictionConfidence() {\n      return predictionConfidence_;\n    }\n\n    public static final int PREDICTION_REASONING_FIELD_NUMBER = 11;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object predictionReasoning_ = \"\";\n    /**\n     * <code>optional string prediction_reasoning = 11;</code>\n     * @return Whether the predictionReasoning field is set.\n     */\n    @java.lang.Override\n    public boolean hasPredictionReasoning() {\n      return ((bitField0_ & 0x00000010) != 0);\n    }\n    /**\n     * <code>optional string prediction_reasoning = 11;</code>\n     * @return The predictionReasoning.\n     */\n    @java.lang.Override\n    public java.lang.String getPredictionReasoning() {\n      java.lang.Object ref = predictionReasoning_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        predictionReasoning_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>optional string prediction_reasoning = 11;</code>\n     * @return The bytes for predictionReasoning.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getPredictionReasoningBytes() {\n      java.lang.Object ref = predictionReasoning_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        predictionReasoning_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (timestampMs_ != 0L) {\n        output.writeInt64(1, timestampMs_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, symbol_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(price_) != 0) {\n        output.writeDouble(3, price_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(signalProbability_) != 0) {\n        output.writeDouble(4, signalProbability_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        output.writeMessage(5, getIndicators());\n      }\n      for (int i = 0; i < spikes_.size(); i++) {\n        output.writeMessage(6, spikes_.get(i));\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(reason_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, reason_);\n      }\n      if (((bitField0_ & 0x00000002) != 0)) {\n        output.writeDouble(8, predictedGainTarget_);\n      }\n      if (((bitField0_ & 0x00000004) != 0)) {\n        output.writeInt32(9, predictedTimeToTargetMinutes_);\n      }\n      if (((bitField0_ & 0x00000008) != 0)) {\n        output.writeDouble(10, predictionConfidence_);\n      }\n      if (((bitField0_ & 0x00000010) != 0)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 11, predictionReasoning_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (timestampMs_ != 0L) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt64Size(1, timestampMs_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, symbol_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(price_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(3, price_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(signalProbability_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(4, signalProbability_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(5, getIndicators());\n      }\n      for (int i = 0; i < spikes_.size(); i++) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(6, spikes_.get(i));\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(reason_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, reason_);\n      }\n      if (((bitField0_ & 0x00000002) != 0)) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(8, predictedGainTarget_);\n      }\n      if (((bitField0_ & 0x00000004) != 0)) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(9, predictedTimeToTargetMinutes_);\n      }\n      if (((bitField0_ & 0x00000008) != 0)) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(10, predictionConfidence_);\n      }\n      if (((bitField0_ & 0x00000010) != 0)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(11, predictionReasoning_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.SpikeSignalsProto.BuySignal)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.SpikeSignalsProto.BuySignal other = (com.spiketrade.proto.SpikeSignalsProto.BuySignal) obj;\n\n      if (getTimestampMs()\n          != other.getTimestampMs()) return false;\n      if (!getSymbol()\n          .equals(other.getSymbol())) return false;\n      if (java.lang.Double.doubleToLongBits(getPrice())\n          != java.lang.Double.doubleToLongBits(\n              other.getPrice())) return false;\n      if (java.lang.Double.doubleToLongBits(getSignalProbability())\n          != java.lang.Double.doubleToLongBits(\n              other.getSignalProbability())) return false;\n      if (hasIndicators() != other.hasIndicators()) return false;\n      if (hasIndicators()) {\n        if (!getIndicators()\n            .equals(other.getIndicators())) return false;\n      }\n      if (!getSpikesList()\n          .equals(other.getSpikesList())) return false;\n      if (!getReason()\n          .equals(other.getReason())) return false;\n      if (hasPredictedGainTarget() != other.hasPredictedGainTarget()) return false;\n      if (hasPredictedGainTarget()) {\n        if (java.lang.Double.doubleToLongBits(getPredictedGainTarget())\n            != java.lang.Double.doubleToLongBits(\n                other.getPredictedGainTarget())) return false;\n      }\n      if (hasPredictedTimeToTargetMinutes() != other.hasPredictedTimeToTargetMinutes()) return false;\n      if (hasPredictedTimeToTargetMinutes()) {\n        if (getPredictedTimeToTargetMinutes()\n            != other.getPredictedTimeToTargetMinutes()) return false;\n      }\n      if (hasPredictionConfidence() != other.hasPredictionConfidence()) return false;\n      if (hasPredictionConfidence()) {\n        if (java.lang.Double.doubleToLongBits(getPredictionConfidence())\n            != java.lang.Double.doubleToLongBits(\n                other.getPredictionConfidence())) return false;\n      }\n      if (hasPredictionReasoning() != other.hasPredictionReasoning()) return false;\n      if (hasPredictionReasoning()) {\n        if (!getPredictionReasoning()\n            .equals(other.getPredictionReasoning())) return false;\n      }\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + TIMESTAMP_MS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          getTimestampMs());\n      hash = (37 * hash) + SYMBOL_FIELD_NUMBER;\n      hash = (53 * hash) + getSymbol().hashCode();\n      hash = (37 * hash) + PRICE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPrice()));\n      hash = (37 * hash) + SIGNAL_PROBABILITY_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getSignalProbability()));\n      if (hasIndicators()) {\n        hash = (37 * hash) + INDICATORS_FIELD_NUMBER;\n        hash = (53 * hash) + getIndicators().hashCode();\n      }\n      if (getSpikesCount() > 0) {\n        hash = (37 * hash) + SPIKES_FIELD_NUMBER;\n        hash = (53 * hash) + getSpikesList().hashCode();\n      }\n      hash = (37 * hash) + REASON_FIELD_NUMBER;\n      hash = (53 * hash) + getReason().hashCode();\n      if (hasPredictedGainTarget()) {\n        hash = (37 * hash) + PREDICTED_GAIN_TARGET_FIELD_NUMBER;\n        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n            java.lang.Double.doubleToLongBits(getPredictedGainTarget()));\n      }\n      if (hasPredictedTimeToTargetMinutes()) {\n        hash = (37 * hash) + PREDICTED_TIME_TO_TARGET_MINUTES_FIELD_NUMBER;\n        hash = (53 * hash) + getPredictedTimeToTargetMinutes();\n      }\n      if (hasPredictionConfidence()) {\n        hash = (37 * hash) + PREDICTION_CONFIDENCE_FIELD_NUMBER;\n        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n            java.lang.Double.doubleToLongBits(getPredictionConfidence()));\n      }\n      if (hasPredictionReasoning()) {\n        hash = (37 * hash) + PREDICTION_REASONING_FIELD_NUMBER;\n        hash = (53 * hash) + getPredictionReasoning().hashCode();\n      }\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.BuySignal parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.BuySignal parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.BuySignal parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.BuySignal parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.BuySignal parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.BuySignal parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.BuySignal parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.BuySignal parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.BuySignal parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.BuySignal parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.BuySignal parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.BuySignal parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.SpikeSignalsProto.BuySignal prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Buy signal message\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.BuySignal}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.BuySignal)\n        com.spiketrade.proto.SpikeSignalsProto.BuySignalOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_BuySignal_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_BuySignal_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.SpikeSignalsProto.BuySignal.class, com.spiketrade.proto.SpikeSignalsProto.BuySignal.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.SpikeSignalsProto.BuySignal.newBuilder()\n      private Builder() {\n        maybeForceBuilderInitialization();\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n        maybeForceBuilderInitialization();\n      }\n      private void maybeForceBuilderInitialization() {\n        if (com.google.protobuf.GeneratedMessageV3\n                .alwaysUseFieldBuilders) {\n          getIndicatorsFieldBuilder();\n          getSpikesFieldBuilder();\n        }\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        timestampMs_ = 0L;\n        symbol_ = \"\";\n        price_ = 0D;\n        signalProbability_ = 0D;\n        indicators_ = null;\n        if (indicatorsBuilder_ != null) {\n          indicatorsBuilder_.dispose();\n          indicatorsBuilder_ = null;\n        }\n        if (spikesBuilder_ == null) {\n          spikes_ = java.util.Collections.emptyList();\n        } else {\n          spikes_ = null;\n          spikesBuilder_.clear();\n        }\n        bitField0_ = (bitField0_ & ~0x00000020);\n        reason_ = \"\";\n        predictedGainTarget_ = 0D;\n        predictedTimeToTargetMinutes_ = 0;\n        predictionConfidence_ = 0D;\n        predictionReasoning_ = \"\";\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_BuySignal_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.BuySignal getDefaultInstanceForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.BuySignal.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.BuySignal build() {\n        com.spiketrade.proto.SpikeSignalsProto.BuySignal result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.BuySignal buildPartial() {\n        com.spiketrade.proto.SpikeSignalsProto.BuySignal result = new com.spiketrade.proto.SpikeSignalsProto.BuySignal(this);\n        buildPartialRepeatedFields(result);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartialRepeatedFields(com.spiketrade.proto.SpikeSignalsProto.BuySignal result) {\n        if (spikesBuilder_ == null) {\n          if (((bitField0_ & 0x00000020) != 0)) {\n            spikes_ = java.util.Collections.unmodifiableList(spikes_);\n            bitField0_ = (bitField0_ & ~0x00000020);\n          }\n          result.spikes_ = spikes_;\n        } else {\n          result.spikes_ = spikesBuilder_.build();\n        }\n      }\n\n      private void buildPartial0(com.spiketrade.proto.SpikeSignalsProto.BuySignal result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.timestampMs_ = timestampMs_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.symbol_ = symbol_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.price_ = price_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.signalProbability_ = signalProbability_;\n        }\n        int to_bitField0_ = 0;\n        if (((from_bitField0_ & 0x00000010) != 0)) {\n          result.indicators_ = indicatorsBuilder_ == null\n              ? indicators_\n              : indicatorsBuilder_.build();\n          to_bitField0_ |= 0x00000001;\n        }\n        if (((from_bitField0_ & 0x00000040) != 0)) {\n          result.reason_ = reason_;\n        }\n        if (((from_bitField0_ & 0x00000080) != 0)) {\n          result.predictedGainTarget_ = predictedGainTarget_;\n          to_bitField0_ |= 0x00000002;\n        }\n        if (((from_bitField0_ & 0x00000100) != 0)) {\n          result.predictedTimeToTargetMinutes_ = predictedTimeToTargetMinutes_;\n          to_bitField0_ |= 0x00000004;\n        }\n        if (((from_bitField0_ & 0x00000200) != 0)) {\n          result.predictionConfidence_ = predictionConfidence_;\n          to_bitField0_ |= 0x00000008;\n        }\n        if (((from_bitField0_ & 0x00000400) != 0)) {\n          result.predictionReasoning_ = predictionReasoning_;\n          to_bitField0_ |= 0x00000010;\n        }\n        result.bitField0_ |= to_bitField0_;\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.SpikeSignalsProto.BuySignal) {\n          return mergeFrom((com.spiketrade.proto.SpikeSignalsProto.BuySignal)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.SpikeSignalsProto.BuySignal other) {\n        if (other == com.spiketrade.proto.SpikeSignalsProto.BuySignal.getDefaultInstance()) return this;\n        if (other.getTimestampMs() != 0L) {\n          setTimestampMs(other.getTimestampMs());\n        }\n        if (!other.getSymbol().isEmpty()) {\n          symbol_ = other.symbol_;\n          bitField0_ |= 0x00000002;\n          onChanged();\n        }\n        if (other.getPrice() != 0D) {\n          setPrice(other.getPrice());\n        }\n        if (other.getSignalProbability() != 0D) {\n          setSignalProbability(other.getSignalProbability());\n        }\n        if (other.hasIndicators()) {\n          mergeIndicators(other.getIndicators());\n        }\n        if (spikesBuilder_ == null) {\n          if (!other.spikes_.isEmpty()) {\n            if (spikes_.isEmpty()) {\n              spikes_ = other.spikes_;\n              bitField0_ = (bitField0_ & ~0x00000020);\n            } else {\n              ensureSpikesIsMutable();\n              spikes_.addAll(other.spikes_);\n            }\n            onChanged();\n          }\n        } else {\n          if (!other.spikes_.isEmpty()) {\n            if (spikesBuilder_.isEmpty()) {\n              spikesBuilder_.dispose();\n              spikesBuilder_ = null;\n              spikes_ = other.spikes_;\n              bitField0_ = (bitField0_ & ~0x00000020);\n              spikesBuilder_ = \n                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?\n                   getSpikesFieldBuilder() : null;\n            } else {\n              spikesBuilder_.addAllMessages(other.spikes_);\n            }\n          }\n        }\n        if (!other.getReason().isEmpty()) {\n          reason_ = other.reason_;\n          bitField0_ |= 0x00000040;\n          onChanged();\n        }\n        if (other.hasPredictedGainTarget()) {\n          setPredictedGainTarget(other.getPredictedGainTarget());\n        }\n        if (other.hasPredictedTimeToTargetMinutes()) {\n          setPredictedTimeToTargetMinutes(other.getPredictedTimeToTargetMinutes());\n        }\n        if (other.hasPredictionConfidence()) {\n          setPredictionConfidence(other.getPredictionConfidence());\n        }\n        if (other.hasPredictionReasoning()) {\n          predictionReasoning_ = other.predictionReasoning_;\n          bitField0_ |= 0x00000400;\n          onChanged();\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 8: {\n                timestampMs_ = input.readInt64();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 8\n              case 18: {\n                symbol_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 18\n              case 25: {\n                price_ = input.readDouble();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 25\n              case 33: {\n                signalProbability_ = input.readDouble();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 33\n              case 42: {\n                input.readMessage(\n                    getIndicatorsFieldBuilder().getBuilder(),\n                    extensionRegistry);\n                bitField0_ |= 0x00000010;\n                break;\n              } // case 42\n              case 50: {\n                com.spiketrade.proto.SpikeSignalsProto.SpikeRecord m =\n                    input.readMessage(\n                        com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.parser(),\n                        extensionRegistry);\n                if (spikesBuilder_ == null) {\n                  ensureSpikesIsMutable();\n                  spikes_.add(m);\n                } else {\n                  spikesBuilder_.addMessage(m);\n                }\n                break;\n              } // case 50\n              case 58: {\n                reason_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000040;\n                break;\n              } // case 58\n              case 65: {\n                predictedGainTarget_ = input.readDouble();\n                bitField0_ |= 0x00000080;\n                break;\n              } // case 65\n              case 72: {\n                predictedTimeToTargetMinutes_ = input.readInt32();\n                bitField0_ |= 0x00000100;\n                break;\n              } // case 72\n              case 81: {\n                predictionConfidence_ = input.readDouble();\n                bitField0_ |= 0x00000200;\n                break;\n              } // case 81\n              case 90: {\n                predictionReasoning_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000400;\n                break;\n              } // case 90\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private long timestampMs_ ;\n      /**\n       * <code>int64 timestamp_ms = 1;</code>\n       * @return The timestampMs.\n       */\n      @java.lang.Override\n      public long getTimestampMs() {\n        return timestampMs_;\n      }\n      /**\n       * <code>int64 timestamp_ms = 1;</code>\n       * @param value The timestampMs to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTimestampMs(long value) {\n\n        timestampMs_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int64 timestamp_ms = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTimestampMs() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        timestampMs_ = 0L;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object symbol_ = \"\";\n      /**\n       * <code>string symbol = 2;</code>\n       * @return The symbol.\n       */\n      public java.lang.String getSymbol() {\n        java.lang.Object ref = symbol_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          symbol_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 2;</code>\n       * @return The bytes for symbol.\n       */\n      public com.google.protobuf.ByteString\n          getSymbolBytes() {\n        java.lang.Object ref = symbol_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          symbol_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 2;</code>\n       * @param value The symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbol(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        symbol_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSymbol() {\n        symbol_ = getDefaultInstance().getSymbol();\n        bitField0_ = (bitField0_ & ~0x00000002);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 2;</code>\n       * @param value The bytes for symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbolBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        symbol_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n\n      private double price_ ;\n      /**\n       * <code>double price = 3;</code>\n       * @return The price.\n       */\n      @java.lang.Override\n      public double getPrice() {\n        return price_;\n      }\n      /**\n       * <code>double price = 3;</code>\n       * @param value The price to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPrice(double value) {\n\n        price_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double price = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPrice() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        price_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double signalProbability_ ;\n      /**\n       * <code>double signal_probability = 4;</code>\n       * @return The signalProbability.\n       */\n      @java.lang.Override\n      public double getSignalProbability() {\n        return signalProbability_;\n      }\n      /**\n       * <code>double signal_probability = 4;</code>\n       * @param value The signalProbability to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSignalProbability(double value) {\n\n        signalProbability_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double signal_probability = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSignalProbability() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        signalProbability_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private com.spiketrade.proto.SpikeSignalsProto.Indicators indicators_;\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.SpikeSignalsProto.Indicators, com.spiketrade.proto.SpikeSignalsProto.Indicators.Builder, com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder> indicatorsBuilder_;\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n       * @return Whether the indicators field is set.\n       */\n      public boolean hasIndicators() {\n        return ((bitField0_ & 0x00000010) != 0);\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n       * @return The indicators.\n       */\n      public com.spiketrade.proto.SpikeSignalsProto.Indicators getIndicators() {\n        if (indicatorsBuilder_ == null) {\n          return indicators_ == null ? com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance() : indicators_;\n        } else {\n          return indicatorsBuilder_.getMessage();\n        }\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n       */\n      public Builder setIndicators(com.spiketrade.proto.SpikeSignalsProto.Indicators value) {\n        if (indicatorsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          indicators_ = value;\n        } else {\n          indicatorsBuilder_.setMessage(value);\n        }\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n       */\n      public Builder setIndicators(\n          com.spiketrade.proto.SpikeSignalsProto.Indicators.Builder builderForValue) {\n        if (indicatorsBuilder_ == null) {\n          indicators_ = builderForValue.build();\n        } else {\n          indicatorsBuilder_.setMessage(builderForValue.build());\n        }\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n       */\n      public Builder mergeIndicators(com.spiketrade.proto.SpikeSignalsProto.Indicators value) {\n        if (indicatorsBuilder_ == null) {\n          if (((bitField0_ & 0x00000010) != 0) &&\n            indicators_ != null &&\n            indicators_ != com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance()) {\n            getIndicatorsBuilder().mergeFrom(value);\n          } else {\n            indicators_ = value;\n          }\n        } else {\n          indicatorsBuilder_.mergeFrom(value);\n        }\n        if (indicators_ != null) {\n          bitField0_ |= 0x00000010;\n          onChanged();\n        }\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n       */\n      public Builder clearIndicators() {\n        bitField0_ = (bitField0_ & ~0x00000010);\n        indicators_ = null;\n        if (indicatorsBuilder_ != null) {\n          indicatorsBuilder_.dispose();\n          indicatorsBuilder_ = null;\n        }\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n       */\n      public com.spiketrade.proto.SpikeSignalsProto.Indicators.Builder getIndicatorsBuilder() {\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return getIndicatorsFieldBuilder().getBuilder();\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n       */\n      public com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder getIndicatorsOrBuilder() {\n        if (indicatorsBuilder_ != null) {\n          return indicatorsBuilder_.getMessageOrBuilder();\n        } else {\n          return indicators_ == null ?\n              com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance() : indicators_;\n        }\n      }\n      /**\n       * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n       */\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.SpikeSignalsProto.Indicators, com.spiketrade.proto.SpikeSignalsProto.Indicators.Builder, com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder> \n          getIndicatorsFieldBuilder() {\n        if (indicatorsBuilder_ == null) {\n          indicatorsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<\n              com.spiketrade.proto.SpikeSignalsProto.Indicators, com.spiketrade.proto.SpikeSignalsProto.Indicators.Builder, com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder>(\n                  getIndicators(),\n                  getParentForChildren(),\n                  isClean());\n          indicators_ = null;\n        }\n        return indicatorsBuilder_;\n      }\n\n      private java.util.List<com.spiketrade.proto.SpikeSignalsProto.SpikeRecord> spikes_ =\n        java.util.Collections.emptyList();\n      private void ensureSpikesIsMutable() {\n        if (!((bitField0_ & 0x00000020) != 0)) {\n          spikes_ = new java.util.ArrayList<com.spiketrade.proto.SpikeSignalsProto.SpikeRecord>(spikes_);\n          bitField0_ |= 0x00000020;\n         }\n      }\n\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          com.spiketrade.proto.SpikeSignalsProto.SpikeRecord, com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.Builder, com.spiketrade.proto.SpikeSignalsProto.SpikeRecordOrBuilder> spikesBuilder_;\n\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public java.util.List<com.spiketrade.proto.SpikeSignalsProto.SpikeRecord> getSpikesList() {\n        if (spikesBuilder_ == null) {\n          return java.util.Collections.unmodifiableList(spikes_);\n        } else {\n          return spikesBuilder_.getMessageList();\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public int getSpikesCount() {\n        if (spikesBuilder_ == null) {\n          return spikes_.size();\n        } else {\n          return spikesBuilder_.getCount();\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public com.spiketrade.proto.SpikeSignalsProto.SpikeRecord getSpikes(int index) {\n        if (spikesBuilder_ == null) {\n          return spikes_.get(index);\n        } else {\n          return spikesBuilder_.getMessage(index);\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public Builder setSpikes(\n          int index, com.spiketrade.proto.SpikeSignalsProto.SpikeRecord value) {\n        if (spikesBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureSpikesIsMutable();\n          spikes_.set(index, value);\n          onChanged();\n        } else {\n          spikesBuilder_.setMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public Builder setSpikes(\n          int index, com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.Builder builderForValue) {\n        if (spikesBuilder_ == null) {\n          ensureSpikesIsMutable();\n          spikes_.set(index, builderForValue.build());\n          onChanged();\n        } else {\n          spikesBuilder_.setMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public Builder addSpikes(com.spiketrade.proto.SpikeSignalsProto.SpikeRecord value) {\n        if (spikesBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureSpikesIsMutable();\n          spikes_.add(value);\n          onChanged();\n        } else {\n          spikesBuilder_.addMessage(value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public Builder addSpikes(\n          int index, com.spiketrade.proto.SpikeSignalsProto.SpikeRecord value) {\n        if (spikesBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureSpikesIsMutable();\n          spikes_.add(index, value);\n          onChanged();\n        } else {\n          spikesBuilder_.addMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public Builder addSpikes(\n          com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.Builder builderForValue) {\n        if (spikesBuilder_ == null) {\n          ensureSpikesIsMutable();\n          spikes_.add(builderForValue.build());\n          onChanged();\n        } else {\n          spikesBuilder_.addMessage(builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public Builder addSpikes(\n          int index, com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.Builder builderForValue) {\n        if (spikesBuilder_ == null) {\n          ensureSpikesIsMutable();\n          spikes_.add(index, builderForValue.build());\n          onChanged();\n        } else {\n          spikesBuilder_.addMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public Builder addAllSpikes(\n          java.lang.Iterable<? extends com.spiketrade.proto.SpikeSignalsProto.SpikeRecord> values) {\n        if (spikesBuilder_ == null) {\n          ensureSpikesIsMutable();\n          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n              values, spikes_);\n          onChanged();\n        } else {\n          spikesBuilder_.addAllMessages(values);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public Builder clearSpikes() {\n        if (spikesBuilder_ == null) {\n          spikes_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000020);\n          onChanged();\n        } else {\n          spikesBuilder_.clear();\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public Builder removeSpikes(int index) {\n        if (spikesBuilder_ == null) {\n          ensureSpikesIsMutable();\n          spikes_.remove(index);\n          onChanged();\n        } else {\n          spikesBuilder_.remove(index);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.Builder getSpikesBuilder(\n          int index) {\n        return getSpikesFieldBuilder().getBuilder(index);\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public com.spiketrade.proto.SpikeSignalsProto.SpikeRecordOrBuilder getSpikesOrBuilder(\n          int index) {\n        if (spikesBuilder_ == null) {\n          return spikes_.get(index);  } else {\n          return spikesBuilder_.getMessageOrBuilder(index);\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public java.util.List<? extends com.spiketrade.proto.SpikeSignalsProto.SpikeRecordOrBuilder> \n           getSpikesOrBuilderList() {\n        if (spikesBuilder_ != null) {\n          return spikesBuilder_.getMessageOrBuilderList();\n        } else {\n          return java.util.Collections.unmodifiableList(spikes_);\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.Builder addSpikesBuilder() {\n        return getSpikesFieldBuilder().addBuilder(\n            com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.Builder addSpikesBuilder(\n          int index) {\n        return getSpikesFieldBuilder().addBuilder(\n            index, com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .spiketrade.proto.SpikeRecord spikes = 6;</code>\n       */\n      public java.util.List<com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.Builder> \n           getSpikesBuilderList() {\n        return getSpikesFieldBuilder().getBuilderList();\n      }\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          com.spiketrade.proto.SpikeSignalsProto.SpikeRecord, com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.Builder, com.spiketrade.proto.SpikeSignalsProto.SpikeRecordOrBuilder> \n          getSpikesFieldBuilder() {\n        if (spikesBuilder_ == null) {\n          spikesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<\n              com.spiketrade.proto.SpikeSignalsProto.SpikeRecord, com.spiketrade.proto.SpikeSignalsProto.SpikeRecord.Builder, com.spiketrade.proto.SpikeSignalsProto.SpikeRecordOrBuilder>(\n                  spikes_,\n                  ((bitField0_ & 0x00000020) != 0),\n                  getParentForChildren(),\n                  isClean());\n          spikes_ = null;\n        }\n        return spikesBuilder_;\n      }\n\n      private java.lang.Object reason_ = \"\";\n      /**\n       * <code>string reason = 7;</code>\n       * @return The reason.\n       */\n      public java.lang.String getReason() {\n        java.lang.Object ref = reason_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          reason_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string reason = 7;</code>\n       * @return The bytes for reason.\n       */\n      public com.google.protobuf.ByteString\n          getReasonBytes() {\n        java.lang.Object ref = reason_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          reason_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string reason = 7;</code>\n       * @param value The reason to set.\n       * @return This builder for chaining.\n       */\n      public Builder setReason(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        reason_ = value;\n        bitField0_ |= 0x00000040;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string reason = 7;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearReason() {\n        reason_ = getDefaultInstance().getReason();\n        bitField0_ = (bitField0_ & ~0x00000040);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string reason = 7;</code>\n       * @param value The bytes for reason to set.\n       * @return This builder for chaining.\n       */\n      public Builder setReasonBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        reason_ = value;\n        bitField0_ |= 0x00000040;\n        onChanged();\n        return this;\n      }\n\n      private double predictedGainTarget_ ;\n      /**\n       * <code>optional double predicted_gain_target = 8;</code>\n       * @return Whether the predictedGainTarget field is set.\n       */\n      @java.lang.Override\n      public boolean hasPredictedGainTarget() {\n        return ((bitField0_ & 0x00000080) != 0);\n      }\n      /**\n       * <code>optional double predicted_gain_target = 8;</code>\n       * @return The predictedGainTarget.\n       */\n      @java.lang.Override\n      public double getPredictedGainTarget() {\n        return predictedGainTarget_;\n      }\n      /**\n       * <code>optional double predicted_gain_target = 8;</code>\n       * @param value The predictedGainTarget to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPredictedGainTarget(double value) {\n\n        predictedGainTarget_ = value;\n        bitField0_ |= 0x00000080;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>optional double predicted_gain_target = 8;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPredictedGainTarget() {\n        bitField0_ = (bitField0_ & ~0x00000080);\n        predictedGainTarget_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private int predictedTimeToTargetMinutes_ ;\n      /**\n       * <code>optional int32 predicted_time_to_target_minutes = 9;</code>\n       * @return Whether the predictedTimeToTargetMinutes field is set.\n       */\n      @java.lang.Override\n      public boolean hasPredictedTimeToTargetMinutes() {\n        return ((bitField0_ & 0x00000100) != 0);\n      }\n      /**\n       * <code>optional int32 predicted_time_to_target_minutes = 9;</code>\n       * @return The predictedTimeToTargetMinutes.\n       */\n      @java.lang.Override\n      public int getPredictedTimeToTargetMinutes() {\n        return predictedTimeToTargetMinutes_;\n      }\n      /**\n       * <code>optional int32 predicted_time_to_target_minutes = 9;</code>\n       * @param value The predictedTimeToTargetMinutes to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPredictedTimeToTargetMinutes(int value) {\n\n        predictedTimeToTargetMinutes_ = value;\n        bitField0_ |= 0x00000100;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>optional int32 predicted_time_to_target_minutes = 9;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPredictedTimeToTargetMinutes() {\n        bitField0_ = (bitField0_ & ~0x00000100);\n        predictedTimeToTargetMinutes_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private double predictionConfidence_ ;\n      /**\n       * <code>optional double prediction_confidence = 10;</code>\n       * @return Whether the predictionConfidence field is set.\n       */\n      @java.lang.Override\n      public boolean hasPredictionConfidence() {\n        return ((bitField0_ & 0x00000200) != 0);\n      }\n      /**\n       * <code>optional double prediction_confidence = 10;</code>\n       * @return The predictionConfidence.\n       */\n      @java.lang.Override\n      public double getPredictionConfidence() {\n        return predictionConfidence_;\n      }\n      /**\n       * <code>optional double prediction_confidence = 10;</code>\n       * @param value The predictionConfidence to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPredictionConfidence(double value) {\n\n        predictionConfidence_ = value;\n        bitField0_ |= 0x00000200;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>optional double prediction_confidence = 10;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPredictionConfidence() {\n        bitField0_ = (bitField0_ & ~0x00000200);\n        predictionConfidence_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object predictionReasoning_ = \"\";\n      /**\n       * <code>optional string prediction_reasoning = 11;</code>\n       * @return Whether the predictionReasoning field is set.\n       */\n      public boolean hasPredictionReasoning() {\n        return ((bitField0_ & 0x00000400) != 0);\n      }\n      /**\n       * <code>optional string prediction_reasoning = 11;</code>\n       * @return The predictionReasoning.\n       */\n      public java.lang.String getPredictionReasoning() {\n        java.lang.Object ref = predictionReasoning_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          predictionReasoning_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>optional string prediction_reasoning = 11;</code>\n       * @return The bytes for predictionReasoning.\n       */\n      public com.google.protobuf.ByteString\n          getPredictionReasoningBytes() {\n        java.lang.Object ref = predictionReasoning_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          predictionReasoning_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>optional string prediction_reasoning = 11;</code>\n       * @param value The predictionReasoning to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPredictionReasoning(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        predictionReasoning_ = value;\n        bitField0_ |= 0x00000400;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>optional string prediction_reasoning = 11;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPredictionReasoning() {\n        predictionReasoning_ = getDefaultInstance().getPredictionReasoning();\n        bitField0_ = (bitField0_ & ~0x00000400);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>optional string prediction_reasoning = 11;</code>\n       * @param value The bytes for predictionReasoning to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPredictionReasoningBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        predictionReasoning_ = value;\n        bitField0_ |= 0x00000400;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.BuySignal)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.BuySignal)\n    private static final com.spiketrade.proto.SpikeSignalsProto.BuySignal DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.SpikeSignalsProto.BuySignal();\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.BuySignal getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<BuySignal>\n        PARSER = new com.google.protobuf.AbstractParser<BuySignal>() {\n      @java.lang.Override\n      public BuySignal parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<BuySignal> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<BuySignal> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.BuySignal getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface SellSignalOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.SellSignal)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>int64 timestamp_ms = 1;</code>\n     * @return The timestampMs.\n     */\n    long getTimestampMs();\n\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The symbol.\n     */\n    java.lang.String getSymbol();\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The bytes for symbol.\n     */\n    com.google.protobuf.ByteString\n        getSymbolBytes();\n\n    /**\n     * <code>double price = 3;</code>\n     * @return The price.\n     */\n    double getPrice();\n\n    /**\n     * <code>string reason = 4;</code>\n     * @return The reason.\n     */\n    java.lang.String getReason();\n    /**\n     * <code>string reason = 4;</code>\n     * @return The bytes for reason.\n     */\n    com.google.protobuf.ByteString\n        getReasonBytes();\n\n    /**\n     * <code>double profit_loss = 5;</code>\n     * @return The profitLoss.\n     */\n    double getProfitLoss();\n\n    /**\n     * <code>double profit_loss_pct = 6;</code>\n     * @return The profitLossPct.\n     */\n    double getProfitLossPct();\n  }\n  /**\n   * <pre>\n   * Sell signal message\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.SellSignal}\n   */\n  public static final class SellSignal extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.SellSignal)\n      SellSignalOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use SellSignal.newBuilder() to construct.\n    private SellSignal(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private SellSignal() {\n      symbol_ = \"\";\n      reason_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new SellSignal();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SellSignal_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SellSignal_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.SpikeSignalsProto.SellSignal.class, com.spiketrade.proto.SpikeSignalsProto.SellSignal.Builder.class);\n    }\n\n    public static final int TIMESTAMP_MS_FIELD_NUMBER = 1;\n    private long timestampMs_ = 0L;\n    /**\n     * <code>int64 timestamp_ms = 1;</code>\n     * @return The timestampMs.\n     */\n    @java.lang.Override\n    public long getTimestampMs() {\n      return timestampMs_;\n    }\n\n    public static final int SYMBOL_FIELD_NUMBER = 2;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object symbol_ = \"\";\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The symbol.\n     */\n    @java.lang.Override\n    public java.lang.String getSymbol() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        symbol_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The bytes for symbol.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getSymbolBytes() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        symbol_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int PRICE_FIELD_NUMBER = 3;\n    private double price_ = 0D;\n    /**\n     * <code>double price = 3;</code>\n     * @return The price.\n     */\n    @java.lang.Override\n    public double getPrice() {\n      return price_;\n    }\n\n    public static final int REASON_FIELD_NUMBER = 4;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object reason_ = \"\";\n    /**\n     * <code>string reason = 4;</code>\n     * @return The reason.\n     */\n    @java.lang.Override\n    public java.lang.String getReason() {\n      java.lang.Object ref = reason_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        reason_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string reason = 4;</code>\n     * @return The bytes for reason.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getReasonBytes() {\n      java.lang.Object ref = reason_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        reason_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int PROFIT_LOSS_FIELD_NUMBER = 5;\n    private double profitLoss_ = 0D;\n    /**\n     * <code>double profit_loss = 5;</code>\n     * @return The profitLoss.\n     */\n    @java.lang.Override\n    public double getProfitLoss() {\n      return profitLoss_;\n    }\n\n    public static final int PROFIT_LOSS_PCT_FIELD_NUMBER = 6;\n    private double profitLossPct_ = 0D;\n    /**\n     * <code>double profit_loss_pct = 6;</code>\n     * @return The profitLossPct.\n     */\n    @java.lang.Override\n    public double getProfitLossPct() {\n      return profitLossPct_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (timestampMs_ != 0L) {\n        output.writeInt64(1, timestampMs_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, symbol_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(price_) != 0) {\n        output.writeDouble(3, price_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(reason_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, reason_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(profitLoss_) != 0) {\n        output.writeDouble(5, profitLoss_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(profitLossPct_) != 0) {\n        output.writeDouble(6, profitLossPct_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (timestampMs_ != 0L) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt64Size(1, timestampMs_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, symbol_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(price_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(3, price_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(reason_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, reason_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(profitLoss_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(5, profitLoss_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(profitLossPct_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(6, profitLossPct_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.SpikeSignalsProto.SellSignal)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.SpikeSignalsProto.SellSignal other = (com.spiketrade.proto.SpikeSignalsProto.SellSignal) obj;\n\n      if (getTimestampMs()\n          != other.getTimestampMs()) return false;\n      if (!getSymbol()\n          .equals(other.getSymbol())) return false;\n      if (java.lang.Double.doubleToLongBits(getPrice())\n          != java.lang.Double.doubleToLongBits(\n              other.getPrice())) return false;\n      if (!getReason()\n          .equals(other.getReason())) return false;\n      if (java.lang.Double.doubleToLongBits(getProfitLoss())\n          != java.lang.Double.doubleToLongBits(\n              other.getProfitLoss())) return false;\n      if (java.lang.Double.doubleToLongBits(getProfitLossPct())\n          != java.lang.Double.doubleToLongBits(\n              other.getProfitLossPct())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + TIMESTAMP_MS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          getTimestampMs());\n      hash = (37 * hash) + SYMBOL_FIELD_NUMBER;\n      hash = (53 * hash) + getSymbol().hashCode();\n      hash = (37 * hash) + PRICE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPrice()));\n      hash = (37 * hash) + REASON_FIELD_NUMBER;\n      hash = (53 * hash) + getReason().hashCode();\n      hash = (37 * hash) + PROFIT_LOSS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getProfitLoss()));\n      hash = (37 * hash) + PROFIT_LOSS_PCT_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getProfitLossPct()));\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.SellSignal parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellSignal parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellSignal parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellSignal parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellSignal parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellSignal parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellSignal parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellSignal parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.SellSignal parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.SellSignal parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellSignal parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellSignal parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.SpikeSignalsProto.SellSignal prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Sell signal message\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.SellSignal}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.SellSignal)\n        com.spiketrade.proto.SpikeSignalsProto.SellSignalOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SellSignal_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SellSignal_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.SpikeSignalsProto.SellSignal.class, com.spiketrade.proto.SpikeSignalsProto.SellSignal.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.SpikeSignalsProto.SellSignal.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        timestampMs_ = 0L;\n        symbol_ = \"\";\n        price_ = 0D;\n        reason_ = \"\";\n        profitLoss_ = 0D;\n        profitLossPct_ = 0D;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SellSignal_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.SellSignal getDefaultInstanceForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.SellSignal.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.SellSignal build() {\n        com.spiketrade.proto.SpikeSignalsProto.SellSignal result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.SellSignal buildPartial() {\n        com.spiketrade.proto.SpikeSignalsProto.SellSignal result = new com.spiketrade.proto.SpikeSignalsProto.SellSignal(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.SpikeSignalsProto.SellSignal result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.timestampMs_ = timestampMs_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.symbol_ = symbol_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.price_ = price_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.reason_ = reason_;\n        }\n        if (((from_bitField0_ & 0x00000010) != 0)) {\n          result.profitLoss_ = profitLoss_;\n        }\n        if (((from_bitField0_ & 0x00000020) != 0)) {\n          result.profitLossPct_ = profitLossPct_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.SpikeSignalsProto.SellSignal) {\n          return mergeFrom((com.spiketrade.proto.SpikeSignalsProto.SellSignal)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.SpikeSignalsProto.SellSignal other) {\n        if (other == com.spiketrade.proto.SpikeSignalsProto.SellSignal.getDefaultInstance()) return this;\n        if (other.getTimestampMs() != 0L) {\n          setTimestampMs(other.getTimestampMs());\n        }\n        if (!other.getSymbol().isEmpty()) {\n          symbol_ = other.symbol_;\n          bitField0_ |= 0x00000002;\n          onChanged();\n        }\n        if (other.getPrice() != 0D) {\n          setPrice(other.getPrice());\n        }\n        if (!other.getReason().isEmpty()) {\n          reason_ = other.reason_;\n          bitField0_ |= 0x00000008;\n          onChanged();\n        }\n        if (other.getProfitLoss() != 0D) {\n          setProfitLoss(other.getProfitLoss());\n        }\n        if (other.getProfitLossPct() != 0D) {\n          setProfitLossPct(other.getProfitLossPct());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 8: {\n                timestampMs_ = input.readInt64();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 8\n              case 18: {\n                symbol_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 18\n              case 25: {\n                price_ = input.readDouble();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 25\n              case 34: {\n                reason_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 34\n              case 41: {\n                profitLoss_ = input.readDouble();\n                bitField0_ |= 0x00000010;\n                break;\n              } // case 41\n              case 49: {\n                profitLossPct_ = input.readDouble();\n                bitField0_ |= 0x00000020;\n                break;\n              } // case 49\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private long timestampMs_ ;\n      /**\n       * <code>int64 timestamp_ms = 1;</code>\n       * @return The timestampMs.\n       */\n      @java.lang.Override\n      public long getTimestampMs() {\n        return timestampMs_;\n      }\n      /**\n       * <code>int64 timestamp_ms = 1;</code>\n       * @param value The timestampMs to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTimestampMs(long value) {\n\n        timestampMs_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int64 timestamp_ms = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTimestampMs() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        timestampMs_ = 0L;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object symbol_ = \"\";\n      /**\n       * <code>string symbol = 2;</code>\n       * @return The symbol.\n       */\n      public java.lang.String getSymbol() {\n        java.lang.Object ref = symbol_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          symbol_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 2;</code>\n       * @return The bytes for symbol.\n       */\n      public com.google.protobuf.ByteString\n          getSymbolBytes() {\n        java.lang.Object ref = symbol_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          symbol_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 2;</code>\n       * @param value The symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbol(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        symbol_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSymbol() {\n        symbol_ = getDefaultInstance().getSymbol();\n        bitField0_ = (bitField0_ & ~0x00000002);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 2;</code>\n       * @param value The bytes for symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbolBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        symbol_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n\n      private double price_ ;\n      /**\n       * <code>double price = 3;</code>\n       * @return The price.\n       */\n      @java.lang.Override\n      public double getPrice() {\n        return price_;\n      }\n      /**\n       * <code>double price = 3;</code>\n       * @param value The price to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPrice(double value) {\n\n        price_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double price = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPrice() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        price_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object reason_ = \"\";\n      /**\n       * <code>string reason = 4;</code>\n       * @return The reason.\n       */\n      public java.lang.String getReason() {\n        java.lang.Object ref = reason_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          reason_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string reason = 4;</code>\n       * @return The bytes for reason.\n       */\n      public com.google.protobuf.ByteString\n          getReasonBytes() {\n        java.lang.Object ref = reason_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          reason_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string reason = 4;</code>\n       * @param value The reason to set.\n       * @return This builder for chaining.\n       */\n      public Builder setReason(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        reason_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string reason = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearReason() {\n        reason_ = getDefaultInstance().getReason();\n        bitField0_ = (bitField0_ & ~0x00000008);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string reason = 4;</code>\n       * @param value The bytes for reason to set.\n       * @return This builder for chaining.\n       */\n      public Builder setReasonBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        reason_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n\n      private double profitLoss_ ;\n      /**\n       * <code>double profit_loss = 5;</code>\n       * @return The profitLoss.\n       */\n      @java.lang.Override\n      public double getProfitLoss() {\n        return profitLoss_;\n      }\n      /**\n       * <code>double profit_loss = 5;</code>\n       * @param value The profitLoss to set.\n       * @return This builder for chaining.\n       */\n      public Builder setProfitLoss(double value) {\n\n        profitLoss_ = value;\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double profit_loss = 5;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearProfitLoss() {\n        bitField0_ = (bitField0_ & ~0x00000010);\n        profitLoss_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double profitLossPct_ ;\n      /**\n       * <code>double profit_loss_pct = 6;</code>\n       * @return The profitLossPct.\n       */\n      @java.lang.Override\n      public double getProfitLossPct() {\n        return profitLossPct_;\n      }\n      /**\n       * <code>double profit_loss_pct = 6;</code>\n       * @param value The profitLossPct to set.\n       * @return This builder for chaining.\n       */\n      public Builder setProfitLossPct(double value) {\n\n        profitLossPct_ = value;\n        bitField0_ |= 0x00000020;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double profit_loss_pct = 6;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearProfitLossPct() {\n        bitField0_ = (bitField0_ & ~0x00000020);\n        profitLossPct_ = 0D;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.SellSignal)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.SellSignal)\n    private static final com.spiketrade.proto.SpikeSignalsProto.SellSignal DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.SpikeSignalsProto.SellSignal();\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.SellSignal getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<SellSignal>\n        PARSER = new com.google.protobuf.AbstractParser<SellSignal>() {\n      @java.lang.Override\n      public SellSignal parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<SellSignal> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<SellSignal> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.SellSignal getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface SellWarningOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.SellWarning)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>int64 timestamp_ms = 1;</code>\n     * @return The timestampMs.\n     */\n    long getTimestampMs();\n\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The symbol.\n     */\n    java.lang.String getSymbol();\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The bytes for symbol.\n     */\n    com.google.protobuf.ByteString\n        getSymbolBytes();\n\n    /**\n     * <code>double price = 3;</code>\n     * @return The price.\n     */\n    double getPrice();\n\n    /**\n     * <code>double warning_probability = 4;</code>\n     * @return The warningProbability.\n     */\n    double getWarningProbability();\n\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n     * @return Whether the indicators field is set.\n     */\n    boolean hasIndicators();\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n     * @return The indicators.\n     */\n    com.spiketrade.proto.SpikeSignalsProto.Indicators getIndicators();\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n     */\n    com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder getIndicatorsOrBuilder();\n\n    /**\n     * <code>string reason = 6;</code>\n     * @return The reason.\n     */\n    java.lang.String getReason();\n    /**\n     * <code>string reason = 6;</code>\n     * @return The bytes for reason.\n     */\n    com.google.protobuf.ByteString\n        getReasonBytes();\n  }\n  /**\n   * <pre>\n   * Sell warning message\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.SellWarning}\n   */\n  public static final class SellWarning extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.SellWarning)\n      SellWarningOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use SellWarning.newBuilder() to construct.\n    private SellWarning(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private SellWarning() {\n      symbol_ = \"\";\n      reason_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new SellWarning();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SellWarning_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SellWarning_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.SpikeSignalsProto.SellWarning.class, com.spiketrade.proto.SpikeSignalsProto.SellWarning.Builder.class);\n    }\n\n    private int bitField0_;\n    public static final int TIMESTAMP_MS_FIELD_NUMBER = 1;\n    private long timestampMs_ = 0L;\n    /**\n     * <code>int64 timestamp_ms = 1;</code>\n     * @return The timestampMs.\n     */\n    @java.lang.Override\n    public long getTimestampMs() {\n      return timestampMs_;\n    }\n\n    public static final int SYMBOL_FIELD_NUMBER = 2;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object symbol_ = \"\";\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The symbol.\n     */\n    @java.lang.Override\n    public java.lang.String getSymbol() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        symbol_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string symbol = 2;</code>\n     * @return The bytes for symbol.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getSymbolBytes() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        symbol_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int PRICE_FIELD_NUMBER = 3;\n    private double price_ = 0D;\n    /**\n     * <code>double price = 3;</code>\n     * @return The price.\n     */\n    @java.lang.Override\n    public double getPrice() {\n      return price_;\n    }\n\n    public static final int WARNING_PROBABILITY_FIELD_NUMBER = 4;\n    private double warningProbability_ = 0D;\n    /**\n     * <code>double warning_probability = 4;</code>\n     * @return The warningProbability.\n     */\n    @java.lang.Override\n    public double getWarningProbability() {\n      return warningProbability_;\n    }\n\n    public static final int INDICATORS_FIELD_NUMBER = 5;\n    private com.spiketrade.proto.SpikeSignalsProto.Indicators indicators_;\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n     * @return Whether the indicators field is set.\n     */\n    @java.lang.Override\n    public boolean hasIndicators() {\n      return ((bitField0_ & 0x00000001) != 0);\n    }\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n     * @return The indicators.\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.Indicators getIndicators() {\n      return indicators_ == null ? com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance() : indicators_;\n    }\n    /**\n     * <code>.spiketrade.proto.Indicators indicators = 5;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.SpikeSignalsProto.IndicatorsOrBuilder getIndicatorsOrBuilder() {\n      return indicators_ == null ? com.spiketrade.proto.SpikeSignalsProto.Indicators.getDefaultInstance() : indicators_;\n    }\n\n    public static final int REASON_FIELD_NUMBER = 6;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object reason_ = \"\";\n    /**\n     * <code>string reason = 6;</code>\n     * @return The reason.\n     */\n    @java.lang.Override\n    public java.lang.String getReason() {\n      java.lang.Object ref = reason_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        reason_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string reason = 6;</code>\n     * @return The bytes for reason.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getReasonBytes() {\n      java.lang.Object ref = reason_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        reason_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (timestampMs_ != 0L) {\n        output.writeInt64(1, timestampMs_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, symbol_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(price_) != 0) {\n        output.writeDouble(3, price_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(warningProbability_) != 0) {\n        output.writeDouble(4, warningProbability_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        output.writeMessage(5, getIndicators());\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(reason_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, reason_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (timestampMs_ != 0L) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt64Size(1, timestampMs_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, symbol_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(price_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(3, price_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(warningProbability_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(4, warningProbability_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(5, getIndicators());\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(reason_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, reason_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.SpikeSignalsProto.SellWarning)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.SpikeSignalsProto.SellWarning other = (com.spiketrade.proto.SpikeSignalsProto.SellWarning) obj;\n\n      if (getTimestampMs()\n          != other.getTimestampMs()) return false;\n      if (!getSymbol()\n          .equals(other.getSymbol())) return false;\n      if (java.lang.Double.doubleToLongBits(getPrice())\n          != java.lang.Double.doubleToLongBits(\n              other.getPrice())) return false;\n      if (java.lang.Double.doubleToLongBits(getWarningProbability())\n          != java.lang.Double.doubleToLongBits(\n              other.getWarningProbability())) return false;\n      if (hasIndicators() != other.hasIndicators()) return false;\n      if (hasIndicators()) {\n        if (!getIndicators()\n            .equals(other.getIndicators())) return false;\n      }\n      if (!getReason()\n          .equals(other.getReason())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + TIMESTAMP_MS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          getTimestampMs());\n      hash = (37 * hash) + SYMBOL_FIELD_NUMBER;\n      hash = (53 * hash) + getSymbol().hashCode();\n      hash = (37 * hash) + PRICE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPrice()));\n      hash = (37 * hash) + WARNING_PROBABILITY_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getWarningProbability()));\n      if (hasIndicators()) {\n        hash = (37 * hash) + INDICATORS_FIELD_NUMBER;\n        hash = (53 * hash) + getIndicators().hashCode();\n      }\n      hash = (37 * hash) + REASON_FIELD_NUMBER;\n      hash = (53 * hash) + getReason().hashCode();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.SellWarning parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellWarning parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellWarning parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellWarning parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellWarning parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellWarning parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellWarning parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellWarning parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.SellWarning parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.SpikeSignalsProto.SellWarning parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellWarning parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.SpikeSignalsProto.SellWarning parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.SpikeSignalsProto.SellWarning prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Sell warning message\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.SellWarning}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.SellWarning)\n        com.spiketrade.proto.SpikeSignalsProto.SellWarningOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SellWarning_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SellWarning_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.SpikeSignalsProto.SellWarning.class, com.spiketrade.proto.SpikeSignalsProto.SellWarning.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.SpikeSignalsProto.SellWarning.newBuilder()\n      private Builder() {\n        maybeForceBuilderInitialization();\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n        maybeForceBuilderInitialization();\n      }\n      private void maybeForceBuilderInitialization() {\n        if (com.google.protobuf.GeneratedMessageV3\n                .alwaysUseFieldBuilders) {\n          getIndicatorsFieldBuilder();\n        }\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        timestampMs_ = 0L;\n        symbol_ = \"\";\n        price_ = 0D;\n        warningProbability_ = 0D;\n        indicators_ = null;\n        if (indicatorsBuilder_ != null) {\n          indicatorsBuilder_.dispose();\n          indicatorsBuilder_ = null;\n        }\n        reason_ = \"\";\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.internal_static_spiketrade_proto_SellWarning_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.SellWarning getDefaultInstanceForType() {\n        return com.spiketrade.proto.SpikeSignalsProto.SellWarning.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.SellWarning build() {\n        com.spiketrade.proto.SpikeSignalsProto.SellWarning result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.SpikeSignalsProto.SellWarning buildPartial() {\n        com.spiketrade.proto.SpikeSignalsProto.SellWarning result = new com.spiketrade.proto.SpikeSignalsProto.SellWarning(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.SpikeSignalsProto.SellWarning result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0","size_bytes":360000},"build/extracted-include-protos/test/google/type/money.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/money;money\";\noption java_multiple_files = true;\noption java_outer_classname = \"MoneyProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents an amount of money with its currency type.\nmessage Money {\n  // The three-letter currency code defined in ISO 4217.\n  string currency_code = 1;\n\n  // The whole units of the amount.\n  // For example if `currencyCode` is `\"USD\"`, then 1 unit is one US dollar.\n  int64 units = 2;\n\n  // Number of nano (10^-9) units of the amount.\n  // The value must be between -999,999,999 and +999,999,999 inclusive.\n  // If `units` is positive, `nanos` must be positive or zero.\n  // If `units` is zero, `nanos` can be positive, zero, or negative.\n  // If `units` is negative, `nanos` must be negative or zero.\n  // For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.\n  int32 nanos = 3;\n}\n","size_bytes":1603},"src/main/java/com/spiketrade/backend/SpikeAnalysisConfig.java":{"content":"package com.spiketrade.backend;\n\npublic class SpikeAnalysisConfig {\n    // Legacy parameters\n    public int rollingWindowHours = 24;\n    public int minSpikeSamples = 10;\n    public int evaluationPeriodMinutes = 60;\n    public double statisticalThreshold = 2.0;\n    public double qualityScoreThreshold = 0.5;\n    public int retrainFrequency = 100;\n    public int maxSpikeHistory = 1000;\n    public double spikeCooldownStddevThreshold = 2.0;\n    \n    // Indicator calculation periods\n    public int rsiLengthMinutes = 14;\n    public int buyPeriodMinutes = 20;\n    public int mfiPeriodMinutes = 10;  // Reduced from 14 for better intraday responsiveness\n    public int bbLengthMinutes = 12;   // Reduced from 20 for intraday small-cap volatility\n    public int vwapPeriodMinutes = 20; // Note: Now using anchored VWAP from market open, period unused\n    \n    // Individual spike ROC Z-thresholds\n    public double spikePriceRocZThreshold = 1.5;\n    public double spikeRsiRocZThreshold = 1.5;\n    public double spikeObvRocZThreshold = 1.5;\n    public double spikeMfiRocZThreshold = 1.5;\n    public double spikePercentBRocZThreshold = 1.5;\n    public double spikeVwapRocZThreshold = 1.5;\n    public double spikeVolumeRocZThreshold = 1.5;\n    \n    // Regular ROC thresholds (absolute %)\n    public double regularPriceRocThreshold = 0.5;\n    public double regularRsiRocThreshold = 0.5;\n    public double regularObvRocThreshold = 0.3;\n    public double regularMfiRocThreshold = 0.3;\n    public double regularPercentBRocThreshold = 1.0;\n    public double regularVwapRocThreshold = 0.5;\n    public double regularVolumeRocThreshold = 10.0;\n    \n    // Regular ROC periods (minutes)\n    public int regularPriceRocPeriod = 20;\n    public int regularRsiRocPeriod = 14;\n    public int regularObvRocPeriod = 20;\n    public int regularMfiRocPeriod = 14;\n    public int regularPercentBRocPeriod = 20;\n    public int regularVwapRocPeriod = 20;\n    public int regularVolumeRocPeriod = 20;\n    \n    // Signal Rules (which indicators/conditions to include)\n    public boolean enablePriceRocSpike = true;\n    public boolean enableRsiRocSpike = true;\n    public boolean enableObvRocSpike = true;\n    public boolean enableMfiRocSpike = true;\n    public boolean enablePercentBRocSpike = true;\n    public boolean enableVwapRocSpike = true;\n    public boolean enableVolumeRocSpike = true;\n    public boolean enableAdxIndicator = false;\n    public boolean useMlSpikes = false;\n    \n    // ===== NEW PENNY STOCK INDICATORS =====\n    // Enable/disable flags for penny stock indicators\n    public boolean enableMacdHistogramRoc = true;  // Predictive MACD histogram rate-of-change\n    public boolean enableStochasticIndicator = true;\n    public boolean enableRvolIndicator = true;\n    public boolean enableEmaIndicator = true;\n    public boolean enableEmaTrendFilter = true;  // Filter out trades when price below all EMAs\n    \n    // MACD periods (optimized for volatile 1-minute candles)\n    public int macdFastPeriod = 8;\n    public int macdSlowPeriod = 17;\n    public int macdSignalPeriod = 9;\n    \n    // MACD Histogram ROC threshold (as % of price) - predictive convergence detection\n    public double macdHistogramRocThreshold = 0.5;  // 0.5% of price per bar = bullish acceleration\n    \n    // Stochastic periods and thresholds\n    public int stochasticPeriod = 14;\n    public int stochasticKSmooth = 3;\n    public int stochasticDSmooth = 3;\n    public double stochasticOversoldThreshold = 20.0;  // Below this = oversold (good for mean reversion)\n    public double stochasticOverboughtThreshold = 80.0;  // Above this = overbought\n    \n    // Relative Volume (RVOL) settings\n    public int rvolPeriod = 20;\n    public double rvolThreshold = 2.0;  // RVOL > 2.0 indicates unusual volume activity\n    \n    // EMA periods\n    public int ema9Period = 9;\n    public int ema20Period = 20;\n    public int ema50Period = 50;\n    \n    // Volume spike detection\n    public double volumeSpikeThreshold = 2.0;  // Current volume / avg volume > 2.0\n    \n    // Trading parameters\n    public double comboSignalThreshold = 0.7;\n    public double highProbThreshold = 0.8;\n    public double stopLossPct = 0.02;\n    public boolean enableCooldowns = true;\n    \n    // Warmup data points (number of candles needed before trading is ready)\n    public int warmupDataPoints = 100;  // Default, should be set from TradingConfig\n}\n","size_bytes":4382},"src/main/java/com/spiketrade/controller/DataStreamController.java":{"content":"package com.spiketrade.controller;\n\nimport com.spiketrade.TradingServiceClient;\nimport com.spiketrade.model.TickerData;\nimport com.spiketrade.service.NotificationService;\nimport com.spiketrade.util.ResilienceUtil;\nimport com.spiketrade.viewmodel.ApplicationState;\nimport javafx.application.Platform;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\npublic class DataStreamController {\n    private static final Logger logger = LoggerFactory.getLogger(DataStreamController.class);\n    \n    private final ApplicationState appState;\n    private final TradingServiceClient grpcClient;\n    private final NotificationService notificationService;\n    private final ResilienceUtil.RetryPolicy grpcRetryPolicy;\n    \n    public DataStreamController(ApplicationState appState, TradingServiceClient grpcClient, \n                                NotificationService notificationService) {\n        this.appState = appState;\n        this.grpcClient = grpcClient;\n        this.notificationService = notificationService;\n        this.grpcRetryPolicy = ResilienceUtil.defaultGrpcPolicy();\n    }\n    \n    public void startQuoteStreaming(List<String> symbols) {\n        if (symbols == null || symbols.isEmpty()) {\n            logger.warn(\"No symbols to stream quotes for\");\n            return;\n        }\n        \n        try {\n            ResilienceUtil.executeWithRetry(() -> {\n                grpcClient.streamQuotes(symbols, new TradingServiceClient.QuoteCallback() {\n                    @Override\n                    public void onQuote(com.spiketrade.proto.MarketDataProto.Quote quote) {\n                        Platform.runLater(() -> {\n                            updateTickerWithQuote(quote);\n                        });\n                    }\n                    \n                    @Override\n                    public void onError(String error) {\n                        logger.error(\"Quote stream error: {}\", error);\n                    }\n                    \n                    @Override\n                    public void onCompleted() {\n                        logger.info(\"Quote stream completed\");\n                    }\n                });\n                return null;\n            }, grpcRetryPolicy, \"Start Quote Streaming\");\n        } catch (Exception e) {\n            logger.error(\"Failed to start quote streaming after retries\", e);\n        }\n    }\n    \n    public void startSignalStreaming(List<String> symbols) {\n        if (symbols == null || symbols.isEmpty()) {\n            logger.warn(\"No symbols to stream signals for\");\n            return;\n        }\n        \n        try {\n            ResilienceUtil.executeWithRetry(() -> {\n                grpcClient.streamSignals(symbols, 0.0, new TradingServiceClient.SignalCallback() {\n                    @Override\n                    public void onSignal(com.spiketrade.proto.SpikeSignalsProto.BuySignal signal) {\n                        Platform.runLater(() -> {\n                            handleBuySignal(signal);\n                        });\n                    }\n                    \n                    @Override\n                    public void onError(String error) {\n                        logger.error(\"Signal stream error: {}\", error);\n                    }\n                    \n                    @Override\n                    public void onCompleted() {\n                        logger.info(\"Signal stream completed\");\n                    }\n                });\n                return null;\n            }, grpcRetryPolicy, \"Start Signal Streaming\");\n        } catch (Exception e) {\n            logger.error(\"Failed to start signal streaming after retries\", e);\n        }\n    }\n    \n    private void updateTickerWithQuote(com.spiketrade.proto.MarketDataProto.Quote quote) {\n        String symbol = quote.getSymbol();\n        \n        TickerData existingData = appState.getTickerDataMap().get(symbol);\n        if (existingData == null) {\n            existingData = new TickerData(symbol, quote.getPrice());\n            appState.getTickerDataMap().put(symbol, existingData);\n            appState.getTickerDataList().add(existingData);\n        } else {\n            existingData.setCurrentPrice(quote.getPrice());\n            \n            // Update all indicators from quote stream (now includes MACD, EMA, ATR, etc.)\n            if (quote.hasIndicators()) {\n                updateTickerIndicators(existingData, quote.getIndicators());\n            }\n            \n            // Update buy probability if available (continuous calculation)\n            if (quote.hasSignalProbability()) {\n                existingData.setSignalProbability(quote.getSignalProbability());\n            }\n            \n            // Update ATR if available at quote level\n            if (quote.hasAtr()) {\n                existingData.setAtr(quote.getAtr());\n            }\n        }\n    }\n    \n    private void updateTickerIndicators(TickerData tickerData, com.spiketrade.proto.MarketDataProto.IndicatorsData indicators) {\n        // Basic indicators\n        tickerData.setRsi(indicators.getRsi());\n        tickerData.setVolume(indicators.getVolume());\n        tickerData.setVolumeRoc(indicators.getVolumeRoc());\n        tickerData.setPriceRoc(indicators.getPriceRoc());\n        tickerData.setObvRoc(indicators.getObvRoc());\n        tickerData.setMfi(indicators.getMfi());\n        tickerData.setBollingerPosition(indicators.getBollingerPosition());\n        tickerData.setPercentB(indicators.getPercentB());\n        tickerData.setVwap(indicators.getVwap());\n        \n        // Extended indicators (now available in IndicatorsData)\n        tickerData.setMacdHistogram(indicators.getMacdHistogram());\n        tickerData.setEma9(indicators.getEma9());\n        tickerData.setEma20(indicators.getEma20());\n        tickerData.setEma50(indicators.getEma50());\n        tickerData.setStochK(indicators.getStochK());\n        tickerData.setStochD(indicators.getStochD());\n        tickerData.setRvol(indicators.getRvol());\n        tickerData.setVolumeSpike(indicators.getVolumeSpike());\n        tickerData.setAtr(indicators.getAtr());\n    }\n    \n    private void updateTickerIndicators(TickerData tickerData, com.spiketrade.proto.SpikeSignalsProto.Indicators indicators) {\n        tickerData.setRsi(indicators.getRsi());\n        tickerData.setVolumeRoc(indicators.getVolumeRoc());\n        tickerData.setPriceRoc(indicators.getPriceRoc());\n        tickerData.setObvRoc(indicators.getObvRoc());\n        tickerData.setMfi(indicators.getMfi());\n        tickerData.setBollingerPosition(indicators.getBollingerPosition());\n        tickerData.setPercentB(indicators.getPercentB());\n        tickerData.setVwap(indicators.getVwap());\n        tickerData.setMacdHistogram(indicators.getMacdHistogram());\n        tickerData.setEma9(indicators.getEma9());\n        tickerData.setEma20(indicators.getEma20());\n        tickerData.setEma50(indicators.getEma50());\n        tickerData.setStochK(indicators.getStochK());\n        tickerData.setStochD(indicators.getStochD());\n        tickerData.setRvol(indicators.getRvol());\n        tickerData.setVolumeSpike(indicators.getVolumeSpike());\n        tickerData.setAtr(indicators.getAtr());\n    }\n    \n    private void handleBuySignal(com.spiketrade.proto.SpikeSignalsProto.BuySignal signal) {\n        String symbol = signal.getSymbol();\n        double probability = signal.getSignalProbability();\n        \n        logger.info(\"BUY SIGNAL DETECTED: {} | Probability: {}%\", symbol, probability * 100);\n        \n        if (signal.hasIndicators()) {\n            TickerData tickerData = appState.getTickerDataMap().get(symbol);\n            if (tickerData != null) {\n                updateTickerIndicators(tickerData, signal.getIndicators());\n                tickerData.setSignalProbability(probability);\n            }\n        }\n        \n        notificationService.showBuySignal(symbol, signal.getPrice(), probability, \n                                         formatSignalDetails(signal));\n    }\n    \n    private String formatSignalDetails(com.spiketrade.proto.SpikeSignalsProto.BuySignal signal) {\n        StringBuilder details = new StringBuilder();\n        \n        if (signal.hasPredictedGainTarget()) {\n            int minutes = signal.getPredictedTimeToTargetMinutes();\n            String timeframe = formatTimeframe(minutes);\n            details.append(String.format(\"Target: %.1f%% in %s\\n\", signal.getPredictedGainTarget(), timeframe));\n        }\n        \n        if (signal.hasIndicators()) {\n            var ind = signal.getIndicators();\n            details.append(String.format(\"RSI: %.2f | Price ROC: %.2f%% | Vol ROC: %.2f%%\", \n                                        ind.getRsi(), ind.getPriceRoc(), ind.getVolumeRoc()));\n        }\n        \n        return details.toString();\n    }\n    \n    private String formatTimeframe(int minutes) {\n        if (minutes < 60) {\n            return minutes + \" min\";\n        } else if (minutes < 1440) {\n            return (minutes / 60) + \" hours\";\n        } else {\n            int days = minutes / 1440;\n            int hours = (minutes % 1440) / 60;\n            return days + \"d \" + hours + \"h\";\n        }\n    }\n}\n","size_bytes":9140},"src/main/java/com/spiketrade/model/TimeframeMode.java":{"content":"package com.spiketrade.model;\n\npublic enum TimeframeMode {\n    MIN_1(1, \"1 Minute\"),\n    MIN_10(10, \"10 Minutes\"),\n    MIN_30(30, \"30 Minutes\"),\n    HOUR_1(60, \"1 Hour\"),\n    HOUR_3(180, \"3 Hours\");\n    \n    private final int multiplier;\n    private final String displayName;\n    \n    TimeframeMode(int multiplier, String displayName) {\n        this.multiplier = multiplier;\n        this.displayName = displayName;\n    }\n    \n    public int getMultiplier() { return multiplier; }\n    public String getDisplayName() { return displayName; }\n}\n","size_bytes":541},"build/extracted-include-protos/test/google/api/usage.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"UsageProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Configuration controlling usage of a service.\nmessage Usage {\n  // Requirements that must be satisfied before a consumer project can use the\n  // service. Each requirement is of the form <service.name>/<requirement-id>;\n  // for example 'serviceusage.googleapis.com/billing-enabled'.\n  //\n  // For Google APIs, a Terms of Service requirement must be included here.\n  // Google Cloud APIs must include \"serviceusage.googleapis.com/tos/cloud\".\n  // Other Google APIs should include\n  // \"serviceusage.googleapis.com/tos/universal\". Additional ToS can be\n  // included based on the business needs.\n  repeated string requirements = 1;\n\n  // A list of usage rules that apply to individual API methods.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated UsageRule rules = 6;\n\n  // The full resource name of a channel used for sending notifications to the\n  // service producer.\n  //\n  // Google Service Management currently only supports\n  // [Google Cloud Pub/Sub](https://cloud.google.com/pubsub) as a notification\n  // channel. To use Google Cloud Pub/Sub as the channel, this must be the name\n  // of a Cloud Pub/Sub topic that uses the Cloud Pub/Sub topic name format\n  // documented in https://cloud.google.com/pubsub/docs/overview.\n  string producer_notification_channel = 7;\n}\n\n// Usage configuration rules for the service.\n//\n// NOTE: Under development.\n//\n//\n// Use this rule to configure unregistered calls for the service. Unregistered\n// calls are calls that do not contain consumer project identity.\n// (Example: calls that do not contain an API key).\n// By default, API methods do not allow unregistered calls, and each method call\n// must be identified by a consumer project identity. Use this rule to\n// allow/disallow unregistered calls.\n//\n// Example of an API that wants to allow unregistered calls for entire service.\n//\n//     usage:\n//       rules:\n//       - selector: \"*\"\n//         allow_unregistered_calls: true\n//\n// Example of a method that wants to allow unregistered calls.\n//\n//     usage:\n//       rules:\n//       - selector: \"google.example.library.v1.LibraryService.CreateBook\"\n//         allow_unregistered_calls: true\nmessage UsageRule {\n  // Selects the methods to which this rule applies. Use '*' to indicate all\n  // methods in all APIs.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // If true, the selected method allows unregistered calls, e.g. calls\n  // that don't identify any user or application.\n  bool allow_unregistered_calls = 2;\n\n  // If true, the selected method should skip service control and the control\n  // plane features, such as quota and billing, will not be available.\n  // This flag is used by Google Cloud Endpoints to bypass checks for internal\n  // methods, such as service health check methods.\n  bool skip_service_control = 3;\n}\n","size_bytes":3787},"src/main/java/com/spiketrade/backend/TradingConfig.java":{"content":"package com.spiketrade.backend;\n\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class TradingConfig {\n    // Window parameters\n    public int buyPeriodMinutes = 20;\n    public int bbLengthMinutes = 25;\n    public int rsiLengthMinutes = 36;\n    public int priceRocPeriodMinutes = 20;\n    public int obvRocPeriodMinutes = 20;\n    public int mfiPeriodMinutes = 14;\n    public int mfiRocPeriodMinutes = 14;\n    public int vwapPeriodMinutes = 10;\n    public int dataPoints = 200;\n    public int warmupDataPoints = 100;\n    \n    // Timeframe multiplier for candle aggregation\n    public int timeframeMultiplier = 1;  // 1=1min, 10=10min, 30=30min, 60=1hour, 180=3hours\n    \n    // Spike ROC Threshold parameters (Z-score based)\n    public double spikePriceRocZThreshold = 1.0;\n    public double spikeRsiRocZThreshold = 0.5;\n    public double spikeObvRocZThreshold = 0.5;\n    public double spikeMfiRocZThreshold = 0.6;\n    public double spikePercentBRocZThreshold = 0.5;\n    public double spikeVwapRocZThreshold = 0.5;\n    public double spikeVolumeRocZThreshold = 0.5;\n    \n    // Regular ROC Threshold parameters (absolute %)\n    public double regularPriceRocThreshold = 2.0;\n    public double regularRsiRocThreshold = 5.0;\n    public double regularObvRocThreshold = 10.0;\n    public double regularMfiRocThreshold = 5.0;\n    public double regularPercentBRocThreshold = 15.0;\n    public double regularVwapRocThreshold = 1.5;\n    public double regularVolumeRocThreshold = 20.0;\n    \n    // Regular ROC Period parameters (minutes)\n    public int regularPriceRocPeriod = 20;\n    public int regularRsiRocPeriod = 14;\n    public int regularObvRocPeriod = 20;\n    public int regularMfiRocPeriod = 14;\n    public int regularPercentBRocPeriod = 20;\n    public int regularVwapRocPeriod = 10;\n    public int regularVolumeRocPeriod = 20;\n    \n    public double comboSignalThreshold = 0.7;\n    public double highProbThreshold = 0.5;\n    public double stopLossPct = 0.02;\n    public double initialProfitFloorPct = 0.03;\n    public double subsequentProfitFloorPct = 0.02;\n    public double spikeCooldownStddevThreshold = 2.0;\n    \n    // Trading parameters\n    public double equityPerTrade = 1000.0;\n    public double maxOpenTrades = 5.0;\n    public double totalEquityAvailable = 10000.0;\n    \n    // Prediction parameters\n    public double targetGainPercent = 2.0;\n    \n    // Boolean flags\n    public boolean enablePriceRocSpike = true;\n    public boolean enableRsiRocSpike = true;\n    public boolean enableObvRocSpike = true;\n    public boolean enableMfiRocSpike = true;\n    public boolean enablePercentBRocSpike = true;\n    public boolean enableVwapRocSpike = true;\n    public boolean useMlSpikes = true;\n    public boolean enableCooldowns = true;\n    public boolean enableAdxIndicator = true;\n    public boolean enableVolumeRocSpike = true;\n}","size_bytes":2893},"build/extracted-include-protos/main/google/type/postal_address.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/postaladdress;postaladdress\";\noption java_multiple_files = true;\noption java_outer_classname = \"PostalAddressProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a postal address, e.g. for postal delivery or payments addresses.\n// Given a postal address, a postal service can deliver items to a premise, P.O.\n// Box or similar.\n// It is not intended to model geographical locations (roads, towns,\n// mountains).\n//\n// In typical usage an address would be created via user input or from importing\n// existing data, depending on the type of process.\n//\n// Advice on address input / editing:\n//  - Use an i18n-ready address widget such as\n//    https://github.com/google/libaddressinput)\n// - Users should not be presented with UI elements for input or editing of\n//   fields outside countries where that field is used.\n//\n// For more guidance on how to use this schema, please see:\n// https://support.google.com/business/answer/6397478\nmessage PostalAddress {\n  // The schema revision of the `PostalAddress`. This must be set to 0, which is\n  // the latest revision.\n  //\n  // All new revisions **must** be backward compatible with old revisions.\n  int32 revision = 1;\n\n  // Required. CLDR region code of the country/region of the address. This\n  // is never inferred and it is up to the user to ensure the value is\n  // correct. See http://cldr.unicode.org/ and\n  // http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html\n  // for details. Example: \"CH\" for Switzerland.\n  string region_code = 2;\n\n  // Optional. BCP-47 language code of the contents of this address (if\n  // known). This is often the UI language of the input form or is expected\n  // to match one of the languages used in the address' country/region, or their\n  // transliterated equivalents.\n  // This can affect formatting in certain countries, but is not critical\n  // to the correctness of the data and will never affect any validation or\n  // other non-formatting related operations.\n  //\n  // If this value is not known, it should be omitted (rather than specifying a\n  // possibly incorrect default).\n  //\n  // Examples: \"zh-Hant\", \"ja\", \"ja-Latn\", \"en\".\n  string language_code = 3;\n\n  // Optional. Postal code of the address. Not all countries use or require\n  // postal codes to be present, but where they are used, they may trigger\n  // additional validation with other parts of the address (e.g. state/zip\n  // validation in the U.S.A.).\n  string postal_code = 4;\n\n  // Optional. Additional, country-specific, sorting code. This is not used\n  // in most regions. Where it is used, the value is either a string like\n  // \"CEDEX\", optionally followed by a number (e.g. \"CEDEX 7\"), or just a number\n  // alone, representing the \"sector code\" (Jamaica), \"delivery area indicator\"\n  // (Malawi) or \"post office indicator\" (e.g. Cte d'Ivoire).\n  string sorting_code = 5;\n\n  // Optional. Highest administrative subdivision which is used for postal\n  // addresses of a country or region.\n  // For example, this can be a state, a province, an oblast, or a prefecture.\n  // Specifically, for Spain this is the province and not the autonomous\n  // community (e.g. \"Barcelona\" and not \"Catalonia\").\n  // Many countries don't use an administrative area in postal addresses. E.g.\n  // in Switzerland this should be left unpopulated.\n  string administrative_area = 6;\n\n  // Optional. Generally refers to the city/town portion of the address.\n  // Examples: US city, IT comune, UK post town.\n  // In regions of the world where localities are not well defined or do not fit\n  // into this structure well, leave locality empty and use address_lines.\n  string locality = 7;\n\n  // Optional. Sublocality of the address.\n  // For example, this can be neighborhoods, boroughs, districts.\n  string sublocality = 8;\n\n  // Unstructured address lines describing the lower levels of an address.\n  //\n  // Because values in address_lines do not have type information and may\n  // sometimes contain multiple values in a single field (e.g.\n  // \"Austin, TX\"), it is important that the line order is clear. The order of\n  // address lines should be \"envelope order\" for the country/region of the\n  // address. In places where this can vary (e.g. Japan), address_language is\n  // used to make it explicit (e.g. \"ja\" for large-to-small ordering and\n  // \"ja-Latn\" or \"en\" for small-to-large). This way, the most specific line of\n  // an address can be selected based on the language.\n  //\n  // The minimum permitted structural representation of an address consists\n  // of a region_code with all remaining information placed in the\n  // address_lines. It would be possible to format such an address very\n  // approximately without geocoding, but no semantic reasoning could be\n  // made about any of the address components until it was at least\n  // partially resolved.\n  //\n  // Creating an address only containing a region_code and address_lines, and\n  // then geocoding is the recommended way to handle completely unstructured\n  // addresses (as opposed to guessing which parts of the address should be\n  // localities or administrative areas).\n  repeated string address_lines = 9;\n\n  // Optional. The recipient at the address.\n  // This field may, under certain circumstances, contain multiline information.\n  // For example, it might contain \"care of\" information.\n  repeated string recipients = 10;\n\n  // Optional. The name of the organization at the address.\n  string organization = 11;\n}\n","size_bytes":6235},"src/main/java/com/spiketrade/backend/SpikeRecord.java":{"content":"package com.spiketrade.backend;\n\nimport java.time.Instant;\n\npublic class SpikeRecord {\n    public Instant timestamp;\n    public String symbol;\n    public String spikeType;\n    public double magnitude;\n    public int duration;\n    public double priceAtSpike;\n    public long volumeAtSpike;\n    public double rsiAtSpike;\n    public double bollingerPosition;\n    public double marketVolatility;\n    public int timeOfDay;\n    public int dayOfWeek;\n    \n    public IndicatorsData indicators;\n    \n    public Boolean outcomeProfitable;\n    public Double outcomeScore;\n    public Double statisticalZScore;\n    public String trendContext;\n    public Double spikeQualityScore;\n    \n    public boolean isRootSpike;\n    public double rootSpikeScore;\n    public boolean usedForSignal;\n    \n    public SpikeRecord() {\n        this.timestamp = Instant.now();\n        this.indicators = new IndicatorsData();\n        this.isRootSpike = false;\n        this.usedForSignal = false;\n        this.rootSpikeScore = 0.0;\n        this.duration = 0;\n    }\n}\n","size_bytes":1033},"build/extracted-include-protos/test/google/type/latlng.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/latlng;latlng\";\noption java_multiple_files = true;\noption java_outer_classname = \"LatLngProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// An object that represents a latitude/longitude pair. This is expressed as a\n// pair of doubles to represent degrees latitude and degrees longitude. Unless\n// specified otherwise, this must conform to the\n// <a href=\"http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf\">WGS84\n// standard</a>. Values must be within normalized ranges.\nmessage LatLng {\n  // The latitude in degrees. It must be in the range [-90.0, +90.0].\n  double latitude = 1;\n\n  // The longitude in degrees. It must be in the range [-180.0, +180.0].\n  double longitude = 2;\n}\n","size_bytes":1447},"build/extracted-include-protos/test/google/api/client.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/api/launch_stage.proto\";\nimport \"google/protobuf/descriptor.proto\";\nimport \"google/protobuf/duration.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/annotations;annotations\";\noption java_multiple_files = true;\noption java_outer_classname = \"ClientProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\nextend google.protobuf.MethodOptions {\n  // A definition of a client library method signature.\n  //\n  // In client libraries, each proto RPC corresponds to one or more methods\n  // which the end user is able to call, and calls the underlying RPC.\n  // Normally, this method receives a single argument (a struct or instance\n  // corresponding to the RPC request object). Defining this field will\n  // add one or more overloads providing flattened or simpler method signatures\n  // in some languages.\n  //\n  // The fields on the method signature are provided as a comma-separated\n  // string.\n  //\n  // For example, the proto RPC and annotation:\n  //\n  //   rpc CreateSubscription(CreateSubscriptionRequest)\n  //       returns (Subscription) {\n  //     option (google.api.method_signature) = \"name,topic\";\n  //   }\n  //\n  // Would add the following Java overload (in addition to the method accepting\n  // the request object):\n  //\n  //   public final Subscription createSubscription(String name, String topic)\n  //\n  // The following backwards-compatibility guidelines apply:\n  //\n  //   * Adding this annotation to an unannotated method is backwards\n  //     compatible.\n  //   * Adding this annotation to a method which already has existing\n  //     method signature annotations is backwards compatible if and only if\n  //     the new method signature annotation is last in the sequence.\n  //   * Modifying or removing an existing method signature annotation is\n  //     a breaking change.\n  //   * Re-ordering existing method signature annotations is a breaking\n  //     change.\n  repeated string method_signature = 1051;\n}\n\nextend google.protobuf.ServiceOptions {\n  // The hostname for this service.\n  // This should be specified with no prefix or protocol.\n  //\n  // Example:\n  //\n  //   service Foo {\n  //     option (google.api.default_host) = \"foo.googleapi.com\";\n  //     ...\n  //   }\n  string default_host = 1049;\n\n  // OAuth scopes needed for the client.\n  //\n  // Example:\n  //\n  //   service Foo {\n  //     option (google.api.oauth_scopes) = \\\n  //       \"https://www.googleapis.com/auth/cloud-platform\";\n  //     ...\n  //   }\n  //\n  // If there is more than one scope, use a comma-separated string:\n  //\n  // Example:\n  //\n  //   service Foo {\n  //     option (google.api.oauth_scopes) = \\\n  //       \"https://www.googleapis.com/auth/cloud-platform,\"\n  //       \"https://www.googleapis.com/auth/monitoring\";\n  //     ...\n  //   }\n  string oauth_scopes = 1050;\n}\n\n// Required information for every language.\nmessage CommonLanguageSettings {\n  // Link to automatically generated reference documentation.  Example:\n  // https://cloud.google.com/nodejs/docs/reference/asset/latest\n  string reference_docs_uri = 1 [deprecated = true];\n\n  // The destination where API teams want this client library to be published.\n  repeated ClientLibraryDestination destinations = 2;\n}\n\n// Details about how and where to publish client libraries.\nmessage ClientLibrarySettings {\n  // Version of the API to apply these settings to. This is the full protobuf\n  // package for the API, ending in the version element.\n  // Examples: \"google.cloud.speech.v1\" and \"google.spanner.admin.database.v1\".\n  string version = 1;\n\n  // Launch stage of this version of the API.\n  LaunchStage launch_stage = 2;\n\n  // When using transport=rest, the client request will encode enums as\n  // numbers rather than strings.\n  bool rest_numeric_enums = 3;\n\n  // Settings for legacy Java features, supported in the Service YAML.\n  JavaSettings java_settings = 21;\n\n  // Settings for C++ client libraries.\n  CppSettings cpp_settings = 22;\n\n  // Settings for PHP client libraries.\n  PhpSettings php_settings = 23;\n\n  // Settings for Python client libraries.\n  PythonSettings python_settings = 24;\n\n  // Settings for Node client libraries.\n  NodeSettings node_settings = 25;\n\n  // Settings for .NET client libraries.\n  DotnetSettings dotnet_settings = 26;\n\n  // Settings for Ruby client libraries.\n  RubySettings ruby_settings = 27;\n\n  // Settings for Go client libraries.\n  GoSettings go_settings = 28;\n}\n\n// This message configures the settings for publishing [Google Cloud Client\n// libraries](https://cloud.google.com/apis/docs/cloud-client-libraries)\n// generated from the service config.\nmessage Publishing {\n  // A list of API method settings, e.g. the behavior for methods that use the\n  // long-running operation pattern.\n  repeated MethodSettings method_settings = 2;\n\n  // Link to a *public* URI where users can report issues.  Example:\n  // https://issuetracker.google.com/issues/new?component=190865&template=1161103\n  string new_issue_uri = 101;\n\n  // Link to product home page.  Example:\n  // https://cloud.google.com/asset-inventory/docs/overview\n  string documentation_uri = 102;\n\n  // Used as a tracking tag when collecting data about the APIs developer\n  // relations artifacts like docs, packages delivered to package managers,\n  // etc.  Example: \"speech\".\n  string api_short_name = 103;\n\n  // GitHub label to apply to issues and pull requests opened for this API.\n  string github_label = 104;\n\n  // GitHub teams to be added to CODEOWNERS in the directory in GitHub\n  // containing source code for the client libraries for this API.\n  repeated string codeowner_github_teams = 105;\n\n  // A prefix used in sample code when demarking regions to be included in\n  // documentation.\n  string doc_tag_prefix = 106;\n\n  // For whom the client library is being published.\n  ClientLibraryOrganization organization = 107;\n\n  // Client library settings.  If the same version string appears multiple\n  // times in this list, then the last one wins.  Settings from earlier\n  // settings with the same version string are discarded.\n  repeated ClientLibrarySettings library_settings = 109;\n\n  // Optional link to proto reference documentation.  Example:\n  // https://cloud.google.com/pubsub/lite/docs/reference/rpc\n  string proto_reference_documentation_uri = 110;\n}\n\n// Settings for Java client libraries.\nmessage JavaSettings {\n  // The package name to use in Java. Clobbers the java_package option\n  // set in the protobuf. This should be used **only** by APIs\n  // who have already set the language_settings.java.package_name\" field\n  // in gapic.yaml. API teams should use the protobuf java_package option\n  // where possible.\n  //\n  // Example of a YAML configuration::\n  //\n  //  publishing:\n  //    java_settings:\n  //      library_package: com.google.cloud.pubsub.v1\n  string library_package = 1;\n\n  // Configure the Java class name to use instead of the service's for its\n  // corresponding generated GAPIC client. Keys are fully-qualified\n  // service names as they appear in the protobuf (including the full\n  // the language_settings.java.interface_names\" field in gapic.yaml. API\n  // teams should otherwise use the service name as it appears in the\n  // protobuf.\n  //\n  // Example of a YAML configuration::\n  //\n  //  publishing:\n  //    java_settings:\n  //      service_class_names:\n  //        - google.pubsub.v1.Publisher: TopicAdmin\n  //        - google.pubsub.v1.Subscriber: SubscriptionAdmin\n  map<string, string> service_class_names = 2;\n\n  // Some settings.\n  CommonLanguageSettings common = 3;\n}\n\n// Settings for C++ client libraries.\nmessage CppSettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n}\n\n// Settings for Php client libraries.\nmessage PhpSettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n}\n\n// Settings for Python client libraries.\nmessage PythonSettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n}\n\n// Settings for Node client libraries.\nmessage NodeSettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n}\n\n// Settings for Dotnet client libraries.\nmessage DotnetSettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n\n  // Map from original service names to renamed versions.\n  // This is used when the default generated types\n  // would cause a naming conflict. (Neither name is\n  // fully-qualified.)\n  // Example: Subscriber to SubscriberServiceApi.\n  map<string, string> renamed_services = 2;\n\n  // Map from full resource types to the effective short name\n  // for the resource. This is used when otherwise resource\n  // named from different services would cause naming collisions.\n  // Example entry:\n  // \"datalabeling.googleapis.com/Dataset\": \"DataLabelingDataset\"\n  map<string, string> renamed_resources = 3;\n\n  // List of full resource types to ignore during generation.\n  // This is typically used for API-specific Location resources,\n  // which should be handled by the generator as if they were actually\n  // the common Location resources.\n  // Example entry: \"documentai.googleapis.com/Location\"\n  repeated string ignored_resources = 4;\n\n  // Namespaces which must be aliased in snippets due to\n  // a known (but non-generator-predictable) naming collision\n  repeated string forced_namespace_aliases = 5;\n\n  // Method signatures (in the form \"service.method(signature)\")\n  // which are provided separately, so shouldn't be generated.\n  // Snippets *calling* these methods are still generated, however.\n  repeated string handwritten_signatures = 6;\n}\n\n// Settings for Ruby client libraries.\nmessage RubySettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n}\n\n// Settings for Go client libraries.\nmessage GoSettings {\n  // Some settings.\n  CommonLanguageSettings common = 1;\n}\n\n// Describes the generator configuration for a method.\nmessage MethodSettings {\n  // Describes settings to use when generating API methods that use the\n  // long-running operation pattern.\n  // All default values below are from those used in the client library\n  // generators (e.g.\n  // [Java](https://github.com/googleapis/gapic-generator-java/blob/04c2faa191a9b5a10b92392fe8482279c4404803/src/main/java/com/google/api/generator/gapic/composer/common/RetrySettingsComposer.java)).\n  message LongRunning {\n    // Initial delay after which the first poll request will be made.\n    // Default value: 5 seconds.\n    google.protobuf.Duration initial_poll_delay = 1;\n\n    // Multiplier to gradually increase delay between subsequent polls until it\n    // reaches max_poll_delay.\n    // Default value: 1.5.\n    float poll_delay_multiplier = 2;\n\n    // Maximum time between two subsequent poll requests.\n    // Default value: 45 seconds.\n    google.protobuf.Duration max_poll_delay = 3;\n\n    // Total polling timeout.\n    // Default value: 5 minutes.\n    google.protobuf.Duration total_poll_timeout = 4;\n  }\n\n  // The fully qualified name of the method, for which the options below apply.\n  // This is used to find the method to apply the options.\n  string selector = 1;\n\n  // Describes settings to use for long-running operations when generating\n  // API methods for RPCs. Complements RPCs that use the annotations in\n  // google/longrunning/operations.proto.\n  //\n  // Example of a YAML configuration::\n  //\n  //  publishing:\n  //    method_settings:\n  //      - selector: google.cloud.speech.v2.Speech.BatchRecognize\n  //        long_running:\n  //          initial_poll_delay:\n  //            seconds: 60 # 1 minute\n  //          poll_delay_multiplier: 1.5\n  //          max_poll_delay:\n  //            seconds: 360 # 6 minutes\n  //          total_poll_timeout:\n  //             seconds: 54000 # 90 minutes\n  LongRunning long_running = 2;\n}\n\n// The organization for which the client libraries are being published.\n// Affects the url where generated docs are published, etc.\nenum ClientLibraryOrganization {\n  // Not useful.\n  CLIENT_LIBRARY_ORGANIZATION_UNSPECIFIED = 0;\n\n  // Google Cloud Platform Org.\n  CLOUD = 1;\n\n  // Ads (Advertising) Org.\n  ADS = 2;\n\n  // Photos Org.\n  PHOTOS = 3;\n\n  // Street View Org.\n  STREET_VIEW = 4;\n\n  // Shopping Org.\n  SHOPPING = 5;\n\n  // Geo Org.\n  GEO = 6;\n\n  // Generative AI - https://developers.generativeai.google\n  GENERATIVE_AI = 7;\n}\n\n// To where should client libraries be published?\nenum ClientLibraryDestination {\n  // Client libraries will neither be generated nor published to package\n  // managers.\n  CLIENT_LIBRARY_DESTINATION_UNSPECIFIED = 0;\n\n  // Generate the client library in a repo under github.com/googleapis,\n  // but don't publish it to package managers.\n  GITHUB = 10;\n\n  // Publish the library to package managers like nuget.org and npmjs.com.\n  PACKAGE_MANAGER = 20;\n}\n","size_bytes":13316},"build/extracted-include-protos/main/google/type/expr.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption go_package = \"google.golang.org/genproto/googleapis/type/expr;expr\";\noption java_multiple_files = true;\noption java_outer_classname = \"ExprProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a textual expression in the Common Expression Language (CEL)\n// syntax. CEL is a C-like expression language. The syntax and semantics of CEL\n// are documented at https://github.com/google/cel-spec.\n//\n// Example (Comparison):\n//\n//     title: \"Summary size limit\"\n//     description: \"Determines if a summary is less than 100 chars\"\n//     expression: \"document.summary.size() < 100\"\n//\n// Example (Equality):\n//\n//     title: \"Requestor is owner\"\n//     description: \"Determines if requestor is the document owner\"\n//     expression: \"document.owner == request.auth.claims.email\"\n//\n// Example (Logic):\n//\n//     title: \"Public documents\"\n//     description: \"Determine whether the document should be publicly visible\"\n//     expression: \"document.type != 'private' && document.type != 'internal'\"\n//\n// Example (Data Manipulation):\n//\n//     title: \"Notification string\"\n//     description: \"Create a notification string with a timestamp.\"\n//     expression: \"'New message received at ' + string(document.create_time)\"\n//\n// The exact variables and functions that may be referenced within an expression\n// are determined by the service that evaluates it. See the service\n// documentation for additional information.\nmessage Expr {\n  // Textual representation of an expression in Common Expression Language\n  // syntax.\n  string expression = 1;\n\n  // Optional. Title for the expression, i.e. a short string describing\n  // its purpose. This can be used e.g. in UIs which allow to enter the\n  // expression.\n  string title = 2;\n\n  // Optional. Description of the expression. This is a longer text which\n  // describes the expression, e.g. when hovered over it in a UI.\n  string description = 3;\n\n  // Optional. String indicating the location of the expression for error\n  // reporting, e.g. a file name and a position in the file.\n  string location = 4;\n}\n","size_bytes":2730},"build/extracted-include-protos/main/google/api/http.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/api/annotations;annotations\";\noption java_multiple_files = true;\noption java_outer_classname = \"HttpProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Defines the HTTP configuration for an API service. It contains a list of\n// [HttpRule][google.api.HttpRule], each specifying the mapping of an RPC method\n// to one or more HTTP REST API methods.\nmessage Http {\n  // A list of HTTP configuration rules that apply to individual API methods.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated HttpRule rules = 1;\n\n  // When set to true, URL path parameters will be fully URI-decoded except in\n  // cases of single segment matches in reserved expansion, where \"%2F\" will be\n  // left encoded.\n  //\n  // The default behavior is to not decode RFC 6570 reserved characters in multi\n  // segment matches.\n  bool fully_decode_reserved_expansion = 2;\n}\n\n// # gRPC Transcoding\n//\n// gRPC Transcoding is a feature for mapping between a gRPC method and one or\n// more HTTP REST endpoints. It allows developers to build a single API service\n// that supports both gRPC APIs and REST APIs. Many systems, including [Google\n// APIs](https://github.com/googleapis/googleapis),\n// [Cloud Endpoints](https://cloud.google.com/endpoints), [gRPC\n// Gateway](https://github.com/grpc-ecosystem/grpc-gateway),\n// and [Envoy](https://github.com/envoyproxy/envoy) proxy support this feature\n// and use it for large scale production services.\n//\n// `HttpRule` defines the schema of the gRPC/REST mapping. The mapping specifies\n// how different portions of the gRPC request message are mapped to the URL\n// path, URL query parameters, and HTTP request body. It also controls how the\n// gRPC response message is mapped to the HTTP response body. `HttpRule` is\n// typically specified as an `google.api.http` annotation on the gRPC method.\n//\n// Each mapping specifies a URL path template and an HTTP method. The path\n// template may refer to one or more fields in the gRPC request message, as long\n// as each field is a non-repeated field with a primitive (non-message) type.\n// The path template controls how fields of the request message are mapped to\n// the URL path.\n//\n// Example:\n//\n//     service Messaging {\n//       rpc GetMessage(GetMessageRequest) returns (Message) {\n//         option (google.api.http) = {\n//             get: \"/v1/{name=messages/*}\"\n//         };\n//       }\n//     }\n//     message GetMessageRequest {\n//       string name = 1; // Mapped to URL path.\n//     }\n//     message Message {\n//       string text = 1; // The resource content.\n//     }\n//\n// This enables an HTTP REST to gRPC mapping as below:\n//\n// HTTP | gRPC\n// -----|-----\n// `GET /v1/messages/123456`  | `GetMessage(name: \"messages/123456\")`\n//\n// Any fields in the request message which are not bound by the path template\n// automatically become HTTP query parameters if there is no HTTP request body.\n// For example:\n//\n//     service Messaging {\n//       rpc GetMessage(GetMessageRequest) returns (Message) {\n//         option (google.api.http) = {\n//             get:\"/v1/messages/{message_id}\"\n//         };\n//       }\n//     }\n//     message GetMessageRequest {\n//       message SubMessage {\n//         string subfield = 1;\n//       }\n//       string message_id = 1; // Mapped to URL path.\n//       int64 revision = 2;    // Mapped to URL query parameter `revision`.\n//       SubMessage sub = 3;    // Mapped to URL query parameter `sub.subfield`.\n//     }\n//\n// This enables a HTTP JSON to RPC mapping as below:\n//\n// HTTP | gRPC\n// -----|-----\n// `GET /v1/messages/123456?revision=2&sub.subfield=foo` |\n// `GetMessage(message_id: \"123456\" revision: 2 sub: SubMessage(subfield:\n// \"foo\"))`\n//\n// Note that fields which are mapped to URL query parameters must have a\n// primitive type or a repeated primitive type or a non-repeated message type.\n// In the case of a repeated type, the parameter can be repeated in the URL\n// as `...?param=A&param=B`. In the case of a message type, each field of the\n// message is mapped to a separate parameter, such as\n// `...?foo.a=A&foo.b=B&foo.c=C`.\n//\n// For HTTP methods that allow a request body, the `body` field\n// specifies the mapping. Consider a REST update method on the\n// message resource collection:\n//\n//     service Messaging {\n//       rpc UpdateMessage(UpdateMessageRequest) returns (Message) {\n//         option (google.api.http) = {\n//           patch: \"/v1/messages/{message_id}\"\n//           body: \"message\"\n//         };\n//       }\n//     }\n//     message UpdateMessageRequest {\n//       string message_id = 1; // mapped to the URL\n//       Message message = 2;   // mapped to the body\n//     }\n//\n// The following HTTP JSON to RPC mapping is enabled, where the\n// representation of the JSON in the request body is determined by\n// protos JSON encoding:\n//\n// HTTP | gRPC\n// -----|-----\n// `PATCH /v1/messages/123456 { \"text\": \"Hi!\" }` | `UpdateMessage(message_id:\n// \"123456\" message { text: \"Hi!\" })`\n//\n// The special name `*` can be used in the body mapping to define that\n// every field not bound by the path template should be mapped to the\n// request body.  This enables the following alternative definition of\n// the update method:\n//\n//     service Messaging {\n//       rpc UpdateMessage(Message) returns (Message) {\n//         option (google.api.http) = {\n//           patch: \"/v1/messages/{message_id}\"\n//           body: \"*\"\n//         };\n//       }\n//     }\n//     message Message {\n//       string message_id = 1;\n//       string text = 2;\n//     }\n//\n//\n// The following HTTP JSON to RPC mapping is enabled:\n//\n// HTTP | gRPC\n// -----|-----\n// `PATCH /v1/messages/123456 { \"text\": \"Hi!\" }` | `UpdateMessage(message_id:\n// \"123456\" text: \"Hi!\")`\n//\n// Note that when using `*` in the body mapping, it is not possible to\n// have HTTP parameters, as all fields not bound by the path end in\n// the body. This makes this option more rarely used in practice when\n// defining REST APIs. The common usage of `*` is in custom methods\n// which don't use the URL at all for transferring data.\n//\n// It is possible to define multiple HTTP methods for one RPC by using\n// the `additional_bindings` option. Example:\n//\n//     service Messaging {\n//       rpc GetMessage(GetMessageRequest) returns (Message) {\n//         option (google.api.http) = {\n//           get: \"/v1/messages/{message_id}\"\n//           additional_bindings {\n//             get: \"/v1/users/{user_id}/messages/{message_id}\"\n//           }\n//         };\n//       }\n//     }\n//     message GetMessageRequest {\n//       string message_id = 1;\n//       string user_id = 2;\n//     }\n//\n// This enables the following two alternative HTTP JSON to RPC mappings:\n//\n// HTTP | gRPC\n// -----|-----\n// `GET /v1/messages/123456` | `GetMessage(message_id: \"123456\")`\n// `GET /v1/users/me/messages/123456` | `GetMessage(user_id: \"me\" message_id:\n// \"123456\")`\n//\n// ## Rules for HTTP mapping\n//\n// 1. Leaf request fields (recursive expansion nested messages in the request\n//    message) are classified into three categories:\n//    - Fields referred by the path template. They are passed via the URL path.\n//    - Fields referred by the [HttpRule.body][google.api.HttpRule.body]. They\n//    are passed via the HTTP\n//      request body.\n//    - All other fields are passed via the URL query parameters, and the\n//      parameter name is the field path in the request message. A repeated\n//      field can be represented as multiple query parameters under the same\n//      name.\n//  2. If [HttpRule.body][google.api.HttpRule.body] is \"*\", there is no URL\n//  query parameter, all fields\n//     are passed via URL path and HTTP request body.\n//  3. If [HttpRule.body][google.api.HttpRule.body] is omitted, there is no HTTP\n//  request body, all\n//     fields are passed via URL path and URL query parameters.\n//\n// ### Path template syntax\n//\n//     Template = \"/\" Segments [ Verb ] ;\n//     Segments = Segment { \"/\" Segment } ;\n//     Segment  = \"*\" | \"**\" | LITERAL | Variable ;\n//     Variable = \"{\" FieldPath [ \"=\" Segments ] \"}\" ;\n//     FieldPath = IDENT { \".\" IDENT } ;\n//     Verb     = \":\" LITERAL ;\n//\n// The syntax `*` matches a single URL path segment. The syntax `**` matches\n// zero or more URL path segments, which must be the last part of the URL path\n// except the `Verb`.\n//\n// The syntax `Variable` matches part of the URL path as specified by its\n// template. A variable template must not contain other variables. If a variable\n// matches a single path segment, its template may be omitted, e.g. `{var}`\n// is equivalent to `{var=*}`.\n//\n// The syntax `LITERAL` matches literal text in the URL path. If the `LITERAL`\n// contains any reserved character, such characters should be percent-encoded\n// before the matching.\n//\n// If a variable contains exactly one path segment, such as `\"{var}\"` or\n// `\"{var=*}\"`, when such a variable is expanded into a URL path on the client\n// side, all characters except `[-_.~0-9a-zA-Z]` are percent-encoded. The\n// server side does the reverse decoding. Such variables show up in the\n// [Discovery\n// Document](https://developers.google.com/discovery/v1/reference/apis) as\n// `{var}`.\n//\n// If a variable contains multiple path segments, such as `\"{var=foo/*}\"`\n// or `\"{var=**}\"`, when such a variable is expanded into a URL path on the\n// client side, all characters except `[-_.~/0-9a-zA-Z]` are percent-encoded.\n// The server side does the reverse decoding, except \"%2F\" and \"%2f\" are left\n// unchanged. Such variables show up in the\n// [Discovery\n// Document](https://developers.google.com/discovery/v1/reference/apis) as\n// `{+var}`.\n//\n// ## Using gRPC API Service Configuration\n//\n// gRPC API Service Configuration (service config) is a configuration language\n// for configuring a gRPC service to become a user-facing product. The\n// service config is simply the YAML representation of the `google.api.Service`\n// proto message.\n//\n// As an alternative to annotating your proto file, you can configure gRPC\n// transcoding in your service config YAML files. You do this by specifying a\n// `HttpRule` that maps the gRPC method to a REST endpoint, achieving the same\n// effect as the proto annotation. This can be particularly useful if you\n// have a proto that is reused in multiple services. Note that any transcoding\n// specified in the service config will override any matching transcoding\n// configuration in the proto.\n//\n// Example:\n//\n//     http:\n//       rules:\n//         # Selects a gRPC method and applies HttpRule to it.\n//         - selector: example.v1.Messaging.GetMessage\n//           get: /v1/messages/{message_id}/{sub.subfield}\n//\n// ## Special notes\n//\n// When gRPC Transcoding is used to map a gRPC to JSON REST endpoints, the\n// proto to JSON conversion must follow the [proto3\n// specification](https://developers.google.com/protocol-buffers/docs/proto3#json).\n//\n// While the single segment variable follows the semantics of\n// [RFC 6570](https://tools.ietf.org/html/rfc6570) Section 3.2.2 Simple String\n// Expansion, the multi segment variable **does not** follow RFC 6570 Section\n// 3.2.3 Reserved Expansion. The reason is that the Reserved Expansion\n// does not expand special characters like `?` and `#`, which would lead\n// to invalid URLs. As the result, gRPC Transcoding uses a custom encoding\n// for multi segment variables.\n//\n// The path variables **must not** refer to any repeated or mapped field,\n// because client libraries are not capable of handling such variable expansion.\n//\n// The path variables **must not** capture the leading \"/\" character. The reason\n// is that the most common use case \"{var}\" does not capture the leading \"/\"\n// character. For consistency, all path variables must share the same behavior.\n//\n// Repeated message fields must not be mapped to URL query parameters, because\n// no client library can support such complicated mapping.\n//\n// If an API needs to use a JSON array for request or response body, it can map\n// the request or response body to a repeated field. However, some gRPC\n// Transcoding implementations may not support this feature.\nmessage HttpRule {\n  // Selects a method to which this rule applies.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // Determines the URL pattern is matched by this rules. This pattern can be\n  // used with any of the {get|put|post|delete|patch} methods. A custom method\n  // can be defined using the 'custom' field.\n  oneof pattern {\n    // Maps to HTTP GET. Used for listing and getting information about\n    // resources.\n    string get = 2;\n\n    // Maps to HTTP PUT. Used for replacing a resource.\n    string put = 3;\n\n    // Maps to HTTP POST. Used for creating a resource or performing an action.\n    string post = 4;\n\n    // Maps to HTTP DELETE. Used for deleting a resource.\n    string delete = 5;\n\n    // Maps to HTTP PATCH. Used for updating a resource.\n    string patch = 6;\n\n    // The custom pattern is used for specifying an HTTP method that is not\n    // included in the `pattern` field, such as HEAD, or \"*\" to leave the\n    // HTTP method unspecified for this rule. The wild-card rule is useful\n    // for services that provide content to Web (HTML) clients.\n    CustomHttpPattern custom = 8;\n  }\n\n  // The name of the request field whose value is mapped to the HTTP request\n  // body, or `*` for mapping all request fields not captured by the path\n  // pattern to the HTTP body, or omitted for not having any HTTP request body.\n  //\n  // NOTE: the referred field must be present at the top-level of the request\n  // message type.\n  string body = 7;\n\n  // Optional. The name of the response field whose value is mapped to the HTTP\n  // response body. When omitted, the entire response message will be used\n  // as the HTTP response body.\n  //\n  // NOTE: The referred field must be present at the top-level of the response\n  // message type.\n  string response_body = 12;\n\n  // Additional HTTP bindings for the selector. Nested bindings must\n  // not contain an `additional_bindings` field themselves (that is,\n  // the nesting may only be one level deep).\n  repeated HttpRule additional_bindings = 11;\n}\n\n// A custom pattern is used for defining custom HTTP verb.\nmessage CustomHttpPattern {\n  // The name of this custom HTTP verb.\n  string kind = 1;\n\n  // The path matched by this custom verb.\n  string path = 2;\n}\n","size_bytes":15159},"src/main/java/com/spiketrade/model/BacktestParameters.java":{"content":"package com.spiketrade.model;\n\npublic class BacktestParameters {\n    public final int rsiPeriod;\n    public final int rocPeriod;\n    public final double comboThreshold;\n    public final double stopLossPct;\n    public final double initialProfitFloorPct;\n    public final double subsequentProfitFloorPct;\n    public final int minDataPoints;\n    \n    public final int rsiRocPeriod;\n    public final int mfiRocPeriod;\n    public final int obvRocPeriod;\n    public final int vwapRocPeriod;\n    public final int percentBRocPeriod;\n    public final int priceRocPeriod;\n    public final int volumeRocPeriod;\n    \n    public final int mfiPeriod;\n    public final int bbLength;\n    public final double bbStdDevMultiplier;\n    \n    public final int macdFastPeriod;\n    public final int macdSlowPeriod;\n    public final int macdSignalPeriod;\n    public final double macdHistogramRocThreshold;\n    public final int stochPeriod;\n    public final int stochKSmooth;\n    public final int stochDSmooth;\n    public final double stochOversoldThresh;\n    public final int rvolPeriod;\n    public final double rvolThreshold;\n    public final int ema9Period;\n    public final int ema20Period;\n    public final int ema50Period;\n    public final double volSpikeThreshold;\n    \n    public final double priceSpikeZThreshold;\n    public final double volumeSpikeZThreshold;\n    public final double rsiSpikeZThreshold;\n    public final double obvSpikeZThreshold;\n    public final double mfiSpikeZThreshold;\n    public final double percentBSpikeZThreshold;\n    public final double vwapSpikeZThreshold;\n    \n    public final double priceRocThreshold;\n    public final double rsiRocThreshold;\n    public final double obvRocThreshold;\n    public final double mfiRocThreshold;\n    public final double percentBRocThreshold;\n    public final double vwapRocThreshold;\n    public final double volumeRocThreshold;\n    \n    public final boolean requireSpikeQuality;\n    public final boolean requirePriceCondition;\n    public final boolean requireRsiCondition;\n    public final boolean requireObvCondition;\n    public final boolean requireMfiCondition;\n    public final boolean requireBollingerCondition;\n    public final boolean enableVwapIndicator;\n    public final boolean enableAdxIndicator;\n    public final boolean requireVolumeSpike;\n    public final boolean enableMacdHistogramRoc;\n    public final boolean enableStochasticIndicator;\n    public final boolean enableRvolIndicator;\n    public final boolean enableEmaIndicator;\n    \n    public final double targetGainPct;\n    public final double equityPerTradePct;\n    public final double totalCapital;\n    \n    public BacktestParameters(\n        int rsiPeriod, int rocPeriod, double comboThreshold, double stopLossPct,\n        double initialProfitFloorPct, double subsequentProfitFloorPct, int minDataPoints,\n        int rsiRocPeriod, int mfiRocPeriod, int obvRocPeriod, int vwapRocPeriod,\n        int percentBRocPeriod, int priceRocPeriod, int volumeRocPeriod,\n        int mfiPeriod, int bbLength, double bbStdDevMultiplier,\n        int macdFastPeriod, int macdSlowPeriod, int macdSignalPeriod, double macdHistogramRocThreshold,\n        int stochPeriod, int stochKSmooth, int stochDSmooth, double stochOversoldThresh,\n        int rvolPeriod, double rvolThreshold,\n        int ema9Period, int ema20Period, int ema50Period, double volSpikeThreshold,\n        double priceSpikeZThreshold, double volumeSpikeZThreshold, double rsiSpikeZThreshold,\n        double obvSpikeZThreshold, double mfiSpikeZThreshold, double percentBSpikeZThreshold,\n        double vwapSpikeZThreshold,\n        double priceRocThreshold, double rsiRocThreshold, double obvRocThreshold,\n        double mfiRocThreshold, double percentBRocThreshold, double vwapRocThreshold,\n        double volumeRocThreshold,\n        boolean requireSpikeQuality, boolean requirePriceCondition, boolean requireRsiCondition,\n        boolean requireObvCondition, boolean requireMfiCondition, boolean requireBollingerCondition,\n        boolean enableVwapIndicator, boolean enableAdxIndicator, boolean requireVolumeSpike,\n        boolean enableMacdHistogramRoc, boolean enableStochasticIndicator, boolean enableRvolIndicator,\n        boolean enableEmaIndicator,\n        double targetGainPct, double equityPerTradePct, double totalCapital\n    ) {\n        this.rsiPeriod = rsiPeriod;\n        this.rocPeriod = rocPeriod;\n        this.comboThreshold = comboThreshold;\n        this.stopLossPct = stopLossPct;\n        this.initialProfitFloorPct = initialProfitFloorPct;\n        this.subsequentProfitFloorPct = subsequentProfitFloorPct;\n        this.minDataPoints = minDataPoints;\n        this.rsiRocPeriod = rsiRocPeriod;\n        this.mfiRocPeriod = mfiRocPeriod;\n        this.obvRocPeriod = obvRocPeriod;\n        this.vwapRocPeriod = vwapRocPeriod;\n        this.percentBRocPeriod = percentBRocPeriod;\n        this.priceRocPeriod = priceRocPeriod;\n        this.volumeRocPeriod = volumeRocPeriod;\n        this.mfiPeriod = mfiPeriod;\n        this.bbLength = bbLength;\n        this.bbStdDevMultiplier = bbStdDevMultiplier;\n        this.macdFastPeriod = macdFastPeriod;\n        this.macdSlowPeriod = macdSlowPeriod;\n        this.macdSignalPeriod = macdSignalPeriod;\n        this.macdHistogramRocThreshold = macdHistogramRocThreshold;\n        this.stochPeriod = stochPeriod;\n        this.stochKSmooth = stochKSmooth;\n        this.stochDSmooth = stochDSmooth;\n        this.stochOversoldThresh = stochOversoldThresh;\n        this.rvolPeriod = rvolPeriod;\n        this.rvolThreshold = rvolThreshold;\n        this.ema9Period = ema9Period;\n        this.ema20Period = ema20Period;\n        this.ema50Period = ema50Period;\n        this.volSpikeThreshold = volSpikeThreshold;\n        this.priceSpikeZThreshold = priceSpikeZThreshold;\n        this.volumeSpikeZThreshold = volumeSpikeZThreshold;\n        this.rsiSpikeZThreshold = rsiSpikeZThreshold;\n        this.obvSpikeZThreshold = obvSpikeZThreshold;\n        this.mfiSpikeZThreshold = mfiSpikeZThreshold;\n        this.percentBSpikeZThreshold = percentBSpikeZThreshold;\n        this.vwapSpikeZThreshold = vwapSpikeZThreshold;\n        this.priceRocThreshold = priceRocThreshold;\n        this.rsiRocThreshold = rsiRocThreshold;\n        this.obvRocThreshold = obvRocThreshold;\n        this.mfiRocThreshold = mfiRocThreshold;\n        this.percentBRocThreshold = percentBRocThreshold;\n        this.vwapRocThreshold = vwapRocThreshold;\n        this.volumeRocThreshold = volumeRocThreshold;\n        this.requireSpikeQuality = requireSpikeQuality;\n        this.requirePriceCondition = requirePriceCondition;\n        this.requireRsiCondition = requireRsiCondition;\n        this.requireObvCondition = requireObvCondition;\n        this.requireMfiCondition = requireMfiCondition;\n        this.requireBollingerCondition = requireBollingerCondition;\n        this.enableVwapIndicator = enableVwapIndicator;\n        this.enableAdxIndicator = enableAdxIndicator;\n        this.requireVolumeSpike = requireVolumeSpike;\n        this.enableMacdHistogramRoc = enableMacdHistogramRoc;\n        this.enableStochasticIndicator = enableStochasticIndicator;\n        this.enableRvolIndicator = enableRvolIndicator;\n        this.enableEmaIndicator = enableEmaIndicator;\n        this.targetGainPct = targetGainPct;\n        this.equityPerTradePct = equityPerTradePct;\n        this.totalCapital = totalCapital;\n    }\n}\n","size_bytes":7374},"build/extracted-include-protos/test/google/api/launch_stage.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api;api\";\noption java_multiple_files = true;\noption java_outer_classname = \"LaunchStageProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// The launch stage as defined by [Google Cloud Platform\n// Launch Stages](https://cloud.google.com/terms/launch-stages).\nenum LaunchStage {\n  // Do not use this default value.\n  LAUNCH_STAGE_UNSPECIFIED = 0;\n\n  // The feature is not yet implemented. Users can not use it.\n  UNIMPLEMENTED = 6;\n\n  // Prelaunch features are hidden from users and are only visible internally.\n  PRELAUNCH = 7;\n\n  // Early Access features are limited to a closed group of testers. To use\n  // these features, you must sign up in advance and sign a Trusted Tester\n  // agreement (which includes confidentiality provisions). These features may\n  // be unstable, changed in backward-incompatible ways, and are not\n  // guaranteed to be released.\n  EARLY_ACCESS = 1;\n\n  // Alpha is a limited availability test for releases before they are cleared\n  // for widespread use. By Alpha, all significant design issues are resolved\n  // and we are in the process of verifying functionality. Alpha customers\n  // need to apply for access, agree to applicable terms, and have their\n  // projects allowlisted. Alpha releases don't have to be feature complete,\n  // no SLAs are provided, and there are no technical support obligations, but\n  // they will be far enough along that customers can actually use them in\n  // test environments or for limited-use tests -- just like they would in\n  // normal production cases.\n  ALPHA = 2;\n\n  // Beta is the point at which we are ready to open a release for any\n  // customer to use. There are no SLA or technical support obligations in a\n  // Beta release. Products will be complete from a feature perspective, but\n  // may have some open outstanding issues. Beta releases are suitable for\n  // limited production use cases.\n  BETA = 3;\n\n  // GA features are open to all developers and are considered stable and\n  // fully qualified for production use.\n  GA = 4;\n\n  // Deprecated features are scheduled to be shut down and removed. For more\n  // information, see the \"Deprecation Policy\" section of our [Terms of\n  // Service](https://cloud.google.com/terms/)\n  // and the [Google Cloud Platform Subject to the Deprecation\n  // Policy](https://cloud.google.com/terms/deprecation) documentation.\n  DEPRECATED = 5;\n}\n","size_bytes":3083},"src/main/java/com/spiketrade/viewmodel/ApplicationState.java":{"content":"package com.spiketrade.viewmodel;\n\nimport javafx.beans.property.*;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\nimport com.spiketrade.model.*;\nimport com.spiketrade.proto.ConfigProto;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class ApplicationState {\n    private static ApplicationState instance;\n    \n    private final BooleanProperty tradingEnabled = new SimpleBooleanProperty(false);\n    private final BooleanProperty connected = new SimpleBooleanProperty(false);\n    private final StringProperty connectionStatus = new SimpleStringProperty(\"Disconnected\");\n    private final StringProperty warmupStatus = new SimpleStringProperty(\"Not Started\");\n    private final StringProperty quoteSource = new SimpleStringProperty(\"Yahoo Finance\");\n    private final ObjectProperty<TimeframeMode> timeframeMode = new SimpleObjectProperty<>(TimeframeMode.MIN_1);\n    \n    private final ObservableList<String> activeTickers = FXCollections.observableArrayList();\n    private final ObservableList<TradeRecord> tradeRecords = FXCollections.observableArrayList();\n    private final ObservableList<TickerData> tickerDataList = FXCollections.observableArrayList();\n    \n    private final Map<String, TickerData> tickerDataMap = new ConcurrentHashMap<>();\n    \n    private ConfigProto.TradingConfig currentConfig;\n    \n    private ApplicationState() {\n        currentConfig = createDefaultConfig();\n    }\n    \n    public static synchronized ApplicationState getInstance() {\n        if (instance == null) {\n            instance = new ApplicationState();\n        }\n        return instance;\n    }\n    \n    public BooleanProperty tradingEnabledProperty() {\n        return tradingEnabled;\n    }\n    \n    public boolean isTradingEnabled() {\n        return tradingEnabled.get();\n    }\n    \n    public void setTradingEnabled(boolean enabled) {\n        tradingEnabled.set(enabled);\n    }\n    \n    public BooleanProperty connectedProperty() {\n        return connected;\n    }\n    \n    public boolean isConnected() {\n        return connected.get();\n    }\n    \n    public void setConnected(boolean connected) {\n        this.connected.set(connected);\n    }\n    \n    public StringProperty connectionStatusProperty() {\n        return connectionStatus;\n    }\n    \n    public String getConnectionStatus() {\n        return connectionStatus.get();\n    }\n    \n    public void setConnectionStatus(String status) {\n        connectionStatus.set(status);\n    }\n    \n    public StringProperty warmupStatusProperty() {\n        return warmupStatus;\n    }\n    \n    public String getWarmupStatus() {\n        return warmupStatus.get();\n    }\n    \n    public void setWarmupStatus(String status) {\n        warmupStatus.set(status);\n    }\n    \n    public StringProperty quoteSourceProperty() {\n        return quoteSource;\n    }\n    \n    public String getQuoteSource() {\n        return quoteSource.get();\n    }\n    \n    public void setQuoteSource(String source) {\n        quoteSource.set(source);\n    }\n    \n    public ObjectProperty<TimeframeMode> timeframeModeProperty() {\n        return timeframeMode;\n    }\n    \n    public TimeframeMode getTimeframeMode() {\n        return timeframeMode.get();\n    }\n    \n    public void setTimeframeMode(TimeframeMode mode) {\n        timeframeMode.set(mode);\n    }\n    \n    public ObservableList<String> getActiveTickers() {\n        return activeTickers;\n    }\n    \n    public ObservableList<TradeRecord> getTradeRecords() {\n        return tradeRecords;\n    }\n    \n    public ObservableList<TickerData> getTickerDataList() {\n        return tickerDataList;\n    }\n    \n    public Map<String, TickerData> getTickerDataMap() {\n        return tickerDataMap;\n    }\n    \n    public ConfigProto.TradingConfig getCurrentConfig() {\n        return currentConfig;\n    }\n    \n    public void setCurrentConfig(ConfigProto.TradingConfig config) {\n        this.currentConfig = config;\n    }\n    \n    private ConfigProto.TradingConfig createDefaultConfig() {\n        return ConfigProto.TradingConfig.newBuilder()\n            .setDataPoints(200)\n            .setWarmupDataPoints(100)\n            .setBuyPeriodMinutes(20)\n            .setBbLengthMinutes(12)\n            .setRsiLengthMinutes(36)\n            .setComboSignalThreshold(0.7)\n            .setSpikeCooldownStddevThreshold(2.0)\n            .setEnableCooldowns(true)\n            .build();\n    }\n}\n","size_bytes":4396},"build/extracted-include-protos/main/google/api/usage.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"UsageProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Configuration controlling usage of a service.\nmessage Usage {\n  // Requirements that must be satisfied before a consumer project can use the\n  // service. Each requirement is of the form <service.name>/<requirement-id>;\n  // for example 'serviceusage.googleapis.com/billing-enabled'.\n  //\n  // For Google APIs, a Terms of Service requirement must be included here.\n  // Google Cloud APIs must include \"serviceusage.googleapis.com/tos/cloud\".\n  // Other Google APIs should include\n  // \"serviceusage.googleapis.com/tos/universal\". Additional ToS can be\n  // included based on the business needs.\n  repeated string requirements = 1;\n\n  // A list of usage rules that apply to individual API methods.\n  //\n  // **NOTE:** All service configuration rules follow \"last one wins\" order.\n  repeated UsageRule rules = 6;\n\n  // The full resource name of a channel used for sending notifications to the\n  // service producer.\n  //\n  // Google Service Management currently only supports\n  // [Google Cloud Pub/Sub](https://cloud.google.com/pubsub) as a notification\n  // channel. To use Google Cloud Pub/Sub as the channel, this must be the name\n  // of a Cloud Pub/Sub topic that uses the Cloud Pub/Sub topic name format\n  // documented in https://cloud.google.com/pubsub/docs/overview.\n  string producer_notification_channel = 7;\n}\n\n// Usage configuration rules for the service.\n//\n// NOTE: Under development.\n//\n//\n// Use this rule to configure unregistered calls for the service. Unregistered\n// calls are calls that do not contain consumer project identity.\n// (Example: calls that do not contain an API key).\n// By default, API methods do not allow unregistered calls, and each method call\n// must be identified by a consumer project identity. Use this rule to\n// allow/disallow unregistered calls.\n//\n// Example of an API that wants to allow unregistered calls for entire service.\n//\n//     usage:\n//       rules:\n//       - selector: \"*\"\n//         allow_unregistered_calls: true\n//\n// Example of a method that wants to allow unregistered calls.\n//\n//     usage:\n//       rules:\n//       - selector: \"google.example.library.v1.LibraryService.CreateBook\"\n//         allow_unregistered_calls: true\nmessage UsageRule {\n  // Selects the methods to which this rule applies. Use '*' to indicate all\n  // methods in all APIs.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax\n  // details.\n  string selector = 1;\n\n  // If true, the selected method allows unregistered calls, e.g. calls\n  // that don't identify any user or application.\n  bool allow_unregistered_calls = 2;\n\n  // If true, the selected method should skip service control and the control\n  // plane features, such as quota and billing, will not be available.\n  // This flag is used by Google Cloud Endpoints to bypass checks for internal\n  // methods, such as service health check methods.\n  bool skip_service_control = 3;\n}\n","size_bytes":3787},"build/extracted-include-protos/test/google/api/monitoring.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"MonitoringProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Monitoring configuration of the service.\n//\n// The example below shows how to configure monitored resources and metrics\n// for monitoring. In the example, a monitored resource and two metrics are\n// defined. The `library.googleapis.com/book/returned_count` metric is sent\n// to both producer and consumer projects, whereas the\n// `library.googleapis.com/book/num_overdue` metric is only sent to the\n// consumer project.\n//\n//     monitored_resources:\n//     - type: library.googleapis.com/Branch\n//       display_name: \"Library Branch\"\n//       description: \"A branch of a library.\"\n//       launch_stage: GA\n//       labels:\n//       - key: resource_container\n//         description: \"The Cloud container (ie. project id) for the Branch.\"\n//       - key: location\n//         description: \"The location of the library branch.\"\n//       - key: branch_id\n//         description: \"The id of the branch.\"\n//     metrics:\n//     - name: library.googleapis.com/book/returned_count\n//       display_name: \"Books Returned\"\n//       description: \"The count of books that have been returned.\"\n//       launch_stage: GA\n//       metric_kind: DELTA\n//       value_type: INT64\n//       unit: \"1\"\n//       labels:\n//       - key: customer_id\n//         description: \"The id of the customer.\"\n//     - name: library.googleapis.com/book/num_overdue\n//       display_name: \"Books Overdue\"\n//       description: \"The current number of overdue books.\"\n//       launch_stage: GA\n//       metric_kind: GAUGE\n//       value_type: INT64\n//       unit: \"1\"\n//       labels:\n//       - key: customer_id\n//         description: \"The id of the customer.\"\n//     monitoring:\n//       producer_destinations:\n//       - monitored_resource: library.googleapis.com/Branch\n//         metrics:\n//         - library.googleapis.com/book/returned_count\n//       consumer_destinations:\n//       - monitored_resource: library.googleapis.com/Branch\n//         metrics:\n//         - library.googleapis.com/book/returned_count\n//         - library.googleapis.com/book/num_overdue\nmessage Monitoring {\n  // Configuration of a specific monitoring destination (the producer project\n  // or the consumer project).\n  message MonitoringDestination {\n    // The monitored resource type. The type must be defined in\n    // [Service.monitored_resources][google.api.Service.monitored_resources]\n    // section.\n    string monitored_resource = 1;\n\n    // Types of the metrics to report to this monitoring destination.\n    // Each type must be defined in\n    // [Service.metrics][google.api.Service.metrics] section.\n    repeated string metrics = 2;\n  }\n\n  // Monitoring configurations for sending metrics to the producer project.\n  // There can be multiple producer destinations. A monitored resource type may\n  // appear in multiple monitoring destinations if different aggregations are\n  // needed for different sets of metrics associated with that monitored\n  // resource type. A monitored resource and metric pair may only be used once\n  // in the Monitoring configuration.\n  repeated MonitoringDestination producer_destinations = 1;\n\n  // Monitoring configurations for sending metrics to the consumer project.\n  // There can be multiple consumer destinations. A monitored resource type may\n  // appear in multiple monitoring destinations if different aggregations are\n  // needed for different sets of metrics associated with that monitored\n  // resource type. A monitored resource and metric pair may only be used once\n  // in the Monitoring configuration.\n  repeated MonitoringDestination consumer_destinations = 2;\n}\n","size_bytes":4457},"build/extracted-include-protos/test/google/protobuf/struct.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/protobuf/types/known/structpb\";\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"StructProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\n\n// `Struct` represents a structured data value, consisting of fields\n// which map to dynamically typed values. In some languages, `Struct`\n// might be supported by a native representation. For example, in\n// scripting languages like JS a struct is represented as an\n// object. The details of that representation are described together\n// with the proto support for the language.\n//\n// The JSON representation for `Struct` is JSON object.\nmessage Struct {\n  // Unordered map of dynamically typed values.\n  map<string, Value> fields = 1;\n}\n\n// `Value` represents a dynamically typed value which can be either\n// null, a number, a string, a boolean, a recursive struct value, or a\n// list of values. A producer of value is expected to set one of these\n// variants. Absence of any variant indicates an error.\n//\n// The JSON representation for `Value` is JSON value.\nmessage Value {\n  // The kind of value.\n  oneof kind {\n    // Represents a null value.\n    NullValue null_value = 1;\n    // Represents a double value.\n    double number_value = 2;\n    // Represents a string value.\n    string string_value = 3;\n    // Represents a boolean value.\n    bool bool_value = 4;\n    // Represents a structured value.\n    Struct struct_value = 5;\n    // Represents a repeated `Value`.\n    ListValue list_value = 6;\n  }\n}\n\n// `NullValue` is a singleton enumeration to represent the null value for the\n// `Value` type union.\n//\n// The JSON representation for `NullValue` is JSON `null`.\nenum NullValue {\n  // Null value.\n  NULL_VALUE = 0;\n}\n\n// `ListValue` is a wrapper around a repeated field of values.\n//\n// The JSON representation for `ListValue` is JSON array.\nmessage ListValue {\n  // Repeated field of dynamically typed values.\n  repeated Value values = 1;\n}\n","size_bytes":3778},"build/extracted-include-protos/test/google/api/source_info.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/any.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig\";\noption java_multiple_files = true;\noption java_outer_classname = \"SourceInfoProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Source information used to create a Service Config\nmessage SourceInfo {\n  // All files used during config generation.\n  repeated google.protobuf.Any source_files = 1;\n}\n","size_bytes":1091},"build/extracted-include-protos/main/google/rpc/context/audit_context.proto":{"content":"// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.rpc.context;\n\nimport \"google/protobuf/struct.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/rpc/context;context\";\noption java_multiple_files = true;\noption java_outer_classname = \"AuditContextProto\";\noption java_package = \"com.google.rpc.context\";\n\n// `AuditContext` provides information that is needed for audit logging.\nmessage AuditContext {\n  // Serialized audit log.\n  bytes audit_log = 1;\n\n  // An API request message that is scrubbed based on the method annotation.\n  // This field should only be filled if audit_log field is present.\n  // Service Control will use this to assemble a complete log for Cloud Audit\n  // Logs and Google internal audit logs.\n  google.protobuf.Struct scrubbed_request = 2;\n\n  // An API response message that is scrubbed based on the method annotation.\n  // This field should only be filled if audit_log field is present.\n  // Service Control will use this to assemble a complete log for Cloud Audit\n  // Logs and Google internal audit logs.\n  google.protobuf.Struct scrubbed_response = 3;\n\n  // Number of scrubbed response items.\n  int32 scrubbed_response_item_count = 4;\n\n  // Audit resource name which is scrubbed.\n  string target_resource = 5;\n}\n","size_bytes":1861},"build/extracted-include-protos/test/google/logging/type/log_severity.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.logging.type;\n\noption csharp_namespace = \"Google.Cloud.Logging.Type\";\noption go_package = \"google.golang.org/genproto/googleapis/logging/type;ltype\";\noption java_multiple_files = true;\noption java_outer_classname = \"LogSeverityProto\";\noption java_package = \"com.google.logging.type\";\noption objc_class_prefix = \"GLOG\";\noption php_namespace = \"Google\\\\Cloud\\\\Logging\\\\Type\";\noption ruby_package = \"Google::Cloud::Logging::Type\";\n\n// The severity of the event described in a log entry, expressed as one of the\n// standard severity levels listed below.  For your reference, the levels are\n// assigned the listed numeric values. The effect of using numeric values other\n// than those listed is undefined.\n//\n// You can filter for log entries by severity.  For example, the following\n// filter expression will match log entries with severities `INFO`, `NOTICE`,\n// and `WARNING`:\n//\n//     severity > DEBUG AND severity <= WARNING\n//\n// If you are writing log entries, you should map other severity encodings to\n// one of these standard levels. For example, you might map all of Java's FINE,\n// FINER, and FINEST levels to `LogSeverity.DEBUG`. You can preserve the\n// original severity level in the log entry payload if you wish.\nenum LogSeverity {\n  // (0) The log entry has no assigned severity level.\n  DEFAULT = 0;\n\n  // (100) Debug or trace information.\n  DEBUG = 100;\n\n  // (200) Routine information, such as ongoing status or performance.\n  INFO = 200;\n\n  // (300) Normal but significant events, such as start up, shut down, or\n  // a configuration change.\n  NOTICE = 300;\n\n  // (400) Warning events might cause problems.\n  WARNING = 400;\n\n  // (500) Error events are likely to cause problems.\n  ERROR = 500;\n\n  // (600) Critical events cause more severe problems or outages.\n  CRITICAL = 600;\n\n  // (700) A person must take an action immediately.\n  ALERT = 700;\n\n  // (800) One or more systems are unusable.\n  EMERGENCY = 800;\n}\n","size_bytes":2555},"build/generated/source/proto/main/java/com/spiketrade/proto/MarketDataProto.java":{"content":"// Generated by the protocol buffer compiler.  DO NOT EDIT!\n// source: market_data.proto\n\n// Protobuf Java Version: 3.25.1\npackage com.spiketrade.proto;\n\npublic final class MarketDataProto {\n  private MarketDataProto() {}\n  public static void registerAllExtensions(\n      com.google.protobuf.ExtensionRegistryLite registry) {\n  }\n\n  public static void registerAllExtensions(\n      com.google.protobuf.ExtensionRegistry registry) {\n    registerAllExtensions(\n        (com.google.protobuf.ExtensionRegistryLite) registry);\n  }\n  public interface IndicatorsDataOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.IndicatorsData)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <pre>\n     * Basic indicators\n     * </pre>\n     *\n     * <code>double rsi = 1;</code>\n     * @return The rsi.\n     */\n    double getRsi();\n\n    /**\n     * <code>double price_roc = 2;</code>\n     * @return The priceRoc.\n     */\n    double getPriceRoc();\n\n    /**\n     * <code>double volume_roc = 3;</code>\n     * @return The volumeRoc.\n     */\n    double getVolumeRoc();\n\n    /**\n     * <code>double volume = 4;</code>\n     * @return The volume.\n     */\n    double getVolume();\n\n    /**\n     * <code>double obv = 5;</code>\n     * @return The obv.\n     */\n    double getObv();\n\n    /**\n     * <code>double mfi = 6;</code>\n     * @return The mfi.\n     */\n    double getMfi();\n\n    /**\n     * <code>double bollinger_position = 7;</code>\n     * @return The bollingerPosition.\n     */\n    double getBollingerPosition();\n\n    /**\n     * <code>double percent_b = 8;</code>\n     * @return The percentB.\n     */\n    double getPercentB();\n\n    /**\n     * <code>double vwap = 9;</code>\n     * @return The vwap.\n     */\n    double getVwap();\n\n    /**\n     * <pre>\n     * ROC (Rate of Change) indicators\n     * </pre>\n     *\n     * <code>double rsi_roc = 10;</code>\n     * @return The rsiRoc.\n     */\n    double getRsiRoc();\n\n    /**\n     * <code>double obv_roc = 11;</code>\n     * @return The obvRoc.\n     */\n    double getObvRoc();\n\n    /**\n     * <code>double mfi_roc = 12;</code>\n     * @return The mfiRoc.\n     */\n    double getMfiRoc();\n\n    /**\n     * <code>double bollinger_pos_roc = 13;</code>\n     * @return The bollingerPosRoc.\n     */\n    double getBollingerPosRoc();\n\n    /**\n     * <code>double percent_b_roc = 14;</code>\n     * @return The percentBRoc.\n     */\n    double getPercentBRoc();\n\n    /**\n     * <code>double vwap_roc = 15;</code>\n     * @return The vwapRoc.\n     */\n    double getVwapRoc();\n\n    /**\n     * <pre>\n     * MACD (Moving Average Convergence Divergence)\n     * </pre>\n     *\n     * <code>double macd_line = 16;</code>\n     * @return The macdLine.\n     */\n    double getMacdLine();\n\n    /**\n     * <code>double macd_signal = 17;</code>\n     * @return The macdSignal.\n     */\n    double getMacdSignal();\n\n    /**\n     * <code>double macd_histogram = 18;</code>\n     * @return The macdHistogram.\n     */\n    double getMacdHistogram();\n\n    /**\n     * <pre>\n     * EMA (Exponential Moving Average) - multiple periods\n     * </pre>\n     *\n     * <code>double ema_9 = 19;</code>\n     * @return The ema9.\n     */\n    double getEma9();\n\n    /**\n     * <code>double ema_20 = 20;</code>\n     * @return The ema20.\n     */\n    double getEma20();\n\n    /**\n     * <code>double ema_50 = 21;</code>\n     * @return The ema50.\n     */\n    double getEma50();\n\n    /**\n     * <pre>\n     * Stochastic Oscillator\n     * </pre>\n     *\n     * <code>double stoch_k = 22;</code>\n     * @return The stochK.\n     */\n    double getStochK();\n\n    /**\n     * <code>double stoch_d = 23;</code>\n     * @return The stochD.\n     */\n    double getStochD();\n\n    /**\n     * <pre>\n     * Relative Volume\n     * </pre>\n     *\n     * <code>double rvol = 24;</code>\n     * @return The rvol.\n     */\n    double getRvol();\n\n    /**\n     * <pre>\n     * Volume Spike Detection\n     * </pre>\n     *\n     * <code>bool volume_spike = 25;</code>\n     * @return The volumeSpike.\n     */\n    boolean getVolumeSpike();\n\n    /**\n     * <code>double volume_ratio = 26;</code>\n     * @return The volumeRatio.\n     */\n    double getVolumeRatio();\n\n    /**\n     * <pre>\n     * ATR (Average True Range)\n     * </pre>\n     *\n     * <code>double atr = 27;</code>\n     * @return The atr.\n     */\n    double getAtr();\n\n    /**\n     * <pre>\n     * Bollinger Band values (for completeness)\n     * </pre>\n     *\n     * <code>double bollinger_upper = 28;</code>\n     * @return The bollingerUpper.\n     */\n    double getBollingerUpper();\n\n    /**\n     * <code>double bollinger_lower = 29;</code>\n     * @return The bollingerLower.\n     */\n    double getBollingerLower();\n  }\n  /**\n   * <pre>\n   * Indicators data - Extended to include all technical indicators for continuous quote updates\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.IndicatorsData}\n   */\n  public static final class IndicatorsData extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.IndicatorsData)\n      IndicatorsDataOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use IndicatorsData.newBuilder() to construct.\n    private IndicatorsData(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private IndicatorsData() {\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new IndicatorsData();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_IndicatorsData_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_IndicatorsData_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.MarketDataProto.IndicatorsData.class, com.spiketrade.proto.MarketDataProto.IndicatorsData.Builder.class);\n    }\n\n    public static final int RSI_FIELD_NUMBER = 1;\n    private double rsi_ = 0D;\n    /**\n     * <pre>\n     * Basic indicators\n     * </pre>\n     *\n     * <code>double rsi = 1;</code>\n     * @return The rsi.\n     */\n    @java.lang.Override\n    public double getRsi() {\n      return rsi_;\n    }\n\n    public static final int PRICE_ROC_FIELD_NUMBER = 2;\n    private double priceRoc_ = 0D;\n    /**\n     * <code>double price_roc = 2;</code>\n     * @return The priceRoc.\n     */\n    @java.lang.Override\n    public double getPriceRoc() {\n      return priceRoc_;\n    }\n\n    public static final int VOLUME_ROC_FIELD_NUMBER = 3;\n    private double volumeRoc_ = 0D;\n    /**\n     * <code>double volume_roc = 3;</code>\n     * @return The volumeRoc.\n     */\n    @java.lang.Override\n    public double getVolumeRoc() {\n      return volumeRoc_;\n    }\n\n    public static final int VOLUME_FIELD_NUMBER = 4;\n    private double volume_ = 0D;\n    /**\n     * <code>double volume = 4;</code>\n     * @return The volume.\n     */\n    @java.lang.Override\n    public double getVolume() {\n      return volume_;\n    }\n\n    public static final int OBV_FIELD_NUMBER = 5;\n    private double obv_ = 0D;\n    /**\n     * <code>double obv = 5;</code>\n     * @return The obv.\n     */\n    @java.lang.Override\n    public double getObv() {\n      return obv_;\n    }\n\n    public static final int MFI_FIELD_NUMBER = 6;\n    private double mfi_ = 0D;\n    /**\n     * <code>double mfi = 6;</code>\n     * @return The mfi.\n     */\n    @java.lang.Override\n    public double getMfi() {\n      return mfi_;\n    }\n\n    public static final int BOLLINGER_POSITION_FIELD_NUMBER = 7;\n    private double bollingerPosition_ = 0D;\n    /**\n     * <code>double bollinger_position = 7;</code>\n     * @return The bollingerPosition.\n     */\n    @java.lang.Override\n    public double getBollingerPosition() {\n      return bollingerPosition_;\n    }\n\n    public static final int PERCENT_B_FIELD_NUMBER = 8;\n    private double percentB_ = 0D;\n    /**\n     * <code>double percent_b = 8;</code>\n     * @return The percentB.\n     */\n    @java.lang.Override\n    public double getPercentB() {\n      return percentB_;\n    }\n\n    public static final int VWAP_FIELD_NUMBER = 9;\n    private double vwap_ = 0D;\n    /**\n     * <code>double vwap = 9;</code>\n     * @return The vwap.\n     */\n    @java.lang.Override\n    public double getVwap() {\n      return vwap_;\n    }\n\n    public static final int RSI_ROC_FIELD_NUMBER = 10;\n    private double rsiRoc_ = 0D;\n    /**\n     * <pre>\n     * ROC (Rate of Change) indicators\n     * </pre>\n     *\n     * <code>double rsi_roc = 10;</code>\n     * @return The rsiRoc.\n     */\n    @java.lang.Override\n    public double getRsiRoc() {\n      return rsiRoc_;\n    }\n\n    public static final int OBV_ROC_FIELD_NUMBER = 11;\n    private double obvRoc_ = 0D;\n    /**\n     * <code>double obv_roc = 11;</code>\n     * @return The obvRoc.\n     */\n    @java.lang.Override\n    public double getObvRoc() {\n      return obvRoc_;\n    }\n\n    public static final int MFI_ROC_FIELD_NUMBER = 12;\n    private double mfiRoc_ = 0D;\n    /**\n     * <code>double mfi_roc = 12;</code>\n     * @return The mfiRoc.\n     */\n    @java.lang.Override\n    public double getMfiRoc() {\n      return mfiRoc_;\n    }\n\n    public static final int BOLLINGER_POS_ROC_FIELD_NUMBER = 13;\n    private double bollingerPosRoc_ = 0D;\n    /**\n     * <code>double bollinger_pos_roc = 13;</code>\n     * @return The bollingerPosRoc.\n     */\n    @java.lang.Override\n    public double getBollingerPosRoc() {\n      return bollingerPosRoc_;\n    }\n\n    public static final int PERCENT_B_ROC_FIELD_NUMBER = 14;\n    private double percentBRoc_ = 0D;\n    /**\n     * <code>double percent_b_roc = 14;</code>\n     * @return The percentBRoc.\n     */\n    @java.lang.Override\n    public double getPercentBRoc() {\n      return percentBRoc_;\n    }\n\n    public static final int VWAP_ROC_FIELD_NUMBER = 15;\n    private double vwapRoc_ = 0D;\n    /**\n     * <code>double vwap_roc = 15;</code>\n     * @return The vwapRoc.\n     */\n    @java.lang.Override\n    public double getVwapRoc() {\n      return vwapRoc_;\n    }\n\n    public static final int MACD_LINE_FIELD_NUMBER = 16;\n    private double macdLine_ = 0D;\n    /**\n     * <pre>\n     * MACD (Moving Average Convergence Divergence)\n     * </pre>\n     *\n     * <code>double macd_line = 16;</code>\n     * @return The macdLine.\n     */\n    @java.lang.Override\n    public double getMacdLine() {\n      return macdLine_;\n    }\n\n    public static final int MACD_SIGNAL_FIELD_NUMBER = 17;\n    private double macdSignal_ = 0D;\n    /**\n     * <code>double macd_signal = 17;</code>\n     * @return The macdSignal.\n     */\n    @java.lang.Override\n    public double getMacdSignal() {\n      return macdSignal_;\n    }\n\n    public static final int MACD_HISTOGRAM_FIELD_NUMBER = 18;\n    private double macdHistogram_ = 0D;\n    /**\n     * <code>double macd_histogram = 18;</code>\n     * @return The macdHistogram.\n     */\n    @java.lang.Override\n    public double getMacdHistogram() {\n      return macdHistogram_;\n    }\n\n    public static final int EMA_9_FIELD_NUMBER = 19;\n    private double ema9_ = 0D;\n    /**\n     * <pre>\n     * EMA (Exponential Moving Average) - multiple periods\n     * </pre>\n     *\n     * <code>double ema_9 = 19;</code>\n     * @return The ema9.\n     */\n    @java.lang.Override\n    public double getEma9() {\n      return ema9_;\n    }\n\n    public static final int EMA_20_FIELD_NUMBER = 20;\n    private double ema20_ = 0D;\n    /**\n     * <code>double ema_20 = 20;</code>\n     * @return The ema20.\n     */\n    @java.lang.Override\n    public double getEma20() {\n      return ema20_;\n    }\n\n    public static final int EMA_50_FIELD_NUMBER = 21;\n    private double ema50_ = 0D;\n    /**\n     * <code>double ema_50 = 21;</code>\n     * @return The ema50.\n     */\n    @java.lang.Override\n    public double getEma50() {\n      return ema50_;\n    }\n\n    public static final int STOCH_K_FIELD_NUMBER = 22;\n    private double stochK_ = 0D;\n    /**\n     * <pre>\n     * Stochastic Oscillator\n     * </pre>\n     *\n     * <code>double stoch_k = 22;</code>\n     * @return The stochK.\n     */\n    @java.lang.Override\n    public double getStochK() {\n      return stochK_;\n    }\n\n    public static final int STOCH_D_FIELD_NUMBER = 23;\n    private double stochD_ = 0D;\n    /**\n     * <code>double stoch_d = 23;</code>\n     * @return The stochD.\n     */\n    @java.lang.Override\n    public double getStochD() {\n      return stochD_;\n    }\n\n    public static final int RVOL_FIELD_NUMBER = 24;\n    private double rvol_ = 0D;\n    /**\n     * <pre>\n     * Relative Volume\n     * </pre>\n     *\n     * <code>double rvol = 24;</code>\n     * @return The rvol.\n     */\n    @java.lang.Override\n    public double getRvol() {\n      return rvol_;\n    }\n\n    public static final int VOLUME_SPIKE_FIELD_NUMBER = 25;\n    private boolean volumeSpike_ = false;\n    /**\n     * <pre>\n     * Volume Spike Detection\n     * </pre>\n     *\n     * <code>bool volume_spike = 25;</code>\n     * @return The volumeSpike.\n     */\n    @java.lang.Override\n    public boolean getVolumeSpike() {\n      return volumeSpike_;\n    }\n\n    public static final int VOLUME_RATIO_FIELD_NUMBER = 26;\n    private double volumeRatio_ = 0D;\n    /**\n     * <code>double volume_ratio = 26;</code>\n     * @return The volumeRatio.\n     */\n    @java.lang.Override\n    public double getVolumeRatio() {\n      return volumeRatio_;\n    }\n\n    public static final int ATR_FIELD_NUMBER = 27;\n    private double atr_ = 0D;\n    /**\n     * <pre>\n     * ATR (Average True Range)\n     * </pre>\n     *\n     * <code>double atr = 27;</code>\n     * @return The atr.\n     */\n    @java.lang.Override\n    public double getAtr() {\n      return atr_;\n    }\n\n    public static final int BOLLINGER_UPPER_FIELD_NUMBER = 28;\n    private double bollingerUpper_ = 0D;\n    /**\n     * <pre>\n     * Bollinger Band values (for completeness)\n     * </pre>\n     *\n     * <code>double bollinger_upper = 28;</code>\n     * @return The bollingerUpper.\n     */\n    @java.lang.Override\n    public double getBollingerUpper() {\n      return bollingerUpper_;\n    }\n\n    public static final int BOLLINGER_LOWER_FIELD_NUMBER = 29;\n    private double bollingerLower_ = 0D;\n    /**\n     * <code>double bollinger_lower = 29;</code>\n     * @return The bollingerLower.\n     */\n    @java.lang.Override\n    public double getBollingerLower() {\n      return bollingerLower_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (java.lang.Double.doubleToRawLongBits(rsi_) != 0) {\n        output.writeDouble(1, rsi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(priceRoc_) != 0) {\n        output.writeDouble(2, priceRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeRoc_) != 0) {\n        output.writeDouble(3, volumeRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volume_) != 0) {\n        output.writeDouble(4, volume_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(obv_) != 0) {\n        output.writeDouble(5, obv_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(mfi_) != 0) {\n        output.writeDouble(6, mfi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosition_) != 0) {\n        output.writeDouble(7, bollingerPosition_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(percentB_) != 0) {\n        output.writeDouble(8, percentB_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(vwap_) != 0) {\n        output.writeDouble(9, vwap_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rsiRoc_) != 0) {\n        output.writeDouble(10, rsiRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(obvRoc_) != 0) {\n        output.writeDouble(11, obvRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(mfiRoc_) != 0) {\n        output.writeDouble(12, mfiRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosRoc_) != 0) {\n        output.writeDouble(13, bollingerPosRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(percentBRoc_) != 0) {\n        output.writeDouble(14, percentBRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(vwapRoc_) != 0) {\n        output.writeDouble(15, vwapRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdLine_) != 0) {\n        output.writeDouble(16, macdLine_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdSignal_) != 0) {\n        output.writeDouble(17, macdSignal_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdHistogram_) != 0) {\n        output.writeDouble(18, macdHistogram_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema9_) != 0) {\n        output.writeDouble(19, ema9_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema20_) != 0) {\n        output.writeDouble(20, ema20_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema50_) != 0) {\n        output.writeDouble(21, ema50_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochK_) != 0) {\n        output.writeDouble(22, stochK_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochD_) != 0) {\n        output.writeDouble(23, stochD_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rvol_) != 0) {\n        output.writeDouble(24, rvol_);\n      }\n      if (volumeSpike_ != false) {\n        output.writeBool(25, volumeSpike_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeRatio_) != 0) {\n        output.writeDouble(26, volumeRatio_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(atr_) != 0) {\n        output.writeDouble(27, atr_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerUpper_) != 0) {\n        output.writeDouble(28, bollingerUpper_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerLower_) != 0) {\n        output.writeDouble(29, bollingerLower_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (java.lang.Double.doubleToRawLongBits(rsi_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(1, rsi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(priceRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(2, priceRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(3, volumeRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volume_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(4, volume_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(obv_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(5, obv_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(mfi_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(6, mfi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosition_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(7, bollingerPosition_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(percentB_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(8, percentB_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(vwap_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(9, vwap_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rsiRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(10, rsiRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(obvRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(11, obvRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(mfiRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(12, mfiRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(13, bollingerPosRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(percentBRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(14, percentBRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(vwapRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(15, vwapRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdLine_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(16, macdLine_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdSignal_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(17, macdSignal_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdHistogram_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(18, macdHistogram_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema9_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(19, ema9_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema20_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(20, ema20_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ema50_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(21, ema50_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochK_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(22, stochK_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochD_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(23, stochD_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rvol_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(24, rvol_);\n      }\n      if (volumeSpike_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(25, volumeSpike_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeRatio_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(26, volumeRatio_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(atr_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(27, atr_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerUpper_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(28, bollingerUpper_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerLower_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(29, bollingerLower_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.MarketDataProto.IndicatorsData)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.MarketDataProto.IndicatorsData other = (com.spiketrade.proto.MarketDataProto.IndicatorsData) obj;\n\n      if (java.lang.Double.doubleToLongBits(getRsi())\n          != java.lang.Double.doubleToLongBits(\n              other.getRsi())) return false;\n      if (java.lang.Double.doubleToLongBits(getPriceRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getPriceRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getVolumeRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getVolumeRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getVolume())\n          != java.lang.Double.doubleToLongBits(\n              other.getVolume())) return false;\n      if (java.lang.Double.doubleToLongBits(getObv())\n          != java.lang.Double.doubleToLongBits(\n              other.getObv())) return false;\n      if (java.lang.Double.doubleToLongBits(getMfi())\n          != java.lang.Double.doubleToLongBits(\n              other.getMfi())) return false;\n      if (java.lang.Double.doubleToLongBits(getBollingerPosition())\n          != java.lang.Double.doubleToLongBits(\n              other.getBollingerPosition())) return false;\n      if (java.lang.Double.doubleToLongBits(getPercentB())\n          != java.lang.Double.doubleToLongBits(\n              other.getPercentB())) return false;\n      if (java.lang.Double.doubleToLongBits(getVwap())\n          != java.lang.Double.doubleToLongBits(\n              other.getVwap())) return false;\n      if (java.lang.Double.doubleToLongBits(getRsiRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getRsiRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getObvRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getObvRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getMfiRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getMfiRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getBollingerPosRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getBollingerPosRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getPercentBRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getPercentBRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getVwapRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getVwapRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getMacdLine())\n          != java.lang.Double.doubleToLongBits(\n              other.getMacdLine())) return false;\n      if (java.lang.Double.doubleToLongBits(getMacdSignal())\n          != java.lang.Double.doubleToLongBits(\n              other.getMacdSignal())) return false;\n      if (java.lang.Double.doubleToLongBits(getMacdHistogram())\n          != java.lang.Double.doubleToLongBits(\n              other.getMacdHistogram())) return false;\n      if (java.lang.Double.doubleToLongBits(getEma9())\n          != java.lang.Double.doubleToLongBits(\n              other.getEma9())) return false;\n      if (java.lang.Double.doubleToLongBits(getEma20())\n          != java.lang.Double.doubleToLongBits(\n              other.getEma20())) return false;\n      if (java.lang.Double.doubleToLongBits(getEma50())\n          != java.lang.Double.doubleToLongBits(\n              other.getEma50())) return false;\n      if (java.lang.Double.doubleToLongBits(getStochK())\n          != java.lang.Double.doubleToLongBits(\n              other.getStochK())) return false;\n      if (java.lang.Double.doubleToLongBits(getStochD())\n          != java.lang.Double.doubleToLongBits(\n              other.getStochD())) return false;\n      if (java.lang.Double.doubleToLongBits(getRvol())\n          != java.lang.Double.doubleToLongBits(\n              other.getRvol())) return false;\n      if (getVolumeSpike()\n          != other.getVolumeSpike()) return false;\n      if (java.lang.Double.doubleToLongBits(getVolumeRatio())\n          != java.lang.Double.doubleToLongBits(\n              other.getVolumeRatio())) return false;\n      if (java.lang.Double.doubleToLongBits(getAtr())\n          != java.lang.Double.doubleToLongBits(\n              other.getAtr())) return false;\n      if (java.lang.Double.doubleToLongBits(getBollingerUpper())\n          != java.lang.Double.doubleToLongBits(\n              other.getBollingerUpper())) return false;\n      if (java.lang.Double.doubleToLongBits(getBollingerLower())\n          != java.lang.Double.doubleToLongBits(\n              other.getBollingerLower())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + RSI_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRsi()));\n      hash = (37 * hash) + PRICE_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPriceRoc()));\n      hash = (37 * hash) + VOLUME_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVolumeRoc()));\n      hash = (37 * hash) + VOLUME_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVolume()));\n      hash = (37 * hash) + OBV_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getObv()));\n      hash = (37 * hash) + MFI_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMfi()));\n      hash = (37 * hash) + BOLLINGER_POSITION_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getBollingerPosition()));\n      hash = (37 * hash) + PERCENT_B_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPercentB()));\n      hash = (37 * hash) + VWAP_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVwap()));\n      hash = (37 * hash) + RSI_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRsiRoc()));\n      hash = (37 * hash) + OBV_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getObvRoc()));\n      hash = (37 * hash) + MFI_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMfiRoc()));\n      hash = (37 * hash) + BOLLINGER_POS_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getBollingerPosRoc()));\n      hash = (37 * hash) + PERCENT_B_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPercentBRoc()));\n      hash = (37 * hash) + VWAP_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVwapRoc()));\n      hash = (37 * hash) + MACD_LINE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMacdLine()));\n      hash = (37 * hash) + MACD_SIGNAL_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMacdSignal()));\n      hash = (37 * hash) + MACD_HISTOGRAM_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMacdHistogram()));\n      hash = (37 * hash) + EMA_9_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getEma9()));\n      hash = (37 * hash) + EMA_20_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getEma20()));\n      hash = (37 * hash) + EMA_50_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getEma50()));\n      hash = (37 * hash) + STOCH_K_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getStochK()));\n      hash = (37 * hash) + STOCH_D_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getStochD()));\n      hash = (37 * hash) + RVOL_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRvol()));\n      hash = (37 * hash) + VOLUME_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getVolumeSpike());\n      hash = (37 * hash) + VOLUME_RATIO_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVolumeRatio()));\n      hash = (37 * hash) + ATR_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getAtr()));\n      hash = (37 * hash) + BOLLINGER_UPPER_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getBollingerUpper()));\n      hash = (37 * hash) + BOLLINGER_LOWER_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getBollingerLower()));\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.IndicatorsData parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.IndicatorsData parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.IndicatorsData parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.IndicatorsData parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.IndicatorsData parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.IndicatorsData parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.IndicatorsData parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.IndicatorsData parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.IndicatorsData parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.IndicatorsData parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.IndicatorsData parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.IndicatorsData parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.MarketDataProto.IndicatorsData prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Indicators data - Extended to include all technical indicators for continuous quote updates\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.IndicatorsData}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.IndicatorsData)\n        com.spiketrade.proto.MarketDataProto.IndicatorsDataOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_IndicatorsData_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_IndicatorsData_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.MarketDataProto.IndicatorsData.class, com.spiketrade.proto.MarketDataProto.IndicatorsData.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.MarketDataProto.IndicatorsData.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        rsi_ = 0D;\n        priceRoc_ = 0D;\n        volumeRoc_ = 0D;\n        volume_ = 0D;\n        obv_ = 0D;\n        mfi_ = 0D;\n        bollingerPosition_ = 0D;\n        percentB_ = 0D;\n        vwap_ = 0D;\n        rsiRoc_ = 0D;\n        obvRoc_ = 0D;\n        mfiRoc_ = 0D;\n        bollingerPosRoc_ = 0D;\n        percentBRoc_ = 0D;\n        vwapRoc_ = 0D;\n        macdLine_ = 0D;\n        macdSignal_ = 0D;\n        macdHistogram_ = 0D;\n        ema9_ = 0D;\n        ema20_ = 0D;\n        ema50_ = 0D;\n        stochK_ = 0D;\n        stochD_ = 0D;\n        rvol_ = 0D;\n        volumeSpike_ = false;\n        volumeRatio_ = 0D;\n        atr_ = 0D;\n        bollingerUpper_ = 0D;\n        bollingerLower_ = 0D;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_IndicatorsData_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.IndicatorsData getDefaultInstanceForType() {\n        return com.spiketrade.proto.MarketDataProto.IndicatorsData.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.IndicatorsData build() {\n        com.spiketrade.proto.MarketDataProto.IndicatorsData result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.IndicatorsData buildPartial() {\n        com.spiketrade.proto.MarketDataProto.IndicatorsData result = new com.spiketrade.proto.MarketDataProto.IndicatorsData(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.MarketDataProto.IndicatorsData result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.rsi_ = rsi_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.priceRoc_ = priceRoc_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.volumeRoc_ = volumeRoc_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.volume_ = volume_;\n        }\n        if (((from_bitField0_ & 0x00000010) != 0)) {\n          result.obv_ = obv_;\n        }\n        if (((from_bitField0_ & 0x00000020) != 0)) {\n          result.mfi_ = mfi_;\n        }\n        if (((from_bitField0_ & 0x00000040) != 0)) {\n          result.bollingerPosition_ = bollingerPosition_;\n        }\n        if (((from_bitField0_ & 0x00000080) != 0)) {\n          result.percentB_ = percentB_;\n        }\n        if (((from_bitField0_ & 0x00000100) != 0)) {\n          result.vwap_ = vwap_;\n        }\n        if (((from_bitField0_ & 0x00000200) != 0)) {\n          result.rsiRoc_ = rsiRoc_;\n        }\n        if (((from_bitField0_ & 0x00000400) != 0)) {\n          result.obvRoc_ = obvRoc_;\n        }\n        if (((from_bitField0_ & 0x00000800) != 0)) {\n          result.mfiRoc_ = mfiRoc_;\n        }\n        if (((from_bitField0_ & 0x00001000) != 0)) {\n          result.bollingerPosRoc_ = bollingerPosRoc_;\n        }\n        if (((from_bitField0_ & 0x00002000) != 0)) {\n          result.percentBRoc_ = percentBRoc_;\n        }\n        if (((from_bitField0_ & 0x00004000) != 0)) {\n          result.vwapRoc_ = vwapRoc_;\n        }\n        if (((from_bitField0_ & 0x00008000) != 0)) {\n          result.macdLine_ = macdLine_;\n        }\n        if (((from_bitField0_ & 0x00010000) != 0)) {\n          result.macdSignal_ = macdSignal_;\n        }\n        if (((from_bitField0_ & 0x00020000) != 0)) {\n          result.macdHistogram_ = macdHistogram_;\n        }\n        if (((from_bitField0_ & 0x00040000) != 0)) {\n          result.ema9_ = ema9_;\n        }\n        if (((from_bitField0_ & 0x00080000) != 0)) {\n          result.ema20_ = ema20_;\n        }\n        if (((from_bitField0_ & 0x00100000) != 0)) {\n          result.ema50_ = ema50_;\n        }\n        if (((from_bitField0_ & 0x00200000) != 0)) {\n          result.stochK_ = stochK_;\n        }\n        if (((from_bitField0_ & 0x00400000) != 0)) {\n          result.stochD_ = stochD_;\n        }\n        if (((from_bitField0_ & 0x00800000) != 0)) {\n          result.rvol_ = rvol_;\n        }\n        if (((from_bitField0_ & 0x01000000) != 0)) {\n          result.volumeSpike_ = volumeSpike_;\n        }\n        if (((from_bitField0_ & 0x02000000) != 0)) {\n          result.volumeRatio_ = volumeRatio_;\n        }\n        if (((from_bitField0_ & 0x04000000) != 0)) {\n          result.atr_ = atr_;\n        }\n        if (((from_bitField0_ & 0x08000000) != 0)) {\n          result.bollingerUpper_ = bollingerUpper_;\n        }\n        if (((from_bitField0_ & 0x10000000) != 0)) {\n          result.bollingerLower_ = bollingerLower_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.MarketDataProto.IndicatorsData) {\n          return mergeFrom((com.spiketrade.proto.MarketDataProto.IndicatorsData)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.MarketDataProto.IndicatorsData other) {\n        if (other == com.spiketrade.proto.MarketDataProto.IndicatorsData.getDefaultInstance()) return this;\n        if (other.getRsi() != 0D) {\n          setRsi(other.getRsi());\n        }\n        if (other.getPriceRoc() != 0D) {\n          setPriceRoc(other.getPriceRoc());\n        }\n        if (other.getVolumeRoc() != 0D) {\n          setVolumeRoc(other.getVolumeRoc());\n        }\n        if (other.getVolume() != 0D) {\n          setVolume(other.getVolume());\n        }\n        if (other.getObv() != 0D) {\n          setObv(other.getObv());\n        }\n        if (other.getMfi() != 0D) {\n          setMfi(other.getMfi());\n        }\n        if (other.getBollingerPosition() != 0D) {\n          setBollingerPosition(other.getBollingerPosition());\n        }\n        if (other.getPercentB() != 0D) {\n          setPercentB(other.getPercentB());\n        }\n        if (other.getVwap() != 0D) {\n          setVwap(other.getVwap());\n        }\n        if (other.getRsiRoc() != 0D) {\n          setRsiRoc(other.getRsiRoc());\n        }\n        if (other.getObvRoc() != 0D) {\n          setObvRoc(other.getObvRoc());\n        }\n        if (other.getMfiRoc() != 0D) {\n          setMfiRoc(other.getMfiRoc());\n        }\n        if (other.getBollingerPosRoc() != 0D) {\n          setBollingerPosRoc(other.getBollingerPosRoc());\n        }\n        if (other.getPercentBRoc() != 0D) {\n          setPercentBRoc(other.getPercentBRoc());\n        }\n        if (other.getVwapRoc() != 0D) {\n          setVwapRoc(other.getVwapRoc());\n        }\n        if (other.getMacdLine() != 0D) {\n          setMacdLine(other.getMacdLine());\n        }\n        if (other.getMacdSignal() != 0D) {\n          setMacdSignal(other.getMacdSignal());\n        }\n        if (other.getMacdHistogram() != 0D) {\n          setMacdHistogram(other.getMacdHistogram());\n        }\n        if (other.getEma9() != 0D) {\n          setEma9(other.getEma9());\n        }\n        if (other.getEma20() != 0D) {\n          setEma20(other.getEma20());\n        }\n        if (other.getEma50() != 0D) {\n          setEma50(other.getEma50());\n        }\n        if (other.getStochK() != 0D) {\n          setStochK(other.getStochK());\n        }\n        if (other.getStochD() != 0D) {\n          setStochD(other.getStochD());\n        }\n        if (other.getRvol() != 0D) {\n          setRvol(other.getRvol());\n        }\n        if (other.getVolumeSpike() != false) {\n          setVolumeSpike(other.getVolumeSpike());\n        }\n        if (other.getVolumeRatio() != 0D) {\n          setVolumeRatio(other.getVolumeRatio());\n        }\n        if (other.getAtr() != 0D) {\n          setAtr(other.getAtr());\n        }\n        if (other.getBollingerUpper() != 0D) {\n          setBollingerUpper(other.getBollingerUpper());\n        }\n        if (other.getBollingerLower() != 0D) {\n          setBollingerLower(other.getBollingerLower());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 9: {\n                rsi_ = input.readDouble();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 9\n              case 17: {\n                priceRoc_ = input.readDouble();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 17\n              case 25: {\n                volumeRoc_ = input.readDouble();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 25\n              case 33: {\n                volume_ = input.readDouble();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 33\n              case 41: {\n                obv_ = input.readDouble();\n                bitField0_ |= 0x00000010;\n                break;\n              } // case 41\n              case 49: {\n                mfi_ = input.readDouble();\n                bitField0_ |= 0x00000020;\n                break;\n              } // case 49\n              case 57: {\n                bollingerPosition_ = input.readDouble();\n                bitField0_ |= 0x00000040;\n                break;\n              } // case 57\n              case 65: {\n                percentB_ = input.readDouble();\n                bitField0_ |= 0x00000080;\n                break;\n              } // case 65\n              case 73: {\n                vwap_ = input.readDouble();\n                bitField0_ |= 0x00000100;\n                break;\n              } // case 73\n              case 81: {\n                rsiRoc_ = input.readDouble();\n                bitField0_ |= 0x00000200;\n                break;\n              } // case 81\n              case 89: {\n                obvRoc_ = input.readDouble();\n                bitField0_ |= 0x00000400;\n                break;\n              } // case 89\n              case 97: {\n                mfiRoc_ = input.readDouble();\n                bitField0_ |= 0x00000800;\n                break;\n              } // case 97\n              case 105: {\n                bollingerPosRoc_ = input.readDouble();\n                bitField0_ |= 0x00001000;\n                break;\n              } // case 105\n              case 113: {\n                percentBRoc_ = input.readDouble();\n                bitField0_ |= 0x00002000;\n                break;\n              } // case 113\n              case 121: {\n                vwapRoc_ = input.readDouble();\n                bitField0_ |= 0x00004000;\n                break;\n              } // case 121\n              case 129: {\n                macdLine_ = input.readDouble();\n                bitField0_ |= 0x00008000;\n                break;\n              } // case 129\n              case 137: {\n                macdSignal_ = input.readDouble();\n                bitField0_ |= 0x00010000;\n                break;\n              } // case 137\n              case 145: {\n                macdHistogram_ = input.readDouble();\n                bitField0_ |= 0x00020000;\n                break;\n              } // case 145\n              case 153: {\n                ema9_ = input.readDouble();\n                bitField0_ |= 0x00040000;\n                break;\n              } // case 153\n              case 161: {\n                ema20_ = input.readDouble();\n                bitField0_ |= 0x00080000;\n                break;\n              } // case 161\n              case 169: {\n                ema50_ = input.readDouble();\n                bitField0_ |= 0x00100000;\n                break;\n              } // case 169\n              case 177: {\n                stochK_ = input.readDouble();\n                bitField0_ |= 0x00200000;\n                break;\n              } // case 177\n              case 185: {\n                stochD_ = input.readDouble();\n                bitField0_ |= 0x00400000;\n                break;\n              } // case 185\n              case 193: {\n                rvol_ = input.readDouble();\n                bitField0_ |= 0x00800000;\n                break;\n              } // case 193\n              case 200: {\n                volumeSpike_ = input.readBool();\n                bitField0_ |= 0x01000000;\n                break;\n              } // case 200\n              case 209: {\n                volumeRatio_ = input.readDouble();\n                bitField0_ |= 0x02000000;\n                break;\n              } // case 209\n              case 217: {\n                atr_ = input.readDouble();\n                bitField0_ |= 0x04000000;\n                break;\n              } // case 217\n              case 225: {\n                bollingerUpper_ = input.readDouble();\n                bitField0_ |= 0x08000000;\n                break;\n              } // case 225\n              case 233: {\n                bollingerLower_ = input.readDouble();\n                bitField0_ |= 0x10000000;\n                break;\n              } // case 233\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private double rsi_ ;\n      /**\n       * <pre>\n       * Basic indicators\n       * </pre>\n       *\n       * <code>double rsi = 1;</code>\n       * @return The rsi.\n       */\n      @java.lang.Override\n      public double getRsi() {\n        return rsi_;\n      }\n      /**\n       * <pre>\n       * Basic indicators\n       * </pre>\n       *\n       * <code>double rsi = 1;</code>\n       * @param value The rsi to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRsi(double value) {\n\n        rsi_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Basic indicators\n       * </pre>\n       *\n       * <code>double rsi = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRsi() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        rsi_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double priceRoc_ ;\n      /**\n       * <code>double price_roc = 2;</code>\n       * @return The priceRoc.\n       */\n      @java.lang.Override\n      public double getPriceRoc() {\n        return priceRoc_;\n      }\n      /**\n       * <code>double price_roc = 2;</code>\n       * @param value The priceRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPriceRoc(double value) {\n\n        priceRoc_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double price_roc = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPriceRoc() {\n        bitField0_ = (bitField0_ & ~0x00000002);\n        priceRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double volumeRoc_ ;\n      /**\n       * <code>double volume_roc = 3;</code>\n       * @return The volumeRoc.\n       */\n      @java.lang.Override\n      public double getVolumeRoc() {\n        return volumeRoc_;\n      }\n      /**\n       * <code>double volume_roc = 3;</code>\n       * @param value The volumeRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolumeRoc(double value) {\n\n        volumeRoc_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double volume_roc = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolumeRoc() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        volumeRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double volume_ ;\n      /**\n       * <code>double volume = 4;</code>\n       * @return The volume.\n       */\n      @java.lang.Override\n      public double getVolume() {\n        return volume_;\n      }\n      /**\n       * <code>double volume = 4;</code>\n       * @param value The volume to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolume(double value) {\n\n        volume_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double volume = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolume() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        volume_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double obv_ ;\n      /**\n       * <code>double obv = 5;</code>\n       * @return The obv.\n       */\n      @java.lang.Override\n      public double getObv() {\n        return obv_;\n      }\n      /**\n       * <code>double obv = 5;</code>\n       * @param value The obv to set.\n       * @return This builder for chaining.\n       */\n      public Builder setObv(double value) {\n\n        obv_ = value;\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double obv = 5;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearObv() {\n        bitField0_ = (bitField0_ & ~0x00000010);\n        obv_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double mfi_ ;\n      /**\n       * <code>double mfi = 6;</code>\n       * @return The mfi.\n       */\n      @java.lang.Override\n      public double getMfi() {\n        return mfi_;\n      }\n      /**\n       * <code>double mfi = 6;</code>\n       * @param value The mfi to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMfi(double value) {\n\n        mfi_ = value;\n        bitField0_ |= 0x00000020;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double mfi = 6;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMfi() {\n        bitField0_ = (bitField0_ & ~0x00000020);\n        mfi_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double bollingerPosition_ ;\n      /**\n       * <code>double bollinger_position = 7;</code>\n       * @return The bollingerPosition.\n       */\n      @java.lang.Override\n      public double getBollingerPosition() {\n        return bollingerPosition_;\n      }\n      /**\n       * <code>double bollinger_position = 7;</code>\n       * @param value The bollingerPosition to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBollingerPosition(double value) {\n\n        bollingerPosition_ = value;\n        bitField0_ |= 0x00000040;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double bollinger_position = 7;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBollingerPosition() {\n        bitField0_ = (bitField0_ & ~0x00000040);\n        bollingerPosition_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double percentB_ ;\n      /**\n       * <code>double percent_b = 8;</code>\n       * @return The percentB.\n       */\n      @java.lang.Override\n      public double getPercentB() {\n        return percentB_;\n      }\n      /**\n       * <code>double percent_b = 8;</code>\n       * @param value The percentB to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPercentB(double value) {\n\n        percentB_ = value;\n        bitField0_ |= 0x00000080;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double percent_b = 8;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPercentB() {\n        bitField0_ = (bitField0_ & ~0x00000080);\n        percentB_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double vwap_ ;\n      /**\n       * <code>double vwap = 9;</code>\n       * @return The vwap.\n       */\n      @java.lang.Override\n      public double getVwap() {\n        return vwap_;\n      }\n      /**\n       * <code>double vwap = 9;</code>\n       * @param value The vwap to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVwap(double value) {\n\n        vwap_ = value;\n        bitField0_ |= 0x00000100;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double vwap = 9;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVwap() {\n        bitField0_ = (bitField0_ & ~0x00000100);\n        vwap_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double rsiRoc_ ;\n      /**\n       * <pre>\n       * ROC (Rate of Change) indicators\n       * </pre>\n       *\n       * <code>double rsi_roc = 10;</code>\n       * @return The rsiRoc.\n       */\n      @java.lang.Override\n      public double getRsiRoc() {\n        return rsiRoc_;\n      }\n      /**\n       * <pre>\n       * ROC (Rate of Change) indicators\n       * </pre>\n       *\n       * <code>double rsi_roc = 10;</code>\n       * @param value The rsiRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRsiRoc(double value) {\n\n        rsiRoc_ = value;\n        bitField0_ |= 0x00000200;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * ROC (Rate of Change) indicators\n       * </pre>\n       *\n       * <code>double rsi_roc = 10;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRsiRoc() {\n        bitField0_ = (bitField0_ & ~0x00000200);\n        rsiRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double obvRoc_ ;\n      /**\n       * <code>double obv_roc = 11;</code>\n       * @return The obvRoc.\n       */\n      @java.lang.Override\n      public double getObvRoc() {\n        return obvRoc_;\n      }\n      /**\n       * <code>double obv_roc = 11;</code>\n       * @param value The obvRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setObvRoc(double value) {\n\n        obvRoc_ = value;\n        bitField0_ |= 0x00000400;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double obv_roc = 11;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearObvRoc() {\n        bitField0_ = (bitField0_ & ~0x00000400);\n        obvRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double mfiRoc_ ;\n      /**\n       * <code>double mfi_roc = 12;</code>\n       * @return The mfiRoc.\n       */\n      @java.lang.Override\n      public double getMfiRoc() {\n        return mfiRoc_;\n      }\n      /**\n       * <code>double mfi_roc = 12;</code>\n       * @param value The mfiRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMfiRoc(double value) {\n\n        mfiRoc_ = value;\n        bitField0_ |= 0x00000800;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double mfi_roc = 12;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMfiRoc() {\n        bitField0_ = (bitField0_ & ~0x00000800);\n        mfiRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double bollingerPosRoc_ ;\n      /**\n       * <code>double bollinger_pos_roc = 13;</code>\n       * @return The bollingerPosRoc.\n       */\n      @java.lang.Override\n      public double getBollingerPosRoc() {\n        return bollingerPosRoc_;\n      }\n      /**\n       * <code>double bollinger_pos_roc = 13;</code>\n       * @param value The bollingerPosRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBollingerPosRoc(double value) {\n\n        bollingerPosRoc_ = value;\n        bitField0_ |= 0x00001000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double bollinger_pos_roc = 13;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBollingerPosRoc() {\n        bitField0_ = (bitField0_ & ~0x00001000);\n        bollingerPosRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double percentBRoc_ ;\n      /**\n       * <code>double percent_b_roc = 14;</code>\n       * @return The percentBRoc.\n       */\n      @java.lang.Override\n      public double getPercentBRoc() {\n        return percentBRoc_;\n      }\n      /**\n       * <code>double percent_b_roc = 14;</code>\n       * @param value The percentBRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPercentBRoc(double value) {\n\n        percentBRoc_ = value;\n        bitField0_ |= 0x00002000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double percent_b_roc = 14;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPercentBRoc() {\n        bitField0_ = (bitField0_ & ~0x00002000);\n        percentBRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double vwapRoc_ ;\n      /**\n       * <code>double vwap_roc = 15;</code>\n       * @return The vwapRoc.\n       */\n      @java.lang.Override\n      public double getVwapRoc() {\n        return vwapRoc_;\n      }\n      /**\n       * <code>double vwap_roc = 15;</code>\n       * @param value The vwapRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVwapRoc(double value) {\n\n        vwapRoc_ = value;\n        bitField0_ |= 0x00004000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double vwap_roc = 15;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVwapRoc() {\n        bitField0_ = (bitField0_ & ~0x00004000);\n        vwapRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double macdLine_ ;\n      /**\n       * <pre>\n       * MACD (Moving Average Convergence Divergence)\n       * </pre>\n       *\n       * <code>double macd_line = 16;</code>\n       * @return The macdLine.\n       */\n      @java.lang.Override\n      public double getMacdLine() {\n        return macdLine_;\n      }\n      /**\n       * <pre>\n       * MACD (Moving Average Convergence Divergence)\n       * </pre>\n       *\n       * <code>double macd_line = 16;</code>\n       * @param value The macdLine to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMacdLine(double value) {\n\n        macdLine_ = value;\n        bitField0_ |= 0x00008000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * MACD (Moving Average Convergence Divergence)\n       * </pre>\n       *\n       * <code>double macd_line = 16;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMacdLine() {\n        bitField0_ = (bitField0_ & ~0x00008000);\n        macdLine_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double macdSignal_ ;\n      /**\n       * <code>double macd_signal = 17;</code>\n       * @return The macdSignal.\n       */\n      @java.lang.Override\n      public double getMacdSignal() {\n        return macdSignal_;\n      }\n      /**\n       * <code>double macd_signal = 17;</code>\n       * @param value The macdSignal to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMacdSignal(double value) {\n\n        macdSignal_ = value;\n        bitField0_ |= 0x00010000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double macd_signal = 17;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMacdSignal() {\n        bitField0_ = (bitField0_ & ~0x00010000);\n        macdSignal_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double macdHistogram_ ;\n      /**\n       * <code>double macd_histogram = 18;</code>\n       * @return The macdHistogram.\n       */\n      @java.lang.Override\n      public double getMacdHistogram() {\n        return macdHistogram_;\n      }\n      /**\n       * <code>double macd_histogram = 18;</code>\n       * @param value The macdHistogram to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMacdHistogram(double value) {\n\n        macdHistogram_ = value;\n        bitField0_ |= 0x00020000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double macd_histogram = 18;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMacdHistogram() {\n        bitField0_ = (bitField0_ & ~0x00020000);\n        macdHistogram_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double ema9_ ;\n      /**\n       * <pre>\n       * EMA (Exponential Moving Average) - multiple periods\n       * </pre>\n       *\n       * <code>double ema_9 = 19;</code>\n       * @return The ema9.\n       */\n      @java.lang.Override\n      public double getEma9() {\n        return ema9_;\n      }\n      /**\n       * <pre>\n       * EMA (Exponential Moving Average) - multiple periods\n       * </pre>\n       *\n       * <code>double ema_9 = 19;</code>\n       * @param value The ema9 to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEma9(double value) {\n\n        ema9_ = value;\n        bitField0_ |= 0x00040000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * EMA (Exponential Moving Average) - multiple periods\n       * </pre>\n       *\n       * <code>double ema_9 = 19;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEma9() {\n        bitField0_ = (bitField0_ & ~0x00040000);\n        ema9_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double ema20_ ;\n      /**\n       * <code>double ema_20 = 20;</code>\n       * @return The ema20.\n       */\n      @java.lang.Override\n      public double getEma20() {\n        return ema20_;\n      }\n      /**\n       * <code>double ema_20 = 20;</code>\n       * @param value The ema20 to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEma20(double value) {\n\n        ema20_ = value;\n        bitField0_ |= 0x00080000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double ema_20 = 20;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEma20() {\n        bitField0_ = (bitField0_ & ~0x00080000);\n        ema20_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double ema50_ ;\n      /**\n       * <code>double ema_50 = 21;</code>\n       * @return The ema50.\n       */\n      @java.lang.Override\n      public double getEma50() {\n        return ema50_;\n      }\n      /**\n       * <code>double ema_50 = 21;</code>\n       * @param value The ema50 to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEma50(double value) {\n\n        ema50_ = value;\n        bitField0_ |= 0x00100000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double ema_50 = 21;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEma50() {\n        bitField0_ = (bitField0_ & ~0x00100000);\n        ema50_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double stochK_ ;\n      /**\n       * <pre>\n       * Stochastic Oscillator\n       * </pre>\n       *\n       * <code>double stoch_k = 22;</code>\n       * @return The stochK.\n       */\n      @java.lang.Override\n      public double getStochK() {\n        return stochK_;\n      }\n      /**\n       * <pre>\n       * Stochastic Oscillator\n       * </pre>\n       *\n       * <code>double stoch_k = 22;</code>\n       * @param value The stochK to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStochK(double value) {\n\n        stochK_ = value;\n        bitField0_ |= 0x00200000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Stochastic Oscillator\n       * </pre>\n       *\n       * <code>double stoch_k = 22;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStochK() {\n        bitField0_ = (bitField0_ & ~0x00200000);\n        stochK_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double stochD_ ;\n      /**\n       * <code>double stoch_d = 23;</code>\n       * @return The stochD.\n       */\n      @java.lang.Override\n      public double getStochD() {\n        return stochD_;\n      }\n      /**\n       * <code>double stoch_d = 23;</code>\n       * @param value The stochD to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStochD(double value) {\n\n        stochD_ = value;\n        bitField0_ |= 0x00400000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double stoch_d = 23;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStochD() {\n        bitField0_ = (bitField0_ & ~0x00400000);\n        stochD_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double rvol_ ;\n      /**\n       * <pre>\n       * Relative Volume\n       * </pre>\n       *\n       * <code>double rvol = 24;</code>\n       * @return The rvol.\n       */\n      @java.lang.Override\n      public double getRvol() {\n        return rvol_;\n      }\n      /**\n       * <pre>\n       * Relative Volume\n       * </pre>\n       *\n       * <code>double rvol = 24;</code>\n       * @param value The rvol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRvol(double value) {\n\n        rvol_ = value;\n        bitField0_ |= 0x00800000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Relative Volume\n       * </pre>\n       *\n       * <code>double rvol = 24;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRvol() {\n        bitField0_ = (bitField0_ & ~0x00800000);\n        rvol_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private boolean volumeSpike_ ;\n      /**\n       * <pre>\n       * Volume Spike Detection\n       * </pre>\n       *\n       * <code>bool volume_spike = 25;</code>\n       * @return The volumeSpike.\n       */\n      @java.lang.Override\n      public boolean getVolumeSpike() {\n        return volumeSpike_;\n      }\n      /**\n       * <pre>\n       * Volume Spike Detection\n       * </pre>\n       *\n       * <code>bool volume_spike = 25;</code>\n       * @param value The volumeSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolumeSpike(boolean value) {\n\n        volumeSpike_ = value;\n        bitField0_ |= 0x01000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Volume Spike Detection\n       * </pre>\n       *\n       * <code>bool volume_spike = 25;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolumeSpike() {\n        bitField0_ = (bitField0_ & ~0x01000000);\n        volumeSpike_ = false;\n        onChanged();\n        return this;\n      }\n\n      private double volumeRatio_ ;\n      /**\n       * <code>double volume_ratio = 26;</code>\n       * @return The volumeRatio.\n       */\n      @java.lang.Override\n      public double getVolumeRatio() {\n        return volumeRatio_;\n      }\n      /**\n       * <code>double volume_ratio = 26;</code>\n       * @param value The volumeRatio to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolumeRatio(double value) {\n\n        volumeRatio_ = value;\n        bitField0_ |= 0x02000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double volume_ratio = 26;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolumeRatio() {\n        bitField0_ = (bitField0_ & ~0x02000000);\n        volumeRatio_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double atr_ ;\n      /**\n       * <pre>\n       * ATR (Average True Range)\n       * </pre>\n       *\n       * <code>double atr = 27;</code>\n       * @return The atr.\n       */\n      @java.lang.Override\n      public double getAtr() {\n        return atr_;\n      }\n      /**\n       * <pre>\n       * ATR (Average True Range)\n       * </pre>\n       *\n       * <code>double atr = 27;</code>\n       * @param value The atr to set.\n       * @return This builder for chaining.\n       */\n      public Builder setAtr(double value) {\n\n        atr_ = value;\n        bitField0_ |= 0x04000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * ATR (Average True Range)\n       * </pre>\n       *\n       * <code>double atr = 27;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearAtr() {\n        bitField0_ = (bitField0_ & ~0x04000000);\n        atr_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double bollingerUpper_ ;\n      /**\n       * <pre>\n       * Bollinger Band values (for completeness)\n       * </pre>\n       *\n       * <code>double bollinger_upper = 28;</code>\n       * @return The bollingerUpper.\n       */\n      @java.lang.Override\n      public double getBollingerUpper() {\n        return bollingerUpper_;\n      }\n      /**\n       * <pre>\n       * Bollinger Band values (for completeness)\n       * </pre>\n       *\n       * <code>double bollinger_upper = 28;</code>\n       * @param value The bollingerUpper to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBollingerUpper(double value) {\n\n        bollingerUpper_ = value;\n        bitField0_ |= 0x08000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Bollinger Band values (for completeness)\n       * </pre>\n       *\n       * <code>double bollinger_upper = 28;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBollingerUpper() {\n        bitField0_ = (bitField0_ & ~0x08000000);\n        bollingerUpper_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double bollingerLower_ ;\n      /**\n       * <code>double bollinger_lower = 29;</code>\n       * @return The bollingerLower.\n       */\n      @java.lang.Override\n      public double getBollingerLower() {\n        return bollingerLower_;\n      }\n      /**\n       * <code>double bollinger_lower = 29;</code>\n       * @param value The bollingerLower to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBollingerLower(double value) {\n\n        bollingerLower_ = value;\n        bitField0_ |= 0x10000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double bollinger_lower = 29;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBollingerLower() {\n        bitField0_ = (bitField0_ & ~0x10000000);\n        bollingerLower_ = 0D;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.IndicatorsData)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.IndicatorsData)\n    private static final com.spiketrade.proto.MarketDataProto.IndicatorsData DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.MarketDataProto.IndicatorsData();\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.IndicatorsData getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<IndicatorsData>\n        PARSER = new com.google.protobuf.AbstractParser<IndicatorsData>() {\n      @java.lang.Override\n      public IndicatorsData parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<IndicatorsData> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<IndicatorsData> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.IndicatorsData getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface QuoteOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.Quote)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    java.lang.String getSymbol();\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    com.google.protobuf.ByteString\n        getSymbolBytes();\n\n    /**\n     * <code>double price = 2;</code>\n     * @return The price.\n     */\n    double getPrice();\n\n    /**\n     * <code>int64 volume = 3;</code>\n     * @return The volume.\n     */\n    long getVolume();\n\n    /**\n     * <code>double bid = 4;</code>\n     * @return The bid.\n     */\n    double getBid();\n\n    /**\n     * <pre>\n     * NOTE: The next available field number is 7, not 5 or 6.\n     * </pre>\n     *\n     * <code>double ask = 5;</code>\n     * @return The ask.\n     */\n    double getAsk();\n\n    /**\n     * <code>int64 timestamp_ms = 6;</code>\n     * @return The timestampMs.\n     */\n    long getTimestampMs();\n\n    /**\n     * <pre>\n     * Individual indicator fields (legacy - deprecated, use indicators field instead)\n     * </pre>\n     *\n     * <code>double rsi = 7;</code>\n     * @return The rsi.\n     */\n    double getRsi();\n\n    /**\n     * <code>double price_roc = 8;</code>\n     * @return The priceRoc.\n     */\n    double getPriceRoc();\n\n    /**\n     * <code>double volume_roc = 9;</code>\n     * @return The volumeRoc.\n     */\n    double getVolumeRoc();\n\n    /**\n     * <code>double obv = 10;</code>\n     * @return The obv.\n     */\n    double getObv();\n\n    /**\n     * <code>double mfi = 11;</code>\n     * @return The mfi.\n     */\n    double getMfi();\n\n    /**\n     * <code>double bollinger_position = 12;</code>\n     * @return The bollingerPosition.\n     */\n    double getBollingerPosition();\n\n    /**\n     * <code>double percent_b = 13;</code>\n     * @return The percentB.\n     */\n    double getPercentB();\n\n    /**\n     * <code>double vwap = 14;</code>\n     * @return The vwap.\n     */\n    double getVwap();\n\n    /**\n     * <pre>\n     * Full indicators data (includes all technical indicators)\n     * </pre>\n     *\n     * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n     * @return Whether the indicators field is set.\n     */\n    boolean hasIndicators();\n    /**\n     * <pre>\n     * Full indicators data (includes all technical indicators)\n     * </pre>\n     *\n     * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n     * @return The indicators.\n     */\n    com.spiketrade.proto.MarketDataProto.IndicatorsData getIndicators();\n    /**\n     * <pre>\n     * Full indicators data (includes all technical indicators)\n     * </pre>\n     *\n     * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n     */\n    com.spiketrade.proto.MarketDataProto.IndicatorsDataOrBuilder getIndicatorsOrBuilder();\n\n    /**\n     * <pre>\n     * Buy signal probability (0.0 to 1.0) - continuously calculated\n     * </pre>\n     *\n     * <code>optional double signal_probability = 16;</code>\n     * @return Whether the signalProbability field is set.\n     */\n    boolean hasSignalProbability();\n    /**\n     * <pre>\n     * Buy signal probability (0.0 to 1.0) - continuously calculated\n     * </pre>\n     *\n     * <code>optional double signal_probability = 16;</code>\n     * @return The signalProbability.\n     */\n    double getSignalProbability();\n\n    /**\n     * <pre>\n     * ATR for quick access\n     * </pre>\n     *\n     * <code>optional double atr = 17;</code>\n     * @return Whether the atr field is set.\n     */\n    boolean hasAtr();\n    /**\n     * <pre>\n     * ATR for quick access\n     * </pre>\n     *\n     * <code>optional double atr = 17;</code>\n     * @return The atr.\n     */\n    double getAtr();\n  }\n  /**\n   * <pre>\n   * Market data message\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.Quote}\n   */\n  public static final class Quote extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.Quote)\n      QuoteOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use Quote.newBuilder() to construct.\n    private Quote(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private Quote() {\n      symbol_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new Quote();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_Quote_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_Quote_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.MarketDataProto.Quote.class, com.spiketrade.proto.MarketDataProto.Quote.Builder.class);\n    }\n\n    private int bitField0_;\n    public static final int SYMBOL_FIELD_NUMBER = 1;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object symbol_ = \"\";\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    @java.lang.Override\n    public java.lang.String getSymbol() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        symbol_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getSymbolBytes() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        symbol_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int PRICE_FIELD_NUMBER = 2;\n    private double price_ = 0D;\n    /**\n     * <code>double price = 2;</code>\n     * @return The price.\n     */\n    @java.lang.Override\n    public double getPrice() {\n      return price_;\n    }\n\n    public static final int VOLUME_FIELD_NUMBER = 3;\n    private long volume_ = 0L;\n    /**\n     * <code>int64 volume = 3;</code>\n     * @return The volume.\n     */\n    @java.lang.Override\n    public long getVolume() {\n      return volume_;\n    }\n\n    public static final int BID_FIELD_NUMBER = 4;\n    private double bid_ = 0D;\n    /**\n     * <code>double bid = 4;</code>\n     * @return The bid.\n     */\n    @java.lang.Override\n    public double getBid() {\n      return bid_;\n    }\n\n    public static final int ASK_FIELD_NUMBER = 5;\n    private double ask_ = 0D;\n    /**\n     * <pre>\n     * NOTE: The next available field number is 7, not 5 or 6.\n     * </pre>\n     *\n     * <code>double ask = 5;</code>\n     * @return The ask.\n     */\n    @java.lang.Override\n    public double getAsk() {\n      return ask_;\n    }\n\n    public static final int TIMESTAMP_MS_FIELD_NUMBER = 6;\n    private long timestampMs_ = 0L;\n    /**\n     * <code>int64 timestamp_ms = 6;</code>\n     * @return The timestampMs.\n     */\n    @java.lang.Override\n    public long getTimestampMs() {\n      return timestampMs_;\n    }\n\n    public static final int RSI_FIELD_NUMBER = 7;\n    private double rsi_ = 0D;\n    /**\n     * <pre>\n     * Individual indicator fields (legacy - deprecated, use indicators field instead)\n     * </pre>\n     *\n     * <code>double rsi = 7;</code>\n     * @return The rsi.\n     */\n    @java.lang.Override\n    public double getRsi() {\n      return rsi_;\n    }\n\n    public static final int PRICE_ROC_FIELD_NUMBER = 8;\n    private double priceRoc_ = 0D;\n    /**\n     * <code>double price_roc = 8;</code>\n     * @return The priceRoc.\n     */\n    @java.lang.Override\n    public double getPriceRoc() {\n      return priceRoc_;\n    }\n\n    public static final int VOLUME_ROC_FIELD_NUMBER = 9;\n    private double volumeRoc_ = 0D;\n    /**\n     * <code>double volume_roc = 9;</code>\n     * @return The volumeRoc.\n     */\n    @java.lang.Override\n    public double getVolumeRoc() {\n      return volumeRoc_;\n    }\n\n    public static final int OBV_FIELD_NUMBER = 10;\n    private double obv_ = 0D;\n    /**\n     * <code>double obv = 10;</code>\n     * @return The obv.\n     */\n    @java.lang.Override\n    public double getObv() {\n      return obv_;\n    }\n\n    public static final int MFI_FIELD_NUMBER = 11;\n    private double mfi_ = 0D;\n    /**\n     * <code>double mfi = 11;</code>\n     * @return The mfi.\n     */\n    @java.lang.Override\n    public double getMfi() {\n      return mfi_;\n    }\n\n    public static final int BOLLINGER_POSITION_FIELD_NUMBER = 12;\n    private double bollingerPosition_ = 0D;\n    /**\n     * <code>double bollinger_position = 12;</code>\n     * @return The bollingerPosition.\n     */\n    @java.lang.Override\n    public double getBollingerPosition() {\n      return bollingerPosition_;\n    }\n\n    public static final int PERCENT_B_FIELD_NUMBER = 13;\n    private double percentB_ = 0D;\n    /**\n     * <code>double percent_b = 13;</code>\n     * @return The percentB.\n     */\n    @java.lang.Override\n    public double getPercentB() {\n      return percentB_;\n    }\n\n    public static final int VWAP_FIELD_NUMBER = 14;\n    private double vwap_ = 0D;\n    /**\n     * <code>double vwap = 14;</code>\n     * @return The vwap.\n     */\n    @java.lang.Override\n    public double getVwap() {\n      return vwap_;\n    }\n\n    public static final int INDICATORS_FIELD_NUMBER = 15;\n    private com.spiketrade.proto.MarketDataProto.IndicatorsData indicators_;\n    /**\n     * <pre>\n     * Full indicators data (includes all technical indicators)\n     * </pre>\n     *\n     * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n     * @return Whether the indicators field is set.\n     */\n    @java.lang.Override\n    public boolean hasIndicators() {\n      return ((bitField0_ & 0x00000001) != 0);\n    }\n    /**\n     * <pre>\n     * Full indicators data (includes all technical indicators)\n     * </pre>\n     *\n     * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n     * @return The indicators.\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.IndicatorsData getIndicators() {\n      return indicators_ == null ? com.spiketrade.proto.MarketDataProto.IndicatorsData.getDefaultInstance() : indicators_;\n    }\n    /**\n     * <pre>\n     * Full indicators data (includes all technical indicators)\n     * </pre>\n     *\n     * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.IndicatorsDataOrBuilder getIndicatorsOrBuilder() {\n      return indicators_ == null ? com.spiketrade.proto.MarketDataProto.IndicatorsData.getDefaultInstance() : indicators_;\n    }\n\n    public static final int SIGNAL_PROBABILITY_FIELD_NUMBER = 16;\n    private double signalProbability_ = 0D;\n    /**\n     * <pre>\n     * Buy signal probability (0.0 to 1.0) - continuously calculated\n     * </pre>\n     *\n     * <code>optional double signal_probability = 16;</code>\n     * @return Whether the signalProbability field is set.\n     */\n    @java.lang.Override\n    public boolean hasSignalProbability() {\n      return ((bitField0_ & 0x00000002) != 0);\n    }\n    /**\n     * <pre>\n     * Buy signal probability (0.0 to 1.0) - continuously calculated\n     * </pre>\n     *\n     * <code>optional double signal_probability = 16;</code>\n     * @return The signalProbability.\n     */\n    @java.lang.Override\n    public double getSignalProbability() {\n      return signalProbability_;\n    }\n\n    public static final int ATR_FIELD_NUMBER = 17;\n    private double atr_ = 0D;\n    /**\n     * <pre>\n     * ATR for quick access\n     * </pre>\n     *\n     * <code>optional double atr = 17;</code>\n     * @return Whether the atr field is set.\n     */\n    @java.lang.Override\n    public boolean hasAtr() {\n      return ((bitField0_ & 0x00000004) != 0);\n    }\n    /**\n     * <pre>\n     * ATR for quick access\n     * </pre>\n     *\n     * <code>optional double atr = 17;</code>\n     * @return The atr.\n     */\n    @java.lang.Override\n    public double getAtr() {\n      return atr_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, symbol_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(price_) != 0) {\n        output.writeDouble(2, price_);\n      }\n      if (volume_ != 0L) {\n        output.writeInt64(3, volume_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bid_) != 0) {\n        output.writeDouble(4, bid_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ask_) != 0) {\n        output.writeDouble(5, ask_);\n      }\n      if (timestampMs_ != 0L) {\n        output.writeInt64(6, timestampMs_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rsi_) != 0) {\n        output.writeDouble(7, rsi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(priceRoc_) != 0) {\n        output.writeDouble(8, priceRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeRoc_) != 0) {\n        output.writeDouble(9, volumeRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(obv_) != 0) {\n        output.writeDouble(10, obv_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(mfi_) != 0) {\n        output.writeDouble(11, mfi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosition_) != 0) {\n        output.writeDouble(12, bollingerPosition_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(percentB_) != 0) {\n        output.writeDouble(13, percentB_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(vwap_) != 0) {\n        output.writeDouble(14, vwap_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        output.writeMessage(15, getIndicators());\n      }\n      if (((bitField0_ & 0x00000002) != 0)) {\n        output.writeDouble(16, signalProbability_);\n      }\n      if (((bitField0_ & 0x00000004) != 0)) {\n        output.writeDouble(17, atr_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, symbol_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(price_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(2, price_);\n      }\n      if (volume_ != 0L) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt64Size(3, volume_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bid_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(4, bid_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(ask_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(5, ask_);\n      }\n      if (timestampMs_ != 0L) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt64Size(6, timestampMs_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rsi_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(7, rsi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(priceRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(8, priceRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeRoc_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(9, volumeRoc_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(obv_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(10, obv_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(mfi_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(11, mfi_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(bollingerPosition_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(12, bollingerPosition_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(percentB_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(13, percentB_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(vwap_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(14, vwap_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(15, getIndicators());\n      }\n      if (((bitField0_ & 0x00000002) != 0)) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(16, signalProbability_);\n      }\n      if (((bitField0_ & 0x00000004) != 0)) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(17, atr_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.MarketDataProto.Quote)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.MarketDataProto.Quote other = (com.spiketrade.proto.MarketDataProto.Quote) obj;\n\n      if (!getSymbol()\n          .equals(other.getSymbol())) return false;\n      if (java.lang.Double.doubleToLongBits(getPrice())\n          != java.lang.Double.doubleToLongBits(\n              other.getPrice())) return false;\n      if (getVolume()\n          != other.getVolume()) return false;\n      if (java.lang.Double.doubleToLongBits(getBid())\n          != java.lang.Double.doubleToLongBits(\n              other.getBid())) return false;\n      if (java.lang.Double.doubleToLongBits(getAsk())\n          != java.lang.Double.doubleToLongBits(\n              other.getAsk())) return false;\n      if (getTimestampMs()\n          != other.getTimestampMs()) return false;\n      if (java.lang.Double.doubleToLongBits(getRsi())\n          != java.lang.Double.doubleToLongBits(\n              other.getRsi())) return false;\n      if (java.lang.Double.doubleToLongBits(getPriceRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getPriceRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getVolumeRoc())\n          != java.lang.Double.doubleToLongBits(\n              other.getVolumeRoc())) return false;\n      if (java.lang.Double.doubleToLongBits(getObv())\n          != java.lang.Double.doubleToLongBits(\n              other.getObv())) return false;\n      if (java.lang.Double.doubleToLongBits(getMfi())\n          != java.lang.Double.doubleToLongBits(\n              other.getMfi())) return false;\n      if (java.lang.Double.doubleToLongBits(getBollingerPosition())\n          != java.lang.Double.doubleToLongBits(\n              other.getBollingerPosition())) return false;\n      if (java.lang.Double.doubleToLongBits(getPercentB())\n          != java.lang.Double.doubleToLongBits(\n              other.getPercentB())) return false;\n      if (java.lang.Double.doubleToLongBits(getVwap())\n          != java.lang.Double.doubleToLongBits(\n              other.getVwap())) return false;\n      if (hasIndicators() != other.hasIndicators()) return false;\n      if (hasIndicators()) {\n        if (!getIndicators()\n            .equals(other.getIndicators())) return false;\n      }\n      if (hasSignalProbability() != other.hasSignalProbability()) return false;\n      if (hasSignalProbability()) {\n        if (java.lang.Double.doubleToLongBits(getSignalProbability())\n            != java.lang.Double.doubleToLongBits(\n                other.getSignalProbability())) return false;\n      }\n      if (hasAtr() != other.hasAtr()) return false;\n      if (hasAtr()) {\n        if (java.lang.Double.doubleToLongBits(getAtr())\n            != java.lang.Double.doubleToLongBits(\n                other.getAtr())) return false;\n      }\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + SYMBOL_FIELD_NUMBER;\n      hash = (53 * hash) + getSymbol().hashCode();\n      hash = (37 * hash) + PRICE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPrice()));\n      hash = (37 * hash) + VOLUME_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          getVolume());\n      hash = (37 * hash) + BID_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getBid()));\n      hash = (37 * hash) + ASK_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getAsk()));\n      hash = (37 * hash) + TIMESTAMP_MS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          getTimestampMs());\n      hash = (37 * hash) + RSI_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRsi()));\n      hash = (37 * hash) + PRICE_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPriceRoc()));\n      hash = (37 * hash) + VOLUME_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVolumeRoc()));\n      hash = (37 * hash) + OBV_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getObv()));\n      hash = (37 * hash) + MFI_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMfi()));\n      hash = (37 * hash) + BOLLINGER_POSITION_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getBollingerPosition()));\n      hash = (37 * hash) + PERCENT_B_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getPercentB()));\n      hash = (37 * hash) + VWAP_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVwap()));\n      if (hasIndicators()) {\n        hash = (37 * hash) + INDICATORS_FIELD_NUMBER;\n        hash = (53 * hash) + getIndicators().hashCode();\n      }\n      if (hasSignalProbability()) {\n        hash = (37 * hash) + SIGNAL_PROBABILITY_FIELD_NUMBER;\n        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n            java.lang.Double.doubleToLongBits(getSignalProbability()));\n      }\n      if (hasAtr()) {\n        hash = (37 * hash) + ATR_FIELD_NUMBER;\n        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n            java.lang.Double.doubleToLongBits(getAtr()));\n      }\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.Quote parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Quote parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Quote parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Quote parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Quote parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Quote parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Quote parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Quote parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.Quote parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.Quote parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Quote parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Quote parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.MarketDataProto.Quote prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Market data message\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.Quote}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.Quote)\n        com.spiketrade.proto.MarketDataProto.QuoteOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_Quote_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_Quote_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.MarketDataProto.Quote.class, com.spiketrade.proto.MarketDataProto.Quote.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.MarketDataProto.Quote.newBuilder()\n      private Builder() {\n        maybeForceBuilderInitialization();\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n        maybeForceBuilderInitialization();\n      }\n      private void maybeForceBuilderInitialization() {\n        if (com.google.protobuf.GeneratedMessageV3\n                .alwaysUseFieldBuilders) {\n          getIndicatorsFieldBuilder();\n        }\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        symbol_ = \"\";\n        price_ = 0D;\n        volume_ = 0L;\n        bid_ = 0D;\n        ask_ = 0D;\n        timestampMs_ = 0L;\n        rsi_ = 0D;\n        priceRoc_ = 0D;\n        volumeRoc_ = 0D;\n        obv_ = 0D;\n        mfi_ = 0D;\n        bollingerPosition_ = 0D;\n        percentB_ = 0D;\n        vwap_ = 0D;\n        indicators_ = null;\n        if (indicatorsBuilder_ != null) {\n          indicatorsBuilder_.dispose();\n          indicatorsBuilder_ = null;\n        }\n        signalProbability_ = 0D;\n        atr_ = 0D;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_Quote_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.Quote getDefaultInstanceForType() {\n        return com.spiketrade.proto.MarketDataProto.Quote.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.Quote build() {\n        com.spiketrade.proto.MarketDataProto.Quote result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.Quote buildPartial() {\n        com.spiketrade.proto.MarketDataProto.Quote result = new com.spiketrade.proto.MarketDataProto.Quote(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.MarketDataProto.Quote result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.symbol_ = symbol_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.price_ = price_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.volume_ = volume_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.bid_ = bid_;\n        }\n        if (((from_bitField0_ & 0x00000010) != 0)) {\n          result.ask_ = ask_;\n        }\n        if (((from_bitField0_ & 0x00000020) != 0)) {\n          result.timestampMs_ = timestampMs_;\n        }\n        if (((from_bitField0_ & 0x00000040) != 0)) {\n          result.rsi_ = rsi_;\n        }\n        if (((from_bitField0_ & 0x00000080) != 0)) {\n          result.priceRoc_ = priceRoc_;\n        }\n        if (((from_bitField0_ & 0x00000100) != 0)) {\n          result.volumeRoc_ = volumeRoc_;\n        }\n        if (((from_bitField0_ & 0x00000200) != 0)) {\n          result.obv_ = obv_;\n        }\n        if (((from_bitField0_ & 0x00000400) != 0)) {\n          result.mfi_ = mfi_;\n        }\n        if (((from_bitField0_ & 0x00000800) != 0)) {\n          result.bollingerPosition_ = bollingerPosition_;\n        }\n        if (((from_bitField0_ & 0x00001000) != 0)) {\n          result.percentB_ = percentB_;\n        }\n        if (((from_bitField0_ & 0x00002000) != 0)) {\n          result.vwap_ = vwap_;\n        }\n        int to_bitField0_ = 0;\n        if (((from_bitField0_ & 0x00004000) != 0)) {\n          result.indicators_ = indicatorsBuilder_ == null\n              ? indicators_\n              : indicatorsBuilder_.build();\n          to_bitField0_ |= 0x00000001;\n        }\n        if (((from_bitField0_ & 0x00008000) != 0)) {\n          result.signalProbability_ = signalProbability_;\n          to_bitField0_ |= 0x00000002;\n        }\n        if (((from_bitField0_ & 0x00010000) != 0)) {\n          result.atr_ = atr_;\n          to_bitField0_ |= 0x00000004;\n        }\n        result.bitField0_ |= to_bitField0_;\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.MarketDataProto.Quote) {\n          return mergeFrom((com.spiketrade.proto.MarketDataProto.Quote)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.MarketDataProto.Quote other) {\n        if (other == com.spiketrade.proto.MarketDataProto.Quote.getDefaultInstance()) return this;\n        if (!other.getSymbol().isEmpty()) {\n          symbol_ = other.symbol_;\n          bitField0_ |= 0x00000001;\n          onChanged();\n        }\n        if (other.getPrice() != 0D) {\n          setPrice(other.getPrice());\n        }\n        if (other.getVolume() != 0L) {\n          setVolume(other.getVolume());\n        }\n        if (other.getBid() != 0D) {\n          setBid(other.getBid());\n        }\n        if (other.getAsk() != 0D) {\n          setAsk(other.getAsk());\n        }\n        if (other.getTimestampMs() != 0L) {\n          setTimestampMs(other.getTimestampMs());\n        }\n        if (other.getRsi() != 0D) {\n          setRsi(other.getRsi());\n        }\n        if (other.getPriceRoc() != 0D) {\n          setPriceRoc(other.getPriceRoc());\n        }\n        if (other.getVolumeRoc() != 0D) {\n          setVolumeRoc(other.getVolumeRoc());\n        }\n        if (other.getObv() != 0D) {\n          setObv(other.getObv());\n        }\n        if (other.getMfi() != 0D) {\n          setMfi(other.getMfi());\n        }\n        if (other.getBollingerPosition() != 0D) {\n          setBollingerPosition(other.getBollingerPosition());\n        }\n        if (other.getPercentB() != 0D) {\n          setPercentB(other.getPercentB());\n        }\n        if (other.getVwap() != 0D) {\n          setVwap(other.getVwap());\n        }\n        if (other.hasIndicators()) {\n          mergeIndicators(other.getIndicators());\n        }\n        if (other.hasSignalProbability()) {\n          setSignalProbability(other.getSignalProbability());\n        }\n        if (other.hasAtr()) {\n          setAtr(other.getAtr());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 10: {\n                symbol_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 10\n              case 17: {\n                price_ = input.readDouble();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 17\n              case 24: {\n                volume_ = input.readInt64();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 24\n              case 33: {\n                bid_ = input.readDouble();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 33\n              case 41: {\n                ask_ = input.readDouble();\n                bitField0_ |= 0x00000010;\n                break;\n              } // case 41\n              case 48: {\n                timestampMs_ = input.readInt64();\n                bitField0_ |= 0x00000020;\n                break;\n              } // case 48\n              case 57: {\n                rsi_ = input.readDouble();\n                bitField0_ |= 0x00000040;\n                break;\n              } // case 57\n              case 65: {\n                priceRoc_ = input.readDouble();\n                bitField0_ |= 0x00000080;\n                break;\n              } // case 65\n              case 73: {\n                volumeRoc_ = input.readDouble();\n                bitField0_ |= 0x00000100;\n                break;\n              } // case 73\n              case 81: {\n                obv_ = input.readDouble();\n                bitField0_ |= 0x00000200;\n                break;\n              } // case 81\n              case 89: {\n                mfi_ = input.readDouble();\n                bitField0_ |= 0x00000400;\n                break;\n              } // case 89\n              case 97: {\n                bollingerPosition_ = input.readDouble();\n                bitField0_ |= 0x00000800;\n                break;\n              } // case 97\n              case 105: {\n                percentB_ = input.readDouble();\n                bitField0_ |= 0x00001000;\n                break;\n              } // case 105\n              case 113: {\n                vwap_ = input.readDouble();\n                bitField0_ |= 0x00002000;\n                break;\n              } // case 113\n              case 122: {\n                input.readMessage(\n                    getIndicatorsFieldBuilder().getBuilder(),\n                    extensionRegistry);\n                bitField0_ |= 0x00004000;\n                break;\n              } // case 122\n              case 129: {\n                signalProbability_ = input.readDouble();\n                bitField0_ |= 0x00008000;\n                break;\n              } // case 129\n              case 137: {\n                atr_ = input.readDouble();\n                bitField0_ |= 0x00010000;\n                break;\n              } // case 137\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private java.lang.Object symbol_ = \"\";\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The symbol.\n       */\n      public java.lang.String getSymbol() {\n        java.lang.Object ref = symbol_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          symbol_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The bytes for symbol.\n       */\n      public com.google.protobuf.ByteString\n          getSymbolBytes() {\n        java.lang.Object ref = symbol_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          symbol_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbol(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSymbol() {\n        symbol_ = getDefaultInstance().getSymbol();\n        bitField0_ = (bitField0_ & ~0x00000001);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The bytes for symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbolBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n\n      private double price_ ;\n      /**\n       * <code>double price = 2;</code>\n       * @return The price.\n       */\n      @java.lang.Override\n      public double getPrice() {\n        return price_;\n      }\n      /**\n       * <code>double price = 2;</code>\n       * @param value The price to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPrice(double value) {\n\n        price_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double price = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPrice() {\n        bitField0_ = (bitField0_ & ~0x00000002);\n        price_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private long volume_ ;\n      /**\n       * <code>int64 volume = 3;</code>\n       * @return The volume.\n       */\n      @java.lang.Override\n      public long getVolume() {\n        return volume_;\n      }\n      /**\n       * <code>int64 volume = 3;</code>\n       * @param value The volume to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolume(long value) {\n\n        volume_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int64 volume = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolume() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        volume_ = 0L;\n        onChanged();\n        return this;\n      }\n\n      private double bid_ ;\n      /**\n       * <code>double bid = 4;</code>\n       * @return The bid.\n       */\n      @java.lang.Override\n      public double getBid() {\n        return bid_;\n      }\n      /**\n       * <code>double bid = 4;</code>\n       * @param value The bid to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBid(double value) {\n\n        bid_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double bid = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBid() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        bid_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double ask_ ;\n      /**\n       * <pre>\n       * NOTE: The next available field number is 7, not 5 or 6.\n       * </pre>\n       *\n       * <code>double ask = 5;</code>\n       * @return The ask.\n       */\n      @java.lang.Override\n      public double getAsk() {\n        return ask_;\n      }\n      /**\n       * <pre>\n       * NOTE: The next available field number is 7, not 5 or 6.\n       * </pre>\n       *\n       * <code>double ask = 5;</code>\n       * @param value The ask to set.\n       * @return This builder for chaining.\n       */\n      public Builder setAsk(double value) {\n\n        ask_ = value;\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * NOTE: The next available field number is 7, not 5 or 6.\n       * </pre>\n       *\n       * <code>double ask = 5;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearAsk() {\n        bitField0_ = (bitField0_ & ~0x00000010);\n        ask_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private long timestampMs_ ;\n      /**\n       * <code>int64 timestamp_ms = 6;</code>\n       * @return The timestampMs.\n       */\n      @java.lang.Override\n      public long getTimestampMs() {\n        return timestampMs_;\n      }\n      /**\n       * <code>int64 timestamp_ms = 6;</code>\n       * @param value The timestampMs to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTimestampMs(long value) {\n\n        timestampMs_ = value;\n        bitField0_ |= 0x00000020;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int64 timestamp_ms = 6;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTimestampMs() {\n        bitField0_ = (bitField0_ & ~0x00000020);\n        timestampMs_ = 0L;\n        onChanged();\n        return this;\n      }\n\n      private double rsi_ ;\n      /**\n       * <pre>\n       * Individual indicator fields (legacy - deprecated, use indicators field instead)\n       * </pre>\n       *\n       * <code>double rsi = 7;</code>\n       * @return The rsi.\n       */\n      @java.lang.Override\n      public double getRsi() {\n        return rsi_;\n      }\n      /**\n       * <pre>\n       * Individual indicator fields (legacy - deprecated, use indicators field instead)\n       * </pre>\n       *\n       * <code>double rsi = 7;</code>\n       * @param value The rsi to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRsi(double value) {\n\n        rsi_ = value;\n        bitField0_ |= 0x00000040;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Individual indicator fields (legacy - deprecated, use indicators field instead)\n       * </pre>\n       *\n       * <code>double rsi = 7;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRsi() {\n        bitField0_ = (bitField0_ & ~0x00000040);\n        rsi_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double priceRoc_ ;\n      /**\n       * <code>double price_roc = 8;</code>\n       * @return The priceRoc.\n       */\n      @java.lang.Override\n      public double getPriceRoc() {\n        return priceRoc_;\n      }\n      /**\n       * <code>double price_roc = 8;</code>\n       * @param value The priceRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPriceRoc(double value) {\n\n        priceRoc_ = value;\n        bitField0_ |= 0x00000080;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double price_roc = 8;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPriceRoc() {\n        bitField0_ = (bitField0_ & ~0x00000080);\n        priceRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double volumeRoc_ ;\n      /**\n       * <code>double volume_roc = 9;</code>\n       * @return The volumeRoc.\n       */\n      @java.lang.Override\n      public double getVolumeRoc() {\n        return volumeRoc_;\n      }\n      /**\n       * <code>double volume_roc = 9;</code>\n       * @param value The volumeRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolumeRoc(double value) {\n\n        volumeRoc_ = value;\n        bitField0_ |= 0x00000100;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double volume_roc = 9;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolumeRoc() {\n        bitField0_ = (bitField0_ & ~0x00000100);\n        volumeRoc_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double obv_ ;\n      /**\n       * <code>double obv = 10;</code>\n       * @return The obv.\n       */\n      @java.lang.Override\n      public double getObv() {\n        return obv_;\n      }\n      /**\n       * <code>double obv = 10;</code>\n       * @param value The obv to set.\n       * @return This builder for chaining.\n       */\n      public Builder setObv(double value) {\n\n        obv_ = value;\n        bitField0_ |= 0x00000200;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double obv = 10;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearObv() {\n        bitField0_ = (bitField0_ & ~0x00000200);\n        obv_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double mfi_ ;\n      /**\n       * <code>double mfi = 11;</code>\n       * @return The mfi.\n       */\n      @java.lang.Override\n      public double getMfi() {\n        return mfi_;\n      }\n      /**\n       * <code>double mfi = 11;</code>\n       * @param value The mfi to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMfi(double value) {\n\n        mfi_ = value;\n        bitField0_ |= 0x00000400;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double mfi = 11;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMfi() {\n        bitField0_ = (bitField0_ & ~0x00000400);\n        mfi_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double bollingerPosition_ ;\n      /**\n       * <code>double bollinger_position = 12;</code>\n       * @return The bollingerPosition.\n       */\n      @java.lang.Override\n      public double getBollingerPosition() {\n        return bollingerPosition_;\n      }\n      /**\n       * <code>double bollinger_position = 12;</code>\n       * @param value The bollingerPosition to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBollingerPosition(double value) {\n\n        bollingerPosition_ = value;\n        bitField0_ |= 0x00000800;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double bollinger_position = 12;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBollingerPosition() {\n        bitField0_ = (bitField0_ & ~0x00000800);\n        bollingerPosition_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double percentB_ ;\n      /**\n       * <code>double percent_b = 13;</code>\n       * @return The percentB.\n       */\n      @java.lang.Override\n      public double getPercentB() {\n        return percentB_;\n      }\n      /**\n       * <code>double percent_b = 13;</code>\n       * @param value The percentB to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPercentB(double value) {\n\n        percentB_ = value;\n        bitField0_ |= 0x00001000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double percent_b = 13;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPercentB() {\n        bitField0_ = (bitField0_ & ~0x00001000);\n        percentB_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double vwap_ ;\n      /**\n       * <code>double vwap = 14;</code>\n       * @return The vwap.\n       */\n      @java.lang.Override\n      public double getVwap() {\n        return vwap_;\n      }\n      /**\n       * <code>double vwap = 14;</code>\n       * @param value The vwap to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVwap(double value) {\n\n        vwap_ = value;\n        bitField0_ |= 0x00002000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double vwap = 14;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVwap() {\n        bitField0_ = (bitField0_ & ~0x00002000);\n        vwap_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private com.spiketrade.proto.MarketDataProto.IndicatorsData indicators_;\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.MarketDataProto.IndicatorsData, com.spiketrade.proto.MarketDataProto.IndicatorsData.Builder, com.spiketrade.proto.MarketDataProto.IndicatorsDataOrBuilder> indicatorsBuilder_;\n      /**\n       * <pre>\n       * Full indicators data (includes all technical indicators)\n       * </pre>\n       *\n       * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n       * @return Whether the indicators field is set.\n       */\n      public boolean hasIndicators() {\n        return ((bitField0_ & 0x00004000) != 0);\n      }\n      /**\n       * <pre>\n       * Full indicators data (includes all technical indicators)\n       * </pre>\n       *\n       * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n       * @return The indicators.\n       */\n      public com.spiketrade.proto.MarketDataProto.IndicatorsData getIndicators() {\n        if (indicatorsBuilder_ == null) {\n          return indicators_ == null ? com.spiketrade.proto.MarketDataProto.IndicatorsData.getDefaultInstance() : indicators_;\n        } else {\n          return indicatorsBuilder_.getMessage();\n        }\n      }\n      /**\n       * <pre>\n       * Full indicators data (includes all technical indicators)\n       * </pre>\n       *\n       * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n       */\n      public Builder setIndicators(com.spiketrade.proto.MarketDataProto.IndicatorsData value) {\n        if (indicatorsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          indicators_ = value;\n        } else {\n          indicatorsBuilder_.setMessage(value);\n        }\n        bitField0_ |= 0x00004000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Full indicators data (includes all technical indicators)\n       * </pre>\n       *\n       * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n       */\n      public Builder setIndicators(\n          com.spiketrade.proto.MarketDataProto.IndicatorsData.Builder builderForValue) {\n        if (indicatorsBuilder_ == null) {\n          indicators_ = builderForValue.build();\n        } else {\n          indicatorsBuilder_.setMessage(builderForValue.build());\n        }\n        bitField0_ |= 0x00004000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Full indicators data (includes all technical indicators)\n       * </pre>\n       *\n       * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n       */\n      public Builder mergeIndicators(com.spiketrade.proto.MarketDataProto.IndicatorsData value) {\n        if (indicatorsBuilder_ == null) {\n          if (((bitField0_ & 0x00004000) != 0) &&\n            indicators_ != null &&\n            indicators_ != com.spiketrade.proto.MarketDataProto.IndicatorsData.getDefaultInstance()) {\n            getIndicatorsBuilder().mergeFrom(value);\n          } else {\n            indicators_ = value;\n          }\n        } else {\n          indicatorsBuilder_.mergeFrom(value);\n        }\n        if (indicators_ != null) {\n          bitField0_ |= 0x00004000;\n          onChanged();\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Full indicators data (includes all technical indicators)\n       * </pre>\n       *\n       * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n       */\n      public Builder clearIndicators() {\n        bitField0_ = (bitField0_ & ~0x00004000);\n        indicators_ = null;\n        if (indicatorsBuilder_ != null) {\n          indicatorsBuilder_.dispose();\n          indicatorsBuilder_ = null;\n        }\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Full indicators data (includes all technical indicators)\n       * </pre>\n       *\n       * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n       */\n      public com.spiketrade.proto.MarketDataProto.IndicatorsData.Builder getIndicatorsBuilder() {\n        bitField0_ |= 0x00004000;\n        onChanged();\n        return getIndicatorsFieldBuilder().getBuilder();\n      }\n      /**\n       * <pre>\n       * Full indicators data (includes all technical indicators)\n       * </pre>\n       *\n       * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n       */\n      public com.spiketrade.proto.MarketDataProto.IndicatorsDataOrBuilder getIndicatorsOrBuilder() {\n        if (indicatorsBuilder_ != null) {\n          return indicatorsBuilder_.getMessageOrBuilder();\n        } else {\n          return indicators_ == null ?\n              com.spiketrade.proto.MarketDataProto.IndicatorsData.getDefaultInstance() : indicators_;\n        }\n      }\n      /**\n       * <pre>\n       * Full indicators data (includes all technical indicators)\n       * </pre>\n       *\n       * <code>optional .spiketrade.proto.IndicatorsData indicators = 15;</code>\n       */\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.MarketDataProto.IndicatorsData, com.spiketrade.proto.MarketDataProto.IndicatorsData.Builder, com.spiketrade.proto.MarketDataProto.IndicatorsDataOrBuilder> \n          getIndicatorsFieldBuilder() {\n        if (indicatorsBuilder_ == null) {\n          indicatorsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<\n              com.spiketrade.proto.MarketDataProto.IndicatorsData, com.spiketrade.proto.MarketDataProto.IndicatorsData.Builder, com.spiketrade.proto.MarketDataProto.IndicatorsDataOrBuilder>(\n                  getIndicators(),\n                  getParentForChildren(),\n                  isClean());\n          indicators_ = null;\n        }\n        return indicatorsBuilder_;\n      }\n\n      private double signalProbability_ ;\n      /**\n       * <pre>\n       * Buy signal probability (0.0 to 1.0) - continuously calculated\n       * </pre>\n       *\n       * <code>optional double signal_probability = 16;</code>\n       * @return Whether the signalProbability field is set.\n       */\n      @java.lang.Override\n      public boolean hasSignalProbability() {\n        return ((bitField0_ & 0x00008000) != 0);\n      }\n      /**\n       * <pre>\n       * Buy signal probability (0.0 to 1.0) - continuously calculated\n       * </pre>\n       *\n       * <code>optional double signal_probability = 16;</code>\n       * @return The signalProbability.\n       */\n      @java.lang.Override\n      public double getSignalProbability() {\n        return signalProbability_;\n      }\n      /**\n       * <pre>\n       * Buy signal probability (0.0 to 1.0) - continuously calculated\n       * </pre>\n       *\n       * <code>optional double signal_probability = 16;</code>\n       * @param value The signalProbability to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSignalProbability(double value) {\n\n        signalProbability_ = value;\n        bitField0_ |= 0x00008000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Buy signal probability (0.0 to 1.0) - continuously calculated\n       * </pre>\n       *\n       * <code>optional double signal_probability = 16;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSignalProbability() {\n        bitField0_ = (bitField0_ & ~0x00008000);\n        signalProbability_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double atr_ ;\n      /**\n       * <pre>\n       * ATR for quick access\n       * </pre>\n       *\n       * <code>optional double atr = 17;</code>\n       * @return Whether the atr field is set.\n       */\n      @java.lang.Override\n      public boolean hasAtr() {\n        return ((bitField0_ & 0x00010000) != 0);\n      }\n      /**\n       * <pre>\n       * ATR for quick access\n       * </pre>\n       *\n       * <code>optional double atr = 17;</code>\n       * @return The atr.\n       */\n      @java.lang.Override\n      public double getAtr() {\n        return atr_;\n      }\n      /**\n       * <pre>\n       * ATR for quick access\n       * </pre>\n       *\n       * <code>optional double atr = 17;</code>\n       * @param value The atr to set.\n       * @return This builder for chaining.\n       */\n      public Builder setAtr(double value) {\n\n        atr_ = value;\n        bitField0_ |= 0x00010000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * ATR for quick access\n       * </pre>\n       *\n       * <code>optional double atr = 17;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearAtr() {\n        bitField0_ = (bitField0_ & ~0x00010000);\n        atr_ = 0D;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.Quote)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.Quote)\n    private static final com.spiketrade.proto.MarketDataProto.Quote DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.MarketDataProto.Quote();\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.Quote getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<Quote>\n        PARSER = new com.google.protobuf.AbstractParser<Quote>() {\n      @java.lang.Override\n      public Quote parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<Quote> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<Quote> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.Quote getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface CandleOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.Candle)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>int64 timestamp_ms = 1;</code>\n     * @return The timestampMs.\n     */\n    long getTimestampMs();\n\n    /**\n     * <code>double open = 2;</code>\n     * @return The open.\n     */\n    double getOpen();\n\n    /**\n     * <code>double high = 3;</code>\n     * @return The high.\n     */\n    double getHigh();\n\n    /**\n     * <code>double low = 4;</code>\n     * @return The low.\n     */\n    double getLow();\n\n    /**\n     * <code>double close = 5;</code>\n     * @return The close.\n     */\n    double getClose();\n\n    /**\n     * <code>int64 volume = 6;</code>\n     * @return The volume.\n     */\n    long getVolume();\n  }\n  /**\n   * <pre>\n   * OHLCV candle data\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.Candle}\n   */\n  public static final class Candle extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.Candle)\n      CandleOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use Candle.newBuilder() to construct.\n    private Candle(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private Candle() {\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new Candle();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_Candle_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_Candle_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.MarketDataProto.Candle.class, com.spiketrade.proto.MarketDataProto.Candle.Builder.class);\n    }\n\n    public static final int TIMESTAMP_MS_FIELD_NUMBER = 1;\n    private long timestampMs_ = 0L;\n    /**\n     * <code>int64 timestamp_ms = 1;</code>\n     * @return The timestampMs.\n     */\n    @java.lang.Override\n    public long getTimestampMs() {\n      return timestampMs_;\n    }\n\n    public static final int OPEN_FIELD_NUMBER = 2;\n    private double open_ = 0D;\n    /**\n     * <code>double open = 2;</code>\n     * @return The open.\n     */\n    @java.lang.Override\n    public double getOpen() {\n      return open_;\n    }\n\n    public static final int HIGH_FIELD_NUMBER = 3;\n    private double high_ = 0D;\n    /**\n     * <code>double high = 3;</code>\n     * @return The high.\n     */\n    @java.lang.Override\n    public double getHigh() {\n      return high_;\n    }\n\n    public static final int LOW_FIELD_NUMBER = 4;\n    private double low_ = 0D;\n    /**\n     * <code>double low = 4;</code>\n     * @return The low.\n     */\n    @java.lang.Override\n    public double getLow() {\n      return low_;\n    }\n\n    public static final int CLOSE_FIELD_NUMBER = 5;\n    private double close_ = 0D;\n    /**\n     * <code>double close = 5;</code>\n     * @return The close.\n     */\n    @java.lang.Override\n    public double getClose() {\n      return close_;\n    }\n\n    public static final int VOLUME_FIELD_NUMBER = 6;\n    private long volume_ = 0L;\n    /**\n     * <code>int64 volume = 6;</code>\n     * @return The volume.\n     */\n    @java.lang.Override\n    public long getVolume() {\n      return volume_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (timestampMs_ != 0L) {\n        output.writeInt64(1, timestampMs_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(open_) != 0) {\n        output.writeDouble(2, open_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(high_) != 0) {\n        output.writeDouble(3, high_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(low_) != 0) {\n        output.writeDouble(4, low_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(close_) != 0) {\n        output.writeDouble(5, close_);\n      }\n      if (volume_ != 0L) {\n        output.writeInt64(6, volume_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (timestampMs_ != 0L) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt64Size(1, timestampMs_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(open_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(2, open_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(high_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(3, high_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(low_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(4, low_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(close_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(5, close_);\n      }\n      if (volume_ != 0L) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt64Size(6, volume_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.MarketDataProto.Candle)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.MarketDataProto.Candle other = (com.spiketrade.proto.MarketDataProto.Candle) obj;\n\n      if (getTimestampMs()\n          != other.getTimestampMs()) return false;\n      if (java.lang.Double.doubleToLongBits(getOpen())\n          != java.lang.Double.doubleToLongBits(\n              other.getOpen())) return false;\n      if (java.lang.Double.doubleToLongBits(getHigh())\n          != java.lang.Double.doubleToLongBits(\n              other.getHigh())) return false;\n      if (java.lang.Double.doubleToLongBits(getLow())\n          != java.lang.Double.doubleToLongBits(\n              other.getLow())) return false;\n      if (java.lang.Double.doubleToLongBits(getClose())\n          != java.lang.Double.doubleToLongBits(\n              other.getClose())) return false;\n      if (getVolume()\n          != other.getVolume()) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + TIMESTAMP_MS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          getTimestampMs());\n      hash = (37 * hash) + OPEN_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getOpen()));\n      hash = (37 * hash) + HIGH_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getHigh()));\n      hash = (37 * hash) + LOW_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getLow()));\n      hash = (37 * hash) + CLOSE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getClose()));\n      hash = (37 * hash) + VOLUME_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          getVolume());\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.Candle parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Candle parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Candle parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Candle parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Candle parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Candle parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Candle parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Candle parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.Candle parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.Candle parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Candle parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.Candle parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.MarketDataProto.Candle prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * OHLCV candle data\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.Candle}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.Candle)\n        com.spiketrade.proto.MarketDataProto.CandleOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_Candle_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_Candle_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.MarketDataProto.Candle.class, com.spiketrade.proto.MarketDataProto.Candle.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.MarketDataProto.Candle.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        timestampMs_ = 0L;\n        open_ = 0D;\n        high_ = 0D;\n        low_ = 0D;\n        close_ = 0D;\n        volume_ = 0L;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_Candle_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.Candle getDefaultInstanceForType() {\n        return com.spiketrade.proto.MarketDataProto.Candle.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.Candle build() {\n        com.spiketrade.proto.MarketDataProto.Candle result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.Candle buildPartial() {\n        com.spiketrade.proto.MarketDataProto.Candle result = new com.spiketrade.proto.MarketDataProto.Candle(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.MarketDataProto.Candle result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.timestampMs_ = timestampMs_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.open_ = open_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.high_ = high_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.low_ = low_;\n        }\n        if (((from_bitField0_ & 0x00000010) != 0)) {\n          result.close_ = close_;\n        }\n        if (((from_bitField0_ & 0x00000020) != 0)) {\n          result.volume_ = volume_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.MarketDataProto.Candle) {\n          return mergeFrom((com.spiketrade.proto.MarketDataProto.Candle)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.MarketDataProto.Candle other) {\n        if (other == com.spiketrade.proto.MarketDataProto.Candle.getDefaultInstance()) return this;\n        if (other.getTimestampMs() != 0L) {\n          setTimestampMs(other.getTimestampMs());\n        }\n        if (other.getOpen() != 0D) {\n          setOpen(other.getOpen());\n        }\n        if (other.getHigh() != 0D) {\n          setHigh(other.getHigh());\n        }\n        if (other.getLow() != 0D) {\n          setLow(other.getLow());\n        }\n        if (other.getClose() != 0D) {\n          setClose(other.getClose());\n        }\n        if (other.getVolume() != 0L) {\n          setVolume(other.getVolume());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 8: {\n                timestampMs_ = input.readInt64();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 8\n              case 17: {\n                open_ = input.readDouble();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 17\n              case 25: {\n                high_ = input.readDouble();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 25\n              case 33: {\n                low_ = input.readDouble();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 33\n              case 41: {\n                close_ = input.readDouble();\n                bitField0_ |= 0x00000010;\n                break;\n              } // case 41\n              case 48: {\n                volume_ = input.readInt64();\n                bitField0_ |= 0x00000020;\n                break;\n              } // case 48\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private long timestampMs_ ;\n      /**\n       * <code>int64 timestamp_ms = 1;</code>\n       * @return The timestampMs.\n       */\n      @java.lang.Override\n      public long getTimestampMs() {\n        return timestampMs_;\n      }\n      /**\n       * <code>int64 timestamp_ms = 1;</code>\n       * @param value The timestampMs to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTimestampMs(long value) {\n\n        timestampMs_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int64 timestamp_ms = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTimestampMs() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        timestampMs_ = 0L;\n        onChanged();\n        return this;\n      }\n\n      private double open_ ;\n      /**\n       * <code>double open = 2;</code>\n       * @return The open.\n       */\n      @java.lang.Override\n      public double getOpen() {\n        return open_;\n      }\n      /**\n       * <code>double open = 2;</code>\n       * @param value The open to set.\n       * @return This builder for chaining.\n       */\n      public Builder setOpen(double value) {\n\n        open_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double open = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearOpen() {\n        bitField0_ = (bitField0_ & ~0x00000002);\n        open_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double high_ ;\n      /**\n       * <code>double high = 3;</code>\n       * @return The high.\n       */\n      @java.lang.Override\n      public double getHigh() {\n        return high_;\n      }\n      /**\n       * <code>double high = 3;</code>\n       * @param value The high to set.\n       * @return This builder for chaining.\n       */\n      public Builder setHigh(double value) {\n\n        high_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double high = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearHigh() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        high_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double low_ ;\n      /**\n       * <code>double low = 4;</code>\n       * @return The low.\n       */\n      @java.lang.Override\n      public double getLow() {\n        return low_;\n      }\n      /**\n       * <code>double low = 4;</code>\n       * @param value The low to set.\n       * @return This builder for chaining.\n       */\n      public Builder setLow(double value) {\n\n        low_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double low = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearLow() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        low_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double close_ ;\n      /**\n       * <code>double close = 5;</code>\n       * @return The close.\n       */\n      @java.lang.Override\n      public double getClose() {\n        return close_;\n      }\n      /**\n       * <code>double close = 5;</code>\n       * @param value The close to set.\n       * @return This builder for chaining.\n       */\n      public Builder setClose(double value) {\n\n        close_ = value;\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double close = 5;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearClose() {\n        bitField0_ = (bitField0_ & ~0x00000010);\n        close_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private long volume_ ;\n      /**\n       * <code>int64 volume = 6;</code>\n       * @return The volume.\n       */\n      @java.lang.Override\n      public long getVolume() {\n        return volume_;\n      }\n      /**\n       * <code>int64 volume = 6;</code>\n       * @param value The volume to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolume(long value) {\n\n        volume_ = value;\n        bitField0_ |= 0x00000020;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int64 volume = 6;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolume() {\n        bitField0_ = (bitField0_ & ~0x00000020);\n        volume_ = 0L;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.Candle)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.Candle)\n    private static final com.spiketrade.proto.MarketDataProto.Candle DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.MarketDataProto.Candle();\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.Candle getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<Candle>\n        PARSER = new com.google.protobuf.AbstractParser<Candle>() {\n      @java.lang.Override\n      public Candle parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<Candle> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<Candle> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.Candle getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface HistoricalDataRequestOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.HistoricalDataRequest)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    java.lang.String getSymbol();\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    com.google.protobuf.ByteString\n        getSymbolBytes();\n\n    /**\n     * <code>int32 interval_minutes = 2;</code>\n     * @return The intervalMinutes.\n     */\n    int getIntervalMinutes();\n\n    /**\n     * <code>int32 num_bars = 3;</code>\n     * @return The numBars.\n     */\n    int getNumBars();\n  }\n  /**\n   * <pre>\n   * Historical market data request\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.HistoricalDataRequest}\n   */\n  public static final class HistoricalDataRequest extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.HistoricalDataRequest)\n      HistoricalDataRequestOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use HistoricalDataRequest.newBuilder() to construct.\n    private HistoricalDataRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private HistoricalDataRequest() {\n      symbol_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new HistoricalDataRequest();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_HistoricalDataRequest_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_HistoricalDataRequest_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.MarketDataProto.HistoricalDataRequest.class, com.spiketrade.proto.MarketDataProto.HistoricalDataRequest.Builder.class);\n    }\n\n    public static final int SYMBOL_FIELD_NUMBER = 1;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object symbol_ = \"\";\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    @java.lang.Override\n    public java.lang.String getSymbol() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        symbol_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getSymbolBytes() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        symbol_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int INTERVAL_MINUTES_FIELD_NUMBER = 2;\n    private int intervalMinutes_ = 0;\n    /**\n     * <code>int32 interval_minutes = 2;</code>\n     * @return The intervalMinutes.\n     */\n    @java.lang.Override\n    public int getIntervalMinutes() {\n      return intervalMinutes_;\n    }\n\n    public static final int NUM_BARS_FIELD_NUMBER = 3;\n    private int numBars_ = 0;\n    /**\n     * <code>int32 num_bars = 3;</code>\n     * @return The numBars.\n     */\n    @java.lang.Override\n    public int getNumBars() {\n      return numBars_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, symbol_);\n      }\n      if (intervalMinutes_ != 0) {\n        output.writeInt32(2, intervalMinutes_);\n      }\n      if (numBars_ != 0) {\n        output.writeInt32(3, numBars_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, symbol_);\n      }\n      if (intervalMinutes_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(2, intervalMinutes_);\n      }\n      if (numBars_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(3, numBars_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.MarketDataProto.HistoricalDataRequest)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.MarketDataProto.HistoricalDataRequest other = (com.spiketrade.proto.MarketDataProto.HistoricalDataRequest) obj;\n\n      if (!getSymbol()\n          .equals(other.getSymbol())) return false;\n      if (getIntervalMinutes()\n          != other.getIntervalMinutes()) return false;\n      if (getNumBars()\n          != other.getNumBars()) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + SYMBOL_FIELD_NUMBER;\n      hash = (53 * hash) + getSymbol().hashCode();\n      hash = (37 * hash) + INTERVAL_MINUTES_FIELD_NUMBER;\n      hash = (53 * hash) + getIntervalMinutes();\n      hash = (37 * hash) + NUM_BARS_FIELD_NUMBER;\n      hash = (53 * hash) + getNumBars();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataRequest parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataRequest parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataRequest parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataRequest parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataRequest parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataRequest parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataRequest parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataRequest parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataRequest parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataRequest parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataRequest parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataRequest parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.MarketDataProto.HistoricalDataRequest prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Historical market data request\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.HistoricalDataRequest}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.HistoricalDataRequest)\n        com.spiketrade.proto.MarketDataProto.HistoricalDataRequestOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_HistoricalDataRequest_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_HistoricalDataRequest_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.MarketDataProto.HistoricalDataRequest.class, com.spiketrade.proto.MarketDataProto.HistoricalDataRequest.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.MarketDataProto.HistoricalDataRequest.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        symbol_ = \"\";\n        intervalMinutes_ = 0;\n        numBars_ = 0;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_HistoricalDataRequest_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.HistoricalDataRequest getDefaultInstanceForType() {\n        return com.spiketrade.proto.MarketDataProto.HistoricalDataRequest.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.HistoricalDataRequest build() {\n        com.spiketrade.proto.MarketDataProto.HistoricalDataRequest result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.HistoricalDataRequest buildPartial() {\n        com.spiketrade.proto.MarketDataProto.HistoricalDataRequest result = new com.spiketrade.proto.MarketDataProto.HistoricalDataRequest(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.MarketDataProto.HistoricalDataRequest result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.symbol_ = symbol_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.intervalMinutes_ = intervalMinutes_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.numBars_ = numBars_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.MarketDataProto.HistoricalDataRequest) {\n          return mergeFrom((com.spiketrade.proto.MarketDataProto.HistoricalDataRequest)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.MarketDataProto.HistoricalDataRequest other) {\n        if (other == com.spiketrade.proto.MarketDataProto.HistoricalDataRequest.getDefaultInstance()) return this;\n        if (!other.getSymbol().isEmpty()) {\n          symbol_ = other.symbol_;\n          bitField0_ |= 0x00000001;\n          onChanged();\n        }\n        if (other.getIntervalMinutes() != 0) {\n          setIntervalMinutes(other.getIntervalMinutes());\n        }\n        if (other.getNumBars() != 0) {\n          setNumBars(other.getNumBars());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 10: {\n                symbol_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 10\n              case 16: {\n                intervalMinutes_ = input.readInt32();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 16\n              case 24: {\n                numBars_ = input.readInt32();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 24\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private java.lang.Object symbol_ = \"\";\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The symbol.\n       */\n      public java.lang.String getSymbol() {\n        java.lang.Object ref = symbol_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          symbol_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The bytes for symbol.\n       */\n      public com.google.protobuf.ByteString\n          getSymbolBytes() {\n        java.lang.Object ref = symbol_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          symbol_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbol(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSymbol() {\n        symbol_ = getDefaultInstance().getSymbol();\n        bitField0_ = (bitField0_ & ~0x00000001);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The bytes for symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbolBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n\n      private int intervalMinutes_ ;\n      /**\n       * <code>int32 interval_minutes = 2;</code>\n       * @return The intervalMinutes.\n       */\n      @java.lang.Override\n      public int getIntervalMinutes() {\n        return intervalMinutes_;\n      }\n      /**\n       * <code>int32 interval_minutes = 2;</code>\n       * @param value The intervalMinutes to set.\n       * @return This builder for chaining.\n       */\n      public Builder setIntervalMinutes(int value) {\n\n        intervalMinutes_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 interval_minutes = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearIntervalMinutes() {\n        bitField0_ = (bitField0_ & ~0x00000002);\n        intervalMinutes_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int numBars_ ;\n      /**\n       * <code>int32 num_bars = 3;</code>\n       * @return The numBars.\n       */\n      @java.lang.Override\n      public int getNumBars() {\n        return numBars_;\n      }\n      /**\n       * <code>int32 num_bars = 3;</code>\n       * @param value The numBars to set.\n       * @return This builder for chaining.\n       */\n      public Builder setNumBars(int value) {\n\n        numBars_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 num_bars = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearNumBars() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        numBars_ = 0;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.HistoricalDataRequest)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.HistoricalDataRequest)\n    private static final com.spiketrade.proto.MarketDataProto.HistoricalDataRequest DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.MarketDataProto.HistoricalDataRequest();\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataRequest getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<HistoricalDataRequest>\n        PARSER = new com.google.protobuf.AbstractParser<HistoricalDataRequest>() {\n      @java.lang.Override\n      public HistoricalDataRequest parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<HistoricalDataRequest> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<HistoricalDataRequest> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.HistoricalDataRequest getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface HistoricalDataResponseOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.HistoricalDataResponse)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    java.lang.String getSymbol();\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    com.google.protobuf.ByteString\n        getSymbolBytes();\n\n    /**\n     * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n     */\n    java.util.List<com.spiketrade.proto.MarketDataProto.Candle> \n        getCandlesList();\n    /**\n     * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n     */\n    com.spiketrade.proto.MarketDataProto.Candle getCandles(int index);\n    /**\n     * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n     */\n    int getCandlesCount();\n    /**\n     * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n     */\n    java.util.List<? extends com.spiketrade.proto.MarketDataProto.CandleOrBuilder> \n        getCandlesOrBuilderList();\n    /**\n     * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n     */\n    com.spiketrade.proto.MarketDataProto.CandleOrBuilder getCandlesOrBuilder(\n        int index);\n\n    /**\n     * <code>string error_message = 3;</code>\n     * @return The errorMessage.\n     */\n    java.lang.String getErrorMessage();\n    /**\n     * <code>string error_message = 3;</code>\n     * @return The bytes for errorMessage.\n     */\n    com.google.protobuf.ByteString\n        getErrorMessageBytes();\n  }\n  /**\n   * <pre>\n   * Historical market data response\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.HistoricalDataResponse}\n   */\n  public static final class HistoricalDataResponse extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.HistoricalDataResponse)\n      HistoricalDataResponseOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use HistoricalDataResponse.newBuilder() to construct.\n    private HistoricalDataResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private HistoricalDataResponse() {\n      symbol_ = \"\";\n      candles_ = java.util.Collections.emptyList();\n      errorMessage_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new HistoricalDataResponse();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_HistoricalDataResponse_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_HistoricalDataResponse_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.MarketDataProto.HistoricalDataResponse.class, com.spiketrade.proto.MarketDataProto.HistoricalDataResponse.Builder.class);\n    }\n\n    public static final int SYMBOL_FIELD_NUMBER = 1;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object symbol_ = \"\";\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The symbol.\n     */\n    @java.lang.Override\n    public java.lang.String getSymbol() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        symbol_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string symbol = 1;</code>\n     * @return The bytes for symbol.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getSymbolBytes() {\n      java.lang.Object ref = symbol_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        symbol_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int CANDLES_FIELD_NUMBER = 2;\n    @SuppressWarnings(\"serial\")\n    private java.util.List<com.spiketrade.proto.MarketDataProto.Candle> candles_;\n    /**\n     * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n     */\n    @java.lang.Override\n    public java.util.List<com.spiketrade.proto.MarketDataProto.Candle> getCandlesList() {\n      return candles_;\n    }\n    /**\n     * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n     */\n    @java.lang.Override\n    public java.util.List<? extends com.spiketrade.proto.MarketDataProto.CandleOrBuilder> \n        getCandlesOrBuilderList() {\n      return candles_;\n    }\n    /**\n     * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n     */\n    @java.lang.Override\n    public int getCandlesCount() {\n      return candles_.size();\n    }\n    /**\n     * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.Candle getCandles(int index) {\n      return candles_.get(index);\n    }\n    /**\n     * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.CandleOrBuilder getCandlesOrBuilder(\n        int index) {\n      return candles_.get(index);\n    }\n\n    public static final int ERROR_MESSAGE_FIELD_NUMBER = 3;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object errorMessage_ = \"\";\n    /**\n     * <code>string error_message = 3;</code>\n     * @return The errorMessage.\n     */\n    @java.lang.Override\n    public java.lang.String getErrorMessage() {\n      java.lang.Object ref = errorMessage_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        errorMessage_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string error_message = 3;</code>\n     * @return The bytes for errorMessage.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getErrorMessageBytes() {\n      java.lang.Object ref = errorMessage_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        errorMessage_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, symbol_);\n      }\n      for (int i = 0; i < candles_.size(); i++) {\n        output.writeMessage(2, candles_.get(i));\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, errorMessage_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbol_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, symbol_);\n      }\n      for (int i = 0; i < candles_.size(); i++) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(2, candles_.get(i));\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, errorMessage_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.MarketDataProto.HistoricalDataResponse)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.MarketDataProto.HistoricalDataResponse other = (com.spiketrade.proto.MarketDataProto.HistoricalDataResponse) obj;\n\n      if (!getSymbol()\n          .equals(other.getSymbol())) return false;\n      if (!getCandlesList()\n          .equals(other.getCandlesList())) return false;\n      if (!getErrorMessage()\n          .equals(other.getErrorMessage())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + SYMBOL_FIELD_NUMBER;\n      hash = (53 * hash) + getSymbol().hashCode();\n      if (getCandlesCount() > 0) {\n        hash = (37 * hash) + CANDLES_FIELD_NUMBER;\n        hash = (53 * hash) + getCandlesList().hashCode();\n      }\n      hash = (37 * hash) + ERROR_MESSAGE_FIELD_NUMBER;\n      hash = (53 * hash) + getErrorMessage().hashCode();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataResponse parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataResponse parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataResponse parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataResponse parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataResponse parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataResponse parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataResponse parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataResponse parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataResponse parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataResponse parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataResponse parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataResponse parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.MarketDataProto.HistoricalDataResponse prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Historical market data response\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.HistoricalDataResponse}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.HistoricalDataResponse)\n        com.spiketrade.proto.MarketDataProto.HistoricalDataResponseOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_HistoricalDataResponse_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_HistoricalDataResponse_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.MarketDataProto.HistoricalDataResponse.class, com.spiketrade.proto.MarketDataProto.HistoricalDataResponse.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.MarketDataProto.HistoricalDataResponse.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        symbol_ = \"\";\n        if (candlesBuilder_ == null) {\n          candles_ = java.util.Collections.emptyList();\n        } else {\n          candles_ = null;\n          candlesBuilder_.clear();\n        }\n        bitField0_ = (bitField0_ & ~0x00000002);\n        errorMessage_ = \"\";\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_HistoricalDataResponse_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.HistoricalDataResponse getDefaultInstanceForType() {\n        return com.spiketrade.proto.MarketDataProto.HistoricalDataResponse.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.HistoricalDataResponse build() {\n        com.spiketrade.proto.MarketDataProto.HistoricalDataResponse result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.HistoricalDataResponse buildPartial() {\n        com.spiketrade.proto.MarketDataProto.HistoricalDataResponse result = new com.spiketrade.proto.MarketDataProto.HistoricalDataResponse(this);\n        buildPartialRepeatedFields(result);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartialRepeatedFields(com.spiketrade.proto.MarketDataProto.HistoricalDataResponse result) {\n        if (candlesBuilder_ == null) {\n          if (((bitField0_ & 0x00000002) != 0)) {\n            candles_ = java.util.Collections.unmodifiableList(candles_);\n            bitField0_ = (bitField0_ & ~0x00000002);\n          }\n          result.candles_ = candles_;\n        } else {\n          result.candles_ = candlesBuilder_.build();\n        }\n      }\n\n      private void buildPartial0(com.spiketrade.proto.MarketDataProto.HistoricalDataResponse result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.symbol_ = symbol_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.errorMessage_ = errorMessage_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.MarketDataProto.HistoricalDataResponse) {\n          return mergeFrom((com.spiketrade.proto.MarketDataProto.HistoricalDataResponse)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.MarketDataProto.HistoricalDataResponse other) {\n        if (other == com.spiketrade.proto.MarketDataProto.HistoricalDataResponse.getDefaultInstance()) return this;\n        if (!other.getSymbol().isEmpty()) {\n          symbol_ = other.symbol_;\n          bitField0_ |= 0x00000001;\n          onChanged();\n        }\n        if (candlesBuilder_ == null) {\n          if (!other.candles_.isEmpty()) {\n            if (candles_.isEmpty()) {\n              candles_ = other.candles_;\n              bitField0_ = (bitField0_ & ~0x00000002);\n            } else {\n              ensureCandlesIsMutable();\n              candles_.addAll(other.candles_);\n            }\n            onChanged();\n          }\n        } else {\n          if (!other.candles_.isEmpty()) {\n            if (candlesBuilder_.isEmpty()) {\n              candlesBuilder_.dispose();\n              candlesBuilder_ = null;\n              candles_ = other.candles_;\n              bitField0_ = (bitField0_ & ~0x00000002);\n              candlesBuilder_ = \n                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?\n                   getCandlesFieldBuilder() : null;\n            } else {\n              candlesBuilder_.addAllMessages(other.candles_);\n            }\n          }\n        }\n        if (!other.getErrorMessage().isEmpty()) {\n          errorMessage_ = other.errorMessage_;\n          bitField0_ |= 0x00000004;\n          onChanged();\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 10: {\n                symbol_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 10\n              case 18: {\n                com.spiketrade.proto.MarketDataProto.Candle m =\n                    input.readMessage(\n                        com.spiketrade.proto.MarketDataProto.Candle.parser(),\n                        extensionRegistry);\n                if (candlesBuilder_ == null) {\n                  ensureCandlesIsMutable();\n                  candles_.add(m);\n                } else {\n                  candlesBuilder_.addMessage(m);\n                }\n                break;\n              } // case 18\n              case 26: {\n                errorMessage_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 26\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private java.lang.Object symbol_ = \"\";\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The symbol.\n       */\n      public java.lang.String getSymbol() {\n        java.lang.Object ref = symbol_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          symbol_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return The bytes for symbol.\n       */\n      public com.google.protobuf.ByteString\n          getSymbolBytes() {\n        java.lang.Object ref = symbol_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          symbol_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbol(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSymbol() {\n        symbol_ = getDefaultInstance().getSymbol();\n        bitField0_ = (bitField0_ & ~0x00000001);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string symbol = 1;</code>\n       * @param value The bytes for symbol to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbolBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        symbol_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n\n      private java.util.List<com.spiketrade.proto.MarketDataProto.Candle> candles_ =\n        java.util.Collections.emptyList();\n      private void ensureCandlesIsMutable() {\n        if (!((bitField0_ & 0x00000002) != 0)) {\n          candles_ = new java.util.ArrayList<com.spiketrade.proto.MarketDataProto.Candle>(candles_);\n          bitField0_ |= 0x00000002;\n         }\n      }\n\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          com.spiketrade.proto.MarketDataProto.Candle, com.spiketrade.proto.MarketDataProto.Candle.Builder, com.spiketrade.proto.MarketDataProto.CandleOrBuilder> candlesBuilder_;\n\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public java.util.List<com.spiketrade.proto.MarketDataProto.Candle> getCandlesList() {\n        if (candlesBuilder_ == null) {\n          return java.util.Collections.unmodifiableList(candles_);\n        } else {\n          return candlesBuilder_.getMessageList();\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public int getCandlesCount() {\n        if (candlesBuilder_ == null) {\n          return candles_.size();\n        } else {\n          return candlesBuilder_.getCount();\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public com.spiketrade.proto.MarketDataProto.Candle getCandles(int index) {\n        if (candlesBuilder_ == null) {\n          return candles_.get(index);\n        } else {\n          return candlesBuilder_.getMessage(index);\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public Builder setCandles(\n          int index, com.spiketrade.proto.MarketDataProto.Candle value) {\n        if (candlesBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureCandlesIsMutable();\n          candles_.set(index, value);\n          onChanged();\n        } else {\n          candlesBuilder_.setMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public Builder setCandles(\n          int index, com.spiketrade.proto.MarketDataProto.Candle.Builder builderForValue) {\n        if (candlesBuilder_ == null) {\n          ensureCandlesIsMutable();\n          candles_.set(index, builderForValue.build());\n          onChanged();\n        } else {\n          candlesBuilder_.setMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public Builder addCandles(com.spiketrade.proto.MarketDataProto.Candle value) {\n        if (candlesBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureCandlesIsMutable();\n          candles_.add(value);\n          onChanged();\n        } else {\n          candlesBuilder_.addMessage(value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public Builder addCandles(\n          int index, com.spiketrade.proto.MarketDataProto.Candle value) {\n        if (candlesBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureCandlesIsMutable();\n          candles_.add(index, value);\n          onChanged();\n        } else {\n          candlesBuilder_.addMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public Builder addCandles(\n          com.spiketrade.proto.MarketDataProto.Candle.Builder builderForValue) {\n        if (candlesBuilder_ == null) {\n          ensureCandlesIsMutable();\n          candles_.add(builderForValue.build());\n          onChanged();\n        } else {\n          candlesBuilder_.addMessage(builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public Builder addCandles(\n          int index, com.spiketrade.proto.MarketDataProto.Candle.Builder builderForValue) {\n        if (candlesBuilder_ == null) {\n          ensureCandlesIsMutable();\n          candles_.add(index, builderForValue.build());\n          onChanged();\n        } else {\n          candlesBuilder_.addMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public Builder addAllCandles(\n          java.lang.Iterable<? extends com.spiketrade.proto.MarketDataProto.Candle> values) {\n        if (candlesBuilder_ == null) {\n          ensureCandlesIsMutable();\n          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n              values, candles_);\n          onChanged();\n        } else {\n          candlesBuilder_.addAllMessages(values);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public Builder clearCandles() {\n        if (candlesBuilder_ == null) {\n          candles_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000002);\n          onChanged();\n        } else {\n          candlesBuilder_.clear();\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public Builder removeCandles(int index) {\n        if (candlesBuilder_ == null) {\n          ensureCandlesIsMutable();\n          candles_.remove(index);\n          onChanged();\n        } else {\n          candlesBuilder_.remove(index);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public com.spiketrade.proto.MarketDataProto.Candle.Builder getCandlesBuilder(\n          int index) {\n        return getCandlesFieldBuilder().getBuilder(index);\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public com.spiketrade.proto.MarketDataProto.CandleOrBuilder getCandlesOrBuilder(\n          int index) {\n        if (candlesBuilder_ == null) {\n          return candles_.get(index);  } else {\n          return candlesBuilder_.getMessageOrBuilder(index);\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public java.util.List<? extends com.spiketrade.proto.MarketDataProto.CandleOrBuilder> \n           getCandlesOrBuilderList() {\n        if (candlesBuilder_ != null) {\n          return candlesBuilder_.getMessageOrBuilderList();\n        } else {\n          return java.util.Collections.unmodifiableList(candles_);\n        }\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public com.spiketrade.proto.MarketDataProto.Candle.Builder addCandlesBuilder() {\n        return getCandlesFieldBuilder().addBuilder(\n            com.spiketrade.proto.MarketDataProto.Candle.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public com.spiketrade.proto.MarketDataProto.Candle.Builder addCandlesBuilder(\n          int index) {\n        return getCandlesFieldBuilder().addBuilder(\n            index, com.spiketrade.proto.MarketDataProto.Candle.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .spiketrade.proto.Candle candles = 2;</code>\n       */\n      public java.util.List<com.spiketrade.proto.MarketDataProto.Candle.Builder> \n           getCandlesBuilderList() {\n        return getCandlesFieldBuilder().getBuilderList();\n      }\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          com.spiketrade.proto.MarketDataProto.Candle, com.spiketrade.proto.MarketDataProto.Candle.Builder, com.spiketrade.proto.MarketDataProto.CandleOrBuilder> \n          getCandlesFieldBuilder() {\n        if (candlesBuilder_ == null) {\n          candlesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<\n              com.spiketrade.proto.MarketDataProto.Candle, com.spiketrade.proto.MarketDataProto.Candle.Builder, com.spiketrade.proto.MarketDataProto.CandleOrBuilder>(\n                  candles_,\n                  ((bitField0_ & 0x00000002) != 0),\n                  getParentForChildren(),\n                  isClean());\n          candles_ = null;\n        }\n        return candlesBuilder_;\n      }\n\n      private java.lang.Object errorMessage_ = \"\";\n      /**\n       * <code>string error_message = 3;</code>\n       * @return The errorMessage.\n       */\n      public java.lang.String getErrorMessage() {\n        java.lang.Object ref = errorMessage_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          errorMessage_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string error_message = 3;</code>\n       * @return The bytes for errorMessage.\n       */\n      public com.google.protobuf.ByteString\n          getErrorMessageBytes() {\n        java.lang.Object ref = errorMessage_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          errorMessage_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string error_message = 3;</code>\n       * @param value The errorMessage to set.\n       * @return This builder for chaining.\n       */\n      public Builder setErrorMessage(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        errorMessage_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string error_message = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearErrorMessage() {\n        errorMessage_ = getDefaultInstance().getErrorMessage();\n        bitField0_ = (bitField0_ & ~0x00000004);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string error_message = 3;</code>\n       * @param value The bytes for errorMessage to set.\n       * @return This builder for chaining.\n       */\n      public Builder setErrorMessageBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        errorMessage_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.HistoricalDataResponse)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.HistoricalDataResponse)\n    private static final com.spiketrade.proto.MarketDataProto.HistoricalDataResponse DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.MarketDataProto.HistoricalDataResponse();\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.HistoricalDataResponse getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<HistoricalDataResponse>\n        PARSER = new com.google.protobuf.AbstractParser<HistoricalDataResponse>() {\n      @java.lang.Override\n      public HistoricalDataResponse parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<HistoricalDataResponse> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<HistoricalDataResponse> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.HistoricalDataResponse getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface QuoteStreamRequestOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.QuoteStreamRequest)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @return A list containing the symbols.\n     */\n    java.util.List<java.lang.String>\n        getSymbolsList();\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @return The count of symbols.\n     */\n    int getSymbolsCount();\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @param index The index of the element to return.\n     * @return The symbols at the given index.\n     */\n    java.lang.String getSymbols(int index);\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @param index The index of the value to return.\n     * @return The bytes of the symbols at the given index.\n     */\n    com.google.protobuf.ByteString\n        getSymbolsBytes(int index);\n  }\n  /**\n   * <pre>\n   * Real-time quote stream\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.QuoteStreamRequest}\n   */\n  public static final class QuoteStreamRequest extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.QuoteStreamRequest)\n      QuoteStreamRequestOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use QuoteStreamRequest.newBuilder() to construct.\n    private QuoteStreamRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private QuoteStreamRequest() {\n      symbols_ =\n          com.google.protobuf.LazyStringArrayList.emptyList();\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new QuoteStreamRequest();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_QuoteStreamRequest_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_QuoteStreamRequest_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.MarketDataProto.QuoteStreamRequest.class, com.spiketrade.proto.MarketDataProto.QuoteStreamRequest.Builder.class);\n    }\n\n    public static final int SYMBOLS_FIELD_NUMBER = 1;\n    @SuppressWarnings(\"serial\")\n    private com.google.protobuf.LazyStringArrayList symbols_ =\n        com.google.protobuf.LazyStringArrayList.emptyList();\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @return A list containing the symbols.\n     */\n    public com.google.protobuf.ProtocolStringList\n        getSymbolsList() {\n      return symbols_;\n    }\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @return The count of symbols.\n     */\n    public int getSymbolsCount() {\n      return symbols_.size();\n    }\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @param index The index of the element to return.\n     * @return The symbols at the given index.\n     */\n    public java.lang.String getSymbols(int index) {\n      return symbols_.get(index);\n    }\n    /**\n     * <code>repeated string symbols = 1;</code>\n     * @param index The index of the value to return.\n     * @return The bytes of the symbols at the given index.\n     */\n    public com.google.protobuf.ByteString\n        getSymbolsBytes(int index) {\n      return symbols_.getByteString(index);\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      for (int i = 0; i < symbols_.size(); i++) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, symbols_.getRaw(i));\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      {\n        int dataSize = 0;\n        for (int i = 0; i < symbols_.size(); i++) {\n          dataSize += computeStringSizeNoTag(symbols_.getRaw(i));\n        }\n        size += dataSize;\n        size += 1 * getSymbolsList().size();\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.MarketDataProto.QuoteStreamRequest)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.MarketDataProto.QuoteStreamRequest other = (com.spiketrade.proto.MarketDataProto.QuoteStreamRequest) obj;\n\n      if (!getSymbolsList()\n          .equals(other.getSymbolsList())) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      if (getSymbolsCount() > 0) {\n        hash = (37 * hash) + SYMBOLS_FIELD_NUMBER;\n        hash = (53 * hash) + getSymbolsList().hashCode();\n      }\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.QuoteStreamRequest parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.QuoteStreamRequest parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.QuoteStreamRequest parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.QuoteStreamRequest parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.QuoteStreamRequest parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.QuoteStreamRequest parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.QuoteStreamRequest parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.QuoteStreamRequest parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.QuoteStreamRequest parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.QuoteStreamRequest parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.QuoteStreamRequest parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.QuoteStreamRequest parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.MarketDataProto.QuoteStreamRequest prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Real-time quote stream\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.QuoteStreamRequest}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.QuoteStreamRequest)\n        com.spiketrade.proto.MarketDataProto.QuoteStreamRequestOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_QuoteStreamRequest_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_QuoteStreamRequest_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.MarketDataProto.QuoteStreamRequest.class, com.spiketrade.proto.MarketDataProto.QuoteStreamRequest.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.MarketDataProto.QuoteStreamRequest.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        symbols_ =\n            com.google.protobuf.LazyStringArrayList.emptyList();\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_QuoteStreamRequest_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.QuoteStreamRequest getDefaultInstanceForType() {\n        return com.spiketrade.proto.MarketDataProto.QuoteStreamRequest.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.QuoteStreamRequest build() {\n        com.spiketrade.proto.MarketDataProto.QuoteStreamRequest result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.QuoteStreamRequest buildPartial() {\n        com.spiketrade.proto.MarketDataProto.QuoteStreamRequest result = new com.spiketrade.proto.MarketDataProto.QuoteStreamRequest(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.MarketDataProto.QuoteStreamRequest result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          symbols_.makeImmutable();\n          result.symbols_ = symbols_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.MarketDataProto.QuoteStreamRequest) {\n          return mergeFrom((com.spiketrade.proto.MarketDataProto.QuoteStreamRequest)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.MarketDataProto.QuoteStreamRequest other) {\n        if (other == com.spiketrade.proto.MarketDataProto.QuoteStreamRequest.getDefaultInstance()) return this;\n        if (!other.symbols_.isEmpty()) {\n          if (symbols_.isEmpty()) {\n            symbols_ = other.symbols_;\n            bitField0_ |= 0x00000001;\n          } else {\n            ensureSymbolsIsMutable();\n            symbols_.addAll(other.symbols_);\n          }\n          onChanged();\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 10: {\n                java.lang.String s = input.readStringRequireUtf8();\n                ensureSymbolsIsMutable();\n                symbols_.add(s);\n                break;\n              } // case 10\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private com.google.protobuf.LazyStringArrayList symbols_ =\n          com.google.protobuf.LazyStringArrayList.emptyList();\n      private void ensureSymbolsIsMutable() {\n        if (!symbols_.isModifiable()) {\n          symbols_ = new com.google.protobuf.LazyStringArrayList(symbols_);\n        }\n        bitField0_ |= 0x00000001;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @return A list containing the symbols.\n       */\n      public com.google.protobuf.ProtocolStringList\n          getSymbolsList() {\n        symbols_.makeImmutable();\n        return symbols_;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @return The count of symbols.\n       */\n      public int getSymbolsCount() {\n        return symbols_.size();\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param index The index of the element to return.\n       * @return The symbols at the given index.\n       */\n      public java.lang.String getSymbols(int index) {\n        return symbols_.get(index);\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param index The index of the value to return.\n       * @return The bytes of the symbols at the given index.\n       */\n      public com.google.protobuf.ByteString\n          getSymbolsBytes(int index) {\n        return symbols_.getByteString(index);\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param index The index to set the value at.\n       * @param value The symbols to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSymbols(\n          int index, java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        ensureSymbolsIsMutable();\n        symbols_.set(index, value);\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param value The symbols to add.\n       * @return This builder for chaining.\n       */\n      public Builder addSymbols(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        ensureSymbolsIsMutable();\n        symbols_.add(value);\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param values The symbols to add.\n       * @return This builder for chaining.\n       */\n      public Builder addAllSymbols(\n          java.lang.Iterable<java.lang.String> values) {\n        ensureSymbolsIsMutable();\n        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n            values, symbols_);\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSymbols() {\n        symbols_ =\n          com.google.protobuf.LazyStringArrayList.emptyList();\n        bitField0_ = (bitField0_ & ~0x00000001);;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string symbols = 1;</code>\n       * @param value The bytes of the symbols to add.\n       * @return This builder for chaining.\n       */\n      public Builder addSymbolsBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        ensureSymbolsIsMutable();\n        symbols_.add(value);\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.QuoteStreamRequest)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.QuoteStreamRequest)\n    private static final com.spiketrade.proto.MarketDataProto.QuoteStreamRequest DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.MarketDataProto.QuoteStreamRequest();\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.QuoteStreamRequest getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<QuoteStreamRequest>\n        PARSER = new com.google.protobuf.AbstractParser<QuoteStreamRequest>() {\n      @java.lang.Override\n      public QuoteStreamRequest parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<QuoteStreamRequest> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<QuoteStreamRequest> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.QuoteStreamRequest getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface ConnectionStatusOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.ConnectionStatus)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus.State state = 1;</code>\n     * @return The enum numeric value on the wire for state.\n     */\n    int getStateValue();\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus.State state = 1;</code>\n     * @return The state.\n     */\n    com.spiketrade.proto.MarketDataProto.ConnectionStatus.State getState();\n\n    /**\n     * <code>bool using_fallback = 2;</code>\n     * @return The usingFallback.\n     */\n    boolean getUsingFallback();\n\n    /**\n     * <code>string fallback_reason = 3;</code>\n     * @return The fallbackReason.\n     */\n    java.lang.String getFallbackReason();\n    /**\n     * <code>string fallback_reason = 3;</code>\n     * @return The bytes for fallbackReason.\n     */\n    com.google.protobuf.ByteString\n        getFallbackReasonBytes();\n\n    /**\n     * <code>int32 consecutive_failures = 4;</code>\n     * @return The consecutiveFailures.\n     */\n    int getConsecutiveFailures();\n  }\n  /**\n   * <pre>\n   * Connection status\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.ConnectionStatus}\n   */\n  public static final class ConnectionStatus extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.ConnectionStatus)\n      ConnectionStatusOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use ConnectionStatus.newBuilder() to construct.\n    private ConnectionStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private ConnectionStatus() {\n      state_ = 0;\n      fallbackReason_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new ConnectionStatus();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_ConnectionStatus_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_ConnectionStatus_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.MarketDataProto.ConnectionStatus.class, com.spiketrade.proto.MarketDataProto.ConnectionStatus.Builder.class);\n    }\n\n    /**\n     * Protobuf enum {@code spiketrade.proto.ConnectionStatus.State}\n     */\n    public enum State\n        implements com.google.protobuf.ProtocolMessageEnum {\n      /**\n       * <code>DISCONNECTED = 0;</code>\n       */\n      DISCONNECTED(0),\n      /**\n       * <code>CONNECTED = 1;</code>\n       */\n      CONNECTED(1),\n      /**\n       * <code>DEGRADED = 2;</code>\n       */\n      DEGRADED(2),\n      /**\n       * <code>FAILED = 3;</code>\n       */\n      FAILED(3),\n      UNRECOGNIZED(-1),\n      ;\n\n      /**\n       * <code>DISCONNECTED = 0;</code>\n       */\n      public static final int DISCONNECTED_VALUE = 0;\n      /**\n       * <code>CONNECTED = 1;</code>\n       */\n      public static final int CONNECTED_VALUE = 1;\n      /**\n       * <code>DEGRADED = 2;</code>\n       */\n      public static final int DEGRADED_VALUE = 2;\n      /**\n       * <code>FAILED = 3;</code>\n       */\n      public static final int FAILED_VALUE = 3;\n\n\n      public final int getNumber() {\n        if (this == UNRECOGNIZED) {\n          throw new java.lang.IllegalArgumentException(\n              \"Can't get the number of an unknown enum value.\");\n        }\n        return value;\n      }\n\n      /**\n       * @param value The numeric wire value of the corresponding enum entry.\n       * @return The enum associated with the given numeric wire value.\n       * @deprecated Use {@link #forNumber(int)} instead.\n       */\n      @java.lang.Deprecated\n      public static State valueOf(int value) {\n        return forNumber(value);\n      }\n\n      /**\n       * @param value The numeric wire value of the corresponding enum entry.\n       * @return The enum associated with the given numeric wire value.\n       */\n      public static State forNumber(int value) {\n        switch (value) {\n          case 0: return DISCONNECTED;\n          case 1: return CONNECTED;\n          case 2: return DEGRADED;\n          case 3: return FAILED;\n          default: return null;\n        }\n      }\n\n      public static com.google.protobuf.Internal.EnumLiteMap<State>\n          internalGetValueMap() {\n        return internalValueMap;\n      }\n      private static final com.google.protobuf.Internal.EnumLiteMap<\n          State> internalValueMap =\n            new com.google.protobuf.Internal.EnumLiteMap<State>() {\n              public State findValueByNumber(int number) {\n                return State.forNumber(number);\n              }\n            };\n\n      public final com.google.protobuf.Descriptors.EnumValueDescriptor\n          getValueDescriptor() {\n        if (this == UNRECOGNIZED) {\n          throw new java.lang.IllegalStateException(\n              \"Can't get the descriptor of an unrecognized enum value.\");\n        }\n        return getDescriptor().getValues().get(ordinal());\n      }\n      public final com.google.protobuf.Descriptors.EnumDescriptor\n          getDescriptorForType() {\n        return getDescriptor();\n      }\n      public static final com.google.protobuf.Descriptors.EnumDescriptor\n          getDescriptor() {\n        return com.spiketrade.proto.MarketDataProto.ConnectionStatus.getDescriptor().getEnumTypes().get(0);\n      }\n\n      private static final State[] VALUES = values();\n\n      public static State valueOf(\n          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n        if (desc.getType() != getDescriptor()) {\n          throw new java.lang.IllegalArgumentException(\n            \"EnumValueDescriptor is not for this type.\");\n        }\n        if (desc.getIndex() == -1) {\n          return UNRECOGNIZED;\n        }\n        return VALUES[desc.getIndex()];\n      }\n\n      private final int value;\n\n      private State(int value) {\n        this.value = value;\n      }\n\n      // @@protoc_insertion_point(enum_scope:spiketrade.proto.ConnectionStatus.State)\n    }\n\n    public static final int STATE_FIELD_NUMBER = 1;\n    private int state_ = 0;\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus.State state = 1;</code>\n     * @return The enum numeric value on the wire for state.\n     */\n    @java.lang.Override public int getStateValue() {\n      return state_;\n    }\n    /**\n     * <code>.spiketrade.proto.ConnectionStatus.State state = 1;</code>\n     * @return The state.\n     */\n    @java.lang.Override public com.spiketrade.proto.MarketDataProto.ConnectionStatus.State getState() {\n      com.spiketrade.proto.MarketDataProto.ConnectionStatus.State result = com.spiketrade.proto.MarketDataProto.ConnectionStatus.State.forNumber(state_);\n      return result == null ? com.spiketrade.proto.MarketDataProto.ConnectionStatus.State.UNRECOGNIZED : result;\n    }\n\n    public static final int USING_FALLBACK_FIELD_NUMBER = 2;\n    private boolean usingFallback_ = false;\n    /**\n     * <code>bool using_fallback = 2;</code>\n     * @return The usingFallback.\n     */\n    @java.lang.Override\n    public boolean getUsingFallback() {\n      return usingFallback_;\n    }\n\n    public static final int FALLBACK_REASON_FIELD_NUMBER = 3;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object fallbackReason_ = \"\";\n    /**\n     * <code>string fallback_reason = 3;</code>\n     * @return The fallbackReason.\n     */\n    @java.lang.Override\n    public java.lang.String getFallbackReason() {\n      java.lang.Object ref = fallbackReason_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        fallbackReason_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string fallback_reason = 3;</code>\n     * @return The bytes for fallbackReason.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getFallbackReasonBytes() {\n      java.lang.Object ref = fallbackReason_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        fallbackReason_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int CONSECUTIVE_FAILURES_FIELD_NUMBER = 4;\n    private int consecutiveFailures_ = 0;\n    /**\n     * <code>int32 consecutive_failures = 4;</code>\n     * @return The consecutiveFailures.\n     */\n    @java.lang.Override\n    public int getConsecutiveFailures() {\n      return consecutiveFailures_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (state_ != com.spiketrade.proto.MarketDataProto.ConnectionStatus.State.DISCONNECTED.getNumber()) {\n        output.writeEnum(1, state_);\n      }\n      if (usingFallback_ != false) {\n        output.writeBool(2, usingFallback_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(fallbackReason_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, fallbackReason_);\n      }\n      if (consecutiveFailures_ != 0) {\n        output.writeInt32(4, consecutiveFailures_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (state_ != com.spiketrade.proto.MarketDataProto.ConnectionStatus.State.DISCONNECTED.getNumber()) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeEnumSize(1, state_);\n      }\n      if (usingFallback_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(2, usingFallback_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(fallbackReason_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, fallbackReason_);\n      }\n      if (consecutiveFailures_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(4, consecutiveFailures_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.MarketDataProto.ConnectionStatus)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.MarketDataProto.ConnectionStatus other = (com.spiketrade.proto.MarketDataProto.ConnectionStatus) obj;\n\n      if (state_ != other.state_) return false;\n      if (getUsingFallback()\n          != other.getUsingFallback()) return false;\n      if (!getFallbackReason()\n          .equals(other.getFallbackReason())) return false;\n      if (getConsecutiveFailures()\n          != other.getConsecutiveFailures()) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + STATE_FIELD_NUMBER;\n      hash = (53 * hash) + state_;\n      hash = (37 * hash) + USING_FALLBACK_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getUsingFallback());\n      hash = (37 * hash) + FALLBACK_REASON_FIELD_NUMBER;\n      hash = (53 * hash) + getFallbackReason().hashCode();\n      hash = (37 * hash) + CONSECUTIVE_FAILURES_FIELD_NUMBER;\n      hash = (53 * hash) + getConsecutiveFailures();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.ConnectionStatus parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.ConnectionStatus parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.ConnectionStatus parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.ConnectionStatus parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.ConnectionStatus parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.MarketDataProto.ConnectionStatus parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.ConnectionStatus parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.ConnectionStatus parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.ConnectionStatus parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.ConnectionStatus parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.MarketDataProto.ConnectionStatus parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.MarketDataProto.ConnectionStatus parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.MarketDataProto.ConnectionStatus prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Connection status\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.ConnectionStatus}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.ConnectionStatus)\n        com.spiketrade.proto.MarketDataProto.ConnectionStatusOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_ConnectionStatus_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_ConnectionStatus_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.MarketDataProto.ConnectionStatus.class, com.spiketrade.proto.MarketDataProto.ConnectionStatus.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.MarketDataProto.ConnectionStatus.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        state_ = 0;\n        usingFallback_ = false;\n        fallbackReason_ = \"\";\n        consecutiveFailures_ = 0;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.MarketDataProto.internal_static_spiketrade_proto_ConnectionStatus_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.ConnectionStatus getDefaultInstanceForType() {\n        return com.spiketrade.proto.MarketDataProto.ConnectionStatus.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.ConnectionStatus build() {\n        com.spiketrade.proto.MarketDataProto.ConnectionStatus result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.ConnectionStatus buildPartial() {\n        com.spiketrade.proto.MarketDataProto.ConnectionStatus result = new com.spiketrade.proto.MarketDataProto.ConnectionStatus(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.MarketDataProto.ConnectionStatus result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.state_ = state_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.usingFallback_ = usingFallback_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.fallbackReason_ = fallbackReason_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.consecutiveFailures_ = consecutiveFailures_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.MarketDataProto.ConnectionStatus) {\n          return mergeFrom((com.spiketrade.proto.MarketDataProto.ConnectionStatus)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.MarketDataProto.ConnectionStatus other) {\n        if (other == com.spiketrade.proto.MarketDataProto.ConnectionStatus.getDefaultInstance()) return this;\n        if (other.state_ != 0) {\n          setStateValue(other.getStateValue());\n        }\n        if (other.getUsingFallback() != false) {\n          setUsingFallback(other.getUsingFallback());\n        }\n        if (!other.getFallbackReason().isEmpty()) {\n          fallbackReason_ = other.fallbackReason_;\n          bitField0_ |= 0x00000004;\n          onChanged();\n        }\n        if (other.getConsecutiveFailures() != 0) {\n          setConsecutiveFailures(other.getConsecutiveFailures());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 8: {\n                state_ = input.readEnum();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 8\n              case 16: {\n                usingFallback_ = input.readBool();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 16\n              case 26: {\n                fallbackReason_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 26\n              case 32: {\n                consecutiveFailures_ = input.readInt32();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 32\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private int state_ = 0;\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus.State state = 1;</code>\n       * @return The enum numeric value on the wire for state.\n       */\n      @java.lang.Override public int getStateValue() {\n        return state_;\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus.State state = 1;</code>\n       * @param value The enum numeric value on the wire for state to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStateValue(int value) {\n        state_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus.State state = 1;</code>\n       * @return The state.\n       */\n      @java.lang.Override\n      public com.spiketrade.proto.MarketDataProto.ConnectionStatus.State getState() {\n        com.spiketrade.proto.MarketDataProto.ConnectionStatus.State result = com.spiketrade.proto.MarketDataProto.ConnectionStatus.State.forNumber(state_);\n        return result == null ? com.spiketrade.proto.MarketDataProto.ConnectionStatus.State.UNRECOGNIZED : result;\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus.State state = 1;</code>\n       * @param value The state to set.\n       * @return This builder for chaining.\n       */\n      public Builder setState(com.spiketrade.proto.MarketDataProto.ConnectionStatus.State value) {\n        if (value == null) {\n          throw new NullPointerException();\n        }\n        bitField0_ |= 0x00000001;\n        state_ = value.getNumber();\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.ConnectionStatus.State state = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearState() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        state_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private boolean usingFallback_ ;\n      /**\n       * <code>bool using_fallback = 2;</code>\n       * @return The usingFallback.\n       */\n      @java.lang.Override\n      public boolean getUsingFallback() {\n        return usingFallback_;\n      }\n      /**\n       * <code>bool using_fallback = 2;</code>\n       * @param value The usingFallback to set.\n       * @return This builder for chaining.\n       */\n      public Builder setUsingFallback(boolean value) {\n\n        usingFallback_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool using_fallback = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearUsingFallback() {\n        bitField0_ = (bitField0_ & ~0x00000002);\n        usingFallback_ = false;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object fallbackReason_ = \"\";\n      /**\n       * <code>string fallback_reason = 3;</code>\n       * @return The fallbackReason.\n       */\n      public java.lang.String getFallbackReason() {\n        java.lang.Object ref = fallbackReason_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          fallbackReason_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string fallback_reason = 3;</code>\n       * @return The bytes for fallbackReason.\n       */\n      public com.google.protobuf.ByteString\n          getFallbackReasonBytes() {\n        java.lang.Object ref = fallbackReason_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          fallbackReason_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string fallback_reason = 3;</code>\n       * @param value The fallbackReason to set.\n       * @return This builder for chaining.\n       */\n      public Builder setFallbackReason(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        fallbackReason_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string fallback_reason = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearFallbackReason() {\n        fallbackReason_ = getDefaultInstance().getFallbackReason();\n        bitField0_ = (bitField0_ & ~0x00000004);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string fallback_reason = 3;</code>\n       * @param value The bytes for fallbackReason to set.\n       * @return This builder for chaining.\n       */\n      public Builder setFallbackReasonBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        fallbackReason_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n\n      private int consecutiveFailures_ ;\n      /**\n       * <code>int32 consecutive_failures = 4;</code>\n       * @return The consecutiveFailures.\n       */\n      @java.lang.Override\n      public int getConsecutiveFailures() {\n        return consecutiveFailures_;\n      }\n      /**\n       * <code>int32 consecutive_failures = 4;</code>\n       * @param value The consecutiveFailures to set.\n       * @return This builder for chaining.\n       */\n      public Builder setConsecutiveFailures(int value) {\n\n        consecutiveFailures_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 consecutive_failures = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearConsecutiveFailures() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        consecutiveFailures_ = 0;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.ConnectionStatus)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.ConnectionStatus)\n    private static final com.spiketrade.proto.MarketDataProto.ConnectionStatus DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.MarketDataProto.ConnectionStatus();\n    }\n\n    public static com.spiketrade.proto.MarketDataProto.ConnectionStatus getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<ConnectionStatus>\n        PARSER = new com.google.protobuf.AbstractParser<ConnectionStatus>() {\n      @java.lang.Override\n      public ConnectionStatus parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<ConnectionStatus> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<ConnectionStatus> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.MarketDataProto.ConnectionStatus getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  private static final com.google.protobuf.Descriptors.Descriptor\n    internal_static_spiketrade_proto_IndicatorsData_descriptor;\n  private static final \n    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internal_static_spiketrade_proto_IndicatorsData_fieldAccessorTable;\n  private static final com.google.protobuf.Descriptors.Descriptor\n    internal_static_spiketrade_proto_Quote_descriptor;\n  private static final \n    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internal_static_spiketrade_proto_Quote_fieldAccessorTable;\n  private static final com.google.protobuf.Descriptors.Descriptor\n    internal_static_spiketrade_proto_Candle_descriptor;\n  private static final \n    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internal_static_spiketrade_proto_Candle_fieldAccessorTable;\n  private static final com.google.protobuf.Descriptors.Descriptor\n    internal_static_spiketrade_proto_HistoricalDataRequest_descriptor;\n  private static final \n    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internal_static_spiketrade_proto_HistoricalDataRequest_fieldAccessorTable;\n  private static final com.google.protobuf.Descriptors.Descriptor\n    internal_static_spiketrade_proto_HistoricalDataResponse_descriptor;\n  private static final \n    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internal_static_spiketrade_proto_HistoricalDataResponse_fieldAccessorTable;\n  private static final com.google.protobuf.Descriptors.Descriptor\n    internal_static_spiketrade_proto_QuoteStreamRequest_descriptor;\n  private static final \n    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internal_static_spiketrade_proto_QuoteStreamRequest_fieldAccessorTable;\n  private static final com.google.protobuf.Descriptors.Descriptor\n    internal_static_spiketrade_proto_ConnectionStatus_descriptor;\n  private static final \n    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internal_static_spiketrade_proto_ConnectionStatus_fieldAccessorTable;\n\n  public static com.google.protobuf.Descriptors.FileDescriptor\n      getDescriptor() {\n    return descriptor;\n  }\n  private static  com.google.protobuf.Descriptors.FileDescriptor\n      descriptor;\n  static {\n    java.lang.String[] descriptorData = {\n      \"\\n\\021market_data.proto\\022\\020spiketrade.proto\\\"\\254\\004\" +\n      \"\\n\\016IndicatorsData\\022\\013\\n\\003rsi\\030\\001 \\001(\\001\\022\\021\\n\\tprice_r\" +\n      \"oc\\030\\002 \\001(\\001\\022\\022\\n\\nvolume_roc\\030\\003 \\001(\\001\\022\\016\\n\\006volume\\030\\004\" +\n      \" \\001(\\001\\022\\013\\n\\003obv\\030\\005 \\001(\\001\\022\\013\\n\\003mfi\\030\\006 \\001(\\001\\022\\032\\n\\022bollin\" +\n      \"ger_position\\030\\007 \\001(\\001\\022\\021\\n\\tpercent_b\\030\\010 \\001(\\001\\022\\014\\n\" +\n      \"\\004vwap\\030\\t \\001(\\001\\022\\017\\n\\007rsi_roc\\030\\n \\001(\\001\\022\\017\\n\\007obv_roc\\030\" +\n      \"\\013 \\001(\\001\\022\\017\\n\\007mfi_roc\\030\\014 \\001(\\001\\022\\031\\n\\021bollinger_pos_\" +\n      \"roc\\030\\r \\001(\\001\\022\\025\\n\\rpercent_b_roc\\030\\016 \\001(\\001\\022\\020\\n\\010vwap\" +\n      \"_roc\\030\\017 \\001(\\001\\022\\021\\n\\tmacd_line\\030\\020 \\001(\\001\\022\\023\\n\\013macd_si\" +\n      \"gnal\\030\\021 \\001(\\001\\022\\026\\n\\016macd_histogram\\030\\022 \\001(\\001\\022\\r\\n\\005em\" +\n      \"a_9\\030\\023 \\001(\\001\\022\\016\\n\\006ema_20\\030\\024 \\001(\\001\\022\\016\\n\\006ema_50\\030\\025 \\001(\" +\n      \"\\001\\022\\017\\n\\007stoch_k\\030\\026 \\001(\\001\\022\\017\\n\\007stoch_d\\030\\027 \\001(\\001\\022\\014\\n\\004r\" +\n      \"vol\\030\\030 \\001(\\001\\022\\024\\n\\014volume_spike\\030\\031 \\001(\\010\\022\\024\\n\\014volum\" +\n      \"e_ratio\\030\\032 \\001(\\001\\022\\013\\n\\003atr\\030\\033 \\001(\\001\\022\\027\\n\\017bollinger_\" +\n      \"upper\\030\\034 \\001(\\001\\022\\027\\n\\017bollinger_lower\\030\\035 \\001(\\001\\\"\\215\\003\\n\" +\n      \"\\005Quote\\022\\016\\n\\006symbol\\030\\001 \\001(\\t\\022\\r\\n\\005price\\030\\002 \\001(\\001\\022\\016\\n\" +\n      \"\\006volume\\030\\003 \\001(\\003\\022\\013\\n\\003bid\\030\\004 \\001(\\001\\022\\013\\n\\003ask\\030\\005 \\001(\\001\\022\" +\n      \"\\024\\n\\014timestamp_ms\\030\\006 \\001(\\003\\022\\013\\n\\003rsi\\030\\007 \\001(\\001\\022\\021\\n\\tpr\" +\n      \"ice_roc\\030\\010 \\001(\\001\\022\\022\\n\\nvolume_roc\\030\\t \\001(\\001\\022\\013\\n\\003obv\" +\n      \"\\030\\n \\001(\\001\\022\\013\\n\\003mfi\\030\\013 \\001(\\001\\022\\032\\n\\022bollinger_positio\" +\n      \"n\\030\\014 \\001(\\001\\022\\021\\n\\tpercent_b\\030\\r \\001(\\001\\022\\014\\n\\004vwap\\030\\016 \\001(\\001\" +\n      \"\\0229\\n\\nindicators\\030\\017 \\001(\\0132 .spiketrade.proto.\" +\n      \"IndicatorsDataH\\000\\210\\001\\001\\022\\037\\n\\022signal_probabilit\" +\n      \"y\\030\\020 \\001(\\001H\\001\\210\\001\\001\\022\\020\\n\\003atr\\030\\021 \\001(\\001H\\002\\210\\001\\001B\\r\\n\\013_indic\" +\n      \"atorsB\\025\\n\\023_signal_probabilityB\\006\\n\\004_atr\\\"f\\n\\006\" +\n      \"Candle\\022\\024\\n\\014timestamp_ms\\030\\001 \\001(\\003\\022\\014\\n\\004open\\030\\002 \\001\" +\n      \"(\\001\\022\\014\\n\\004high\\030\\003 \\001(\\001\\022\\013\\n\\003low\\030\\004 \\001(\\001\\022\\r\\n\\005close\\030\\005\" +\n      \" \\001(\\001\\022\\016\\n\\006volume\\030\\006 \\001(\\003\\\"S\\n\\025HistoricalDataRe\" +\n      \"quest\\022\\016\\n\\006symbol\\030\\001 \\001(\\t\\022\\030\\n\\020interval_minute\" +\n      \"s\\030\\002 \\001(\\005\\022\\020\\n\\010num_bars\\030\\003 \\001(\\005\\\"j\\n\\026HistoricalD\" +\n      \"ataResponse\\022\\016\\n\\006symbol\\030\\001 \\001(\\t\\022)\\n\\007candles\\030\\002\" +\n      \" \\003(\\0132\\030.spiketrade.proto.Candle\\022\\025\\n\\rerror_\" +\n      \"message\\030\\003 \\001(\\t\\\"%\\n\\022QuoteStreamRequest\\022\\017\\n\\007s\" +\n      \"ymbols\\030\\001 \\003(\\t\\\"\\336\\001\\n\\020ConnectionStatus\\0227\\n\\005sta\" +\n      \"te\\030\\001 \\001(\\0162(.spiketrade.proto.ConnectionSt\" +\n      \"atus.State\\022\\026\\n\\016using_fallback\\030\\002 \\001(\\010\\022\\027\\n\\017fa\" +\n      \"llback_reason\\030\\003 \\001(\\t\\022\\034\\n\\024consecutive_failu\" +\n      \"res\\030\\004 \\001(\\005\\\"B\\n\\005State\\022\\020\\n\\014DISCONNECTED\\020\\000\\022\\r\\n\\t\" +\n      \"CONNECTED\\020\\001\\022\\014\\n\\010DEGRADED\\020\\002\\022\\n\\n\\006FAILED\\020\\003B\\'\\n\" +\n      \"\\024com.spiketrade.protoB\\017MarketDataProtob\\006\" +\n      \"proto3\"\n    };\n    descriptor = com.google.protobuf.Descriptors.FileDescriptor\n      .internalBuildGeneratedFileFrom(descriptorData,\n        new com.google.protobuf.Descriptors.FileDescriptor[] {\n        });\n    internal_static_spiketrade_proto_IndicatorsData_descriptor =\n      getDescriptor().getMessageTypes().get(0);\n    internal_static_spiketrade_proto_IndicatorsData_fieldAccessorTable = new\n      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(\n        internal_static_spiketrade_proto_IndicatorsData_descriptor,\n        new java.lang.String[] { \"Rsi\", \"PriceRoc\", \"VolumeRoc\", \"Volume\", \"Obv\", \"Mfi\", \"BollingerPosition\", \"PercentB\", \"Vwap\", \"RsiRoc\", \"ObvRoc\", \"MfiRoc\", \"BollingerPosRoc\", \"PercentBRoc\", \"VwapRoc\", \"MacdLine\", \"MacdSignal\", \"MacdHistogram\", \"Ema9\", \"Ema20\", \"Ema50\", \"StochK\", \"StochD\", \"Rvol\", \"VolumeSpike\", \"VolumeRatio\", \"Atr\", \"BollingerUpper\", \"BollingerLower\", });\n    internal_static_spiketrade_proto_Quote_descriptor =\n      getDescriptor().getMessageTypes().get(1);\n    internal_static_spiketrade_proto_Quote_fieldAccessorTable = new\n      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(\n        internal_static_spiketrade_proto_Quote_descriptor,\n        new java.lang.String[] { \"Symbol\", \"Price\", \"Volume\", \"Bid\", \"Ask\", \"TimestampMs\", \"Rsi\", \"PriceRoc\", \"VolumeRoc\", \"Obv\", \"Mfi\", \"BollingerPosition\", \"PercentB\", \"Vwap\", \"Indicators\", \"SignalProbability\", \"Atr\", });\n    internal_static_spiketrade_proto_Candle_descriptor =\n      getDescriptor().getMessageTypes().get(2);\n    internal_static_spiketrade_proto_Candle_fieldAccessorTable = new\n      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(\n        internal_static_spiketrade_proto_Candle_descriptor,\n        new java.lang.String[] { \"TimestampMs\", \"Open\", \"High\", \"Low\", \"Close\", \"Volume\", });\n    internal_static_spiketrade_proto_HistoricalDataRequest_descriptor =\n      getDescriptor().getMessageTypes().get(3);\n    internal_static_spiketrade_proto_HistoricalDataRequest_fieldAccessorTable = new\n      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(\n        internal_static_spiketrade_proto_HistoricalDataRequest_descriptor,\n        new java.lang.String[] { \"Symbol\", \"IntervalMinutes\", \"NumBars\", });\n    internal_static_spiketrade_proto_HistoricalDataResponse_descriptor =\n      getDescriptor().getMessageTypes().get(4);\n    internal_static_spiketrade_proto_HistoricalDataResponse_fieldAccessorTable = new\n      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(\n        internal_static_spiketrade_proto_HistoricalDataResponse_descriptor,\n        new java.lang.String[] { \"Symbol\", \"Candles\", \"ErrorMessage\", });\n    internal_static_spiketrade_proto_QuoteStreamRequest_descriptor =\n      getDescriptor().getMessageTypes().get(5);\n    internal_static_spiketrade_proto_QuoteStreamRequest_fieldAccessorTable = new\n      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(\n        internal_static_spiketrade_proto_QuoteStreamRequest_descriptor,\n        new java.lang.String[] { \"Symbols\", });\n    internal_static_spiketrade_proto_ConnectionStatus_descriptor =\n      getDescriptor().getMessageTypes().get(6);\n    internal_static_spiketrade_proto_ConnectionStatus_fieldAccessorTable = new\n      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(\n        internal_static_spiketrade_proto_ConnectionStatus_descriptor,\n        new java.lang.String[] { \"State\", \"UsingFallback\", \"FallbackReason\", \"ConsecutiveFailures\", });\n  }\n\n  // @@protoc_insertion_point(outer_class_scope)\n}\n","size_bytes":304433},"build/extracted-include-protos/test/google/rpc/error_details.proto":{"content":"// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.rpc;\n\nimport \"google/protobuf/duration.proto\";\n\noption go_package = \"google.golang.org/genproto/googleapis/rpc/errdetails;errdetails\";\noption java_multiple_files = true;\noption java_outer_classname = \"ErrorDetailsProto\";\noption java_package = \"com.google.rpc\";\noption objc_class_prefix = \"RPC\";\n\n// Describes the cause of the error with structured details.\n//\n// Example of an error when contacting the \"pubsub.googleapis.com\" API when it\n// is not enabled:\n//\n//     { \"reason\": \"API_DISABLED\"\n//       \"domain\": \"googleapis.com\"\n//       \"metadata\": {\n//         \"resource\": \"projects/123\",\n//         \"service\": \"pubsub.googleapis.com\"\n//       }\n//     }\n//\n// This response indicates that the pubsub.googleapis.com API is not enabled.\n//\n// Example of an error that is returned when attempting to create a Spanner\n// instance in a region that is out of stock:\n//\n//     { \"reason\": \"STOCKOUT\"\n//       \"domain\": \"spanner.googleapis.com\",\n//       \"metadata\": {\n//         \"availableRegions\": \"us-central1,us-east2\"\n//       }\n//     }\nmessage ErrorInfo {\n  // The reason of the error. This is a constant value that identifies the\n  // proximate cause of the error. Error reasons are unique within a particular\n  // domain of errors. This should be at most 63 characters and match a\n  // regular expression of `[A-Z][A-Z0-9_]+[A-Z0-9]`, which represents\n  // UPPER_SNAKE_CASE.\n  string reason = 1;\n\n  // The logical grouping to which the \"reason\" belongs. The error domain\n  // is typically the registered service name of the tool or product that\n  // generates the error. Example: \"pubsub.googleapis.com\". If the error is\n  // generated by some common infrastructure, the error domain must be a\n  // globally unique value that identifies the infrastructure. For Google API\n  // infrastructure, the error domain is \"googleapis.com\".\n  string domain = 2;\n\n  // Additional structured details about this error.\n  //\n  // Keys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in\n  // length. When identifying the current value of an exceeded limit, the units\n  // should be contained in the key, not the value.  For example, rather than\n  // {\"instanceLimit\": \"100/request\"}, should be returned as,\n  // {\"instanceLimitPerRequest\": \"100\"}, if the client exceeds the number of\n  // instances that can be created in a single (batch) request.\n  map<string, string> metadata = 3;\n}\n\n// Describes when the clients can retry a failed request. Clients could ignore\n// the recommendation here or retry when this information is missing from error\n// responses.\n//\n// It's always recommended that clients should use exponential backoff when\n// retrying.\n//\n// Clients should wait until `retry_delay` amount of time has passed since\n// receiving the error response before retrying.  If retrying requests also\n// fail, clients should use an exponential backoff scheme to gradually increase\n// the delay between retries based on `retry_delay`, until either a maximum\n// number of retries have been reached or a maximum retry delay cap has been\n// reached.\nmessage RetryInfo {\n  // Clients should wait at least this long between retrying the same request.\n  google.protobuf.Duration retry_delay = 1;\n}\n\n// Describes additional debugging info.\nmessage DebugInfo {\n  // The stack trace entries indicating where the error occurred.\n  repeated string stack_entries = 1;\n\n  // Additional debugging information provided by the server.\n  string detail = 2;\n}\n\n// Describes how a quota check failed.\n//\n// For example if a daily limit was exceeded for the calling project,\n// a service could respond with a QuotaFailure detail containing the project\n// id and the description of the quota limit that was exceeded.  If the\n// calling project hasn't enabled the service in the developer console, then\n// a service could respond with the project id and set `service_disabled`\n// to true.\n//\n// Also see RetryInfo and Help types for other details about handling a\n// quota failure.\nmessage QuotaFailure {\n  // A message type used to describe a single quota violation.  For example, a\n  // daily quota or a custom quota that was exceeded.\n  message Violation {\n    // The subject on which the quota check failed.\n    // For example, \"clientip:<ip address of client>\" or \"project:<Google\n    // developer project id>\".\n    string subject = 1;\n\n    // A description of how the quota check failed. Clients can use this\n    // description to find more about the quota configuration in the service's\n    // public documentation, or find the relevant quota limit to adjust through\n    // developer console.\n    //\n    // For example: \"Service disabled\" or \"Daily Limit for read operations\n    // exceeded\".\n    string description = 2;\n  }\n\n  // Describes all quota violations.\n  repeated Violation violations = 1;\n}\n\n// Describes what preconditions have failed.\n//\n// For example, if an RPC failed because it required the Terms of Service to be\n// acknowledged, it could list the terms of service violation in the\n// PreconditionFailure message.\nmessage PreconditionFailure {\n  // A message type used to describe a single precondition failure.\n  message Violation {\n    // The type of PreconditionFailure. We recommend using a service-specific\n    // enum type to define the supported precondition violation subjects. For\n    // example, \"TOS\" for \"Terms of Service violation\".\n    string type = 1;\n\n    // The subject, relative to the type, that failed.\n    // For example, \"google.com/cloud\" relative to the \"TOS\" type would indicate\n    // which terms of service is being referenced.\n    string subject = 2;\n\n    // A description of how the precondition failed. Developers can use this\n    // description to understand how to fix the failure.\n    //\n    // For example: \"Terms of service not accepted\".\n    string description = 3;\n  }\n\n  // Describes all precondition violations.\n  repeated Violation violations = 1;\n}\n\n// Describes violations in a client request. This error type focuses on the\n// syntactic aspects of the request.\nmessage BadRequest {\n  // A message type used to describe a single bad request field.\n  message FieldViolation {\n    // A path that leads to a field in the request body. The value will be a\n    // sequence of dot-separated identifiers that identify a protocol buffer\n    // field.\n    //\n    // Consider the following:\n    //\n    //     message CreateContactRequest {\n    //       message EmailAddress {\n    //         enum Type {\n    //           TYPE_UNSPECIFIED = 0;\n    //           HOME = 1;\n    //           WORK = 2;\n    //         }\n    //\n    //         optional string email = 1;\n    //         repeated EmailType type = 2;\n    //       }\n    //\n    //       string full_name = 1;\n    //       repeated EmailAddress email_addresses = 2;\n    //     }\n    //\n    // In this example, in proto `field` could take one of the following values:\n    //\n    // * `full_name` for a violation in the `full_name` value\n    // * `email_addresses[1].email` for a violation in the `email` field of the\n    //   first `email_addresses` message\n    // * `email_addresses[3].type[2]` for a violation in the second `type`\n    //   value in the third `email_addresses` message.\n    //\n    // In JSON, the same values are represented as:\n    //\n    // * `fullName` for a violation in the `fullName` value\n    // * `emailAddresses[1].email` for a violation in the `email` field of the\n    //   first `emailAddresses` message\n    // * `emailAddresses[3].type[2]` for a violation in the second `type`\n    //   value in the third `emailAddresses` message.\n    string field = 1;\n\n    // A description of why the request element is bad.\n    string description = 2;\n  }\n\n  // Describes all violations in a client request.\n  repeated FieldViolation field_violations = 1;\n}\n\n// Contains metadata about the request that clients can attach when filing a bug\n// or providing other forms of feedback.\nmessage RequestInfo {\n  // An opaque string that should only be interpreted by the service generating\n  // it. For example, it can be used to identify requests in the service's logs.\n  string request_id = 1;\n\n  // Any data that was used to serve this request. For example, an encrypted\n  // stack trace that can be sent back to the service provider for debugging.\n  string serving_data = 2;\n}\n\n// Describes the resource that is being accessed.\nmessage ResourceInfo {\n  // A name for the type of resource being accessed, e.g. \"sql table\",\n  // \"cloud storage bucket\", \"file\", \"Google calendar\"; or the type URL\n  // of the resource: e.g. \"type.googleapis.com/google.pubsub.v1.Topic\".\n  string resource_type = 1;\n\n  // The name of the resource being accessed.  For example, a shared calendar\n  // name: \"example.com_4fghdhgsrgh@group.calendar.google.com\", if the current\n  // error is\n  // [google.rpc.Code.PERMISSION_DENIED][google.rpc.Code.PERMISSION_DENIED].\n  string resource_name = 2;\n\n  // The owner of the resource (optional).\n  // For example, \"user:<owner email>\" or \"project:<Google developer project\n  // id>\".\n  string owner = 3;\n\n  // Describes what error is encountered when accessing this resource.\n  // For example, updating a cloud project may require the `writer` permission\n  // on the developer console project.\n  string description = 4;\n}\n\n// Provides links to documentation or for performing an out of band action.\n//\n// For example, if a quota check failed with an error indicating the calling\n// project hasn't enabled the accessed service, this can contain a URL pointing\n// directly to the right place in the developer console to flip the bit.\nmessage Help {\n  // Describes a URL link.\n  message Link {\n    // Describes what the link offers.\n    string description = 1;\n\n    // The URL of the link.\n    string url = 2;\n  }\n\n  // URL(s) pointing to additional information on handling the current error.\n  repeated Link links = 1;\n}\n\n// Provides a localized error message that is safe to return to the user\n// which can be attached to an RPC error.\nmessage LocalizedMessage {\n  // The locale used following the specification defined at\n  // https://www.rfc-editor.org/rfc/bcp/bcp47.txt.\n  // Examples are: \"en-US\", \"fr-CH\", \"es-MX\"\n  string locale = 1;\n\n  // The localized error message in the above locale.\n  string message = 2;\n}\n","size_bytes":10869},"src/main/java/com/spiketrade/SpikeTradeApp.java":{"content":"package com.spiketrade;\n\n\nimport com.spiketrade.proto.TradingServiceProto;\nimport java.io.FileNotFoundException;\nimport javafx.application.Application;\nimport javafx.application.Platform;\nimport javafx.geometry.Insets;\nimport javafx.geometry.Pos;\nimport javafx.scene.Scene;\nimport javafx.scene.control.*;\nimport javafx.scene.control.cell.PropertyValueFactory;\nimport javafx.scene.layout.*;\nimport javafx.stage.Stage;\nimport javafx.stage.FileChooser;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\nimport javafx.scene.chart.LineChart;\nimport javafx.scene.chart.NumberAxis;\nimport javafx.scene.chart.CategoryAxis;\nimport javafx.scene.chart.XYChart;\nimport javafx.scene.chart.BarChart;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport java.time.LocalDateTime;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.io.InputStream;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.FileWriter;\nimport java.io.BufferedWriter;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.stream.Collectors;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\nimport com.spiketrade.backend.SellWarning;\nimport com.spiketrade.backend.SellSignal;\nimport com.spiketrade.model.*;\nimport com.spiketrade.service.SettingsManager;\nimport com.spiketrade.service.IndicatorCalibrationService;\nimport com.spiketrade.service.NotificationService;\nimport com.spiketrade.viewmodel.ApplicationState;\nimport com.spiketrade.controller.TradingController;\n\n/**\n * SpikeTrade Professional - Advanced Trading Intelligence\n * JavaFX Desktop Application matching Python tkinter GUI exactly\n * \n * Features:\n * - 1800x1000 window with greyscale theme (grey/white/black)\n * - 8 tabs: Configuration, Ticker Analysis, Trade Tracker, Backtesting, Analytics, Strategy Presets, Signal Rules, Notifications\n * - Professional UI with rounded buttons, collapsible sections, and modern styling\n */\npublic class SpikeTradeApp extends Application {\n    \n    // UI Components\n    private Label statusLabel;\n    private Label connectionStatusLabel;\n    private Label warmupStatusLabel;\n    private Label quoteSourceLabel;\n    private Button tradingToggleButton;\n    private TabPane mainTabPane;\n    \n    private TimeframeMode currentTimeframeMode = TimeframeMode.MIN_1;\n    private ComboBox<TimeframeMode> timeframeModeSelector;\n    \n    // Configuration Tab Components\n    private TextField tokenEntry;\n    private Label mlStatusLabel;\n    private Label mlSamplesLabel;\n    private TextField warmupEntry;\n    \n    // Ticker Analysis Tab\n    private TextField tickerSymbolEntry;\n    private TableView<TickerData> tickerTable;\n    // FIX #6: Use ConcurrentHashMap for thread-safe access from quote stream\n    // Note: priceHistoryMap still used for legacy cleanup, but chart removed\n    private Map<String, List<PricePoint>> priceHistoryMap = new ConcurrentHashMap<>();\n    private static final int MAX_PRICE_POINTS = 100;\n    \n    // Trade Tracker Tab\n    private TableView<TradeRecord> tradeTable;\n    private Label totalTradesLabel;\n    private Label winRateLabel;\n    private Label avgProfitLabel;\n    private Label totalProfitLabel;\n    \n    // Backtesting Tab\n    private TextField backtestSymbolEntry;\n    private TextField backtestStartDate;\n    private TextField backtestEndDate;\n    private TextField backtestCapital;\n    private TextField backtestTargetGain;\n    private Button runBacktestButton;\n    private Button optimizeButton;\n    private Button stopOptimizationButton;\n    private Label optimizeProgressLabel;\n    private TableView<BacktestTrade> backtestTable;\n    \n    // Backtest metric cards for displaying statistics\n    private VBox totalProfitCard;\n    private VBox totalTradesCard;\n    private VBox winRateCard;\n    private VBox profitFactorCard;\n    private VBox maxDrawdownCard;\n    private VBox sharpeCard;\n    \n    // Optimization state\n    private volatile boolean optimizationRunning = false;\n    private volatile boolean stopOptimizationRequested = false;\n    private OptimizationResult bestProfitResult;\n    private OptimizationResult bestWinRateResult;\n    private VBox optimizationResultsSection;\n    \n    // Signal Rules Tab\n    private CheckBox requireSpikeQuality;\n    private CheckBox requireRsiCondition;\n    private CheckBox requirePriceCondition;\n    private CheckBox requireObvCondition;\n    private CheckBox requireBollingerCondition;\n    private CheckBox enableAdxIndicator;\n    private CheckBox enableVwapIndicator;\n    private CheckBox requireVolumeSpike;\n    private CheckBox requireMfiCondition;  //  ADD THIS\n    \n    // Notification Configuration Controls\n    private Slider notificationCooldownSlider;\n    private CheckBox debugModeCheckBox;\n    private Label notificationStatusLabel;  // Status bar indicator for notification failures\n    \n    // NEW PENNY STOCK INDICATORS\n    private CheckBox enableMacdHistogramRoc;\n    private CheckBox enableStochasticIndicator;\n    private CheckBox enableRvolIndicator;\n    private CheckBox enableEmaIndicator;\n    private CheckBox enableEmaTrendFilter;\n    \n    // Sliders for configuration\n    private Slider stdDevSlider;\n    private Slider periodSlider;\n    \n    // Regular ROC Threshold Sliders\n    private Slider regularPriceRocThresholdSlider;\n    private Slider regularRsiRocThresholdSlider;\n    private Slider regularObvRocThresholdSlider;\n    private Slider regularMfiRocThresholdSlider;\n    private Slider regularPercentBRocThresholdSlider;\n    private Slider regularVwapRocThresholdSlider;\n    private Slider regularVolumeRocThresholdSlider;\n    \n    // Regular ROC Period Sliders\n    private Slider regularPriceRocPeriodSlider;\n    private Slider regularRsiRocPeriodSlider;\n    private Slider regularObvRocPeriodSlider;\n    private Slider regularMfiRocPeriodSlider;\n    private Slider regularPercentBRocPeriodSlider;\n    private Slider regularVwapRocPeriodSlider;\n    private Slider regularVolumeRocPeriodSlider;\n    \n    // New Parameter Sliders for Risk Controls\n    private Slider comboSignalThresholdSlider;\n    private Slider highProbThresholdSlider;\n    private Slider stopLossPctSlider;\n    private Slider initialProfitFloorPctSlider;\n    private Slider subsequentProfitFloorPctSlider;\n    \n    // New Parameter Sliders for Capital Allocation\n    private Slider equityPerTradeSlider;\n    private Slider maxOpenTradesSlider;\n    private Slider totalEquityAvailableSlider;\n    \n    // New Parameter Sliders for System Behavior\n    private Slider dataPointsSlider;\n    private CheckBox enableCooldownsCheckBox;\n    \n    // New Parameter Sliders for Indicator Windows\n    private Slider bbLengthMinutesSlider;\n    private Slider mfiPeriodMinutesSlider;\n    private Slider vwapPeriodMinutesSlider;\n    \n    // Penny Stock Parameter Sliders\n    private Slider macdFastPeriodSlider;\n    private Slider macdSlowPeriodSlider;\n    private Slider macdSignalPeriodSlider;\n    private Slider macdHistogramRocThresholdSlider;\n    private Slider stochasticPeriodSlider;\n    private Slider stochasticKSmoothSlider;\n    private Slider stochasticDSmoothSlider;\n    private Slider stochasticOversoldThresholdSlider;\n    private Slider stochasticOverboughtThresholdSlider;\n    private Slider rvolPeriodSlider;\n    private Slider rvolThresholdSlider;\n    private Slider ema9PeriodSlider;\n    private Slider ema20PeriodSlider;\n    private Slider ema50PeriodSlider;\n    private Slider volumeSpikeThresholdSlider;\n    \n    // Individual Spike Threshold Sliders\n    private Slider spikePriceRocZThresholdSlider;\n    private Slider spikeRsiRocZThresholdSlider;\n    private Slider spikeObvRocZThresholdSlider;\n    private Slider spikeMfiRocZThresholdSlider;\n    private Slider spikePercentBRocZThresholdSlider;\n    private Slider spikeVwapRocZThresholdSlider;\n    private Slider spikeVolumeRocZThresholdSlider;\n    \n    // TitledPane references for visibility control\n    private TitledPane regularPriceRocThresholdSection;\n    private TitledPane regularPriceRocPeriodSection;\n    private TitledPane rsiSection;\n    private TitledPane regularRsiRocThresholdSection;\n    private TitledPane regularRsiRocPeriodSection;\n    private TitledPane regularObvRocThresholdSection;\n    private TitledPane regularObvRocPeriodSection;\n    private TitledPane regularMfiRocThresholdSection;\n    private TitledPane regularMfiRocPeriodSection;\n    private TitledPane regularPercentBRocThresholdSection;\n    private TitledPane regularPercentBRocPeriodSection;\n    private TitledPane regularVwapRocThresholdSection;\n    private TitledPane regularVwapRocPeriodSection;\n    private TitledPane regularVolumeRocThresholdSection;\n    private TitledPane regularVolumeRocPeriodSection;\n    private TitledPane spikeThresholdsSection;\n    \n    // Checkbox-to-Pane Registry for dynamic visibility control\n    private Map<CheckBox, List<TitledPane>> checkboxToPanesMap = new HashMap<>();\n    \n    // Strategy Preset Configuration Checkboxes\n    private CheckBox applyConfigMomentumScalper;\n    private CheckBox applyConfigMeanReversion;\n    private CheckBox applyConfigPennyBreakout;\n    private CheckBox applyConfigSmartMoney;\n    \n    // FIX #6: Signal tracking for ticker analysis - Use ConcurrentHashMap for thread safety\n    // These maps are accessed from multiple threads (quote stream, signal stream, UI thread, polling thread)\n    private Map<String, Double> symbolToProbabilityMap = new ConcurrentHashMap<>();\n    private Map<String, String> symbolToPositionMap = new ConcurrentHashMap<>();\n    private Map<String, Double> symbolToEntryPriceMap = new ConcurrentHashMap<>();\n    private Map<String, Integer> symbolToSharesMap = new ConcurrentHashMap<>();\n    private Map<String, Long> symbolToLastSellWarningCheck = new ConcurrentHashMap<>();\n    // NOTE: tradeRecords now managed by ApplicationState for cross-tab synchronization\n    \n    // PRIORITY 2: ATR (Average True Range) tracking for dynamic stops and position sizing\n    private Map<String, Double> symbolToAtrMap = new ConcurrentHashMap<>();\n    \n    // PRIORITY 3: Bid-Ask Spread monitoring for realistic execution\n    private Map<String, Double> symbolToSpreadMap = new ConcurrentHashMap<>();\n    private Map<String, Double> symbolToBidMap = new ConcurrentHashMap<>();\n    private Map<String, Double> symbolToAskMap = new ConcurrentHashMap<>();\n    \n    // Last known indicator values per symbol (for persistence when updates are unavailable)\n    // FIX #6: Thread-safe access\n    private Map<String, Map<String, Double>> lastKnownIndicators = new ConcurrentHashMap<>();\n    \n    // Notification debouncing to prevent spam - NOW CONFIGURABLE\n    private final Map<String, Long> lastNotificationTime = new ConcurrentHashMap<>();\n    private long notificationCooldownMs = 15000; // Reduced from 60s to 15s (configurable via UI)\n    private boolean debugModeShowAllDecisions = false; // Debug mode: show ALL trade decisions\n    \n    // Price history cleanup counter for deterministic cleanup (thread-safe)\n    private final java.util.concurrent.atomic.AtomicInteger priceUpdateCounter = new java.util.concurrent.atomic.AtomicInteger(0);\n    \n    // NOTE: Trading state (tradingEnabled, connected) now managed by ApplicationState for cross-tab synchronization\n    \n    // FIX #9: Periodic polling for exit conditions (even when quote updates are slow/missing)\n    private ScheduledExecutorService exitConditionPoller;\n    private static final int POLL_INTERVAL_SECONDS = 5; // Check every 5 seconds\n    \n    // Chart and ROC configuration\n    private static final int CHART_INTERVAL_MINUTES = 1; // 1-minute candles for all charts\n    private static final int NUM_HISTORICAL_BARS = 500; // Number of bars to fetch\n    \n    // FIX #11: Background timers for probability polling and trade tracker refresh\n    private javafx.animation.Timeline probabilityPollingTimeline;\n    private javafx.animation.Timeline tradeTrackerRefreshTimeline;\n    \n    // gRPC client\n    private TradingServiceClient grpcClient;\n    \n    // Services\n    private IndicatorCalibrationService calibrationService;\n    private NotificationService notificationService;\n    \n    // MVVM Architecture - Centralized State Management\n    private ApplicationState appState;\n    private TradingController tradingController;\n    \n    // Current configuration from backend\n    private com.spiketrade.proto.ConfigProto.TradingConfig currentConfig;\n    private double lastBacktestAvgProbability = 0.0;\n    \n    // Settings file path\n    private static final String SETTINGS_FILE = \"trading_settings.json\";\n    private ObjectMapper objectMapper = new ObjectMapper();\n    \n    // ===========================\n    // Utility Methods\n    // ===========================\n    \n    /**\n     * Safely set label text, handling JavaFX binding conflicts\n     * Prevents \"bound value cannot be set\" errors by unbinding before setting text\n     */\n    private static void safeLabelSet(Label label, String text) {\n        Platform.runLater(() -> {\n            if (label.textProperty().isBound()) {\n                label.textProperty().unbind();\n            }\n            label.setText(text);\n        });\n    }\n    \n    @Override\n    public void start(Stage primaryStage) {\n        primaryStage.setTitle(\"SpikeTrade Professional  Advanced Trading Intelligence\");\n        \n        // Initialize MVVM Architecture - Centralized State\n        appState = ApplicationState.getInstance();\n        grpcClient = TradingServiceClient.getInstance();\n        tradingController = new TradingController(appState, grpcClient);\n        \n        calibrationService = new IndicatorCalibrationService();\n        notificationService = new NotificationService();\n        notificationService.initialize();\n        \n        // Initialize currentConfig with default values to prevent null pointer errors\n        currentConfig = createDefaultConfig();\n        appState.setCurrentConfig(currentConfig);\n        System.out.println(\"Initialized currentConfig with default values and synchronized with ApplicationState\");\n        \n        // Main layout - BorderPane with header (top), tabs (center), status bar (bottom)\n        BorderPane root = new BorderPane();\n        root.getStyleClass().add(\"root\");\n        \n        // Create header\n        VBox header = createHeader();\n        root.setTop(header);\n        \n        // Create tab pane with 7 tabs\n        mainTabPane = createTabs();\n        root.setCenter(mainTabPane);\n        \n        // Create status bar\n        HBox statusBar = createStatusBar();\n        root.setBottom(statusBar);\n        \n        // Create scene with exact dimensions: 1800x1000\n        Scene scene = new Scene(root, 1100, 600);\n        \n        // Load CSS stylesheet\n        scene.getStylesheets().add(getClass().getResource(\"/styles.css\").toExternalForm());\n        \n        primaryStage.setScene(scene);\n        primaryStage.setMinWidth(1100);\n        primaryStage.setMinHeight(600);\n        primaryStage.setOnCloseRequest(e -> {\n            // FIX #9: Ensure exit condition poller shuts down cleanly\n            stopExitConditionPolling();\n            \n            // FIX #11: Stop background timers to prevent resource leak\n            stopBackgroundTimers();\n            \n            if (notificationService != null) {\n                notificationService.shutdown();\n            }\n            \n            if (grpcClient != null) {\n                grpcClient.shutdown();\n            }\n        });\n        primaryStage.show();\n        \n        // Signal streaming will be started when trading is enabled\n    }\n    \n    /**\n     * Create default configuration to prevent null pointer errors\n     * PRIORITY 5: Changed Bollinger Band default from 25 to 12 minutes\n     */\n    private com.spiketrade.proto.ConfigProto.TradingConfig createDefaultConfig() {\n        return com.spiketrade.proto.ConfigProto.TradingConfig.newBuilder()\n            .setDataPoints(200)\n            .setWarmupDataPoints(100)\n            .setBuyPeriodMinutes(20)\n            .setBbLengthMinutes(12)  // Changed from 25 to 12 minutes\n            .setRsiLengthMinutes(36)\n            .setComboSignalThreshold(0.7)\n            .setSpikeCooldownStddevThreshold(2.0)\n            .setEnableCooldowns(true)\n            .build();\n    }\n    \n    /**\n     * Start streaming buy signals from backend with active symbols\n     */\n    private void startSignalStreaming(List<String> symbols) {\n        if (symbols == null || symbols.isEmpty()) {\n            System.out.println(\"No symbols to stream - skipping signal streaming\");\n            return;\n        }\n        \n        System.out.println(\"Starting signal streaming for symbols: \" + symbols);\n        \n        // REMOVED PROBABILITY FILTER: Always stream ALL signals regardless of probability\n        grpcClient.streamSignals(symbols, 0.0, new TradingServiceClient.SignalCallback() {\n            @Override\n                        public void onSignal(com.spiketrade.proto.SpikeSignalsProto.BuySignal signal) {\n                            Platform.runLater(() -> {\n                                String signalSymbol = signal.getSymbol();\n                                double probability = signal.getSignalProbability();\n                                \n                                System.out.println(\" BUY SIGNAL DETECTED: \" + signalSymbol + \n                                                \" | Probability: \" + (probability * 100) + \"%\");\n                                \n                                // Update ticker with signal indicators immediately\n                                if (signal.hasIndicators()) {\n                                    updateTickerIndicators(signalSymbol, signal.getIndicators(), probability);\n                                } else {\n                                    // FIX: Handle missing indicators - only update probability\n                                    System.out.println(\" WARNING: Signal for \" + signalSymbol + \" missing indicators, updating probability only\");\n                                    updateTickerTableProbability(signalSymbol, probability);\n                                }\n                                \n                                // Show notification for ALL buy signals (no threshold filtering)\n                                System.out.println(\" TRIGGERING BUY SIGNAL NOTIFICATION for \" + signalSymbol + \n                                                 \" (probability: \" + (probability * 100) + \"%)\");\n                                showBuySignalAlert(signal);\n                            });\n                        }            \n            @Override\n            public void onError(String error) {\n                Platform.runLater(() -> {\n                    System.err.println(\"Signal stream error: \" + error);\n                    \n                    // CRITICAL FIX: Show error alert to user instead of just logging\n                    notificationService.alertCritical(\n                        \"Signal Stream Error\", \n                        \"The signal stream has encountered an error:\\n\\n\" + error + \n                        \"\\n\\nBuy signals may not be delivered. Please check your connection.\"\n                    );\n                    \n                    // Update status bar indicator\n                    if (notificationStatusLabel != null) {\n                        notificationStatusLabel.setText(\" SIGNAL STREAM ERROR\");\n                        notificationStatusLabel.setStyle(\"-fx-text-fill: #F59E0B; -fx-font-weight: bold;\");\n                    }\n                });\n            }\n            \n            @Override\n            public void onCompleted() {\n                Platform.runLater(() -> {\n                    System.out.println(\"Signal stream completed\");\n                });\n            }\n        });\n    }\n    \n    /**\n     * Create header with title, status indicators, and control buttons\n     */\n    private VBox createHeader() {\n        VBox header = new VBox();\n        header.getStyleClass().add(\"header\");\n        header.setPadding(new Insets(20, 40, 20, 40));\n        \n        // Main container\n        HBox mainContainer = new HBox(20);\n        mainContainer.setAlignment(Pos.CENTER_LEFT);\n        \n        // Load and display logo (centered, larger)\n        ImageView logoView = null;\n        try {\n            InputStream logoStream = getClass().getResourceAsStream(\"/logo2.jpg\");\n            if (logoStream != null) {\n                Image logoImage = new Image(logoStream);\n                logoView = new ImageView(logoImage);\n                logoView.setFitHeight(180);\n                logoView.setPreserveRatio(true);\n                logoView.setSmooth(true);\n                System.out.println(\"Logo loaded successfully\");\n            } else {\n                System.err.println(\"Warning: Could not load logo2.jpg from resources\");\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error loading logo: \" + e.getMessage());\n            e.printStackTrace();\n        }\n        \n        // Spacer to push status panel and buttons to the right\n        Region spacer = new Region();\n        HBox.setHgrow(spacer, Priority.ALWAYS);\n        \n        // Status panel (right side) - Dark Theme\n        VBox statusPanel = new VBox(6);\n        statusPanel.setStyle(\"-fx-background-color: rgba(26, 31, 41, 0.9); -fx-border-color: #2D3748; -fx-border-width: 1; \" +\n                           \"-fx-border-radius: 10; -fx-background-radius: 10; -fx-padding: 14 18; \" +\n                           \"-fx-effect: dropshadow(gaussian, rgba(0, 0, 0, 0.5), 15, 0, 0, 3);\");\n        \n        connectionStatusLabel = new Label(\" OFFLINE\");\n        connectionStatusLabel.setStyle(\"-fx-font-size: 12px; -fx-font-weight: bold; -fx-text-fill: #718096;\");\n        // Bind to ApplicationState - automatically updates when connection status changes\n        connectionStatusLabel.textProperty().bind(appState.connectionStatusProperty());\n        \n        Label cooldownLabel = new Label(\" COOLDOWN: INACTIVE\");\n        cooldownLabel.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #718096;\");\n        \n        warmupStatusLabel = new Label(\" SYSTEM: READY\");\n        warmupStatusLabel.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #718096;\");\n        // Bind to ApplicationState - automatically updates when warmup status changes\n        warmupStatusLabel.textProperty().bind(appState.warmupStatusProperty());\n        \n        quoteSourceLabel = new Label(\" QUOTES: NOT CONNECTED\");\n        quoteSourceLabel.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #718096;\");\n        // Bind to ApplicationState - automatically updates when quote source changes\n        quoteSourceLabel.textProperty().bind(appState.quoteSourceProperty());\n        \n        statusPanel.getChildren().addAll(connectionStatusLabel, cooldownLabel, warmupStatusLabel, quoteSourceLabel);\n        \n        // Control buttons (right of status panel)\n        VBox controlButtons = new VBox(6);\n        controlButtons.setAlignment(Pos.CENTER_RIGHT);\n        \n        tradingToggleButton = new Button(\" TRADING OFFLINE\");\n        tradingToggleButton.getStyleClass().add(\"button-red\");\n        tradingToggleButton.setPrefWidth(180);\n        tradingToggleButton.setPrefHeight(36);\n        tradingToggleButton.setOnAction(e -> toggleTrading());\n        \n        // Bind to ApplicationState - automatically updates button appearance when trading state changes\n        appState.tradingEnabledProperty().addListener((obs, oldVal, newVal) -> {\n            if (newVal) {\n                tradingToggleButton.setText(\" TRADING ACTIVE\");\n                tradingToggleButton.getStyleClass().remove(\"button-red\");\n                tradingToggleButton.getStyleClass().add(\"button-green\");\n            } else {\n                tradingToggleButton.setText(\" TRADING OFFLINE\");\n                tradingToggleButton.getStyleClass().remove(\"button-green\");\n                tradingToggleButton.getStyleClass().add(\"button-red\");\n            }\n        });\n        \n        Button saveButton = new Button(\" SAVE CONFIG\");\n        saveButton.getStyleClass().add(\"rounded-button\");\n        saveButton.setPrefWidth(140);\n        saveButton.setPrefHeight(32);\n        saveButton.setOnAction(e -> saveSettings());\n        \n        Button loadButton = new Button(\" LOAD CONFIG\");\n        loadButton.getStyleClass().add(\"rounded-button\");\n        loadButton.setPrefWidth(140);\n        loadButton.setPrefHeight(32);\n        loadButton.setOnAction(e -> loadSettings());\n        \n        controlButtons.getChildren().addAll(tradingToggleButton, saveButton, loadButton);\n        \n        // Add components to main container (logo only)\n        if (logoView != null) {\n            mainContainer.getChildren().addAll(logoView, spacer, statusPanel, controlButtons);\n        } else {\n            mainContainer.getChildren().addAll(spacer, statusPanel, controlButtons);\n        }\n        \n        header.getChildren().add(mainContainer);\n        \n        return header;\n    }\n    \n    /**\n     * Create tab pane with all 7 tabs\n     */\n    private TabPane createTabs() {\n        TabPane tabPane = new TabPane();\n        tabPane.setTabClosingPolicy(TabPane.TabClosingPolicy.UNAVAILABLE);\n        \n        // Create all 8 tabs\n        Tab configTab = createConfigurationTab();\n        Tab tickerTab = createTickerAnalysisTab();\n        Tab tradeTrackerTab = createTradeTrackerTab();\n        Tab backtestTab = createBacktestingTab();\n        Tab analyticsTab = createAnalyticsTab();\n        Tab strategyPresetsTab = createStrategyPresetsTab();\n        Tab signalRulesTab = createSignalRulesTab();\n        Tab notificationsTab = createNotificationsTab();\n        \n        tabPane.getTabs().addAll(configTab, tickerTab, tradeTrackerTab, backtestTab, \n                                 analyticsTab, strategyPresetsTab, signalRulesTab, notificationsTab);\n        \n        return tabPane;\n    }\n    \n    /**\n     * Tab 1:  Configuration\n     */\n    private Tab createConfigurationTab() {\n        Tab tab = new Tab(\" Configuration\");\n        \n        ScrollPane scrollPane = new ScrollPane();\n        scrollPane.setFitToWidth(true);\n        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);\n        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);\n        scrollPane.setStyle(\"-fx-background-color: #FAFBFC;\");\n        \n        VBox content = new VBox(20);\n        content.setPadding(new Insets(25));\n        content.setStyle(\"-fx-background-color: #FAFBFC;\");\n        \n        // Title\n        Label titleLabel = new Label(\"  CONFIGURATION\");\n        titleLabel.setStyle(\"-fx-font-size: 17px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF;\");\n        \n        Label subtitleLabel = new Label(\"Customize your trading strategy parameters\");\n        subtitleLabel.setStyle(\"-fx-font-size: 11px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        \n        // Timeframe Mode Selector Section\n        TitledPane timeframeSection = new TitledPane();\n        timeframeSection.setText(\"  Trading Timeframe Mode\");\n        timeframeSection.setExpanded(true);\n        \n        VBox timeframeContent = new VBox(12);\n        timeframeContent.setPadding(new Insets(15));\n        \n        Label timeframeInfoLabel = new Label(\"Select the timeframe for your trading strategy. This scales all parameter limits while keeping 1-minute chart granularity.\");\n        timeframeInfoLabel.setStyle(\"-fx-font-size: 11px; -fx-text-fill: #555555; -fx-wrap-text: true;\");\n        \n        HBox timeframeSelectorBox = new HBox(15);\n        timeframeSelectorBox.setAlignment(Pos.CENTER_LEFT);\n        \n        Label timeframeLabel = new Label(\"Timeframe Mode:\");\n        timeframeLabel.setStyle(\"-fx-font-size: 12px; -fx-font-weight: bold;\");\n        \n        timeframeModeSelector = new ComboBox<>();\n        timeframeModeSelector.getItems().addAll(TimeframeMode.values());\n        timeframeModeSelector.setValue(appState.getTimeframeMode());\n        timeframeModeSelector.setPrefWidth(200);\n        timeframeModeSelector.setStyle(\"-fx-font-size: 12px;\");\n        \n        // Custom cell factory to display the user-friendly names\n        timeframeModeSelector.setCellFactory(lv -> new ListCell<TimeframeMode>() {\n            @Override\n            protected void updateItem(TimeframeMode item, boolean empty) {\n                super.updateItem(item, empty);\n                setText(empty || item == null ? null : item.getDisplayName());\n            }\n        });\n        timeframeModeSelector.setButtonCell(new ListCell<TimeframeMode>() {\n            @Override\n            protected void updateItem(TimeframeMode item, boolean empty) {\n                super.updateItem(item, empty);\n                setText(empty || item == null ? null : item.getDisplayName());\n            }\n        });\n        \n        Label timeframeExplanation = new Label();\n        timeframeExplanation.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #059669; -fx-font-weight: bold;\");\n        updateTimeframeExplanation(timeframeExplanation, appState.getTimeframeMode());\n        \n        // Bind to ApplicationState with bidirectional binding - changes sync across tabs\n        timeframeModeSelector.valueProperty().bindBidirectional(appState.timeframeModeProperty());\n        \n        // Listen for timeframe mode changes to update UI\n        appState.timeframeModeProperty().addListener((obs, oldVal, newVal) -> {\n            if (newVal != null) {\n                currentTimeframeMode = newVal;\n                updateTimeframeExplanation(timeframeExplanation, newVal);\n                updateAllSliderLimits();\n                System.out.println(\" Timeframe mode changed to: \" + newVal.getDisplayName() + \n                                   \" (multiplier: \" + newVal.getMultiplier() + \"x)\");\n            }\n        });\n        \n        timeframeSelectorBox.getChildren().addAll(timeframeLabel, timeframeModeSelector, timeframeExplanation);\n        timeframeContent.getChildren().addAll(timeframeInfoLabel, timeframeSelectorBox);\n        timeframeSection.setContent(timeframeContent);\n        \n        // Questrade Connection Section\n        TitledPane questradeSection = new TitledPane();\n        questradeSection.setText(\"  Questrade Connection\");\n        questradeSection.setExpanded(true);\n        \n        GridPane questradeGrid = new GridPane();\n        questradeGrid.setHgap(15);\n        questradeGrid.setVgap(8);\n        questradeGrid.setPadding(new Insets(15));\n        \n        Label tokenLabel = new Label(\"Refresh Token:\");\n        tokenLabel.setStyle(\"-fx-font-size: 11px;\");\n        \n        tokenEntry = new PasswordField();\n        tokenEntry.setPromptText(\"Enter Questrade refresh token\");\n        tokenEntry.setPrefWidth(400);\n        \n        Button connectButton = new Button(\"Connect to Questrade\");\n        connectButton.getStyleClass().add(\"button-green\");\n        connectButton.setPrefWidth(170);\n        connectButton.setPrefHeight(36);\n        connectButton.setOnAction(e -> connectQuestrade());\n        \n        questradeGrid.add(tokenLabel, 0, 0);\n        questradeGrid.add(tokenEntry, 1, 0);\n        questradeGrid.add(connectButton, 2, 0);\n        \n        questradeSection.setContent(questradeGrid);\n        \n        // Machine Learning Status Section\n        TitledPane mlSection = new TitledPane();\n        mlSection.setText(\"  Machine Learning Status\");\n        mlSection.setExpanded(true);\n        \n        VBox mlContent = new VBox(8);\n        mlContent.setPadding(new Insets(15));\n        \n        mlStatusLabel = new Label(\" ML Model: Inactive (requires 100+ spike samples)\");\n        mlStatusLabel.setStyle(\"-fx-font-size: 11px; -fx-text-fill: #9CA3AF;\");\n        \n        mlSamplesLabel = new Label(\"Spike History: 0 samples collected\");\n        mlSamplesLabel.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #555555;\");\n        \n        mlContent.getChildren().addAll(mlStatusLabel, mlSamplesLabel);\n        mlSection.setContent(mlContent);\n        \n        // System Settings Section\n        TitledPane systemSection = new TitledPane();\n        systemSection.setText(\"  System Settings\");\n        systemSection.setExpanded(true);\n        \n        VBox systemContent = new VBox(8);\n        systemContent.setPadding(new Insets(15));\n        \n        HBox warmupBox = new HBox(10);\n        warmupBox.setAlignment(Pos.CENTER_LEFT);\n        \n        Label warmupLabel = new Label(\"Warmup Data Points:\");\n        warmupLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        warmupEntry = new TextField(\"75\");\n        warmupEntry.setPrefWidth(100);\n        \n        Label warmupHint = new Label(\"(Number of live data points required before trading activates)\");\n        warmupHint.setStyle(\"-fx-font-size: 9px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        \n        Button saveWarmupButton = new Button(\" SAVE\");\n        saveWarmupButton.getStyleClass().add(\"button-green\");\n        saveWarmupButton.setPrefWidth(100);\n        saveWarmupButton.setPrefHeight(30);\n        saveWarmupButton.setOnAction(e -> saveWarmupSettings());\n        \n        warmupBox.getChildren().addAll(warmupLabel, warmupEntry, warmupHint, saveWarmupButton);\n        \n        Button refreshButton = new Button(\" REFRESH GUI\");\n        refreshButton.getStyleClass().add(\"rounded-button\");\n        refreshButton.setPrefWidth(160);\n        refreshButton.setPrefHeight(36);\n        refreshButton.setOnAction(e -> refreshGUI());\n        \n        systemContent.getChildren().addAll(warmupBox, refreshButton);\n        systemSection.setContent(systemContent);\n        \n        // Parameter Sections (Collapsible) - Store references for visibility control\n        TitledPane stdDevSection = createStdDevSection();\n        TitledPane periodSection = createPeriodSection();\n        rsiSection = createRsiSection();\n        \n        // Create individual threshold and period sections for each indicator\n        regularPriceRocThresholdSection = createPriceRocThresholdSection();\n        regularPriceRocPeriodSection = createPriceRocPeriodSection();\n        regularRsiRocThresholdSection = createRsiRocThresholdSection();\n        regularRsiRocPeriodSection = createRsiRocPeriodSection();\n        regularObvRocThresholdSection = createObvRocThresholdSection();\n        regularObvRocPeriodSection = createObvRocPeriodSection();\n        regularMfiRocThresholdSection = createMfiRocThresholdSection();\n        regularMfiRocPeriodSection = createMfiRocPeriodSection();\n        regularPercentBRocThresholdSection = createPercentBRocThresholdSection();\n        regularPercentBRocPeriodSection = createPercentBRocPeriodSection();\n        regularVwapRocThresholdSection = createVwapRocThresholdSection();\n        regularVwapRocPeriodSection = createVwapRocPeriodSection();\n        regularVolumeRocThresholdSection = createVolumeRocThresholdSection();\n        regularVolumeRocPeriodSection = createVolumeRocPeriodSection();\n        \n        // Create new sections and store references\n        TitledPane riskControlsSection = createRiskControlsSection();\n        TitledPane capitalAllocationSection = createCapitalAllocationSection();\n        TitledPane systemBehaviorSection = createSystemBehaviorSection();\n        TitledPane indicatorWindowsSection = createIndicatorWindowsSection();\n        TitledPane pennyStockParametersSection = createPennyStockParametersSection();\n        spikeThresholdsSection = createIndividualSpikeThresholdsSection();\n        \n        // Apply Configuration Button\n        TitledPane applySection = new TitledPane();\n        applySection.setText(\"  Apply Configuration Changes\");\n        applySection.setExpanded(true);\n        \n        VBox applyContent = new VBox(8);\n        applyContent.setPadding(new Insets(15));\n        applyContent.setAlignment(Pos.CENTER);\n        \n        Label applyStatus = new Label(\" Parameters not yet applied\");\n        applyStatus.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #9CA3AF;\");\n        \n        Button updateButton = new Button(\" UPDATE PARAMETERS\");\n        updateButton.getStyleClass().add(\"rounded-button\");\n        updateButton.setPrefWidth(240);\n        updateButton.setPrefHeight(42);\n        updateButton.setOnAction(e -> updateParameters());\n        \n        Label applyHint = new Label(\"Click this button after changing any parameters above.\\n\" +\n                                   \"This will apply your changes to the trading strategy.\");\n        applyHint.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #555555; -fx-text-alignment: center;\");\n        \n        applyContent.getChildren().addAll(applyStatus, updateButton, applyHint);\n        applySection.setContent(applyContent);\n        \n        content.getChildren().addAll(titleLabel, subtitleLabel, timeframeSection, questradeSection, mlSection, \n                                     systemSection, stdDevSection, periodSection, rsiSection,\n                                     regularPriceRocThresholdSection, regularPriceRocPeriodSection,\n                                     regularRsiRocThresholdSection, regularRsiRocPeriodSection,\n                                     regularObvRocThresholdSection, regularObvRocPeriodSection,\n                                     regularMfiRocThresholdSection, regularMfiRocPeriodSection,\n                                     regularPercentBRocThresholdSection, regularPercentBRocPeriodSection,\n                                     regularVwapRocThresholdSection, regularVwapRocPeriodSection,\n                                     regularVolumeRocThresholdSection, regularVolumeRocPeriodSection,\n                                     riskControlsSection, capitalAllocationSection, systemBehaviorSection,\n                                     indicatorWindowsSection, pennyStockParametersSection, spikeThresholdsSection, applySection);\n        \n        scrollPane.setContent(content);\n        tab.setContent(scrollPane);\n        \n        return tab;\n    }\n    \n    /**\n     * Create Standard Deviation Sensitivity Section\n     */\n    private TitledPane createStdDevSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  Standard Deviation Sensitivity\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label description = new Label(\"Controls sensitivity for ALL spike detection thresholds (excludes RSI)\");\n        description.setStyle(\"-fx-font-size: 10px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        \n        Label valueLabel = new Label(\"Low (0.5)  Current: 2.0  High (5.0)\");\n        valueLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #D1D5DB;\");\n        \n        stdDevSlider = new Slider(0.5, 5.0, 2.0);\n        stdDevSlider.setShowTickLabels(true);\n        stdDevSlider.setShowTickMarks(true);\n        stdDevSlider.setMajorTickUnit(1.0);\n        stdDevSlider.setBlockIncrement(0.1);\n        stdDevSlider.setPrefWidth(600);\n        \n        stdDevSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            valueLabel.setText(String.format(\"Low (0.5)  Current: %.1f  High (5.0)\", newVal.doubleValue()));\n        });\n        \n        content.getChildren().addAll(description, valueLabel, stdDevSlider);\n        section.setContent(content);\n        \n        return section;\n    }\n    \n    /**\n     * Create Indicator Periods Section\n     */\n    private TitledPane createPeriodSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  Indicator Periods\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label description = new Label(\"Controls calculation periods for ALL indicators (excludes RSI). Longer periods = smoother, less noise.\");\n        description.setStyle(\"-fx-font-size: 10px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        description.setWrapText(true);\n        \n        Label valueLabel = new Label(\"Short (1 min)  Current: 20 min  Long (100 min)\");\n        valueLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #D1D5DB;\");\n        \n        periodSlider = new Slider(1, 100, 20);\n        periodSlider.setShowTickLabels(true);\n        periodSlider.setShowTickMarks(true);\n        periodSlider.setMajorTickUnit(20);\n        periodSlider.setBlockIncrement(1);\n        periodSlider.setPrefWidth(600);\n        \n        periodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            valueLabel.setText(String.format(\"Short (1 min)  Current: %d min  Long (100 min)\", newVal.intValue()));\n        });\n        \n        content.getChildren().addAll(description, valueLabel, periodSlider);\n        section.setContent(content);\n        \n        return section;\n    }\n    \n    /**\n     * Create RSI Controls Section\n     * NOTE: RSI Period and Threshold sliders are now in dedicated sections below\n     * (regularRsiRocPeriodSlider and regularRsiRocThresholdSlider)\n     */\n    private TitledPane createRsiSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  RSI Controls (Mean Reversion)\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label warning = new Label(\" RSI threshold MUST remain negative for mean reversion strategy\");\n        warning.setStyle(\"-fx-font-size: 10px; -fx-font-weight: bold; -fx-text-fill: #6B7280;\");\n        \n        Label info = new Label(\"RSI configuration has been moved to dedicated sections:\\n\" +\n                               \"  RSI ROC Period section below controls the RSI calculation period\\n\" +\n                               \"  RSI ROC Threshold section below controls the threshold value\");\n        info.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #555555;\");\n        info.setWrapText(true);\n        \n        content.getChildren().addAll(warning, info);\n        section.setContent(content);\n        \n        return section;\n    }\n    \n    /**\n     * Create Price ROC Threshold Section\n     */\n    private TitledPane createPriceRocThresholdSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  Price ROC Threshold (per minute)\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"Price ROC: 2.0% per minute\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularPriceRocThresholdSlider = new Slider(0.1, 10.0, 2.0);\n        regularPriceRocThresholdSlider.setShowTickLabels(true);\n        regularPriceRocThresholdSlider.setMajorTickUnit(2.0);\n        regularPriceRocThresholdSlider.setPrefWidth(600);\n        regularPriceRocThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"Price ROC: %.1f%% per minute\", newVal.doubleValue()));\n        });\n        \n        content.getChildren().addAll(label, regularPriceRocThresholdSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create RSI ROC Threshold Section\n     */\n    private TitledPane createRsiRocThresholdSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  RSI ROC Threshold (per minute)\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"RSI ROC: -5.0% per minute (NEGATIVE = Mean Reversion)\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularRsiRocThresholdSlider = new Slider(-20.0, -0.1, -5.0);\n        regularRsiRocThresholdSlider.setShowTickLabels(true);\n        regularRsiRocThresholdSlider.setMajorTickUnit(5.0);\n        regularRsiRocThresholdSlider.setPrefWidth(600);\n        regularRsiRocThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"RSI ROC: %.1f%% per minute (NEGATIVE = Mean Reversion)\", newVal.doubleValue()));\n        });\n        \n        content.getChildren().addAll(label, regularRsiRocThresholdSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create OBV ROC Threshold Section\n     */\n    private TitledPane createObvRocThresholdSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  OBV ROC Threshold (per minute)\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"OBV ROC: 10.0% per minute\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularObvRocThresholdSlider = new Slider(0.1, 50.0, 10.0);\n        regularObvRocThresholdSlider.setShowTickLabels(true);\n        regularObvRocThresholdSlider.setMajorTickUnit(10.0);\n        regularObvRocThresholdSlider.setPrefWidth(600);\n        regularObvRocThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"OBV ROC: %.1f%% per minute\", newVal.doubleValue()));\n        });\n        \n        content.getChildren().addAll(label, regularObvRocThresholdSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create MFI ROC Threshold Section\n     */\n    private TitledPane createMfiRocThresholdSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  MFI ROC Threshold (per minute)\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"MFI ROC: 5.0% per minute\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularMfiRocThresholdSlider = new Slider(0.1, 20.0, 5.0);\n        regularMfiRocThresholdSlider.setShowTickLabels(true);\n        regularMfiRocThresholdSlider.setMajorTickUnit(5.0);\n        regularMfiRocThresholdSlider.setPrefWidth(600);\n        regularMfiRocThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"MFI ROC: %.1f%% per minute\", newVal.doubleValue()));\n        });\n        \n        content.getChildren().addAll(label, regularMfiRocThresholdSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create Percent B ROC Threshold Section\n     */\n    private TitledPane createPercentBRocThresholdSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  Bollinger %B ROC Threshold (per minute)\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"Bollinger %B ROC: 15.0% per minute\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularPercentBRocThresholdSlider = new Slider(0.1, 50.0, 15.0);\n        regularPercentBRocThresholdSlider.setShowTickLabels(true);\n        regularPercentBRocThresholdSlider.setMajorTickUnit(10.0);\n        regularPercentBRocThresholdSlider.setPrefWidth(600);\n        regularPercentBRocThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"Bollinger %%B ROC: %.1f%% per minute\", newVal.doubleValue()));\n        });\n        \n        content.getChildren().addAll(label, regularPercentBRocThresholdSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create VWAP ROC Threshold Section\n     */\n    private TitledPane createVwapRocThresholdSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  VWAP ROC Threshold (per minute)\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"VWAP ROC: 1.5% per minute\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularVwapRocThresholdSlider = new Slider(0.1, 10.0, 1.5);\n        regularVwapRocThresholdSlider.setShowTickLabels(true);\n        regularVwapRocThresholdSlider.setMajorTickUnit(2.0);\n        regularVwapRocThresholdSlider.setPrefWidth(600);\n        regularVwapRocThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"VWAP ROC: %.1f%% per minute\", newVal.doubleValue()));\n        });\n        \n        content.getChildren().addAll(label, regularVwapRocThresholdSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create Volume ROC Threshold Section\n     */\n    private TitledPane createVolumeRocThresholdSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  Volume ROC Threshold (per minute)\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"Volume ROC: 20.0% per minute\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularVolumeRocThresholdSlider = new Slider(1.0, 100.0, 20.0);\n        regularVolumeRocThresholdSlider.setShowTickLabels(true);\n        regularVolumeRocThresholdSlider.setMajorTickUnit(20.0);\n        regularVolumeRocThresholdSlider.setPrefWidth(600);\n        regularVolumeRocThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"Volume ROC: %.1f%% per minute\", newVal.doubleValue()));\n        });\n        \n        content.getChildren().addAll(label, regularVolumeRocThresholdSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create Price ROC Period Section\n     */\n    private TitledPane createPriceRocPeriodSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  Price ROC Period\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"Price ROC Period: 20 min\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularPriceRocPeriodSlider = new Slider(1, 100, 20);\n        regularPriceRocPeriodSlider.setShowTickLabels(true);\n        regularPriceRocPeriodSlider.setMajorTickUnit(20);\n        regularPriceRocPeriodSlider.setPrefWidth(600);\n        regularPriceRocPeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"Price ROC Period: %d min\", newVal.intValue()));\n        });\n        \n        content.getChildren().addAll(label, regularPriceRocPeriodSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create RSI ROC Period Section\n     */\n    private TitledPane createRsiRocPeriodSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  RSI ROC Period\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"RSI ROC Period: 14 min\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularRsiRocPeriodSlider = new Slider(1, 100, 14);\n        regularRsiRocPeriodSlider.setShowTickLabels(true);\n        regularRsiRocPeriodSlider.setMajorTickUnit(20);\n        regularRsiRocPeriodSlider.setPrefWidth(600);\n        regularRsiRocPeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"RSI ROC Period: %d min\", newVal.intValue()));\n        });\n        \n        content.getChildren().addAll(label, regularRsiRocPeriodSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create OBV ROC Period Section\n     */\n    private TitledPane createObvRocPeriodSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  OBV ROC Period\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"OBV ROC Period: 20 min\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularObvRocPeriodSlider = new Slider(1, 100, 20);\n        regularObvRocPeriodSlider.setShowTickLabels(true);\n        regularObvRocPeriodSlider.setMajorTickUnit(20);\n        regularObvRocPeriodSlider.setPrefWidth(600);\n        regularObvRocPeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"OBV ROC Period: %d min\", newVal.intValue()));\n        });\n        \n        content.getChildren().addAll(label, regularObvRocPeriodSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create MFI ROC Period Section\n     */\n    private TitledPane createMfiRocPeriodSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  MFI ROC Period\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"MFI ROC Period: 14 min\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularMfiRocPeriodSlider = new Slider(1, 100, 14);\n        regularMfiRocPeriodSlider.setShowTickLabels(true);\n        regularMfiRocPeriodSlider.setMajorTickUnit(20);\n        regularMfiRocPeriodSlider.setPrefWidth(600);\n        regularMfiRocPeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"MFI ROC Period: %d min\", newVal.intValue()));\n        });\n        \n        content.getChildren().addAll(label, regularMfiRocPeriodSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create Percent B ROC Period Section\n     */\n    private TitledPane createPercentBRocPeriodSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  Bollinger %B ROC Period\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"Bollinger %B ROC Period: 20 min\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularPercentBRocPeriodSlider = new Slider(1, 100, 20);\n        regularPercentBRocPeriodSlider.setShowTickLabels(true);\n        regularPercentBRocPeriodSlider.setMajorTickUnit(20);\n        regularPercentBRocPeriodSlider.setPrefWidth(600);\n        regularPercentBRocPeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"Bollinger %%B ROC Period: %d min\", newVal.intValue()));\n        });\n        \n        content.getChildren().addAll(label, regularPercentBRocPeriodSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create VWAP ROC Period Section\n     */\n    private TitledPane createVwapRocPeriodSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  VWAP ROC Period\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"VWAP ROC Period: 10 min\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularVwapRocPeriodSlider = new Slider(1, 100, 10);\n        regularVwapRocPeriodSlider.setShowTickLabels(true);\n        regularVwapRocPeriodSlider.setMajorTickUnit(20);\n        regularVwapRocPeriodSlider.setPrefWidth(600);\n        regularVwapRocPeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"VWAP ROC Period: %d min\", newVal.intValue()));\n        });\n        \n        content.getChildren().addAll(label, regularVwapRocPeriodSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create Volume ROC Period Section\n     */\n    private TitledPane createVolumeRocPeriodSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  Volume ROC Period\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(10);\n        content.setPadding(new Insets(15));\n        \n        Label label = new Label(\"Volume ROC Period: 20 min\");\n        label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        regularVolumeRocPeriodSlider = new Slider(1, 100, 20);\n        regularVolumeRocPeriodSlider.setShowTickLabels(true);\n        regularVolumeRocPeriodSlider.setMajorTickUnit(20);\n        regularVolumeRocPeriodSlider.setPrefWidth(600);\n        regularVolumeRocPeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            label.setText(String.format(\"Volume ROC Period: %d min\", newVal.intValue()));\n        });\n        \n        content.getChildren().addAll(label, regularVolumeRocPeriodSlider);\n        section.setContent(content);\n        return section;\n    }\n    \n    /**\n     * Create Risk Controls Section\n     */\n    private TitledPane createRiskControlsSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  Risk Controls\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(15);\n        content.setPadding(new Insets(15));\n        \n        Label description = new Label(\"Configure risk management thresholds for trading signals and stop losses\");\n        description.setStyle(\"-fx-font-size: 10px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        description.setWrapText(true);\n        \n        // Combo Signal Threshold\n        Label comboLabel = new Label(\"Combo Signal Threshold: 0.7\");\n        comboLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        comboSignalThresholdSlider = new Slider(0.1, 1.0, 0.7);\n        comboSignalThresholdSlider.setShowTickLabels(true);\n        comboSignalThresholdSlider.setMajorTickUnit(0.2);\n        comboSignalThresholdSlider.setPrefWidth(600);\n        comboSignalThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            comboLabel.setText(String.format(\"Combo Signal Threshold: %.2f\", newVal.doubleValue()));\n        });\n        \n        // High Probability Threshold\n        Label highProbLabel = new Label(\"High Probability Threshold: 0.5\");\n        highProbLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        highProbThresholdSlider = new Slider(0.1, 1.0, 0.5);\n        highProbThresholdSlider.setShowTickLabels(true);\n        highProbThresholdSlider.setMajorTickUnit(0.2);\n        highProbThresholdSlider.setPrefWidth(600);\n        highProbThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            highProbLabel.setText(String.format(\"High Probability Threshold: %.2f\", newVal.doubleValue()));\n        });\n        \n        // Stop Loss Percentage\n        Label stopLossLabel = new Label(\"Stop Loss Percentage: 2.0%\");\n        stopLossLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        stopLossPctSlider = new Slider(0.5, 10.0, 2.0);\n        stopLossPctSlider.setShowTickLabels(true);\n        stopLossPctSlider.setMajorTickUnit(2.0);\n        stopLossPctSlider.setPrefWidth(600);\n        stopLossPctSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            stopLossLabel.setText(String.format(\"Stop Loss Percentage: %.1f%%\", newVal.doubleValue()));\n        });\n        \n        // Initial Profit Floor Percentage\n        Label initialProfitFloorLabel = new Label(\"Initial Profit Floor: 3.0%\");\n        initialProfitFloorLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        initialProfitFloorPctSlider = new Slider(0.0, 20.0, 3.0);\n        initialProfitFloorPctSlider.setShowTickLabels(true);\n        initialProfitFloorPctSlider.setMajorTickUnit(5.0);\n        initialProfitFloorPctSlider.setPrefWidth(600);\n        initialProfitFloorPctSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            initialProfitFloorLabel.setText(String.format(\"Initial Profit Floor: %.1f%%\", newVal.doubleValue()));\n        });\n        \n        // Subsequent Profit Floor Percentage\n        Label subsequentProfitFloorLabel = new Label(\"Subsequent Profit Floor: 2.0%\");\n        subsequentProfitFloorLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        subsequentProfitFloorPctSlider = new Slider(0.0, 10.0, 2.0);\n        subsequentProfitFloorPctSlider.setShowTickLabels(true);\n        subsequentProfitFloorPctSlider.setMajorTickUnit(2.0);\n        subsequentProfitFloorPctSlider.setPrefWidth(600);\n        subsequentProfitFloorPctSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            subsequentProfitFloorLabel.setText(String.format(\"Subsequent Profit Floor: %.1f%%\", newVal.doubleValue()));\n        });\n        \n        content.getChildren().addAll(\n            description,\n            comboLabel, comboSignalThresholdSlider,\n            highProbLabel, highProbThresholdSlider,\n            stopLossLabel, stopLossPctSlider,\n            initialProfitFloorLabel, initialProfitFloorPctSlider,\n            subsequentProfitFloorLabel, subsequentProfitFloorPctSlider\n        );\n        section.setContent(content);\n        \n        return section;\n    }\n    \n    /**\n     * Create Capital Allocation Section\n     */\n    private TitledPane createCapitalAllocationSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  Capital Allocation\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(15);\n        content.setPadding(new Insets(15));\n        \n        Label description = new Label(\"Configure capital allocation and position sizing parameters\");\n        description.setStyle(\"-fx-font-size: 10px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        description.setWrapText(true);\n        \n        // Equity Per Trade\n        Label equityLabel = new Label(\"Equity Per Trade: $1000\");\n        equityLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        equityPerTradeSlider = new Slider(100, 10000, 1000);\n        equityPerTradeSlider.setShowTickLabels(true);\n        equityPerTradeSlider.setMajorTickUnit(2000);\n        equityPerTradeSlider.setPrefWidth(600);\n        equityPerTradeSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            equityLabel.setText(String.format(\"Equity Per Trade: $%.0f\", newVal.doubleValue()));\n        });\n        \n        // Max Open Trades\n        Label maxTradesLabel = new Label(\"Max Open Trades: 5\");\n        maxTradesLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        maxOpenTradesSlider = new Slider(1, 20, 5);\n        maxOpenTradesSlider.setShowTickLabels(true);\n        maxOpenTradesSlider.setMajorTickUnit(5);\n        maxOpenTradesSlider.setPrefWidth(600);\n        maxOpenTradesSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            maxTradesLabel.setText(String.format(\"Max Open Trades: %d\", newVal.intValue()));\n        });\n        \n        // Total Equity Available\n        Label totalEquityLabel = new Label(\"Total Equity Available: $10000\");\n        totalEquityLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        totalEquityAvailableSlider = new Slider(1000, 100000, 10000);\n        totalEquityAvailableSlider.setShowTickLabels(true);\n        totalEquityAvailableSlider.setMajorTickUnit(20000);\n        totalEquityAvailableSlider.setPrefWidth(600);\n        totalEquityAvailableSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            totalEquityLabel.setText(String.format(\"Total Equity Available: $%.0f\", newVal.doubleValue()));\n            // Auto-sync to backtest capital field (read-only display)\n            if (backtestCapital != null) {\n                backtestCapital.setText(String.format(\"%.0f\", newVal.doubleValue()));\n            }\n        });\n        \n        content.getChildren().addAll(\n            description,\n            equityLabel, equityPerTradeSlider,\n            maxTradesLabel, maxOpenTradesSlider,\n            totalEquityLabel, totalEquityAvailableSlider\n        );\n        section.setContent(content);\n        \n        return section;\n    }\n    \n    /**\n     * Create System Behavior Section\n     */\n    private TitledPane createSystemBehaviorSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  System Behavior\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(15);\n        content.setPadding(new Insets(15));\n        \n        Label description = new Label(\"Configure system-wide behavior and data processing parameters\");\n        description.setStyle(\"-fx-font-size: 10px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        description.setWrapText(true);\n        \n        // Data Points\n        Label dataPointsLabel = new Label(\"Data Points (Buffer Size): 200\");\n        dataPointsLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        dataPointsSlider = new Slider(50, 500, 200);\n        dataPointsSlider.setShowTickLabels(true);\n        dataPointsSlider.setMajorTickUnit(100);\n        dataPointsSlider.setPrefWidth(600);\n        dataPointsSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            dataPointsLabel.setText(String.format(\"Data Points (Buffer Size): %d\", newVal.intValue()));\n        });\n        \n        // Enable Cooldowns\n        enableCooldownsCheckBox = new CheckBox(\"Enable Spike Cooldowns (prevent duplicate signals)\");\n        enableCooldownsCheckBox.setSelected(true);\n        enableCooldownsCheckBox.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        content.getChildren().addAll(\n            description,\n            dataPointsLabel, dataPointsSlider,\n            enableCooldownsCheckBox\n        );\n        section.setContent(content);\n        \n        return section;\n    }\n    \n    /**\n     * Create Indicator Windows Section\n     */\n    private TitledPane createIndicatorWindowsSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  Indicator Windows\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(15);\n        content.setPadding(new Insets(15));\n        \n        Label description = new Label(\"Configure calculation window periods for technical indicators\");\n        description.setStyle(\"-fx-font-size: 10px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        description.setWrapText(true);\n        \n        // WARNING for penny stocks\n        Label pennyStockWarning = new Label(\n            \" IMPORTANT: For stocks under $5, VWAP, MFI, and OBV are UNRELIABLE due to low liquidity and volume manipulation.\\n\" +\n            \" Recommended indicators for penny stocks: MACD, Stochastic, EMA, RVOL, RSI, and Bollinger Bands.\");\n        pennyStockWarning.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #6B7280; \" +\n                                   \"-fx-background-color: #374151; -fx-padding: 10; -fx-border-color: #4B5563; \" +\n                                   \"-fx-border-width: 2; -fx-border-radius: 5; -fx-background-radius: 5;\");\n        pennyStockWarning.setWrapText(true);\n        \n        // PRIORITY 5: Bollinger Band Length - Changed from 25 to 12 minutes\n        Label bbLabel = new Label(\"Bollinger Band Length: 12 min\");\n        bbLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        bbLengthMinutesSlider = new Slider(5, 30, 12);\n        bbLengthMinutesSlider.setShowTickLabels(true);\n        bbLengthMinutesSlider.setMajorTickUnit(20);\n        bbLengthMinutesSlider.setPrefWidth(600);\n        bbLengthMinutesSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            bbLabel.setText(String.format(\"Bollinger Band Length: %d min\", newVal.intValue()));\n        });\n        \n        // MFI Period\n        Label mfiLabel = new Label(\"MFI Period: 14 min\");\n        mfiLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        mfiPeriodMinutesSlider = new Slider(5, 50, 14);\n        mfiPeriodMinutesSlider.setShowTickLabels(true);\n        mfiPeriodMinutesSlider.setMajorTickUnit(10);\n        mfiPeriodMinutesSlider.setPrefWidth(600);\n        mfiPeriodMinutesSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            mfiLabel.setText(String.format(\"MFI Period: %d min\", newVal.intValue()));\n        });\n        \n        // VWAP Period\n        Label vwapLabel = new Label(\"VWAP Period: 10 min\");\n        vwapLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        vwapPeriodMinutesSlider = new Slider(5, 50, 10);\n        vwapPeriodMinutesSlider.setShowTickLabels(true);\n        vwapPeriodMinutesSlider.setMajorTickUnit(10);\n        vwapPeriodMinutesSlider.setPrefWidth(600);\n        vwapPeriodMinutesSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            vwapLabel.setText(String.format(\"VWAP Period: %d min\", newVal.intValue()));\n        });\n        \n        content.getChildren().addAll(\n            description,\n            pennyStockWarning,\n            bbLabel, bbLengthMinutesSlider,\n            mfiLabel, mfiPeriodMinutesSlider,\n            vwapLabel, vwapPeriodMinutesSlider\n        );\n        section.setContent(content);\n        \n        return section;\n    }\n    \n    /**\n     * Create Penny Stock Parameters Section - Fine-tune MACD, Stochastic, RVOL, EMA settings\n     */\n    private TitledPane createPennyStockParametersSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  Penny Stock Indicator Parameters\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(15);\n        content.setPadding(new Insets(15));\n        \n        Label description = new Label(\"Fine-tune parameters for penny stock indicators (MACD, Stochastic, RVOL, EMA)\");\n        description.setStyle(\"-fx-font-size: 10px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        description.setWrapText(true);\n        \n        // MACD Parameters\n        Label macdHeader = new Label(\"MACD Parameters (Moving Average Convergence Divergence)\");\n        macdHeader.setStyle(\"-fx-font-size: 12px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF;\");\n        \n        Label macdFastLabel = new Label(\"MACD Fast Period: 8 minutes\");\n        macdFastLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        macdFastPeriodSlider = new Slider(5, 20, 8);\n        macdFastPeriodSlider.setShowTickLabels(true);\n        macdFastPeriodSlider.setMajorTickUnit(5);\n        macdFastPeriodSlider.setPrefWidth(600);\n        macdFastPeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            macdFastLabel.setText(String.format(\"MACD Fast Period: %d minutes\", newVal.intValue()));\n        });\n        \n        Label macdSlowLabel = new Label(\"MACD Slow Period: 17 minutes\");\n        macdSlowLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        macdSlowPeriodSlider = new Slider(10, 30, 17);\n        macdSlowPeriodSlider.setShowTickLabels(true);\n        macdSlowPeriodSlider.setMajorTickUnit(5);\n        macdSlowPeriodSlider.setPrefWidth(600);\n        macdSlowPeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            macdSlowLabel.setText(String.format(\"MACD Slow Period: %d minutes\", newVal.intValue()));\n        });\n        \n        Label macdSignalLabel = new Label(\"MACD Signal Period: 9 minutes\");\n        macdSignalLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        macdSignalPeriodSlider = new Slider(5, 15, 9);\n        macdSignalPeriodSlider.setShowTickLabels(true);\n        macdSignalPeriodSlider.setMajorTickUnit(5);\n        macdSignalPeriodSlider.setPrefWidth(600);\n        macdSignalPeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            macdSignalLabel.setText(String.format(\"MACD Signal Period: %d minutes\", newVal.intValue()));\n        });\n        \n        Label macdHistogramRocLabel = new Label(\"MACD Histogram ROC Threshold: 0.5% (Predictive Trigger)\");\n        macdHistogramRocLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        macdHistogramRocThresholdSlider = new Slider(0.1, 2.0, 0.5);\n        macdHistogramRocThresholdSlider.setShowTickLabels(true);\n        macdHistogramRocThresholdSlider.setMajorTickUnit(0.5);\n        macdHistogramRocThresholdSlider.setPrefWidth(600);\n        macdHistogramRocThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            macdHistogramRocLabel.setText(String.format(\"MACD Histogram ROC Threshold: %.1f%% (Predictive Trigger)\", newVal.doubleValue()));\n        });\n        \n        Label macdRocHint = new Label(\"    Triggers when histogram  0 AND rising at least this % of price per bar (early warning before crossover)\");\n        macdRocHint.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #555555;\");\n        \n        // Stochastic Parameters\n        Label stochHeader = new Label(\"Stochastic Oscillator Parameters\");\n        stochHeader.setStyle(\"-fx-font-size: 12px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF; -fx-padding: 10 0 0 0;\");\n        \n        Label stochPeriodLabel = new Label(\"Stochastic Period: 14 minutes\");\n        stochPeriodLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        stochasticPeriodSlider = new Slider(5, 30, 14);\n        stochasticPeriodSlider.setShowTickLabels(true);\n        stochasticPeriodSlider.setMajorTickUnit(5);\n        stochasticPeriodSlider.setPrefWidth(600);\n        stochasticPeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            stochPeriodLabel.setText(String.format(\"Stochastic Period: %d minutes\", newVal.intValue()));\n        });\n        \n        Label stochKSmoothLabel = new Label(\"Stochastic %K Smoothing: 3\");\n        stochKSmoothLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        stochasticKSmoothSlider = new Slider(1, 5, 3);\n        stochasticKSmoothSlider.setShowTickLabels(true);\n        stochasticKSmoothSlider.setMajorTickUnit(1);\n        stochasticKSmoothSlider.setPrefWidth(600);\n        stochasticKSmoothSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            stochKSmoothLabel.setText(String.format(\"Stochastic %%K Smoothing: %d\", newVal.intValue()));\n        });\n        \n        Label stochDSmoothLabel = new Label(\"Stochastic %D Smoothing: 3\");\n        stochDSmoothLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        stochasticDSmoothSlider = new Slider(1, 5, 3);\n        stochasticDSmoothSlider.setShowTickLabels(true);\n        stochasticDSmoothSlider.setMajorTickUnit(1);\n        stochasticDSmoothSlider.setPrefWidth(600);\n        stochasticDSmoothSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            stochDSmoothLabel.setText(String.format(\"Stochastic %%D Smoothing: %d\", newVal.intValue()));\n        });\n        \n        Label stochOversoldLabel = new Label(\"Stochastic Oversold Threshold: 20\");\n        stochOversoldLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        stochasticOversoldThresholdSlider = new Slider(10, 30, 20);\n        stochasticOversoldThresholdSlider.setShowTickLabels(true);\n        stochasticOversoldThresholdSlider.setMajorTickUnit(5);\n        stochasticOversoldThresholdSlider.setPrefWidth(600);\n        stochasticOversoldThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            stochOversoldLabel.setText(String.format(\"Stochastic Oversold Threshold: %.0f\", newVal.doubleValue()));\n        });\n        \n        Label stochOverboughtLabel = new Label(\"Stochastic Overbought Threshold: 80\");\n        stochOverboughtLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        stochasticOverboughtThresholdSlider = new Slider(70, 90, 80);\n        stochasticOverboughtThresholdSlider.setShowTickLabels(true);\n        stochasticOverboughtThresholdSlider.setMajorTickUnit(5);\n        stochasticOverboughtThresholdSlider.setPrefWidth(600);\n        stochasticOverboughtThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            stochOverboughtLabel.setText(String.format(\"Stochastic Overbought Threshold: %.0f\", newVal.doubleValue()));\n        });\n        \n        // RVOL Parameters\n        Label rvolHeader = new Label(\"Relative Volume (RVOL) Parameters\");\n        rvolHeader.setStyle(\"-fx-font-size: 12px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF; -fx-padding: 10 0 0 0;\");\n        \n        Label rvolPeriodLabel = new Label(\"RVOL Period: 20 minutes\");\n        rvolPeriodLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        rvolPeriodSlider = new Slider(10, 50, 20);\n        rvolPeriodSlider.setShowTickLabels(true);\n        rvolPeriodSlider.setMajorTickUnit(10);\n        rvolPeriodSlider.setPrefWidth(600);\n        rvolPeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            rvolPeriodLabel.setText(String.format(\"RVOL Period: %d minutes\", newVal.intValue()));\n        });\n        \n        Label rvolThresholdLabel = new Label(\"RVOL Threshold: 2.0x (unusual volume)\");\n        rvolThresholdLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        rvolThresholdSlider = new Slider(1.5, 5.0, 2.0);\n        rvolThresholdSlider.setShowTickLabels(true);\n        rvolThresholdSlider.setMajorTickUnit(0.5);\n        rvolThresholdSlider.setPrefWidth(600);\n        rvolThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            rvolThresholdLabel.setText(String.format(\"RVOL Threshold: %.1fx (unusual volume)\", newVal.doubleValue()));\n        });\n        \n        // EMA Parameters\n        Label emaHeader = new Label(\"Exponential Moving Average (EMA) Parameters\");\n        emaHeader.setStyle(\"-fx-font-size: 12px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF; -fx-padding: 10 0 0 0;\");\n        \n        Label ema9Label = new Label(\"EMA9 Period: 9 minutes\");\n        ema9Label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        ema9PeriodSlider = new Slider(5, 15, 9);\n        ema9PeriodSlider.setShowTickLabels(true);\n        ema9PeriodSlider.setMajorTickUnit(5);\n        ema9PeriodSlider.setPrefWidth(600);\n        ema9PeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            ema9Label.setText(String.format(\"EMA9 Period: %d minutes\", newVal.intValue()));\n        });\n        \n        Label ema20Label = new Label(\"EMA20 Period: 20 minutes\");\n        ema20Label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        ema20PeriodSlider = new Slider(15, 30, 20);\n        ema20PeriodSlider.setShowTickLabels(true);\n        ema20PeriodSlider.setMajorTickUnit(5);\n        ema20PeriodSlider.setPrefWidth(600);\n        ema20PeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            ema20Label.setText(String.format(\"EMA20 Period: %d minutes\", newVal.intValue()));\n        });\n        \n        Label ema50Label = new Label(\"EMA50 Period: 50 minutes\");\n        ema50Label.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        ema50PeriodSlider = new Slider(40, 100, 50);\n        ema50PeriodSlider.setShowTickLabels(true);\n        ema50PeriodSlider.setMajorTickUnit(20);\n        ema50PeriodSlider.setPrefWidth(600);\n        ema50PeriodSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            ema50Label.setText(String.format(\"EMA50 Period: %d minutes\", newVal.intValue()));\n        });\n        \n        // Volume Spike Threshold\n        Label volSpikeHeader = new Label(\"Volume Spike Detection\");\n        volSpikeHeader.setStyle(\"-fx-font-size: 12px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF; -fx-padding: 10 0 0 0;\");\n        \n        Label volSpikeLabel = new Label(\"Volume Spike Threshold: 2.0x\");\n        volSpikeLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        volumeSpikeThresholdSlider = new Slider(1.5, 5.0, 2.0);\n        volumeSpikeThresholdSlider.setShowTickLabels(true);\n        volumeSpikeThresholdSlider.setMajorTickUnit(0.5);\n        volumeSpikeThresholdSlider.setPrefWidth(600);\n        volumeSpikeThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            volSpikeLabel.setText(String.format(\"Volume Spike Threshold: %.1fx\", newVal.doubleValue()));\n        });\n        \n        content.getChildren().addAll(\n            description,\n            macdHeader, macdFastLabel, macdFastPeriodSlider,\n            macdSlowLabel, macdSlowPeriodSlider,\n            macdSignalLabel, macdSignalPeriodSlider,\n            macdHistogramRocLabel, macdHistogramRocThresholdSlider, macdRocHint,\n            stochHeader, stochPeriodLabel, stochasticPeriodSlider,\n            stochKSmoothLabel, stochasticKSmoothSlider,\n            stochDSmoothLabel, stochasticDSmoothSlider,\n            stochOversoldLabel, stochasticOversoldThresholdSlider,\n            stochOverboughtLabel, stochasticOverboughtThresholdSlider,\n            rvolHeader, rvolPeriodLabel, rvolPeriodSlider,\n            rvolThresholdLabel, rvolThresholdSlider,\n            emaHeader, ema9Label, ema9PeriodSlider,\n            ema20Label, ema20PeriodSlider,\n            ema50Label, ema50PeriodSlider,\n            volSpikeHeader, volSpikeLabel, volumeSpikeThresholdSlider\n        );\n        section.setContent(content);\n        \n        return section;\n    }\n    \n    /**\n     * Create Individual Spike Thresholds Section\n     */\n    private TitledPane createIndividualSpikeThresholdsSection() {\n        TitledPane section = new TitledPane();\n        section.setText(\"  Individual Spike Thresholds (Z-scores)\");\n        section.setExpanded(false);\n        \n        VBox content = new VBox(15);\n        content.setPadding(new Insets(15));\n        \n        Label description = new Label(\"Fine-tune individual spike detection thresholds for each indicator (Z-score based)\");\n        description.setStyle(\"-fx-font-size: 10px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        description.setWrapText(true);\n        \n        // Price Spike Threshold\n        Label priceLabel = new Label(\"Price Spike Z-Threshold: 1.0\");\n        priceLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        spikePriceRocZThresholdSlider = new Slider(0.1, 5.0, 1.0);\n        spikePriceRocZThresholdSlider.setShowTickLabels(true);\n        spikePriceRocZThresholdSlider.setMajorTickUnit(1.0);\n        spikePriceRocZThresholdSlider.setPrefWidth(600);\n        spikePriceRocZThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            priceLabel.setText(String.format(\"Price Spike Z-Threshold: %.1f\", newVal.doubleValue()));\n        });\n        \n        // RSI Spike Threshold\n        Label rsiLabel = new Label(\"RSI Spike Z-Threshold: 0.5\");\n        rsiLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        spikeRsiRocZThresholdSlider = new Slider(0.1, 5.0, 0.5);\n        spikeRsiRocZThresholdSlider.setShowTickLabels(true);\n        spikeRsiRocZThresholdSlider.setMajorTickUnit(1.0);\n        spikeRsiRocZThresholdSlider.setPrefWidth(600);\n        spikeRsiRocZThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            rsiLabel.setText(String.format(\"RSI Spike Z-Threshold: %.1f\", newVal.doubleValue()));\n        });\n        \n        // OBV Spike Threshold\n        Label obvLabel = new Label(\"OBV Spike Z-Threshold: 0.5\");\n        obvLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        spikeObvRocZThresholdSlider = new Slider(0.1, 5.0, 0.5);\n        spikeObvRocZThresholdSlider.setShowTickLabels(true);\n        spikeObvRocZThresholdSlider.setMajorTickUnit(1.0);\n        spikeObvRocZThresholdSlider.setPrefWidth(600);\n        spikeObvRocZThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            obvLabel.setText(String.format(\"OBV Spike Z-Threshold: %.1f\", newVal.doubleValue()));\n        });\n        \n        // MFI Spike Threshold\n        Label mfiLabel = new Label(\"MFI Spike Z-Threshold: 0.6\");\n        mfiLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        spikeMfiRocZThresholdSlider = new Slider(0.1, 5.0, 0.6);\n        spikeMfiRocZThresholdSlider.setShowTickLabels(true);\n        spikeMfiRocZThresholdSlider.setMajorTickUnit(1.0);\n        spikeMfiRocZThresholdSlider.setPrefWidth(600);\n        spikeMfiRocZThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            mfiLabel.setText(String.format(\"MFI Spike Z-Threshold: %.1f\", newVal.doubleValue()));\n        });\n        \n        // Percent B Spike Threshold\n        Label percentBLabel = new Label(\"Bollinger %B Spike Z-Threshold: 0.5\");\n        percentBLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        spikePercentBRocZThresholdSlider = new Slider(0.1, 5.0, 0.5);\n        spikePercentBRocZThresholdSlider.setShowTickLabels(true);\n        spikePercentBRocZThresholdSlider.setMajorTickUnit(1.0);\n        spikePercentBRocZThresholdSlider.setPrefWidth(600);\n        spikePercentBRocZThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            percentBLabel.setText(String.format(\"Bollinger %%B Spike Z-Threshold: %.1f\", newVal.doubleValue()));\n        });\n        \n        // VWAP Spike Threshold\n        Label vwapLabel = new Label(\"VWAP Spike Z-Threshold: 0.5\");\n        vwapLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        spikeVwapRocZThresholdSlider = new Slider(0.1, 5.0, 0.5);\n        spikeVwapRocZThresholdSlider.setShowTickLabels(true);\n        spikeVwapRocZThresholdSlider.setMajorTickUnit(1.0);\n        spikeVwapRocZThresholdSlider.setPrefWidth(600);\n        spikeVwapRocZThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            vwapLabel.setText(String.format(\"VWAP Spike Z-Threshold: %.1f\", newVal.doubleValue()));\n        });\n        \n        // Volume Spike Threshold\n        Label volumeLabel = new Label(\"Volume Spike Z-Threshold: 0.5\");\n        volumeLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        spikeVolumeRocZThresholdSlider = new Slider(0.1, 5.0, 0.5);\n        spikeVolumeRocZThresholdSlider.setShowTickLabels(true);\n        spikeVolumeRocZThresholdSlider.setMajorTickUnit(1.0);\n        spikeVolumeRocZThresholdSlider.setPrefWidth(600);\n        spikeVolumeRocZThresholdSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            volumeLabel.setText(String.format(\"Volume Spike Z-Threshold: %.1f\", newVal.doubleValue()));\n        });\n        \n        content.getChildren().addAll(\n            description,\n            priceLabel, spikePriceRocZThresholdSlider,\n            rsiLabel, spikeRsiRocZThresholdSlider,\n            obvLabel, spikeObvRocZThresholdSlider,\n            mfiLabel, spikeMfiRocZThresholdSlider,\n            percentBLabel, spikePercentBRocZThresholdSlider,\n            vwapLabel, spikeVwapRocZThresholdSlider,\n            volumeLabel, spikeVolumeRocZThresholdSlider\n        );\n        section.setContent(content);\n        \n        return section;\n    }\n    \n    /**\n     * Tab 2:  Ticker Analysis\n     */\n    private Tab createTickerAnalysisTab() {\n        Tab tab = new Tab(\" Ticker Analysis\");\n        \n        // FIXED: Add ScrollPane for entire tab\n        ScrollPane scrollPane = new ScrollPane();\n        scrollPane.setFitToWidth(true);\n        scrollPane.setFitToHeight(true);\n        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);\n        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);\n        \n        VBox content = new VBox(15);\n        content.setPadding(new Insets(20));\n        content.setStyle(\"-fx-background-color: #FAFBFC;\");\n        \n        // Header\n        Label headerLabel = new Label(\" Unified Ticker Analysis - Buy & Sell Signals\");\n        headerLabel.setStyle(\"-fx-font-size: 18px; -fx-font-weight: bold; -fx-text-fill: #1A2332;\");\n        \n        // Control panel\n        HBox controlPanel = new HBox(10);\n        controlPanel.setAlignment(Pos.CENTER_LEFT);\n        controlPanel.setPadding(new Insets(15));\n        controlPanel.setStyle(\"-fx-background-color: white; -fx-border-color: #D4DAE4; -fx-border-width: 1; \" +\n                             \"-fx-border-radius: 8; -fx-background-radius: 8;\");\n        \n        Label symbolLabel = new Label(\"Symbol:\");\n        symbolLabel.setStyle(\"-fx-font-size: 11px;\");\n        \n        tickerSymbolEntry = new TextField(\"AAPL\");\n        tickerSymbolEntry.setPrefWidth(100);\n        \n        Button addTickerButton = new Button(\"+ Add Ticker\");\n        addTickerButton.getStyleClass().add(\"button-green\");\n        addTickerButton.setPrefWidth(120);\n        addTickerButton.setPrefHeight(40);\n        addTickerButton.setOnAction(e -> addTicker());\n        \n        Button removeAllButton = new Button(\" Remove All\");\n        removeAllButton.getStyleClass().add(\"button-red\");\n        removeAllButton.setPrefWidth(120);\n        removeAllButton.setPrefHeight(40);\n        removeAllButton.setOnAction(e -> removeAllTickers());\n        \n        Button testSignalButton = new Button(\" Test Signal\");\n        testSignalButton.getStyleClass().add(\"rounded-button\");\n        testSignalButton.setPrefWidth(120);\n        testSignalButton.setPrefHeight(40);\n        testSignalButton.setOnAction(e -> testSignalForSelectedTicker());\n        \n        Label infoLabel = new Label(\" Updates every 10s |  = Active Position |  = Sell Signal\");\n        infoLabel.setStyle(\"-fx-font-size: 10px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        \n        Region spacer = new Region();\n        HBox.setHgrow(spacer, Priority.ALWAYS);\n        \n        controlPanel.getChildren().addAll(symbolLabel, tickerSymbolEntry, addTickerButton, \n                                         removeAllButton, testSignalButton, spacer, infoLabel);\n        \n        // Ticker table with FIXED cell formatters - Bind to ApplicationState for cross-tab synchronization\n        tickerTable = new TableView<>();\n        tickerTable.setItems(appState.getTickerDataList());\n        tickerTable.setPlaceholder(new Label(\"No tickers added. Add a ticker symbol above.\"));\n        tickerTable.setPrefHeight(400);\n        \n        TableColumn<TickerData, String> symbolCol = new TableColumn<>(\"Symbol\");\n        symbolCol.setCellValueFactory(new PropertyValueFactory<>(\"symbol\"));\n        symbolCol.setPrefWidth(100);\n        \n        TableColumn<TickerData, Double> priceCol = new TableColumn<>(\"Price\");\n        priceCol.setCellValueFactory(new PropertyValueFactory<>(\"price\"));\n        priceCol.setPrefWidth(100);\n        priceCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double price, boolean empty) {\n                super.updateItem(price, empty);\n                if (empty || price == null) {\n                    setText(null);\n                } else {\n                    setText(String.format(\"$%.2f\", price));\n                }\n            }\n        });\n        \n        TableColumn<TickerData, Double> probabilityCol = new TableColumn<>(\"Buy Probability\");\n        probabilityCol.setCellValueFactory(new PropertyValueFactory<>(\"probability\"));\n        probabilityCol.setPrefWidth(120);\n        probabilityCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double prob, boolean empty) {\n                super.updateItem(prob, empty);\n                if (empty || prob == null) {\n                    setText(null);\n                    setStyle(\"\");\n                } else {\n                    String indicator = prob > 0.7 ? \" \" : prob > 0.5 ? \" \" : \"\";\n                    setText(indicator + String.format(\"%.1f%%\", prob * 100));\n                    setStyle(prob > 0.7 ? \"-fx-font-weight: bold;\" : \"\");\n                }\n            }\n        });\n        \n        TableColumn<TickerData, Double> rsiCol = new TableColumn<>(\"RSI\");\n        rsiCol.setCellValueFactory(new PropertyValueFactory<>(\"rsi\"));\n        rsiCol.setPrefWidth(60);\n        rsiCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double rsi, boolean empty) {\n                super.updateItem(rsi, empty);\n                if (empty || rsi == null) {\n                    setText(null);\n                } else {\n                    setText(String.format(\"%.1f\", rsi));\n                }\n            }\n        });\n        \n        TableColumn<TickerData, Double> priceRocCol = new TableColumn<>(\"Price ROC%/min\");\n        priceRocCol.setCellValueFactory(new PropertyValueFactory<>(\"priceRoc\"));\n        priceRocCol.setPrefWidth(90);\n        priceRocCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double roc, boolean empty) {\n                super.updateItem(roc, empty);\n                if (empty || roc == null) {\n                    setText(null);\n                } else {\n                    setText(String.format(\"%.2f%%\", roc));\n                }\n            }\n        });\n        \n        TableColumn<TickerData, Double> volumeRocCol = new TableColumn<>(\"Volume ROC%/min\");\n        volumeRocCol.setCellValueFactory(new PropertyValueFactory<>(\"volumeRoc\"));\n        volumeRocCol.setPrefWidth(100);\n        volumeRocCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double roc, boolean empty) {\n                super.updateItem(roc, empty);\n                if (empty || roc == null) {\n                    setText(null);\n                } else {\n                    setText(String.format(\"%.2f%%\", roc));\n                }\n            }\n        });\n        \n        TableColumn<TickerData, Double> obvRocCol = new TableColumn<>(\"OBV ROC%/min\");\n        obvRocCol.setCellValueFactory(new PropertyValueFactory<>(\"obvRoc\"));\n        obvRocCol.setPrefWidth(100);\n        obvRocCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double obvRoc, boolean empty) {\n                super.updateItem(obvRoc, empty);\n                if (empty || obvRoc == null) {\n                    setText(null);\n                } else {\n                    setText(String.format(\"%.2f%%\", obvRoc));\n                }\n            }\n        });\n        \n        TableColumn<TickerData, Double> mfiCol = new TableColumn<>(\"MFI\");\n        mfiCol.setCellValueFactory(new PropertyValueFactory<>(\"mfi\"));\n        mfiCol.setPrefWidth(60);\n        mfiCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double mfi, boolean empty) {\n                super.updateItem(mfi, empty);\n                if (empty || mfi == null) {\n                    setText(null);\n                } else {\n                    setText(String.format(\"%.1f\", mfi));\n                }\n            }\n        });\n\n        TableColumn<TickerData, Double> bollingerPosCol = new TableColumn<>(\"BB Position\");\n        bollingerPosCol.setCellValueFactory(new PropertyValueFactory<>(\"bollingerPosition\"));\n        bollingerPosCol.setPrefWidth(80);\n        bollingerPosCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double bbPos, boolean empty) {\n                super.updateItem(bbPos, empty);\n                if (empty || bbPos == null) {\n                    setText(null);\n                } else {\n                    setText(String.format(\"%.2f\", bbPos));\n                }\n            }\n        });\n        \n        TableColumn<TickerData, Double> percentBCol = new TableColumn<>(\"Bollinger %B\");\n        percentBCol.setCellValueFactory(new PropertyValueFactory<>(\"percentB\"));\n        percentBCol.setPrefWidth(80);\n        percentBCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double percentB, boolean empty) {\n                super.updateItem(percentB, empty);\n                if (empty || percentB == null) {\n                    setText(null);\n                } else {\n                    setText(String.format(\"%.2f\", percentB));\n                }\n            }\n        });\n        \n        TableColumn<TickerData, Double> vwapCol = new TableColumn<>(\"VWAP\");\n        vwapCol.setCellValueFactory(new PropertyValueFactory<>(\"vwap\"));\n        vwapCol.setPrefWidth(80);\n        vwapCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double vwap, boolean empty) {\n                super.updateItem(vwap, empty);\n                if (empty || vwap == null) {\n                    setText(null);\n                } else {\n                    setText(String.format(\"$%.2f\", vwap));\n                }\n            }\n        });\n        \n        TableColumn<TickerData, Double> atrCol = new TableColumn<>(\"ATR\");\n        atrCol.setCellValueFactory(new PropertyValueFactory<>(\"atr\"));\n        atrCol.setPrefWidth(70);\n        atrCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double atr, boolean empty) {\n                super.updateItem(atr, empty);\n                if (empty || atr == null) {\n                    setText(null);\n                } else {\n                    setText(String.format(\"$%.2f\", atr));\n                }\n            }\n        });\n        \n        // NEW PENNY STOCK INDICATOR COLUMNS\n        TableColumn<TickerData, Double> macdCol = new TableColumn<>(\"MACD\");\n        macdCol.setCellValueFactory(new PropertyValueFactory<>(\"macdHistogram\"));\n        macdCol.setPrefWidth(70);\n        macdCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double macd, boolean empty) {\n                super.updateItem(macd, empty);\n                if (empty || macd == null) {\n                    setText(null);\n                    setStyle(\"\");\n                } else {\n                    String indicator = macd > 0 ? \" \" : macd < 0 ? \" \" : \"\";\n                    setText(indicator + String.format(\"%.4f\", macd));\n                    setStyle(Math.abs(macd) > 0.001 ? \"-fx-font-weight: 600;\" : \"\");\n                }\n            }\n        });\n        \n        TableColumn<TickerData, Double> stochCol = new TableColumn<>(\"Stoch %K\");\n        stochCol.setCellValueFactory(new PropertyValueFactory<>(\"stochK\"));\n        stochCol.setPrefWidth(75);\n        stochCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double stoch, boolean empty) {\n                super.updateItem(stoch, empty);\n                if (empty || stoch == null) {\n                    setText(null);\n                    setStyle(\"\");\n                } else {\n                    String indicator = stoch < 20 ? \" \" : stoch > 80 ? \" \" : \"\";\n                    setText(indicator + String.format(\"%.1f\", stoch));\n                    setStyle((stoch < 20 || stoch > 80) ? \"-fx-font-weight: 600;\" : \"\");\n                }\n            }\n        });\n        \n        TableColumn<TickerData, Double> rvolCol = new TableColumn<>(\"RVOL\");\n        rvolCol.setCellValueFactory(new PropertyValueFactory<>(\"rvol\"));\n        rvolCol.setPrefWidth(65);\n        rvolCol.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double rvol, boolean empty) {\n                super.updateItem(rvol, empty);\n                if (empty || rvol == null) {\n                    setText(null);\n                    setStyle(\"\");\n                } else {\n                    String indicator = rvol > 2.0 ? \" \" : \"\";\n                    setText(indicator + String.format(\"%.2fx\", rvol));\n                    setStyle(rvol > 2.0 ? \"-fx-font-weight: 600;\" : \"\");\n                }\n            }\n        });\n        \n        TableColumn<TickerData, Double> ema9Col = new TableColumn<>(\"EMA9\");\n        ema9Col.setCellValueFactory(new PropertyValueFactory<>(\"ema9\"));\n        ema9Col.setPrefWidth(70);\n        ema9Col.setCellFactory(tc -> new TableCell<TickerData, Double>() {\n            @Override\n            protected void updateItem(Double ema, boolean empty) {\n                super.updateItem(ema, empty);\n                if (empty || ema == null) {\n                    setText(null);\n                } else {\n                    setText(String.format(\"$%.2f\", ema));\n                }\n            }\n        });\n        \n        TableColumn<TickerData, String> positionCol = new TableColumn<>(\"Position\");\n        positionCol.setCellValueFactory(new PropertyValueFactory<>(\"position\"));\n        positionCol.setPrefWidth(120);\n        \n        TableColumn<TickerData, String> plCol = new TableColumn<>(\"P/L\");\n        plCol.setCellValueFactory(new PropertyValueFactory<>(\"profitLoss\"));\n        plCol.setPrefWidth(100);\n        \n        tickerTable.getColumns().addAll(symbolCol, priceCol, probabilityCol, rsiCol, priceRocCol, volumeRocCol, \n                                        obvRocCol, mfiCol, bollingerPosCol, percentBCol, vwapCol, atrCol, \n                                        macdCol, stochCol, rvolCol, ema9Col, positionCol, plCol);\n        \n        // Add context menu for removing individual tickers (FIX #3: Memory Leak Prevention)\n        ContextMenu contextMenu = new ContextMenu();\n        MenuItem removeItem = new MenuItem(\"Remove Ticker\");\n        removeItem.setOnAction(e -> {\n            TickerData selected = tickerTable.getSelectionModel().getSelectedItem();\n            if (selected != null) {\n                removeTicker(selected.getSymbol());\n            }\n        });\n        contextMenu.getItems().add(removeItem);\n        tickerTable.setContextMenu(contextMenu);\n        \n        // Market Statistics Panel\n        VBox statsPanel = new VBox(10);\n        statsPanel.setPadding(new Insets(15));\n        statsPanel.setStyle(\"-fx-background-color: white; -fx-border-color: #D4DAE4; -fx-border-width: 1; \" +\n                           \"-fx-border-radius: 8; -fx-background-radius: 8;\");\n        \n        Label statsTitle = new Label(\" Market Statistics\");\n        statsTitle.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold; -fx-text-fill: #1A2332;\");\n        \n        // Create statistics grid\n        GridPane statsGrid = new GridPane();\n        statsGrid.setHgap(30);\n        statsGrid.setVgap(10);\n        statsGrid.setPadding(new Insets(10, 0, 0, 0));\n        \n        // Row 1\n        statsGrid.add(new Label(\"Average Signal Probability:\"), 0, 0);\n        Label avgProbLabel = new Label(\"--\");\n        avgProbLabel.setStyle(\"-fx-font-weight: bold; -fx-text-fill: #2563EB;\");\n        statsGrid.add(avgProbLabel, 1, 0);\n        \n        statsGrid.add(new Label(\"High Probability Signals (>70%):\"), 2, 0);\n        Label highProbLabel = new Label(\"--\");\n        highProbLabel.setStyle(\"-fx-font-weight: 600;\");\n        statsGrid.add(highProbLabel, 3, 0);\n        \n        // Row 2\n        statsGrid.add(new Label(\"Average RSI:\"), 0, 1);\n        Label avgRsiLabel = new Label(\"--\");\n        avgRsiLabel.setStyle(\"-fx-font-weight: bold;\");\n        statsGrid.add(avgRsiLabel, 1, 1);\n        \n        statsGrid.add(new Label(\"Oversold (<30):\"), 2, 1);\n        Label oversoldLabel = new Label(\"--\");\n        oversoldLabel.setStyle(\"-fx-font-weight: 600;\");\n        statsGrid.add(oversoldLabel, 3, 1);\n        \n        // Row 3\n        statsGrid.add(new Label(\"Average Price Momentum:\"), 0, 2);\n        Label avgMomentumLabel = new Label(\"--\");\n        avgMomentumLabel.setStyle(\"-fx-font-weight: bold;\");\n        statsGrid.add(avgMomentumLabel, 1, 2);\n        \n        statsGrid.add(new Label(\"Positive Momentum Count:\"), 2, 2);\n        Label posMomentumLabel = new Label(\"--\");\n        posMomentumLabel.setStyle(\"-fx-font-weight: 600;\");\n        statsGrid.add(posMomentumLabel, 3, 2);\n        \n        // Row 4\n        statsGrid.add(new Label(\"Average Volume Activity:\"), 0, 3);\n        Label avgVolumeLabel = new Label(\"--\");\n        avgVolumeLabel.setStyle(\"-fx-font-weight: bold;\");\n        statsGrid.add(avgVolumeLabel, 1, 3);\n        \n        statsGrid.add(new Label(\"High Volume Signals (>50%):\"), 2, 3);\n        Label highVolumeLabel = new Label(\"--\");\n        highVolumeLabel.setStyle(\"-fx-font-weight: bold; -fx-text-fill: #2563EB;\");\n        statsGrid.add(highVolumeLabel, 3, 3);\n        \n        statsPanel.getChildren().addAll(statsTitle, statsGrid);\n        \n        // Add selection listener to update stats when ticker selection changes\n        tickerTable.getSelectionModel().selectedItemProperty().addListener((obs, oldSelection, newSelection) -> {\n            updateMarketStatistics(avgProbLabel, highProbLabel, avgRsiLabel, oversoldLabel, \n                                  avgMomentumLabel, posMomentumLabel, avgVolumeLabel, highVolumeLabel);\n        });\n        \n        // Update stats whenever table items change\n        tickerTable.getItems().addListener((javafx.collections.ListChangeListener.Change<? extends TickerData> c) -> {\n            updateMarketStatistics(avgProbLabel, highProbLabel, avgRsiLabel, oversoldLabel, \n                                  avgMomentumLabel, posMomentumLabel, avgVolumeLabel, highVolumeLabel);\n        });\n        \n        content.getChildren().addAll(headerLabel, controlPanel, tickerTable, statsPanel);\n        \n        // FIXED: Wrap content in ScrollPane\n        scrollPane.setContent(content);\n        tab.setContent(scrollPane);\n        \n        // REPLACE WITH THIS:\n        // Start continuous probability polling if trading is enabled\n        if (appState.isTradingEnabled() && !tickerTable.getItems().isEmpty()) {\n            List<String> symbols = tickerTable.getItems().stream()\n                .map(TickerData::getSymbol)\n                .collect(Collectors.toList());\n            startProbabilityPolling(symbols);\n        }\n        \n        return tab;\n    }\n    \n    /**\n     * Tab 3:  Trade Tracker\n     */\n    private Tab createTradeTrackerTab() {\n        Tab tab = new Tab(\" Trade Tracker\");\n        \n        \n        ScrollPane scrollPane = new ScrollPane();\n        scrollPane.setFitToWidth(true);\n        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);\n        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);\n        VBox content = new VBox(15);\n        content.setPadding(new Insets(20));\n        content.setStyle(\"-fx-background-color: #FAFBFC;\");\n        \n        // Header\n        Label headerLabel = new Label(\" Trade History & Performance\");\n        headerLabel.setStyle(\"-fx-font-size: 18px; -fx-font-weight: bold; -fx-text-fill: #1A2332;\");\n        \n        // Stats panel\n        GridPane statsGrid = new GridPane();\n        statsGrid.setHgap(15);\n        statsGrid.setVgap(10);\n        statsGrid.setPadding(new Insets(15));\n        statsGrid.setStyle(\"-fx-background-color: white; -fx-border-color: #D4DAE4; -fx-border-width: 1; \" +\n                          \"-fx-border-radius: 8; -fx-background-radius: 8;\");\n        \n        totalTradesLabel = createStatLabel(\"Total Trades:\", \"0\");\n        winRateLabel = createStatLabel(\"Win Rate:\", \"0%\");\n        avgProfitLabel = createStatLabel(\"Avg Profit:\", \"$0.00\");\n        totalProfitLabel = createStatLabel(\"Total Profit:\", \"$0.00\");\n        \n        statsGrid.add(new Label(\"Total Trades:\"), 0, 0);\n        statsGrid.add(totalTradesLabel, 1, 0);\n        statsGrid.add(new Label(\"Win Rate:\"), 2, 0);\n        statsGrid.add(winRateLabel, 3, 0);\n        statsGrid.add(new Label(\"Avg Profit:\"), 0, 1);\n        statsGrid.add(avgProfitLabel, 1, 1);\n        statsGrid.add(new Label(\"Total Profit:\"), 2, 1);\n        statsGrid.add(totalProfitLabel, 3, 1);\n        \n        // Trade table - Bind to ApplicationState for cross-tab synchronization\n        tradeTable = new TableView<>();\n        tradeTable.setItems(appState.getTradeRecords());\n        tradeTable.setPlaceholder(new Label(\"No trades yet. Trades will appear here after execution.\"));\n        \n        TableColumn<TradeRecord, String> symbolCol = new TableColumn<>(\"Symbol\");\n        symbolCol.setCellValueFactory(new PropertyValueFactory<>(\"symbol\"));\n        symbolCol.setPrefWidth(100);\n        \n        TableColumn<TradeRecord, String> entryTimeCol = new TableColumn<>(\"Entry Time\");\n        entryTimeCol.setCellValueFactory(new PropertyValueFactory<>(\"entryTime\"));\n        entryTimeCol.setPrefWidth(150);\n        \n        TableColumn<TradeRecord, String> exitTimeCol = new TableColumn<>(\"Exit Time\");\n        exitTimeCol.setCellValueFactory(new PropertyValueFactory<>(\"exitTime\"));\n        exitTimeCol.setPrefWidth(150);\n        \n        TableColumn<TradeRecord, Double> entryPriceCol = new TableColumn<>(\"Entry Price\");\n        entryPriceCol.setCellValueFactory(new PropertyValueFactory<>(\"entryPrice\"));\n        entryPriceCol.setPrefWidth(100);\n        \n        TableColumn<TradeRecord, Double> exitPriceCol = new TableColumn<>(\"Exit Price\");\n        exitPriceCol.setCellValueFactory(new PropertyValueFactory<>(\"exitPrice\"));\n        exitPriceCol.setPrefWidth(100);\n        \n        TableColumn<TradeRecord, Integer> sharesCol = new TableColumn<>(\"Shares\");\n        sharesCol.setCellValueFactory(new PropertyValueFactory<>(\"shares\"));\n        sharesCol.setPrefWidth(80);\n        \n        TableColumn<TradeRecord, Double> profitCol = new TableColumn<>(\"Profit\");\n        profitCol.setCellValueFactory(new PropertyValueFactory<>(\"profit\"));\n        profitCol.setPrefWidth(100);\n        \n        TableColumn<TradeRecord, Double> profitPctCol = new TableColumn<>(\"Profit %\");\n        profitPctCol.setCellValueFactory(new PropertyValueFactory<>(\"profitPercent\"));\n        profitPctCol.setPrefWidth(100);\n        \n        TableColumn<TradeRecord, String> reasonCol = new TableColumn<>(\"Exit Reason\");\n        reasonCol.setCellValueFactory(new PropertyValueFactory<>(\"exitReason\"));\n        reasonCol.setPrefWidth(150);\n        \n        tradeTable.getColumns().addAll(symbolCol, entryTimeCol, exitTimeCol, entryPriceCol, \n                                      exitPriceCol, sharesCol, profitCol, profitPctCol, reasonCol);\n        VBox.setVgrow(tradeTable, Priority.ALWAYS);\n        \n        // Control buttons\n        HBox buttonBox = new HBox(10);\n        buttonBox.setAlignment(Pos.CENTER_LEFT);\n        \n        Button refreshButton = new Button(\" Refresh\");\n        refreshButton.getStyleClass().add(\"rounded-button\");\n        refreshButton.setPrefWidth(120);\n        refreshButton.setPrefHeight(36);\n        refreshButton.setOnAction(e -> refreshTrades());\n        \n        Button exportButton = new Button(\" Export CSV\");\n        exportButton.getStyleClass().add(\"rounded-button\");\n        exportButton.setPrefWidth(130);\n        exportButton.setPrefHeight(36);\n        exportButton.setOnAction(e -> exportTradesToCSV());\n        \n        Button triggerTradeButton = new Button(\" Trigger Trade\");\n        triggerTradeButton.getStyleClass().add(\"button-green\");\n        triggerTradeButton.setPrefWidth(140);\n        triggerTradeButton.setPrefHeight(36);\n        triggerTradeButton.setOnAction(e -> triggerTestTrade());\n        \n        Button clearButton = new Button(\" Clear All\");\n        clearButton.getStyleClass().add(\"button-red\");\n        clearButton.setPrefWidth(120);\n        clearButton.setPrefHeight(36);\n        clearButton.setOnAction(e -> clearAllTrades());\n        \n        buttonBox.getChildren().addAll(refreshButton, exportButton, triggerTradeButton, clearButton);\n        \n        content.getChildren().addAll(headerLabel, statsGrid, tradeTable, buttonBox);\n        \n        scrollPane.setContent(content);\n        tab.setContent(scrollPane);\n        \n        return tab;\n    }\n    \n    /**\n     * Tab 4:  Backtesting\n     */\n    private Tab createBacktestingTab() {\n        Tab tab = new Tab(\" Backtesting\");\n        \n        ScrollPane scrollPane = new ScrollPane();\n        scrollPane.setFitToWidth(true);\n        scrollPane.setFitToHeight(true);\n        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);\n        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);\n        \n        HBox mainContainer = new HBox(10);\n        mainContainer.setPadding(new Insets(10));\n        mainContainer.setStyle(\"-fx-background-color: #FAFBFC;\");\n        \n        // LEFT PANEL - Controls\n        VBox leftPanel = new VBox(15);\n        leftPanel.setPrefWidth(400);\n        leftPanel.setPadding(new Insets(15));\n        leftPanel.setStyle(\"-fx-background-color: white; -fx-border-color: #D4DAE4; -fx-border-width: 1; \" +\n                          \"-fx-border-radius: 8; -fx-background-radius: 8;\");\n        \n        Label titleLabel = new Label(\"Backtest Configuration\");\n        titleLabel.setStyle(\"-fx-font-size: 16px; -fx-font-weight: bold; -fx-text-fill: #1A2332;\");\n        \n        // WARNING BANNER: Remind users to update parameters first\n        VBox warningBanner = new VBox(8);\n        warningBanner.setPadding(new Insets(12));\n        warningBanner.setStyle(\"-fx-background-color: #374151; -fx-border-color: #4B5563; -fx-border-width: 2; \" +\n                              \"-fx-border-radius: 6; -fx-background-radius: 6;\");\n        \n        Label warningTitle = new Label(\" IMPORTANT: Update Parameters First\");\n        warningTitle.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #991B1B;\");\n        \n        Label warningText = new Label(\"Before running a backtest, make sure to click the \\\"UPDATE PARAMETERS\\\" \" +\n                                     \"button in the  Configuration tab. This ensures the backend uses your \" +\n                                     \"current settings instead of default values.\");\n        warningText.setWrapText(true);\n        warningText.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #7F1D1D;\");\n        \n        warningBanner.getChildren().addAll(warningTitle, warningText);\n        \n        // Symbol\n        VBox symbolSection = new VBox(5);\n        Label symbolLabel = new Label(\"Symbol\");\n        symbolLabel.setStyle(\"-fx-font-size: 10px; -fx-font-weight: bold;\");\n        backtestSymbolEntry = new TextField(\"AAPL\");\n        symbolSection.getChildren().addAll(symbolLabel, backtestSymbolEntry);\n        \n        // Date range\n        VBox dateSection = new VBox(5);\n        Label dateLabel = new Label(\"Date Range\");\n        dateLabel.setStyle(\"-fx-font-size: 10px; -fx-font-weight: bold;\");\n        \n        HBox startDateBox = new HBox(10);\n        startDateBox.setAlignment(Pos.CENTER_LEFT);\n        Label startLabel = new Label(\"Start Date (YYYY-MM-DD):\");\n        startLabel.setStyle(\"-fx-font-size: 9px;\");\n        backtestStartDate = new TextField(LocalDateTime.now().minusDays(30).format(DateTimeFormatter.ISO_DATE));\n        backtestStartDate.setPrefWidth(150);\n        startDateBox.getChildren().addAll(startLabel, backtestStartDate);\n        \n        HBox endDateBox = new HBox(10);\n        endDateBox.setAlignment(Pos.CENTER_LEFT);\n        Label endLabel = new Label(\"End Date (YYYY-MM-DD):\");\n        endLabel.setStyle(\"-fx-font-size: 9px;\");\n        backtestEndDate = new TextField(LocalDateTime.now().format(DateTimeFormatter.ISO_DATE));\n        backtestEndDate.setPrefWidth(150);\n        endDateBox.getChildren().addAll(endLabel, backtestEndDate);\n        \n        dateSection.getChildren().addAll(dateLabel, startDateBox, endDateBox);\n        \n        // Settings\n        VBox settingsSection = new VBox(5);\n        Label settingsLabel = new Label(\"Backtest Settings\");\n        settingsLabel.setStyle(\"-fx-font-size: 10px; -fx-font-weight: bold;\");\n        \n        HBox capitalBox = new HBox(10);\n        capitalBox.setAlignment(Pos.CENTER_LEFT);\n        Label capitalLabel = new Label(\"Initial Capital ($) - from Config Tab:\");\n        capitalLabel.setStyle(\"-fx-font-size: 9px;\");\n        backtestCapital = new TextField(\"10000\");\n        backtestCapital.setPrefWidth(120);\n        backtestCapital.setEditable(false);  // Read-only: value comes from Configuration tab\n        backtestCapital.setStyle(\"-fx-opacity: 0.7; -fx-background-color: #f0f0f0;\");\n        capitalBox.getChildren().addAll(capitalLabel, backtestCapital);\n        \n        HBox targetGainBox = new HBox(10);\n        targetGainBox.setAlignment(Pos.CENTER_LEFT);\n        Label targetGainLabel = new Label(\"Target Gain (%):\");\n        targetGainLabel.setStyle(\"-fx-font-size: 9px;\");\n        backtestTargetGain = new TextField(\"2.0\");\n        backtestTargetGain.setPrefWidth(120);\n        targetGainBox.getChildren().addAll(targetGainLabel, backtestTargetGain);\n        \n        settingsSection.getChildren().addAll(settingsLabel, capitalBox, targetGainBox);\n        \n        // Info\n        Label infoLabel = new Label(\" Uses current strategy parameters from Configuration tab\");\n        infoLabel.setStyle(\"-fx-font-size: 9px; -fx-font-style: italic; -fx-text-fill: #9CA3AF;\");\n        infoLabel.setWrapText(true);\n        \n        // Run button\n        runBacktestButton = new Button(\" Run Backtest\");\n        runBacktestButton.getStyleClass().add(\"button-green\");\n        runBacktestButton.setPrefWidth(200);\n        runBacktestButton.setPrefHeight(40);\n        runBacktestButton.setOnAction(e -> runBacktest());\n        \n        // Optimize button\n        optimizeButton = new Button(\" Optimize Settings\");\n        optimizeButton.getStyleClass().add(\"rounded-button\");\n        optimizeButton.setPrefWidth(200);\n        optimizeButton.setPrefHeight(40);\n        optimizeButton.setOnAction(e -> runOptimization());\n        optimizeButton.setStyle(\"-fx-background-color: #9CA3AF; -fx-text-fill: white; -fx-font-weight: bold;\");\n        \n        // Stop Optimization Button (initially hidden)\n        stopOptimizationButton = new Button(\" Stop Optimization\");\n        stopOptimizationButton.getStyleClass().add(\"button-red\");\n        stopOptimizationButton.setPrefWidth(200);\n        stopOptimizationButton.setPrefHeight(40);\n        stopOptimizationButton.setOnAction(e -> stopOptimization());\n        stopOptimizationButton.setVisible(false);\n        stopOptimizationButton.setManaged(false);\n        \n        Label progressLabel = new Label(\"Ready to run backtest\");\n        progressLabel.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #555555;\");\n        \n        optimizeProgressLabel = new Label(\"\");\n        optimizeProgressLabel.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #9CA3AF; -fx-font-weight: bold;\");\n        optimizeProgressLabel.setWrapText(true);\n        \n        leftPanel.getChildren().addAll(titleLabel, warningBanner, symbolSection, dateSection, settingsSection, \n                                       infoLabel, runBacktestButton, optimizeButton, stopOptimizationButton, progressLabel, optimizeProgressLabel);\n        \n        // RIGHT PANEL - Results\n        VBox rightPanel = new VBox(15);\n        HBox.setHgrow(rightPanel, Priority.ALWAYS);\n        rightPanel.setPadding(new Insets(15));\n        rightPanel.setStyle(\"-fx-background-color: #FAFBFC;\");\n        \n        Label resultsTitle = new Label(\"Backtest Results\");\n        resultsTitle.setStyle(\"-fx-font-size: 16px; -fx-font-weight: bold; -fx-text-fill: #1A2332;\");\n        \n        // Metrics cards\n        GridPane metricsGrid = new GridPane();\n        metricsGrid.setHgap(10);\n        metricsGrid.setVgap(10);\n        \n        totalProfitCard = createMetricCard(\"Total Profit\", \"--\");\n        totalTradesCard = createMetricCard(\"Total Trades\", \"--\");\n        winRateCard = createMetricCard(\"Win Rate\", \"--\");\n        profitFactorCard = createMetricCard(\"Profit Factor\", \"--\");\n        maxDrawdownCard = createMetricCard(\"Max Drawdown\", \"--\");\n        sharpeCard = createMetricCard(\"Sharpe Ratio\", \"--\");\n        \n        metricsGrid.add(totalProfitCard, 0, 0);\n        metricsGrid.add(totalTradesCard, 1, 0);\n        metricsGrid.add(winRateCard, 2, 0);\n        metricsGrid.add(profitFactorCard, 0, 1);\n        metricsGrid.add(maxDrawdownCard, 1, 1);\n        metricsGrid.add(sharpeCard, 2, 1);\n        \n        // Trade log table\n        backtestTable = new TableView<>();\n        backtestTable.setPlaceholder(new Label(\"No backtest results yet. Run a backtest to see results.\"));\n        \n        TableColumn<BacktestTrade, String> entryTimeCol = new TableColumn<>(\"Entry Time\");\n        entryTimeCol.setCellValueFactory(new PropertyValueFactory<>(\"entryTime\"));\n        entryTimeCol.setPrefWidth(150);\n        \n        TableColumn<BacktestTrade, String> exitTimeCol = new TableColumn<>(\"Exit Time\");\n        exitTimeCol.setCellValueFactory(new PropertyValueFactory<>(\"exitTime\"));\n        exitTimeCol.setPrefWidth(150);\n        \n        TableColumn<BacktestTrade, Double> entryPriceCol = new TableColumn<>(\"Entry Price\");\n        entryPriceCol.setCellValueFactory(new PropertyValueFactory<>(\"entryPrice\"));\n        entryPriceCol.setPrefWidth(90);\n        \n        TableColumn<BacktestTrade, Double> exitPriceCol = new TableColumn<>(\"Exit Price\");\n        exitPriceCol.setCellValueFactory(new PropertyValueFactory<>(\"exitPrice\"));\n        exitPriceCol.setPrefWidth(90);\n        \n        TableColumn<BacktestTrade, Integer> sharesCol = new TableColumn<>(\"Shares\");\n        sharesCol.setCellValueFactory(new PropertyValueFactory<>(\"shares\"));\n        sharesCol.setPrefWidth(80);\n        \n        TableColumn<BacktestTrade, Double> plCol = new TableColumn<>(\"P&L\");\n        plCol.setCellValueFactory(new PropertyValueFactory<>(\"profitLoss\"));\n        plCol.setPrefWidth(90);\n        \n        TableColumn<BacktestTrade, Double> plPctCol = new TableColumn<>(\"P&L %\");\n        plPctCol.setCellValueFactory(new PropertyValueFactory<>(\"profitLossPercent\"));\n        plPctCol.setPrefWidth(80);\n        \n        TableColumn<BacktestTrade, String> reasonCol = new TableColumn<>(\"Reason\");\n        reasonCol.setCellValueFactory(new PropertyValueFactory<>(\"exitReason\"));\n        reasonCol.setPrefWidth(120);\n        \n        TableColumn<BacktestTrade, Double> predictedTargetCol = new TableColumn<>(\"Pred. Target %\");\n        predictedTargetCol.setCellValueFactory(new PropertyValueFactory<>(\"predictedGainTarget\"));\n        predictedTargetCol.setPrefWidth(100);\n        \n        TableColumn<BacktestTrade, Integer> predictedTimeCol = new TableColumn<>(\"Pred. Time (m)\");\n        predictedTimeCol.setCellValueFactory(new PropertyValueFactory<>(\"predictedTimeToTarget\"));\n        predictedTimeCol.setPrefWidth(100);\n        \n        TableColumn<BacktestTrade, Integer> actualTimeCol = new TableColumn<>(\"Actual Time (m)\");\n        actualTimeCol.setCellValueFactory(new PropertyValueFactory<>(\"actualTimeToTarget\"));\n        actualTimeCol.setPrefWidth(100);\n        \n        TableColumn<BacktestTrade, Double> accuracyCol = new TableColumn<>(\"Accuracy %\");\n        accuracyCol.setCellValueFactory(new PropertyValueFactory<>(\"predictionAccuracyPercent\"));\n        accuracyCol.setPrefWidth(90);\n        \n        backtestTable.getColumns().addAll(entryTimeCol, exitTimeCol, entryPriceCol, exitPriceCol, \n                                         sharesCol, plCol, plPctCol, reasonCol,\n                                         predictedTargetCol, predictedTimeCol, actualTimeCol, accuracyCol);\n        VBox.setVgrow(backtestTable, Priority.ALWAYS);\n        \n        // Equity curve placeholder\n        VBox equityCurve = new VBox();\n        equityCurve.setAlignment(Pos.CENTER);\n        equityCurve.setPrefHeight(200);\n        equityCurve.setStyle(\"-fx-background-color: white; -fx-border-color: #D4DAE4; -fx-border-width: 1; \" +\n                            \"-fx-border-radius: 8; -fx-background-radius: 8;\");\n        \n        Label chartLabel = new Label(\" Equity Curve (Coming Soon)\");\n        chartLabel.setStyle(\"-fx-font-size: 14px; -fx-text-fill: #555555;\");\n        equityCurve.getChildren().add(chartLabel);\n        \n        // Optimization Results Section (initially hidden)\n        optimizationResultsSection = new VBox(15);\n        optimizationResultsSection.setPadding(new Insets(20));\n        optimizationResultsSection.setStyle(\"-fx-background-color: #374151; -fx-border-color: #9CA3AF; \" +\n                                           \"-fx-border-width: 2; -fx-border-radius: 8; -fx-background-radius: 8;\");\n        optimizationResultsSection.setVisible(false);\n        optimizationResultsSection.setManaged(false);\n        \n        rightPanel.getChildren().addAll(resultsTitle, metricsGrid, optimizationResultsSection, backtestTable, equityCurve);\n        \n        mainContainer.getChildren().addAll(leftPanel, rightPanel);\n        \n        scrollPane.setContent(mainContainer);\n        tab.setContent(scrollPane);\n        \n        return tab;\n    }\n    \n    /**\n     * Tab 5:  Analytics\n     */\n    private Tab createAnalyticsTab() {\n        Tab tab = new Tab(\" Analytics\");\n        \n        ScrollPane scrollPane = new ScrollPane();\n        scrollPane.setFitToWidth(true);\n        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);\n        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);\n        scrollPane.setStyle(\"-fx-background-color: #FAFBFC;\");\n        \n        VBox content = new VBox(20);\n        content.setPadding(new Insets(20));\n        content.setStyle(\"-fx-background-color: #FAFBFC;\");\n        \n        // Title\n        Label titleLabel = new Label(\"  ANALYTICS DASHBOARD\");\n        titleLabel.setStyle(\"-fx-font-size: 22px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF;\");\n        \n        Label subtitleLabel = new Label(\"Real-time spike analysis, ML model performance, and trading statistics\");\n        subtitleLabel.setStyle(\"-fx-font-size: 11px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        \n        // Spike Statistics Section\n        VBox spikeSection = createAnalyticsSectionCard(\" Spike Detection Statistics\",\n                                                      \"Total Spikes Detected: 0\\n\" +\n                                                      \"Last 24 Hours: 0\\n\" +\n                                                      \"ML Model Accuracy: N/A\\n\" +\n                                                      \"Best Performing Spike: N/A\");\n        \n        // Trading Performance Section\n        VBox performanceSection = createAnalyticsSectionCard(\" Trading Performance\",\n                                                            \"Total Profit/Loss: $0.00\\n\" +\n                                                            \"Win Rate: 0%\\n\" +\n                                                            \"Average Trade Duration: N/A\\n\" +\n                                                            \"Best Trading Day: N/A\");\n        \n        // ML Model Section\n        VBox mlSection = createAnalyticsSectionCard(\" Machine Learning Status\",\n                                                   \"Model Status: Inactive\\n\" +\n                                                   \"Training Samples: 0\\n\" +\n                                                   \"Model Accuracy: N/A\\n\" +\n                                                   \"Last Training: Never\");\n        \n        // Chart placeholders\n        HBox chartsRow = new HBox(15);\n        VBox chart1 = createSpikeDistributionChart();\n        VBox chart2 = createProfitDistributionChart();\n        HBox.setHgrow(chart1, Priority.ALWAYS);\n        HBox.setHgrow(chart2, Priority.ALWAYS);\n        chartsRow.getChildren().addAll(chart1, chart2);\n        \n        content.getChildren().addAll(titleLabel, subtitleLabel, spikeSection, \n                                     performanceSection, mlSection, chartsRow);\n        \n        scrollPane.setContent(content);\n        tab.setContent(scrollPane);\n        \n        return tab;\n    }\n    \n    /**\n     * Tab 6:  Strategy Presets\n     */\n    private Tab createStrategyPresetsTab() {\n        Tab tab = new Tab(\" Strategy Presets\");\n        \n        ScrollPane scrollPane = new ScrollPane();\n        scrollPane.setFitToWidth(true);\n        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);\n        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);\n        scrollPane.setStyle(\"-fx-background-color: #FAFBFC;\");\n        \n        VBox content = new VBox(20);\n        content.setPadding(new Insets(25));\n        content.setStyle(\"-fx-background-color: #FAFBFC;\");\n        \n        // Title\n        Label titleLabel = new Label(\"  STRATEGY PRESETS\");\n        titleLabel.setStyle(\"-fx-font-size: 22px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF;\");\n        \n        Label subtitleLabel = new Label(\"Choose a pre-configured strategy optimized for different market conditions and trading styles\");\n        subtitleLabel.setStyle(\"-fx-font-size: 11px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        subtitleLabel.setWrapText(true);\n        \n        // Strategy 1: Pure Momentum Scalper\n        TitledPane strategy1 = new TitledPane();\n        strategy1.setText(\"  Strategy 1: Pure Momentum Scalper\");\n        strategy1.setExpanded(false);\n        \n        VBox strategy1Content = new VBox(10);\n        strategy1Content.setPadding(new Insets(15));\n        \n        Label strategy1Desc = new Label(\"Target: Liquid large-cap stocks (AAPL, MSFT, NVDA)\\n\" +\n                                       \"Philosophy: Ride strong momentum when institutions are aggressively buying\\n\" +\n                                       \"Hold Time: 15 minutes - 2 hours  |  Stop Loss: 1-2%  |  Target: 3-5%\");\n        strategy1Desc.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #5A6C7D;\");\n        strategy1Desc.setWrapText(true);\n        \n        Label strategy1Rules = new Label(\"Signal Rules Configuration:\");\n        strategy1Rules.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF; -fx-padding: 8 0 5 0;\");\n        \n        GridPane strategy1Grid = new GridPane();\n        strategy1Grid.setHgap(20);\n        strategy1Grid.setVgap(5);\n        \n        strategy1Grid.add(createIndicatorLabel(\" Spike Quality\", true), 0, 0);\n        strategy1Grid.add(createIndicatorLabel(\" Price Condition\", true), 0, 1);\n        strategy1Grid.add(createIndicatorLabel(\" RSI Condition\", false), 0, 2);\n        strategy1Grid.add(createIndicatorLabel(\" OBV Condition\", true), 0, 3);\n        strategy1Grid.add(createIndicatorLabel(\" MFI Condition\", false), 0, 4);\n        strategy1Grid.add(createIndicatorLabel(\" Bollinger Condition\", false), 0, 5);\n        strategy1Grid.add(createIndicatorLabel(\" VWAP Indicator\", false), 0, 6);\n        \n        strategy1Grid.add(createIndicatorLabel(\" ADX Indicator\", true), 1, 0);\n        strategy1Grid.add(createIndicatorLabel(\" Volume Spike\", true), 1, 1);\n        strategy1Grid.add(createIndicatorLabel(\" MACD Histogram ROC\", true), 1, 2);\n        strategy1Grid.add(createIndicatorLabel(\" Stochastic\", false), 1, 3);\n        strategy1Grid.add(createIndicatorLabel(\" RVOL\", true), 1, 4);\n        strategy1Grid.add(createIndicatorLabel(\" EMA\", false), 1, 5);\n        strategy1Grid.add(createIndicatorLabel(\" EMA Trend Filter\", false), 1, 6);\n        \n        applyConfigMomentumScalper = new CheckBox(\"Also apply recommended Configuration tab settings\");\n        applyConfigMomentumScalper.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #2563EB;\");\n        applyConfigMomentumScalper.setSelected(false);\n        \n        Label configHint1 = new Label(\"    Combo Threshold: 0.8, Stop Loss: 1.5%, Profit Floor: 3.0%, Equity/Trade: $2500, Max Trades: 4\");\n        configHint1.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #555555;\");\n        \n        Button applyStrategy1 = new Button(\"Apply This Strategy\");\n        applyStrategy1.getStyleClass().add(\"button-green\");\n        applyStrategy1.setPrefWidth(180);\n        applyStrategy1.setPrefHeight(40);\n        applyStrategy1.setOnAction(e -> applyStrategyPreset(\"momentum_scalper\"));\n        \n        strategy1Content.getChildren().addAll(strategy1Desc, strategy1Rules, strategy1Grid, \n                                              applyConfigMomentumScalper, configHint1, applyStrategy1);\n        strategy1.setContent(strategy1Content);\n        \n        // Strategy 2: Mean Reversion Sniper\n        TitledPane strategy2 = new TitledPane();\n        strategy2.setText(\"  Strategy 2: Mean Reversion Sniper\");\n        strategy2.setExpanded(false);\n        \n        VBox strategy2Content = new VBox(10);\n        strategy2Content.setPadding(new Insets(15));\n        \n        Label strategy2Desc = new Label(\"Target: Stable large-cap stocks with low volatility\\n\" +\n                                       \"Philosophy: Buy panicked dips in quality stocks that will recover\\n\" +\n                                       \"Hold Time: 30 minutes - 4 hours  |  Stop Loss: 3-4%  |  Target: 2-3%\");\n        strategy2Desc.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #5A6C7D;\");\n        strategy2Desc.setWrapText(true);\n        \n        Label strategy2Rules = new Label(\"Signal Rules Configuration:\");\n        strategy2Rules.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF; -fx-padding: 8 0 5 0;\");\n        \n        GridPane strategy2Grid = new GridPane();\n        strategy2Grid.setHgap(20);\n        strategy2Grid.setVgap(5);\n        \n        strategy2Grid.add(createIndicatorLabel(\" Spike Quality\", false), 0, 0);\n        strategy2Grid.add(createIndicatorLabel(\" Price Condition\", false), 0, 1);\n        strategy2Grid.add(createIndicatorLabel(\" RSI Condition\", true), 0, 2);\n        strategy2Grid.add(createIndicatorLabel(\" OBV Condition\", false), 0, 3);\n        strategy2Grid.add(createIndicatorLabel(\" MFI Condition\", true), 0, 4);\n        strategy2Grid.add(createIndicatorLabel(\" Bollinger Condition\", true), 0, 5);\n        strategy2Grid.add(createIndicatorLabel(\" VWAP Indicator\", false), 0, 6);\n        \n        strategy2Grid.add(createIndicatorLabel(\" ADX Indicator\", false), 1, 0);\n        strategy2Grid.add(createIndicatorLabel(\" Volume Spike\", false), 1, 1);\n        strategy2Grid.add(createIndicatorLabel(\" MACD Histogram ROC\", false), 1, 2);\n        strategy2Grid.add(createIndicatorLabel(\" Stochastic\", true), 1, 3);\n        strategy2Grid.add(createIndicatorLabel(\" RVOL\", false), 1, 4);\n        strategy2Grid.add(createIndicatorLabel(\" EMA\", false), 1, 5);\n        strategy2Grid.add(createIndicatorLabel(\" EMA Trend Filter\", false), 1, 6);\n        \n        applyConfigMeanReversion = new CheckBox(\"Also apply recommended Configuration tab settings\");\n        applyConfigMeanReversion.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #2563EB;\");\n        applyConfigMeanReversion.setSelected(false);\n        \n        Label configHint2 = new Label(\"    Combo Threshold: 0.7, Stop Loss: 3.0%, Profit Floor: 2.5%, Equity/Trade: $2000, Max Trades: 6\");\n        configHint2.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #555555;\");\n        \n        Button applyStrategy2 = new Button(\"Apply This Strategy\");\n        applyStrategy2.getStyleClass().add(\"button-green\");\n        applyStrategy2.setPrefWidth(180);\n        applyStrategy2.setPrefHeight(40);\n        applyStrategy2.setOnAction(e -> applyStrategyPreset(\"mean_reversion\"));\n        \n        strategy2Content.getChildren().addAll(strategy2Desc, strategy2Rules, strategy2Grid,\n                                              applyConfigMeanReversion, configHint2, applyStrategy2);\n        strategy2.setContent(strategy2Content);\n        \n        // Strategy 3: Penny Stock Breakout Hunter\n        TitledPane strategy3 = new TitledPane();\n        strategy3.setText(\"  Strategy 3: Penny Stock Breakout Hunter\");\n        strategy3.setExpanded(false);\n        \n        VBox strategy3Content = new VBox(10);\n        strategy3Content.setPadding(new Insets(15));\n        \n        Label strategy3Desc = new Label(\"Target: Volatile small-cap stocks under $5\\n\" +\n                                       \"Philosophy: Catch explosive moves in small-caps BEFORE the crowd\\n\" +\n                                       \"Hold Time: 1-6 hours  |  Stop Loss: 5%  |  Target: 10-25%  |  Risk: HIGH\");\n        strategy3Desc.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #5A6C7D;\");\n        strategy3Desc.setWrapText(true);\n        \n        Label strategy3Rules = new Label(\"Signal Rules Configuration:\");\n        strategy3Rules.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF; -fx-padding: 8 0 5 0;\");\n        \n        GridPane strategy3Grid = new GridPane();\n        strategy3Grid.setHgap(20);\n        strategy3Grid.setVgap(5);\n        \n        strategy3Grid.add(createIndicatorLabel(\" Spike Quality\", true), 0, 0);\n        strategy3Grid.add(createIndicatorLabel(\" Price Condition\", true), 0, 1);\n        strategy3Grid.add(createIndicatorLabel(\" RSI Condition\", false), 0, 2);\n        strategy3Grid.add(createIndicatorLabel(\" OBV Condition\", false), 0, 3);\n        strategy3Grid.add(createIndicatorLabel(\" MFI Condition\", false), 0, 4);\n        strategy3Grid.add(createIndicatorLabel(\" Bollinger Condition\", false), 0, 5);\n        strategy3Grid.add(createIndicatorLabel(\" VWAP Indicator\", false), 0, 6);\n        \n        strategy3Grid.add(createIndicatorLabel(\" ADX Indicator\", false), 1, 0);\n        strategy3Grid.add(createIndicatorLabel(\" Volume Spike\", true), 1, 1);\n        strategy3Grid.add(createIndicatorLabel(\" MACD Histogram ROC\", true), 1, 2);\n        strategy3Grid.add(createIndicatorLabel(\" Stochastic\", true), 1, 3);\n        strategy3Grid.add(createIndicatorLabel(\" RVOL\", true), 1, 4);\n        strategy3Grid.add(createIndicatorLabel(\" EMA\", true), 1, 5);\n        strategy3Grid.add(createIndicatorLabel(\" EMA Trend Filter\", true), 1, 6);\n        \n        applyConfigPennyBreakout = new CheckBox(\"Also apply recommended Configuration tab settings\");\n        applyConfigPennyBreakout.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #2563EB;\");\n        applyConfigPennyBreakout.setSelected(false);\n        \n        Label configHint3 = new Label(\"    Combo Threshold: 0.85, Stop Loss: 5.0%, Profit Floor: 10.0%, Equity/Trade: $750, Max Trades: 2\");\n        configHint3.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #555555;\");\n        \n        Button applyStrategy3 = new Button(\"Apply This Strategy\");\n        applyStrategy3.getStyleClass().add(\"button-green\");\n        applyStrategy3.setPrefWidth(180);\n        applyStrategy3.setPrefHeight(40);\n        applyStrategy3.setOnAction(e -> applyStrategyPreset(\"penny_breakout\"));\n        \n        strategy3Content.getChildren().addAll(strategy3Desc, strategy3Rules, strategy3Grid,\n                                              applyConfigPennyBreakout, configHint3, applyStrategy3);\n        strategy3.setContent(strategy3Content);\n        \n        // Strategy 4: Smart Money Follow\n        TitledPane strategy4 = new TitledPane();\n        strategy4.setText(\"  Strategy 4: Smart Money Follow\");\n        strategy4.setExpanded(false);\n        \n        VBox strategy4Content = new VBox(10);\n        strategy4Content.setPadding(new Insets(15));\n        \n        Label strategy4Desc = new Label(\"Target: Mid-to-large cap stocks with institutional interest\\n\" +\n                                       \"Philosophy: Follow institutional accumulation before retail notices\\n\" +\n                                       \"Hold Time: Days to weeks  |  Stop Loss: 5-7%  |  Target: 8-15%\");\n        strategy4Desc.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #5A6C7D;\");\n        strategy4Desc.setWrapText(true);\n        \n        Label strategy4Rules = new Label(\"Signal Rules Configuration:\");\n        strategy4Rules.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF; -fx-padding: 8 0 5 0;\");\n        \n        GridPane strategy4Grid = new GridPane();\n        strategy4Grid.setHgap(20);\n        strategy4Grid.setVgap(5);\n        \n        strategy4Grid.add(createIndicatorLabel(\" Spike Quality\", true), 0, 0);\n        strategy4Grid.add(createIndicatorLabel(\" Price Condition\", false), 0, 1);\n        strategy4Grid.add(createIndicatorLabel(\" RSI Condition\", false), 0, 2);\n        strategy4Grid.add(createIndicatorLabel(\" OBV Condition\", true), 0, 3);\n        strategy4Grid.add(createIndicatorLabel(\" MFI Condition\", true), 0, 4);\n        strategy4Grid.add(createIndicatorLabel(\" Bollinger Condition\", false), 0, 5);\n        strategy4Grid.add(createIndicatorLabel(\" VWAP Indicator\", true), 0, 6);\n        \n        strategy4Grid.add(createIndicatorLabel(\" ADX Indicator\", false), 1, 0);\n        strategy4Grid.add(createIndicatorLabel(\" Volume Spike\", true), 1, 1);\n        strategy4Grid.add(createIndicatorLabel(\" MACD Histogram ROC\", true), 1, 2);\n        strategy4Grid.add(createIndicatorLabel(\" Stochastic\", false), 1, 3);\n        strategy4Grid.add(createIndicatorLabel(\" RVOL\", true), 1, 4);\n        strategy4Grid.add(createIndicatorLabel(\" EMA\", true), 1, 5);\n        strategy4Grid.add(createIndicatorLabel(\" EMA Trend Filter\", true), 1, 6);\n        \n        applyConfigSmartMoney = new CheckBox(\"Also apply recommended Configuration tab settings\");\n        applyConfigSmartMoney.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #2563EB;\");\n        applyConfigSmartMoney.setSelected(false);\n        \n        Label configHint4 = new Label(\"    Combo Threshold: 0.75, Stop Loss: 6.0%, Profit Floor: 8.0%, Equity/Trade: $4000, Max Trades: 3\");\n        configHint4.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #555555;\");\n        \n        Button applyStrategy4 = new Button(\"Apply This Strategy\");\n        applyStrategy4.getStyleClass().add(\"button-green\");\n        applyStrategy4.setPrefWidth(180);\n        applyStrategy4.setPrefHeight(40);\n        applyStrategy4.setOnAction(e -> applyStrategyPreset(\"smart_money\"));\n        \n        strategy4Content.getChildren().addAll(strategy4Desc, strategy4Rules, strategy4Grid,\n                                              applyConfigSmartMoney, configHint4, applyStrategy4);\n        strategy4.setContent(strategy4Content);\n        \n        content.getChildren().addAll(titleLabel, subtitleLabel, strategy1, strategy2, strategy3, strategy4);\n        \n        scrollPane.setContent(content);\n        tab.setContent(scrollPane);\n        \n        return tab;\n    }\n    \n    /**\n     * Helper method to create indicator labels with enabled/disabled styling\n     */\n    private Label createIndicatorLabel(String text, boolean enabled) {\n        Label label = new Label(text);\n        if (enabled) {\n            label.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #D1D5DB; -fx-font-weight: bold;\");\n        } else {\n            label.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #6B7280;\");\n        }\n        return label;\n    }\n    \n    /**\n     * Tab 7:  Signal Rules\n     */\n    private Tab createSignalRulesTab() {\n        Tab tab = new Tab(\" Signal Rules\");\n        \n        ScrollPane scrollPane = new ScrollPane();\n        scrollPane.setFitToWidth(true);\n        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);\n        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);\n        scrollPane.setStyle(\"-fx-background-color: #FAFBFC;\");\n        \n        VBox content = new VBox(20);\n        content.setPadding(new Insets(25));\n        content.setStyle(\"-fx-background-color: #FAFBFC;\");\n        \n        // Title\n        Label titleLabel = new Label(\"  SIGNAL RULES\");\n        titleLabel.setStyle(\"-fx-font-size: 22px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF;\");\n        \n        Label subtitleLabel = new Label(\"Select which conditions must be TRUE for buy signals to fire. Uncheck conditions you want to ignore.\");\n        subtitleLabel.setStyle(\"-fx-font-size: 11px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        subtitleLabel.setWrapText(true);\n        \n        // Spike Quality Section\n        VBox spikeSection = createSignalRulesSection(\" Spike Quality Filter\");\n        \n        requireSpikeQuality = new CheckBox(\"Require High-Quality Spike (Z-score > 1.5, ML score > 0.6)\");\n        requireSpikeQuality.setSelected(true);\n        requireSpikeQuality.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        Label spikeHint = new Label(\"    Measures: Price, RSI, %B, OBV, Volume ACCELERATION (not velocity)\");\n        spikeHint.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #555555;\");\n        \n        spikeSection.getChildren().addAll(requireSpikeQuality, spikeHint);\n        \n        // Technical Conditions Section\n        // Technical Conditions Section\n        VBox techSection = createSignalRulesSection(\" Technical Conditions\");\n\n        requireRsiCondition = new CheckBox(\"Require RSI Acceleration Condition\");\n        requireRsiCondition.setSelected(true);\n        requireRsiCondition.setStyle(\"-fx-font-size: 11px;\");\n\n        requirePriceCondition = new CheckBox(\"Require Price Acceleration Condition\");\n        requirePriceCondition.setSelected(true);\n        requirePriceCondition.setStyle(\"-fx-font-size: 11px;\");\n\n        requireObvCondition = new CheckBox(\"Require OBV Acceleration Condition\");\n        requireObvCondition.setSelected(true);\n        requireObvCondition.setStyle(\"-fx-font-size: 11px;\");\n\n        //  ADD THIS:\n        requireMfiCondition = new CheckBox(\"Require MFI (Money Flow Index) Condition\");\n        requireMfiCondition.setSelected(true);\n        requireMfiCondition.setStyle(\"-fx-font-size: 11px;\");\n\n        requireBollingerCondition = new CheckBox(\"Require Bollinger Band Breakout\");\n        requireBollingerCondition.setSelected(true);\n        requireBollingerCondition.setStyle(\"-fx-font-size: 11px;\");\n\n        enableAdxIndicator = new CheckBox(\"ADX (Average Directional Index)\");\n        enableAdxIndicator.setSelected(true);\n        enableAdxIndicator.setStyle(\"-fx-font-size: 11px;\");\n\n        enableVwapIndicator = new CheckBox(\"%VWAP (Percent VWAP Position)\");\n        enableVwapIndicator.setSelected(true);\n        enableVwapIndicator.setStyle(\"-fx-font-size: 11px;\");\n\n        techSection.getChildren().addAll(requireRsiCondition, requirePriceCondition, \n                                        requireObvCondition, requireMfiCondition,  //  ADD HERE\n                                        requireBollingerCondition,\n                                        enableAdxIndicator, enableVwapIndicator);\n        \n        // NEW PENNY STOCK INDICATORS SECTION\n        VBox pennyStockSection = createSignalRulesSection(\" Penny Stock Indicators (High-Volatility, Low-Priced Stocks)\");\n        \n        Label pennyStockWarning = new Label(\" VWAP, MFI, and OBV are unreliable for stocks under $5 due to low liquidity.\\n\" +\n                                            \" Recommended indicators for penny stocks: MACD, Stochastic, EMA, RVOL, RSI, and Bollinger Bands.\");\n        pennyStockWarning.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #9CA3AF; -fx-background-color: #374151; \" +\n                                   \"-fx-padding: 8; -fx-border-radius: 4; -fx-background-radius: 4;\");\n        pennyStockWarning.setWrapText(true);\n        \n        enableMacdHistogramRoc = new CheckBox(\"MACD Histogram ROC - Predictive Convergence (Early Warning)\");\n        enableMacdHistogramRoc.setSelected(true);\n        enableMacdHistogramRoc.setStyle(\"-fx-font-size: 11px;\");\n        \n        enableStochasticIndicator = new CheckBox(\"Stochastic Oscillator - Oversold/Overbought (Mean Reversion)\");\n        enableStochasticIndicator.setSelected(true);\n        enableStochasticIndicator.setStyle(\"-fx-font-size: 11px;\");\n        \n        enableRvolIndicator = new CheckBox(\"RVOL (Relative Volume) - Unusual Volume Activity\");\n        enableRvolIndicator.setSelected(true);\n        enableRvolIndicator.setStyle(\"-fx-font-size: 11px;\");\n        \n        enableEmaIndicator = new CheckBox(\"EMA (9/20/50) - Exponential Moving Averages\");\n        enableEmaIndicator.setSelected(true);\n        enableEmaIndicator.setStyle(\"-fx-font-size: 11px;\");\n        \n        enableEmaTrendFilter = new CheckBox(\"EMA Trend Filter - Block trades when price below all EMAs (downtrend)\");\n        enableEmaTrendFilter.setSelected(true);\n        enableEmaTrendFilter.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        \n        Label emaFilterHint = new Label(\"    Prevents buying in strong downtrends (price < EMA9 AND price < EMA20 AND price < EMA50)\");\n        emaFilterHint.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #555555;\");\n        \n        pennyStockSection.getChildren().addAll(pennyStockWarning, enableMacdHistogramRoc, enableStochasticIndicator, \n                                               enableRvolIndicator, enableEmaIndicator, enableEmaTrendFilter, emaFilterHint);\n                                        \n        // Advanced Filters Section\n        VBox advancedSection = createSignalRulesSection(\" Advanced Filters\");\n        \n        requireVolumeSpike = new CheckBox(\"Require Volume Spike\");\n        requireVolumeSpike.setSelected(true);\n        requireVolumeSpike.setStyle(\"-fx-font-size: 11px;\");\n        \n        Label volumeHint = new Label(\"    Volume must be above average (1.5x moving average)\");\n        volumeHint.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #555555;\");\n        \n        advancedSection.getChildren().addAll(requireVolumeSpike, volumeHint);\n        \n        // Preset buttons\n        HBox presetBox = new HBox(10);\n        presetBox.setAlignment(Pos.CENTER_LEFT);\n        presetBox.setPadding(new Insets(15));\n        \n        Label presetLabel = new Label(\"Quick Presets:\");\n        presetLabel.setStyle(\"-fx-font-size: 12px; -fx-font-weight: bold;\");\n        \n        Button allConditions = new Button(\"All Conditions\");\n        allConditions.getStyleClass().add(\"button-green\");\n        allConditions.setPrefWidth(140);\n        allConditions.setPrefHeight(42);\n        allConditions.setOnAction(e -> applyPreset(\"all\"));\n        \n        Button spikeOnly = new Button(\"Spike Quality Only\");\n        spikeOnly.getStyleClass().add(\"rounded-button\");\n        spikeOnly.setPrefWidth(170);\n        spikeOnly.setPrefHeight(42);\n        spikeOnly.setOnAction(e -> applyPreset(\"spike_only\"));\n        \n        Button technicalOnly = new Button(\"Technical Only (No Spike)\");\n        technicalOnly.getStyleClass().add(\"rounded-button\");\n        technicalOnly.setPrefWidth(220);\n        technicalOnly.setPrefHeight(42);\n        technicalOnly.setOnAction(e -> applyPreset(\"technical_only\"));\n        \n        Button minimal = new Button(\"Minimal (Price + RSI)\");\n        minimal.getStyleClass().add(\"rounded-button\");\n        minimal.setPrefWidth(190);\n        minimal.setPrefHeight(42);\n        minimal.setOnAction(e -> applyPreset(\"minimal\"));\n        \n        presetBox.getChildren().addAll(presetLabel, allConditions, spikeOnly, technicalOnly, minimal);\n        \n        // Status\n        Label statusLabel = new Label(\" All conditions enabled - Maximum signal quality\");\n        statusLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #D1D5DB; \" +\n                           \"-fx-background-color: white; -fx-border-color: #D4DAE4; -fx-border-width: 2; \" +\n                           \"-fx-border-radius: 6; -fx-background-radius: 6; -fx-padding: 10;\");\n        \n        content.getChildren().addAll(titleLabel, subtitleLabel, spikeSection, techSection, \n                                     pennyStockSection, advancedSection, presetBox, statusLabel);\n        \n        // ========== CHECKBOX-TO-PANE REGISTRY SYSTEM ==========\n        // Register checkboxes with their associated Configuration tab panes\n        // This enables dynamic visibility control based on signal rules\n        \n        // requirePriceCondition  Price ROC sections\n        // ========== CHECKBOX-TO-PANE REGISTRY SYSTEM ==========\n        // Register checkboxes with their associated Configuration tab panes\n        // This enables dynamic visibility control based on signal rules\n\n        // requirePriceCondition  Price ROC sections\n        checkboxToPanesMap.put(requirePriceCondition, List.of(\n            regularPriceRocThresholdSection, \n            regularPriceRocPeriodSection\n        ));\n\n        // requireRsiCondition  RSI sections\n        checkboxToPanesMap.put(requireRsiCondition, List.of(\n            rsiSection,\n            regularRsiRocThresholdSection,\n            regularRsiRocPeriodSection\n        ));\n\n        // requireObvCondition  OBV ROC sections\n        checkboxToPanesMap.put(requireObvCondition, List.of(\n            regularObvRocThresholdSection,\n            regularObvRocPeriodSection\n        ));\n\n        // requireMfiCondition  MFI ROC sections\n        checkboxToPanesMap.put(requireMfiCondition, List.of(\n            regularMfiRocThresholdSection,\n            regularMfiRocPeriodSection\n        ));\n\n        // requireBollingerCondition  Bollinger %B sections\n        checkboxToPanesMap.put(requireBollingerCondition, List.of(\n            regularPercentBRocThresholdSection,\n            regularPercentBRocPeriodSection\n        ));\n\n        // enableVwapIndicator  VWAP sections\n        checkboxToPanesMap.put(enableVwapIndicator, List.of(\n            regularVwapRocThresholdSection,\n            regularVwapRocPeriodSection\n        ));\n\n        // requireVolumeSpike  Volume ROC sections\n        checkboxToPanesMap.put(requireVolumeSpike, List.of(\n            regularVolumeRocThresholdSection,\n            regularVolumeRocPeriodSection\n        ));\n\n        // requireSpikeQuality  Individual Spike Thresholds section\n        checkboxToPanesMap.put(requireSpikeQuality, List.of(\n            spikeThresholdsSection\n        ));        \n        // Add change listeners to all checkboxes to control pane visibility\n        for (Map.Entry<CheckBox, List<TitledPane>> entry : checkboxToPanesMap.entrySet()) {\n            CheckBox checkbox = entry.getKey();\n            List<TitledPane> panes = entry.getValue();\n            \n            // Add listener to toggle visibility\n            checkbox.selectedProperty().addListener((observable, oldValue, newValue) -> {\n                for (TitledPane pane : panes) {\n                    pane.setVisible(newValue);\n                    pane.setManaged(newValue);\n                }\n            });\n            \n            // Set initial visibility based on current checkbox state\n            boolean isSelected = checkbox.isSelected();\n            for (TitledPane pane : panes) {\n                pane.setVisible(isSelected);\n                pane.setManaged(isSelected);\n            }\n        }\n        \n        scrollPane.setContent(content);\n        tab.setContent(scrollPane);\n        \n        return tab;\n    }\n    \n    /**\n     * Tab 7:  Notifications\n     */\n    private Tab createNotificationsTab() {\n        Tab tab = new Tab(\" Notifications\");\n        \n        ScrollPane scrollPane = new ScrollPane();\n        scrollPane.setFitToWidth(true);\n        scrollPane.setStyle(\"-fx-background-color: #FAFBFC;\");\n        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);\n        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);\n        \n        VBox content = new VBox(20);\n        content.setPadding(new Insets(25));\n        content.setStyle(\"-fx-background-color: #FAFBFC;\");\n        \n        // Title\n        Label titleLabel = new Label(\"  NOTIFICATIONS\");\n        titleLabel.setStyle(\"-fx-font-size: 22px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF;\");\n        \n        Label subtitleLabel = new Label(\"Configure email and SMS notifications for buy signals, sell signals, and spikes\");\n        subtitleLabel.setStyle(\"-fx-font-size: 11px; -fx-font-style: italic; -fx-text-fill: #555555;\");\n        \n        // Email Configuration Section with Input Fields\n        TitledPane emailSection = new TitledPane();\n        emailSection.setText(\"  Email Notifications\");\n        emailSection.setExpanded(true);\n        \n        VBox emailContent = new VBox(12);\n        emailContent.setPadding(new Insets(15));\n        \n        Label emailStatusLabel = new Label();\n        emailStatusLabel.setWrapText(true);\n        if (notificationService.isEmailConfigured()) {\n            emailStatusLabel.setText(\" Email notifications are CONFIGURED and active\");\n            emailStatusLabel.setStyle(\"-fx-font-size: 12px; -fx-text-fill: #10B981; -fx-font-weight: bold;\");\n        } else {\n            emailStatusLabel.setText(\" Email notifications are NOT configured\");\n            emailStatusLabel.setStyle(\"-fx-font-size: 12px; -fx-text-fill: #F59E0B; -fx-font-weight: bold;\");\n        }\n        \n        // Email input fields\n        GridPane emailGrid = new GridPane();\n        emailGrid.setHgap(10);\n        emailGrid.setVgap(10);\n        emailGrid.setPadding(new Insets(10, 0, 10, 0));\n        \n        Label emailUsernameLabel = new Label(\"Email Address:\");\n        emailUsernameLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        TextField emailUsernameField = new TextField();\n        emailUsernameField.setPromptText(\"your-email@gmail.com\");\n        emailUsernameField.setPrefWidth(300);\n        emailUsernameField.setText(notificationService.getEmailSender());\n        \n        Label emailPasswordLabel = new Label(\"Password:\");\n        emailPasswordLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        PasswordField emailPasswordField = new PasswordField();\n        emailPasswordField.setPromptText(\"your-gmail-app-password (leave blank to keep current)\");\n        emailPasswordField.setPrefWidth(300);\n        \n        Label emailRecipientLabel = new Label(\"Recipient:\");\n        emailRecipientLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        TextField emailRecipientField = new TextField();\n        emailRecipientField.setPromptText(\"recipient@example.com\");\n        emailRecipientField.setPrefWidth(300);\n        emailRecipientField.setText(notificationService.getEmailRecipient());\n        \n        emailGrid.add(emailUsernameLabel, 0, 0);\n        emailGrid.add(emailUsernameField, 1, 0);\n        emailGrid.add(emailPasswordLabel, 0, 1);\n        emailGrid.add(emailPasswordField, 1, 1);\n        emailGrid.add(emailRecipientLabel, 0, 2);\n        emailGrid.add(emailRecipientField, 1, 2);\n        \n        Button saveEmailButton = new Button(\" SAVE EMAIL CONFIGURATION\");\n        saveEmailButton.getStyleClass().add(\"button-green\");\n        saveEmailButton.setPrefWidth(250);\n        saveEmailButton.setPrefHeight(36);\n        saveEmailButton.setOnAction(e -> saveEmailConfiguration(emailUsernameField.getText(), \n                                                               emailPasswordField.getText(), \n                                                               emailRecipientField.getText(), \n                                                               emailStatusLabel));\n        \n        Label emailHelpLabel = new Label(\n            \"Note: For Gmail, use an App Password (not your regular password).\\n\" +\n            \"Go to: Google Account  Security  2-Step Verification  App passwords\"\n        );\n        emailHelpLabel.setWrapText(true);\n        emailHelpLabel.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #6B7280; -fx-font-style: italic; -fx-background-color: #F3F4F6; -fx-padding: 10;\");\n        \n        emailContent.getChildren().addAll(emailStatusLabel, emailGrid, saveEmailButton, emailHelpLabel);\n        emailSection.setContent(emailContent);\n        \n        // SMS Configuration Section with Input Fields\n        TitledPane smsSection = new TitledPane();\n        smsSection.setText(\"  SMS Notifications\");\n        smsSection.setExpanded(true);\n        \n        VBox smsContent = new VBox(12);\n        smsContent.setPadding(new Insets(15));\n        \n        Label smsStatusLabel = new Label();\n        smsStatusLabel.setWrapText(true);\n        if (notificationService.isSMSConfigured()) {\n            smsStatusLabel.setText(\" SMS notifications are CONFIGURED and active\");\n            smsStatusLabel.setStyle(\"-fx-font-size: 12px; -fx-text-fill: #10B981; -fx-font-weight: bold;\");\n        } else {\n            smsStatusLabel.setText(\" SMS notifications are NOT configured\");\n            smsStatusLabel.setStyle(\"-fx-font-size: 12px; -fx-text-fill: #F59E0B; -fx-font-weight: bold;\");\n        }\n        \n        // SMS input fields\n        GridPane smsGrid = new GridPane();\n        smsGrid.setHgap(10);\n        smsGrid.setVgap(10);\n        smsGrid.setPadding(new Insets(10, 0, 10, 0));\n        \n        Label twilioSidLabel = new Label(\"Account SID:\");\n        twilioSidLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        TextField twilioSidField = new TextField();\n        twilioSidField.setPromptText(\"ACxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n        twilioSidField.setPrefWidth(300);\n        twilioSidField.setText(notificationService.getTwilioAccountSid());\n        \n        Label twilioTokenLabel = new Label(\"Auth Token:\");\n        twilioTokenLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        PasswordField twilioTokenField = new PasswordField();\n        twilioTokenField.setPromptText(\"your-twilio-auth-token (leave blank to keep current)\");\n        twilioTokenField.setPrefWidth(300);\n        \n        Label twilioFromLabel = new Label(\"From Number:\");\n        twilioFromLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        TextField twilioFromField = new TextField();\n        twilioFromField.setPromptText(\"+1234567890\");\n        twilioFromField.setPrefWidth(300);\n        twilioFromField.setText(notificationService.getTwilioFromNumber());\n        \n        Label twilioToLabel = new Label(\"To Number:\");\n        twilioToLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold;\");\n        TextField twilioToField = new TextField();\n        twilioToField.setPromptText(\"+1234567890\");\n        twilioToField.setPrefWidth(300);\n        twilioToField.setText(notificationService.getTwilioToNumber());\n        \n        smsGrid.add(twilioSidLabel, 0, 0);\n        smsGrid.add(twilioSidField, 1, 0);\n        smsGrid.add(twilioTokenLabel, 0, 1);\n        smsGrid.add(twilioTokenField, 1, 1);\n        smsGrid.add(twilioFromLabel, 0, 2);\n        smsGrid.add(twilioFromField, 1, 2);\n        smsGrid.add(twilioToLabel, 0, 3);\n        smsGrid.add(twilioToField, 1, 3);\n        \n        Button saveSmsButton = new Button(\" SAVE SMS CONFIGURATION\");\n        saveSmsButton.getStyleClass().add(\"button-green\");\n        saveSmsButton.setPrefWidth(250);\n        saveSmsButton.setPrefHeight(36);\n        saveSmsButton.setOnAction(e -> saveSmsConfiguration(twilioSidField.getText(), \n                                                            twilioTokenField.getText(), \n                                                            twilioFromField.getText(), \n                                                            twilioToField.getText(), \n                                                            smsStatusLabel));\n        \n        Label smsHelpLabel = new Label(\n            \"Sign up for Twilio at https://www.twilio.com\\n\" +\n            \"Get your credentials from the Twilio Console\"\n        );\n        smsHelpLabel.setWrapText(true);\n        smsHelpLabel.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #6B7280; -fx-font-style: italic; -fx-background-color: #F3F4F6; -fx-padding: 10;\");\n        \n        smsContent.getChildren().addAll(smsStatusLabel, smsGrid, saveSmsButton, smsHelpLabel);\n        smsSection.setContent(smsContent);\n        \n        // Notification Preferences\n        TitledPane preferencesSection = new TitledPane();\n        preferencesSection.setText(\"  Notification Preferences\");\n        preferencesSection.setExpanded(true);\n        \n        VBox preferencesContent = new VBox(10);\n        preferencesContent.setPadding(new Insets(15));\n        \n        CheckBox notifyOnSignal = new CheckBox(\"Notify on Buy Signals (probability > 70%)\");\n        notifyOnSignal.setSelected(true);\n        notifyOnSignal.setStyle(\"-fx-font-size: 11px;\");\n        \n        CheckBox notifyOnTrade = new CheckBox(\"Notify on Trade Execution (entry/exit)\");\n        notifyOnTrade.setSelected(true);\n        notifyOnTrade.setStyle(\"-fx-font-size: 11px;\");\n        \n        CheckBox notifyOnSpike = new CheckBox(\"Notify on High-Quality Spikes\");\n        notifyOnSpike.setSelected(false);\n        notifyOnSpike.setStyle(\"-fx-font-size: 11px;\");\n        \n        // CRITICAL FIX: Notification Cooldown Slider (configurable from 5s to 60s)\n        Label cooldownLabel = new Label(\"Notification Cooldown: 15 seconds\");\n        cooldownLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-padding: 10 0 5 0;\");\n        notificationCooldownSlider = new Slider(5, 60, 15);\n        notificationCooldownSlider.setShowTickLabels(true);\n        notificationCooldownSlider.setMajorTickUnit(15);\n        notificationCooldownSlider.setPrefWidth(400);\n        notificationCooldownSlider.valueProperty().addListener((obs, oldVal, newVal) -> {\n            int seconds = newVal.intValue();\n            notificationCooldownMs = seconds * 1000L;\n            cooldownLabel.setText(String.format(\"Notification Cooldown: %d seconds\", seconds));\n            System.out.println(\" Notification cooldown updated to \" + seconds + \" seconds\");\n        });\n        \n        Label cooldownHelp = new Label(\"Controls the minimum time between duplicate notifications for the same symbol.\");\n        cooldownHelp.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #6B7280; -fx-font-style: italic;\");\n        cooldownHelp.setWrapText(true);\n        \n        // CRITICAL FIX: Debug Mode Checkbox\n        debugModeCheckBox = new CheckBox(\" Debug Mode: Show All Trade Decisions\");\n        debugModeCheckBox.setSelected(false);\n        debugModeCheckBox.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-padding: 10 0 0 0;\");\n        debugModeCheckBox.selectedProperty().addListener((obs, oldVal, newVal) -> {\n            debugModeShowAllDecisions = newVal;\n            System.out.println(\" Debug mode \" + (newVal ? \"ENABLED\" : \"DISABLED\"));\n            if (newVal) {\n                System.out.println(\"    All trade decisions will be displayed\");\n                System.out.println(\"    Notification cooldown bypassed\");\n            }\n        });\n        \n        Label debugHelp = new Label(\"When enabled, displays ALL trade evaluations and bypasses notification cooldown. Useful for debugging signal flow.\");\n        debugHelp.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #6B7280; -fx-font-style: italic;\");\n        debugHelp.setWrapText(true);\n        \n        preferencesContent.getChildren().addAll(\n            notifyOnSignal, notifyOnTrade, notifyOnSpike,\n            cooldownLabel, notificationCooldownSlider, cooldownHelp,\n            debugModeCheckBox, debugHelp\n        );\n        preferencesSection.setContent(preferencesContent);\n        \n        // Test Notification Section (NEW)\n        TitledPane testSection = new TitledPane();\n        testSection.setText(\"  Test Notifications\");\n        testSection.setExpanded(true);\n        \n        VBox testContent = new VBox(15);\n        testContent.setPadding(new Insets(15));\n        \n        Label testInfoLabel = new Label(\"Send a test notification to verify all notification channels are working correctly.\\n\" +\n                                       \"This will send: Windows Toast + Email + SMS\");\n        testInfoLabel.setStyle(\"-fx-font-size: 11px; -fx-text-fill: #555555; -fx-wrap-text: true;\");\n        \n        Button testNotificationButton = new Button(\" SEND TEST NOTIFICATION\");\n        testNotificationButton.getStyleClass().add(\"button-primary\");\n        testNotificationButton.setPrefWidth(250);\n        testNotificationButton.setPrefHeight(40);\n        testNotificationButton.setOnAction(e -> sendTestNotification());\n        \n        Label testStatusLabel = new Label(\"Status: Ready to test\");\n        testStatusLabel.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #555555; -fx-font-style: italic;\");\n        \n        testContent.getChildren().addAll(testInfoLabel, testNotificationButton, testStatusLabel);\n        testSection.setContent(testContent);\n        \n        content.getChildren().addAll(titleLabel, subtitleLabel, emailSection, smsSection, preferencesSection, testSection);\n        \n        scrollPane.setContent(content);\n        tab.setContent(scrollPane);\n        \n        return tab;\n    }\n    \n    /**\n     * Create status bar at bottom\n     */\n    private HBox createStatusBar() {\n        HBox statusBar = new HBox(20);\n        statusBar.getStyleClass().add(\"status-bar\");\n        statusBar.setPadding(new Insets(8, 20, 8, 20));\n        statusBar.setAlignment(Pos.CENTER_LEFT);\n        \n        statusLabel = new Label(\" Status: Disconnected\");\n        statusLabel.setStyle(\"-fx-font-size: 11px; -fx-text-fill: #6B7280;\");\n        \n        Label tradingLabel = new Label(\" Trading: OFFLINE\");\n        tradingLabel.setStyle(\"-fx-font-size: 11px; -fx-text-fill: #6B7280;\");\n        \n        Label quoteLabel = new Label(\" Quote Source: Not Connected\");\n        quoteLabel.setStyle(\"-fx-font-size: 11px; -fx-text-fill: #555555;\");\n        \n        // CRITICAL FIX: Add notification status indicator\n        notificationStatusLabel = new Label(\" NOTIFICATIONS OK\");\n        notificationStatusLabel.setStyle(\"-fx-font-size: 11px; -fx-text-fill: #10B981; -fx-font-weight: bold;\");\n        \n        Region spacer = new Region();\n        HBox.setHgrow(spacer, Priority.ALWAYS);\n        \n        Label timestampLabel = new Label(LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")));\n        timestampLabel.setStyle(\"-fx-font-size: 10px; -fx-text-fill: #555555;\");\n        \n        statusBar.getChildren().addAll(statusLabel, tradingLabel, quoteLabel, notificationStatusLabel, spacer, timestampLabel);\n        \n        return statusBar;\n    }\n    \n    // ===========================\n    // Helper Methods\n    // ===========================\n    \n    /**\n     * Create a stat label\n     */\n    private Label createStatLabel(String labelText, String defaultValue) {\n        Label label = new Label(defaultValue);\n        label.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold; -fx-text-fill: #1A2332;\");\n        return label;\n    }\n    \n    /**\n     * Create a metric card for backtest results\n     */\n    private VBox createMetricCard(String title, String value) {\n        VBox card = new VBox(5);\n        card.setAlignment(Pos.CENTER);\n        card.setPrefWidth(180);\n        card.setPrefHeight(80);\n        card.setStyle(\"-fx-background-color: white; -fx-border-color: #D4DAE4; -fx-border-width: 2; \" +\n                     \"-fx-border-radius: 8; -fx-background-radius: 8; -fx-padding: 10;\");\n        \n        Label titleLabel = new Label(title);\n        titleLabel.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #555555;\");\n        \n        Label valueLabel = new Label(value);\n        valueLabel.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold; -fx-text-fill: #1A2332;\");\n        \n        card.getChildren().addAll(titleLabel, valueLabel);\n        return card;\n    }\n    \n    /**\n     * Update a metric card with new value and color based on performance\n     */\n    private void updateMetricCard(VBox card, String value, boolean isGood) {\n        if (card.getChildren().size() >= 2) {\n            Label valueLabel = (Label) card.getChildren().get(1);\n            valueLabel.setText(value);\n            \n            // Update color based on performance\n            String color = isGood ? \"#D1D5DB\" : \"#6B7280\";  // Green for good, red for bad\n            valueLabel.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold; -fx-text-fill: \" + color + \";\");\n        }\n    }\n    \n    /**\n     * Create an analytics section card\n     */\n    private VBox createAnalyticsSectionCard(String title, String content) {\n        VBox section = new VBox(10);\n        section.setPadding(new Insets(15));\n        section.setStyle(\"-fx-background-color: white; -fx-border-color: #D4DAE4; -fx-border-width: 1; \" +\n                        \"-fx-border-radius: 8; -fx-background-radius: 8;\");\n        \n        Label titleLabel = new Label(title);\n        titleLabel.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF;\");\n        \n        Label contentLabel = new Label(content);\n        contentLabel.setStyle(\"-fx-font-size: 11px; -fx-text-fill: #4A5A6D;\");\n        \n        section.getChildren().addAll(titleLabel, contentLabel);\n        return section;\n    }\n    \n    /**\n     * Create a chart placeholder\n     */\n    private VBox createChartPlaceholder(String title) {\n        VBox chart = new VBox();\n        chart.setAlignment(Pos.CENTER);\n        chart.setPrefHeight(250);\n        chart.setStyle(\"-fx-background-color: white; -fx-border-color: #D4DAE4; -fx-border-width: 1; \" +\n                      \"-fx-border-radius: 8; -fx-background-radius: 8;\");\n        \n        Label label = new Label(\" \" + title + \" (Coming Soon)\");\n        label.setStyle(\"-fx-font-size: 14px; -fx-text-fill: #555555;\");\n        \n        chart.getChildren().add(label);\n        return chart;\n    }\n    \n    /**\n     * Create Spike Distribution Chart\n     * Shows distribution of spike z-scores in buckets\n     */\n    private VBox createSpikeDistributionChart() {\n        VBox container = new VBox(10);\n        container.setPadding(new Insets(15));\n        container.setStyle(\"-fx-background-color: white; -fx-border-color: #D4DAE4; -fx-border-width: 1; \" +\n                          \"-fx-border-radius: 8; -fx-background-radius: 8;\");\n        \n        Label titleLabel = new Label(\" Spike Distribution by Z-Score\");\n        titleLabel.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF;\");\n        \n        CategoryAxis xAxis = new CategoryAxis();\n        xAxis.setLabel(\"Z-Score Range\");\n        \n        NumberAxis yAxis = new NumberAxis();\n        yAxis.setLabel(\"Count\");\n        \n        BarChart<String, Number> barChart = new BarChart<>(xAxis, yAxis);\n        barChart.setTitle(\"Spike Magnitude Distribution\");\n        barChart.setLegendVisible(false);\n        barChart.setPrefHeight(220);\n        \n        XYChart.Series<String, Number> series = new XYChart.Series<>();\n        series.setName(\"Spike Count\");\n        \n        series.getData().add(new XYChart.Data<>(\"0-1\", 0));\n        series.getData().add(new XYChart.Data<>(\"1-2\", 0));\n        series.getData().add(new XYChart.Data<>(\"2-3\", 0));\n        series.getData().add(new XYChart.Data<>(\"3-4\", 0));\n        series.getData().add(new XYChart.Data<>(\"4+\", 0));\n        \n        barChart.getData().add(series);\n        \n        container.getChildren().addAll(titleLabel, barChart);\n        return container;\n    }\n    \n    /**\n     * Create Profit Distribution Chart\n     * Shows distribution of profit/loss percentages from closed trades\n     */\n    private VBox createProfitDistributionChart() {\n        VBox container = new VBox(10);\n        container.setPadding(new Insets(15));\n        container.setStyle(\"-fx-background-color: white; -fx-border-color: #D4DAE4; -fx-border-width: 1; \" +\n                          \"-fx-border-radius: 8; -fx-background-radius: 8;\");\n        \n        Label titleLabel = new Label(\" Profit Distribution by Trade\");\n        titleLabel.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF;\");\n        \n        CategoryAxis xAxis = new CategoryAxis();\n        xAxis.setLabel(\"Profit/Loss Range\");\n        \n        NumberAxis yAxis = new NumberAxis();\n        yAxis.setLabel(\"Number of Trades\");\n        \n        BarChart<String, Number> barChart = new BarChart<>(xAxis, yAxis);\n        barChart.setTitle(\"Trade Outcome Distribution\");\n        barChart.setLegendVisible(false);\n        barChart.setPrefHeight(220);\n        \n        XYChart.Series<String, Number> series = new XYChart.Series<>();\n        series.setName(\"Trade Count\");\n        \n        int lessThanMinus10 = 0;\n        int minus10ToMinus5 = 0;\n        int minus5To0 = 0;\n        int zeroTo5 = 0;\n        int fiveTo10 = 0;\n        int greaterThan10 = 0;\n        \n        for (TradeRecord trade : appState.getTradeRecords()) {\n            if (trade.getProfitPercent() != null) {\n                double profitPct = trade.getProfitPercent();\n                \n                if (profitPct < -10) {\n                    lessThanMinus10++;\n                } else if (profitPct < -5) {\n                    minus10ToMinus5++;\n                } else if (profitPct < 0) {\n                    minus5To0++;\n                } else if (profitPct < 5) {\n                    zeroTo5++;\n                } else if (profitPct < 10) {\n                    fiveTo10++;\n                } else {\n                    greaterThan10++;\n                }\n            }\n        }\n        \n        series.getData().add(new XYChart.Data<>(\"<-10%\", lessThanMinus10));\n        series.getData().add(new XYChart.Data<>(\"-10% to -5%\", minus10ToMinus5));\n        series.getData().add(new XYChart.Data<>(\"-5% to 0%\", minus5To0));\n        series.getData().add(new XYChart.Data<>(\"0% to 5%\", zeroTo5));\n        series.getData().add(new XYChart.Data<>(\"5% to 10%\", fiveTo10));\n        series.getData().add(new XYChart.Data<>(\">10%\", greaterThan10));\n        \n        barChart.getData().add(series);\n        \n        container.getChildren().addAll(titleLabel, barChart);\n        return container;\n    }\n    \n    /**\n     * Create a signal rules section\n     */\n    private VBox createSignalRulesSection(String title) {\n        VBox section = new VBox(8);\n        section.setPadding(new Insets(15));\n        section.setStyle(\"-fx-background-color: white; -fx-border-color: #D4DAE4; -fx-border-width: 1; \" +\n                        \"-fx-border-radius: 8; -fx-background-radius: 8;\");\n        \n        Label titleLabel = new Label(title);\n        titleLabel.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold; -fx-text-fill: #9CA3AF;\");\n        \n        section.getChildren().add(titleLabel);\n        return section;\n    }\n    \n    // ===========================\n    // Event Handlers (Implementations)\n    // ===========================\n    \n    /**\n     * Connect to Questrade - Validate token and save to settings via backend\n     */\n    private void connectQuestrade() {\n        String token = tokenEntry.getText().trim();\n        \n        if (token.isEmpty()) {\n            showError(\"Connection Error\", \"Please enter a Questrade refresh token.\");\n            return;\n        }\n        \n        // Basic validation - Questrade tokens are typically alphanumeric with hyphens\n        if (token.length() < 10) {\n            showError(\"Invalid Token\", \"The token appears to be too short. Please check and try again.\");\n            return;\n        }\n        \n        // Call backend to connect\n        grpcClient.connectQuestrade(token, new TradingServiceClient.ConnectionCallback() {\n            @Override\n            public void onSuccess(String message, com.spiketrade.proto.MarketDataProto.ConnectionStatus status) {\n                Platform.runLater(() -> {\n                    // Update ApplicationState - this automatically propagates to all tabs\n                    appState.setConnected(true);\n                    appState.setConnectionStatus(\"Connected: \" + message);\n                    \n                    // Update UI - unbind before setting if bound\n                    if (connectionStatusLabel.textProperty().isBound()) {\n                        connectionStatusLabel.textProperty().unbind();\n                    }\n                    connectionStatusLabel.setText(\" CONNECTED\");\n                    connectionStatusLabel.setStyle(\"-fx-font-size: 11px; -fx-font-weight: bold; -fx-text-fill: #D1D5DB;\");\n                    \n                    if (quoteSourceLabel.textProperty().isBound()) {\n                        quoteSourceLabel.textProperty().unbind();\n                    }\n                    quoteSourceLabel.setText(\" QUOTES: CONNECTED\");\n                    \n                    showSuccess(\"Connection Successful\", \n                               \"Questrade connection established!\\n\\n\" + message + \n                               \"\\n\\nNote: For security, you'll need to re-enter your token each session.\");\n                });\n            }\n            \n            @Override\n            public void onError(String error) {\n                Platform.runLater(() -> {\n                    showError(\"Connection Failed\", \n                             \"Failed to connect to Questrade:\\n\\n\" + error + \n                             \"\\n\\nMake sure the C++ backend is running.\");\n                });\n            }\n        });\n    }\n    \n    /**\n     * Toggle trading on/off via backend\n     */\n    private void toggleTrading() {\n        if (!appState.isConnected()) {\n            showWarning(\"Not Connected\", \n                       \"Please connect to Questrade first before enabling trading.\");\n            return;\n        }\n        \n        boolean targetState = !appState.isTradingEnabled();\n        \n        if (targetState) {\n            // Start trading - get list of symbols from ticker table\n            List<String> symbols = tickerTable.getItems().stream()\n                    .map(TickerData::getSymbol)\n                    .collect(Collectors.toList());\n            \n            if (symbols.isEmpty()) {\n                showWarning(\"No Tickers\", \"Please add at least one ticker symbol before starting trading.\");\n                return;\n            }\n            \n            grpcClient.startTrading(symbols, new TradingServiceClient.TradingControlCallback() {\n                @Override\n                public void onSuccess(String message) {\n                    Platform.runLater(() -> {\n                        // Update ApplicationState - this automatically propagates to all tabs\n                        appState.setTradingEnabled(true);\n                        \n                        tradingToggleButton.setText(\" TRADING ACTIVE\");\n                        tradingToggleButton.getStyleClass().remove(\"button-red\");\n                        tradingToggleButton.getStyleClass().add(\"button-green\");\n                        warmupStatusLabel.setText(\" SYSTEM: ACTIVE\");\n                        warmupStatusLabel.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #D1D5DB;\");\n                        \n                        // FIX #9: Start periodic exit condition polling\n                        startExitConditionPolling();\n                        \n                        // Start signal streaming with active symbols\n                        startSignalStreaming(symbols);\n                        \n                        // Also start continuous probability polling\n                        startProbabilityPolling(symbols);\n                        \n                        // Start periodic trade tracker refresh\n                        startTradeTrackerAutoRefresh();\n                        \n                        // Initial trade refresh to show any existing trades\n                        refreshTrades();\n                        \n                        showSuccess(\"Trading Started\", message + \"\\nSignal streaming activated for \" + symbols.size() + \" symbols.\");\n                    });\n                }\n                \n                @Override\n                public void onError(String error) {\n                    Platform.runLater(() -> {\n                        showError(\"Start Trading Failed\", error);\n                    });\n                }\n            });\n        } else {\n            // Stop trading\n            grpcClient.stopTrading(new TradingServiceClient.TradingControlCallback() {\n                @Override\n                public void onSuccess(String message) {\n                    Platform.runLater(() -> {\n                        // Update ApplicationState - this automatically propagates to all tabs\n                        appState.setTradingEnabled(false);\n                        \n                        tradingToggleButton.setText(\" TRADING OFFLINE\");\n                        tradingToggleButton.getStyleClass().remove(\"button-green\");\n                        tradingToggleButton.getStyleClass().add(\"button-red\");\n                        warmupStatusLabel.setText(\" SYSTEM: READY\");\n                        warmupStatusLabel.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #555555;\");\n                        \n                        // FIX #9: Stop periodic exit condition polling\n                        stopExitConditionPolling();\n                        \n                        // FIX #11: Stop background timers to prevent resource leak\n                        stopBackgroundTimers();\n                        \n                        showSuccess(\"Trading Stopped\", message);\n                    });\n                }\n                \n                @Override\n                public void onError(String error) {\n                    Platform.runLater(() -> {\n                        showError(\"Stop Trading Failed\", error);\n                    });\n                }\n            });\n        }\n    }\n    \n    /**\n     * Save all settings to JSON file\n     */\n    private void saveSettings() {\n        try {\n            // Load existing settings\n            JsonNode settings = loadSettingsJson();\n            \n            // Make sure params node exists\n            if (!settings.has(\"params\") || settings.get(\"params\") == null) {\n                ((ObjectNode) settings).set(\"params\", objectMapper.createObjectNode());\n            }\n            \n            JsonNode params = settings.get(\"params\");\n            \n            // Update parameters from UI - ALL SLIDERS\n            ((ObjectNode) params).put(\"stddev_master\", stdDevSlider.getValue());\n            ((ObjectNode) params).put(\"period_master\", (int) periodSlider.getValue());\n            ((ObjectNode) params).put(\"rsi_period\", (int) regularRsiRocPeriodSlider.getValue());\n            ((ObjectNode) params).put(\"rsi_threshold\", regularRsiRocThresholdSlider.getValue());\n            ((ObjectNode) params).put(\"warmup_data_points\", Integer.parseInt(warmupEntry.getText()));\n            \n            // Risk Controls\n            ((ObjectNode) params).put(\"combo_signal_threshold\", comboSignalThresholdSlider.getValue());\n            ((ObjectNode) params).put(\"high_prob_threshold\", highProbThresholdSlider.getValue());\n            ((ObjectNode) params).put(\"stop_loss_pct\", stopLossPctSlider.getValue());\n            ((ObjectNode) params).put(\"initial_profit_floor_pct\", initialProfitFloorPctSlider.getValue());\n            ((ObjectNode) params).put(\"subsequent_profit_floor_pct\", subsequentProfitFloorPctSlider.getValue());\n            \n            // Capital Allocation\n            ((ObjectNode) params).put(\"equity_per_trade\", equityPerTradeSlider.getValue());\n            ((ObjectNode) params).put(\"max_open_trades\", (int) maxOpenTradesSlider.getValue());\n            ((ObjectNode) params).put(\"total_equity_available\", totalEquityAvailableSlider.getValue());\n            \n            // System Behavior\n            ((ObjectNode) params).put(\"data_points\", (int) dataPointsSlider.getValue());\n            ((ObjectNode) params).put(\"enable_cooldowns\", enableCooldownsCheckBox.isSelected());\n            \n            // Indicator Windows\n            ((ObjectNode) params).put(\"bb_length_minutes\", (int) bbLengthMinutesSlider.getValue());\n            ((ObjectNode) params).put(\"mfi_period_minutes\", (int) mfiPeriodMinutesSlider.getValue());\n            ((ObjectNode) params).put(\"vwap_period_minutes\", (int) vwapPeriodMinutesSlider.getValue());\n            \n            // Individual Spike Thresholds\n            ((ObjectNode) params).put(\"spike_price_roc_z_threshold\", spikePriceRocZThresholdSlider.getValue());\n            ((ObjectNode) params).put(\"spike_rsi_roc_z_threshold\", spikeRsiRocZThresholdSlider.getValue());\n            ((ObjectNode) params).put(\"spike_obv_roc_z_threshold\", spikeObvRocZThresholdSlider.getValue());\n            ((ObjectNode) params).put(\"spike_mfi_roc_z_threshold\", spikeMfiRocZThresholdSlider.getValue());\n            ((ObjectNode) params).put(\"spike_percent_b_roc_z_threshold\", spikePercentBRocZThresholdSlider.getValue());\n            ((ObjectNode) params).put(\"spike_vwap_roc_z_threshold\", spikeVwapRocZThresholdSlider.getValue());\n            ((ObjectNode) params).put(\"spike_volume_roc_z_threshold\", spikeVolumeRocZThresholdSlider.getValue());\n            \n            // Update signal rules checkboxes\n            // Update signal rules checkboxes\n            ((ObjectNode) params).put(\"require_spike_quality\", requireSpikeQuality.isSelected());\n            ((ObjectNode) params).put(\"require_rsi_condition\", requireRsiCondition.isSelected());\n            ((ObjectNode) params).put(\"require_price_condition\", requirePriceCondition.isSelected());\n            ((ObjectNode) params).put(\"require_obv_condition\", requireObvCondition.isSelected());\n            ((ObjectNode) params).put(\"require_mfi_condition\", requireMfiCondition.isSelected()); //  ADD THIS\n            ((ObjectNode) params).put(\"require_bollinger_condition\", requireBollingerCondition.isSelected());\n            ((ObjectNode) params).put(\"enable_adx_indicator\", enableAdxIndicator.isSelected());\n            ((ObjectNode) params).put(\"enable_percent_vwap_indicator\", enableVwapIndicator.isSelected());\n            ((ObjectNode) params).put(\"require_volume_spike\", requireVolumeSpike.isSelected());\n            \n            // NEW PENNY STOCK INDICATORS - Enable/Disable Flags\n            ((ObjectNode) params).put(\"enable_macd_indicator\", enableMacdHistogramRoc.isSelected());\n            ((ObjectNode) params).put(\"enable_stochastic_indicator\", enableStochasticIndicator.isSelected());\n            ((ObjectNode) params).put(\"enable_rvol_indicator\", enableRvolIndicator.isSelected());\n            ((ObjectNode) params).put(\"enable_ema_indicator\", enableEmaIndicator.isSelected());\n            ((ObjectNode) params).put(\"enable_ema_trend_filter\", enableEmaTrendFilter.isSelected());\n            \n            // NEW PENNY STOCK PARAMETERS - Fine-tuning sliders\n            ((ObjectNode) params).put(\"macd_fast_period\", (int) macdFastPeriodSlider.getValue());\n            ((ObjectNode) params).put(\"macd_slow_period\", (int) macdSlowPeriodSlider.getValue());\n            ((ObjectNode) params).put(\"macd_signal_period\", (int) macdSignalPeriodSlider.getValue());\n            ((ObjectNode) params).put(\"macd_histogram_roc_threshold\", macdHistogramRocThresholdSlider.getValue());\n            ((ObjectNode) params).put(\"stochastic_period\", (int) stochasticPeriodSlider.getValue());\n            ((ObjectNode) params).put(\"stochastic_k_smooth\", (int) stochasticKSmoothSlider.getValue());\n            ((ObjectNode) params).put(\"stochastic_d_smooth\", (int) stochasticDSmoothSlider.getValue());\n            ((ObjectNode) params).put(\"stochastic_oversold_threshold\", stochasticOversoldThresholdSlider.getValue());\n            ((ObjectNode) params).put(\"stochastic_overbought_threshold\", stochasticOverboughtThresholdSlider.getValue());\n            ((ObjectNode) params).put(\"rvol_period\", (int) rvolPeriodSlider.getValue());\n            ((ObjectNode) params).put(\"rvol_threshold\", rvolThresholdSlider.getValue());\n            ((ObjectNode) params).put(\"ema9_period\", (int) ema9PeriodSlider.getValue());\n            ((ObjectNode) params).put(\"ema20_period\", (int) ema20PeriodSlider.getValue());\n            ((ObjectNode) params).put(\"ema50_period\", (int) ema50PeriodSlider.getValue());\n            ((ObjectNode) params).put(\"volume_spike_threshold\", volumeSpikeThresholdSlider.getValue());\n            \n            // Update timestamp\n            ((ObjectNode) settings).put(\"timestamp\", LocalDateTime.now().toString());\n            \n            // Save to file\n            objectMapper.writerWithDefaultPrettyPrinter()\n                    .writeValue(new File(SETTINGS_FILE), settings);\n            \n            showSuccess(\"Settings Saved\", \n                    \"All settings have been successfully saved to:\\n\" + SETTINGS_FILE);\n            \n        } catch (IOException e) {\n            showError(\"Save Error\", \"Failed to save settings:\\n\" + e.getMessage());\n        } catch (NumberFormatException e) {\n            showError(\"Invalid Input\", \"Please check that all numeric fields contain valid numbers.\");\n        }\n    }        /**\n         * Load settings from JSON file and populate UI\n         */\n    /**\n     * Load settings from JSON file and populate UI\n     * FIXED VERSION - matches actual GUI components\n     */\n    private void loadSettings() {\n        try {\n            File configFile = new File(\"trading_settings.json\");\n            if (!configFile.exists()) {\n                System.out.println(\"Config file not found, using default values\");\n                showInfo(\"No Settings File\", \"Configuration file not found. Using default values.\");\n                return;\n            }\n\n            ObjectMapper mapper = new ObjectMapper();\n            JsonNode root = mapper.readTree(configFile);\n            \n            // Check if params node exists\n            JsonNode params = root.has(\"params\") ? root.get(\"params\") : root;\n            \n            // Warmup settings\n            if (params.has(\"warmup_data_points\")) {\n                warmupEntry.setText(String.valueOf(params.get(\"warmup_data_points\").asInt()));\n            }\n            \n            // Load all slider values from saved settings\n            if (params.has(\"stddev_master\")) stdDevSlider.setValue(params.get(\"stddev_master\").asDouble());\n            if (params.has(\"period_master\")) periodSlider.setValue(params.get(\"period_master\").asInt());\n            if (params.has(\"rsi_period\")) regularRsiRocPeriodSlider.setValue(params.get(\"rsi_period\").asInt());\n            if (params.has(\"rsi_threshold\")) regularRsiRocThresholdSlider.setValue(params.get(\"rsi_threshold\").asDouble());\n            \n            // Risk Controls\n            if (params.has(\"combo_signal_threshold\")) comboSignalThresholdSlider.setValue(params.get(\"combo_signal_threshold\").asDouble());\n            if (params.has(\"high_prob_threshold\")) highProbThresholdSlider.setValue(params.get(\"high_prob_threshold\").asDouble());\n            if (params.has(\"stop_loss_pct\")) stopLossPctSlider.setValue(params.get(\"stop_loss_pct\").asDouble());\n            if (params.has(\"initial_profit_floor_pct\")) initialProfitFloorPctSlider.setValue(params.get(\"initial_profit_floor_pct\").asDouble());\n            if (params.has(\"subsequent_profit_floor_pct\")) subsequentProfitFloorPctSlider.setValue(params.get(\"subsequent_profit_floor_pct\").asDouble());\n            \n            // Capital Allocation\n            if (params.has(\"equity_per_trade\")) equityPerTradeSlider.setValue(params.get(\"equity_per_trade\").asDouble());\n            if (params.has(\"max_open_trades\")) maxOpenTradesSlider.setValue(params.get(\"max_open_trades\").asInt());\n            if (params.has(\"total_equity_available\")) totalEquityAvailableSlider.setValue(params.get(\"total_equity_available\").asDouble());\n            \n            // System Behavior\n            if (params.has(\"data_points\")) dataPointsSlider.setValue(params.get(\"data_points\").asInt());\n            if (params.has(\"enable_cooldowns\")) enableCooldownsCheckBox.setSelected(params.get(\"enable_cooldowns\").asBoolean());\n            \n            // Indicator Windows\n            if (params.has(\"bb_length_minutes\")) bbLengthMinutesSlider.setValue(params.get(\"bb_length_minutes\").asInt());\n            if (params.has(\"mfi_period_minutes\")) mfiPeriodMinutesSlider.setValue(params.get(\"mfi_period_minutes\").asInt());\n            if (params.has(\"vwap_period_minutes\")) vwapPeriodMinutesSlider.setValue(params.get(\"vwap_period_minutes\").asInt());\n            \n            // Individual Spike Thresholds\n            if (params.has(\"spike_price_roc_z_threshold\")) spikePriceRocZThresholdSlider.setValue(params.get(\"spike_price_roc_z_threshold\").asDouble());\n            if (params.has(\"spike_rsi_roc_z_threshold\")) spikeRsiRocZThresholdSlider.setValue(params.get(\"spike_rsi_roc_z_threshold\").asDouble());\n            if (params.has(\"spike_obv_roc_z_threshold\")) spikeObvRocZThresholdSlider.setValue(params.get(\"spike_obv_roc_z_threshold\").asDouble());\n            if (params.has(\"spike_mfi_roc_z_threshold\")) spikeMfiRocZThresholdSlider.setValue(params.get(\"spike_mfi_roc_z_threshold\").asDouble());\n            if (params.has(\"spike_percent_b_roc_z_threshold\")) spikePercentBRocZThresholdSlider.setValue(params.get(\"spike_percent_b_roc_z_threshold\").asDouble());\n            if (params.has(\"spike_vwap_roc_z_threshold\")) spikeVwapRocZThresholdSlider.setValue(params.get(\"spike_vwap_roc_z_threshold\").asDouble());\n            if (params.has(\"spike_volume_roc_z_threshold\")) spikeVolumeRocZThresholdSlider.setValue(params.get(\"spike_volume_roc_z_threshold\").asDouble());\n            \n            // Signal Rules checkboxes - restore checkbox states\n            if (params.has(\"require_rsi_condition\")) requireRsiCondition.setSelected(params.get(\"require_rsi_condition\").asBoolean());\n            if (params.has(\"require_price_condition\")) requirePriceCondition.setSelected(params.get(\"require_price_condition\").asBoolean());\n            if (params.has(\"require_obv_condition\")) requireObvCondition.setSelected(params.get(\"require_obv_condition\").asBoolean());\n            if (params.has(\"require_mfi_condition\")) requireMfiCondition.setSelected(params.get(\"require_mfi_condition\").asBoolean()); //  ADD THIS\n            if (params.has(\"require_bollinger_condition\")) requireBollingerCondition.setSelected(params.get(\"require_bollinger_condition\").asBoolean());\n            if (params.has(\"enable_adx_indicator\")) enableAdxIndicator.setSelected(params.get(\"enable_adx_indicator\").asBoolean());\n            if (params.has(\"enable_percent_vwap_indicator\")) enableVwapIndicator.setSelected(params.get(\"enable_percent_vwap_indicator\").asBoolean());\n            if (params.has(\"require_volume_spike\")) requireVolumeSpike.setSelected(params.get(\"require_volume_spike\").asBoolean());\n            \n            // NEW PENNY STOCK INDICATORS - Enable/Disable Flags\n            if (params.has(\"enable_macd_indicator\")) enableMacdHistogramRoc.setSelected(params.get(\"enable_macd_indicator\").asBoolean());\n            if (params.has(\"enable_stochastic_indicator\")) enableStochasticIndicator.setSelected(params.get(\"enable_stochastic_indicator\").asBoolean());\n            if (params.has(\"enable_rvol_indicator\")) enableRvolIndicator.setSelected(params.get(\"enable_rvol_indicator\").asBoolean());\n            if (params.has(\"enable_ema_indicator\")) enableEmaIndicator.setSelected(params.get(\"enable_ema_indicator\").asBoolean());\n            if (params.has(\"enable_ema_trend_filter\")) enableEmaTrendFilter.setSelected(params.get(\"enable_ema_trend_filter\").asBoolean());\n            \n            // NEW PENNY STOCK PARAMETERS - Fine-tuning sliders\n            if (params.has(\"macd_fast_period\")) macdFastPeriodSlider.setValue(params.get(\"macd_fast_period\").asInt());\n            if (params.has(\"macd_slow_period\")) macdSlowPeriodSlider.setValue(params.get(\"macd_slow_period\").asInt());\n            if (params.has(\"macd_signal_period\")) macdSignalPeriodSlider.setValue(params.get(\"macd_signal_period\").asInt());\n            if (params.has(\"macd_histogram_roc_threshold\")) macdHistogramRocThresholdSlider.setValue(params.get(\"macd_histogram_roc_threshold\").asDouble());\n            if (params.has(\"stochastic_period\")) stochasticPeriodSlider.setValue(params.get(\"stochastic_period\").asInt());\n            if (params.has(\"stochastic_k_smooth\")) stochasticKSmoothSlider.setValue(params.get(\"stochastic_k_smooth\").asInt());\n            if (params.has(\"stochastic_d_smooth\")) stochasticDSmoothSlider.setValue(params.get(\"stochastic_d_smooth\").asInt());\n            if (params.has(\"stochastic_oversold_threshold\")) stochasticOversoldThresholdSlider.setValue(params.get(\"stochastic_oversold_threshold\").asDouble());\n            if (params.has(\"stochastic_overbought_threshold\")) stochasticOverboughtThresholdSlider.setValue(params.get(\"stochastic_overbought_threshold\").asDouble());\n            if (params.has(\"rvol_period\")) rvolPeriodSlider.setValue(params.get(\"rvol_period\").asInt());\n            if (params.has(\"rvol_threshold\")) rvolThresholdSlider.setValue(params.get(\"rvol_threshold\").asDouble());\n            if (params.has(\"ema9_period\")) ema9PeriodSlider.setValue(params.get(\"ema9_period\").asInt());\n            if (params.has(\"ema20_period\")) ema20PeriodSlider.setValue(params.get(\"ema20_period\").asInt());\n            if (params.has(\"ema50_period\")) ema50PeriodSlider.setValue(params.get(\"ema50_period\").asInt());\n            if (params.has(\"volume_spike_threshold\")) volumeSpikeThresholdSlider.setValue(params.get(\"volume_spike_threshold\").asDouble());\n            \n            // Apply visibility based on restored checkbox states\n            for (Map.Entry<CheckBox, List<TitledPane>> entry : checkboxToPanesMap.entrySet()) {\n                CheckBox checkbox = entry.getKey();\n                List<TitledPane> panes = entry.getValue();\n                boolean isSelected = checkbox.isSelected();\n                for (TitledPane pane : panes) {\n                    pane.setVisible(isSelected);\n                    pane.setManaged(isSelected);\n                }\n            }\n            \n            System.out.println(\"Settings loaded successfully from trading_settings.json\");\n            showSuccess(\"Settings Loaded\", \"Configuration has been loaded from trading_settings.json\");\n            \n        } catch (FileNotFoundException e) {\n            System.out.println(\"Config file not found: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"Error reading config file: \" + e.getMessage());\n            e.printStackTrace();\n        } catch (Exception e) {\n            System.err.println(\"Unexpected error loading settings: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n    private void updateParameters() {\n        updateParametersInternal(null);\n    }\n    \n    /**\n     * Internal method that updates parameters and optionally executes callback.\n     * If onSuccess is null, shows success dialog; otherwise executes the callback.\n     */\n    private void updateParametersInternal(Runnable onSuccess) {\n        try {\n            // Check if connected to backend\n            if (!grpcClient.isConnected()) {\n                showError(\"Not Connected\", \"Cannot update parameters: Not connected to backend server.\\n\\nPlease wait for the backend to connect or restart the application.\");\n                return;\n            }\n            \n            // Load existing settings\n            JsonNode settings = loadSettingsJson();\n            \n            // Make sure params node exists\n            if (!settings.has(\"params\") || settings.get(\"params\") == null) {\n                ((ObjectNode) settings).set(\"params\", objectMapper.createObjectNode());\n            }\n            \n            JsonNode params = settings.get(\"params\");\n            \n            // Update parameters from sliders\n            ((ObjectNode) params).put(\"stddev_master\", stdDevSlider.getValue());\n            ((ObjectNode) params).put(\"period_master\", (int) periodSlider.getValue());\n            ((ObjectNode) params).put(\"rsi_period\", (int) regularRsiRocPeriodSlider.getValue());\n            ((ObjectNode) params).put(\"rsi_threshold\", regularRsiRocThresholdSlider.getValue());\n            \n            // Update timestamp\n            ((ObjectNode) settings).put(\"timestamp\", LocalDateTime.now().toString());\n            \n            // Save to file\n            objectMapper.writerWithDefaultPrettyPrinter()\n                    .writeValue(new File(SETTINGS_FILE), settings);\n            \n            // Build gRPC TradingConfig and send to backend\n            com.spiketrade.proto.ConfigProto.TradingConfig.Builder configBuilder = \n                com.spiketrade.proto.ConfigProto.TradingConfig.newBuilder();\n            \n            // CRITICAL FIX: Send timeframe multiplier explicitly and BASE periods (not multiplied)\n            // Backend will aggregate candles AND use base periods, avoiding double multiplication\n            int multiplier = currentTimeframeMode.getMultiplier();\n            System.out.println(\" Updating backend config with timeframe multiplier: \" + multiplier + \"x (\" + currentTimeframeMode.getDisplayName() + \")\");\n            \n            // NEW: Set the timeframe multiplier explicitly\n            configBuilder.setTimeframeMultiplier(multiplier);\n            \n            // FIXED: Set window parameters - NOW SENDING BASE VALUES (not multiplied)\n            // Backend will aggregate candles into N-minute candles, then apply these periods\n            configBuilder.setBuyPeriodMinutes((int) periodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setBbLengthMinutes((int) bbLengthMinutesSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setRsiLengthMinutes((int) regularRsiRocPeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setPriceRocPeriodMinutes((int) periodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setObvRocPeriodMinutes((int) periodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setMfiPeriodMinutes((int) mfiPeriodMinutesSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setMfiRocPeriodMinutes((int) regularMfiRocPeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setVwapPeriodMinutes((int) vwapPeriodMinutesSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setDataPoints((int) dataPointsSlider.getValue());\n            configBuilder.setWarmupDataPoints(Integer.parseInt(warmupEntry.getText()));\n            \n            // Set spike ROC z-thresholds - NOW USING INDIVIDUAL SLIDERS\n            configBuilder.setSpikePriceRocZThreshold(spikePriceRocZThresholdSlider.getValue());\n            configBuilder.setSpikeRsiRocZThreshold(spikeRsiRocZThresholdSlider.getValue());\n            configBuilder.setSpikeObvRocZThreshold(spikeObvRocZThresholdSlider.getValue());\n            configBuilder.setSpikeMfiRocZThreshold(spikeMfiRocZThresholdSlider.getValue());\n            configBuilder.setSpikePercentBRocZThreshold(spikePercentBRocZThresholdSlider.getValue());\n            configBuilder.setSpikeVwapRocZThreshold(spikeVwapRocZThresholdSlider.getValue());\n            configBuilder.setSpikeVolumeRocZThreshold(spikeVolumeRocZThresholdSlider.getValue());\n            \n            // Set regular ROC thresholds (absolute %) - from UI sliders\n            configBuilder.setRegularPriceRocThreshold(regularPriceRocThresholdSlider.getValue());\n            configBuilder.setRegularRsiRocThreshold(regularRsiRocThresholdSlider.getValue());\n            configBuilder.setRegularObvRocThreshold(regularObvRocThresholdSlider.getValue());\n            configBuilder.setRegularMfiRocThreshold(regularMfiRocThresholdSlider.getValue());\n            configBuilder.setRegularPercentBRocThreshold(regularPercentBRocThresholdSlider.getValue());\n            configBuilder.setRegularVwapRocThreshold(regularVwapRocThresholdSlider.getValue());\n            configBuilder.setRegularVolumeRocThreshold(regularVolumeRocThresholdSlider.getValue());\n            \n            // FIXED: Set regular ROC periods (minutes) - BASE VALUES (not multiplied)\n            configBuilder.setRegularPriceRocPeriod((int) regularPriceRocPeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setRegularRsiRocPeriod((int) regularRsiRocPeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setRegularObvRocPeriod((int) regularObvRocPeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setRegularMfiRocPeriod((int) regularMfiRocPeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setRegularPercentBRocPeriod((int) regularPercentBRocPeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setRegularVwapRocPeriod((int) regularVwapRocPeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setRegularVolumeRocPeriod((int) regularVolumeRocPeriodSlider.getValue());  // REMOVED * multiplier\n            \n            // Set risk control thresholds - NOW USING SLIDERS\n            configBuilder.setComboSignalThreshold(comboSignalThresholdSlider.getValue());\n            configBuilder.setHighProbThreshold(highProbThresholdSlider.getValue());\n            configBuilder.setStopLossPct(stopLossPctSlider.getValue() / 100.0); // Convert % to decimal\n            configBuilder.setSpikeCooldownStddevThreshold(stdDevSlider.getValue());\n            \n            // Set capital allocation parameters - NOW USING SLIDERS\n            configBuilder.setEquityPerTrade(equityPerTradeSlider.getValue());\n            configBuilder.setMaxOpenTrades(maxOpenTradesSlider.getValue());\n            configBuilder.setTotalEquityAvailable(totalEquityAvailableSlider.getValue());\n            \n            // Signal enablement mapping - ALL CHECKBOXES WIRED\n            configBuilder.setEnablePriceRocSpike(requirePriceCondition.isSelected());\n            configBuilder.setEnableRsiRocSpike(requireRsiCondition.isSelected());\n            configBuilder.setEnableObvRocSpike(requireObvCondition.isSelected());\n            configBuilder.setEnableMfiRocSpike(requireMfiCondition.isSelected());\n            configBuilder.setEnablePercentBRocSpike(requireBollingerCondition.isSelected());\n            configBuilder.setEnableVwapRocSpike(enableVwapIndicator.isSelected());\n            configBuilder.setEnableVolumeRocSpike(requireVolumeSpike.isSelected()); // NEW: Volume spike wired\n            configBuilder.setEnableAdxIndicator(enableAdxIndicator.isSelected()); // NEW: ADX wired\n            configBuilder.setUseMlSpikes(requireSpikeQuality.isSelected());\n            \n            // NEW PENNY STOCK INDICATORS - Enable/Disable Flags\n            configBuilder.setEnableMacdHistogramRoc(enableMacdHistogramRoc.isSelected());\n            configBuilder.setEnableStochasticIndicator(enableStochasticIndicator.isSelected());\n            configBuilder.setEnableRvolIndicator(enableRvolIndicator.isSelected());\n            configBuilder.setEnableEmaIndicator(enableEmaIndicator.isSelected());\n            configBuilder.setEnableEmaTrendFilter(enableEmaTrendFilter.isSelected());\n            configBuilder.setEnableCooldowns(enableCooldownsCheckBox.isSelected()); // NOW USING CHECKBOX\n            \n            // FIXED: NEW PENNY STOCK PARAMETERS - BASE VALUES (not multiplied)\n            configBuilder.setMacdFastPeriod((int) macdFastPeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setMacdSlowPeriod((int) macdSlowPeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setMacdSignalPeriod((int) macdSignalPeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setMacdHistogramRocThreshold(macdHistogramRocThresholdSlider.getValue());\n            configBuilder.setStochasticPeriod((int) stochasticPeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setStochasticKSmooth((int) stochasticKSmoothSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setStochasticDSmooth((int) stochasticDSmoothSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setStochasticOversoldThreshold(stochasticOversoldThresholdSlider.getValue());\n            configBuilder.setStochasticOverboughtThreshold(stochasticOverboughtThresholdSlider.getValue());\n            configBuilder.setRvolPeriod((int) rvolPeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setRvolThreshold(rvolThresholdSlider.getValue());\n            configBuilder.setEma9Period((int) ema9PeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setEma20Period((int) ema20PeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setEma50Period((int) ema50PeriodSlider.getValue());  // REMOVED * multiplier\n            configBuilder.setVolumeSpikeThreshold(volumeSpikeThresholdSlider.getValue());\n            \n            System.out.println(\"Signal rules being sent to backend:\");\n            System.out.println(\"  - Price: \" + requirePriceCondition.isSelected());\n            System.out.println(\"  - RSI: \" + requireRsiCondition.isSelected());\n            System.out.println(\"  - OBV: \" + requireObvCondition.isSelected());\n            System.out.println(\"  - MFI: true (default)\");\n            System.out.println(\"  - %B: \" + requireBollingerCondition.isSelected());\n            System.out.println(\"  - VWAP: \" + enableVwapIndicator.isSelected());\n            System.out.println(\"  - Spike Quality: \" + requireSpikeQuality.isSelected());\n            \n            System.out.println(\"Signal rules - Price:\" + requirePriceCondition.isSelected() + \n                              \" RSI:\" + requireRsiCondition.isSelected() + \n                              \" OBV:\" + requireObvCondition.isSelected() + \n                              \" Spike:\" + requireSpikeQuality.isSelected());\n            \n            com.spiketrade.proto.ConfigProto.TradingConfig config = configBuilder.build();\n            \n            // Send config to backend via gRPC\n            grpcClient.updateConfig(config, new TradingServiceClient.ConfigCallback() {\n                @Override\n                public void onConfig(com.spiketrade.proto.ConfigProto.TradingConfig updatedConfig) {\n                    // Store configuration and sync with ApplicationState for cross-tab consistency\n                    currentConfig = updatedConfig;\n                    appState.setCurrentConfig(updatedConfig);\n                    Platform.runLater(() -> {\n                        // If callback provided, execute it; otherwise show success dialog\n                        if (onSuccess != null) {\n                            onSuccess.run();\n                        } else {\n                            showSuccess(\"Parameters Updated\", \n                                    String.format(\"Parameters have been successfully applied to backend:\\n\\n\" +\n                                                    \"Standard Deviation: %.1f\\n\" +\n                                                    \"Period Master: %d minutes\\n\" +\n                                                    \"RSI Period: %d minutes\\n\" +\n                                                    \"RSI Threshold: %.2f\\n\\n\" +\n                                                    \"Backend has confirmed the configuration update.\",\n                                                    stdDevSlider.getValue(),\n                                                    (int) periodSlider.getValue(),\n                                                    (int) regularRsiRocPeriodSlider.getValue(),\n                                                    regularRsiRocThresholdSlider.getValue()));\n                        }\n                    });\n                }\n                \n                @Override\n                public void onError(String error) {\n                    Platform.runLater(() -> {\n                        showError(\"Backend Update Failed\", \n                                \"Failed to update backend configuration:\\n\" + error + \n                                \"\\n\\nParameters were saved to file but not applied to backend.\");\n                    });\n                }\n            });\n            \n        } catch (IOException e) {\n            showError(\"Update Error\", \"Failed to update parameters:\\n\" + e.getMessage());\n        } catch (NumberFormatException e) {\n            showError(\"Invalid Input\", \"Please enter valid numbers for all fields:\\n\" + e.getMessage());\n        }\n    }\n    \n    // ===========================\n    // Helper Methods for Settings\n    // ===========================\n    \n    /**\n     * Load settings JSON, creating default if doesn't exist\n     */\n    private JsonNode loadSettingsJson() throws IOException {\n        File settingsFile = new File(SETTINGS_FILE);\n        \n        if (!settingsFile.exists()) {\n            // Create default settings structure\n            ObjectNode defaultSettings = objectMapper.createObjectNode();\n            ObjectNode defaultParams = objectMapper.createObjectNode();\n            \n            // Add default parameters\n            defaultParams.put(\"stddev_master\", 2.0);\n            defaultParams.put(\"period_master\", 20);\n            defaultParams.put(\"rsi_period\", 14);\n            defaultParams.put(\"rsi_threshold\", -0.5);\n            defaultParams.put(\"warmup_data_points\", 75);\n            defaultParams.put(\"require_spike_quality\", false);\n            defaultParams.put(\"require_rsi_condition\", false);\n            defaultParams.put(\"require_price_condition\", false);\n            defaultParams.put(\"require_obv_condition\", false);\n            defaultParams.put(\"require_bollinger_condition\", false);\n            defaultParams.put(\"enable_adx_indicator\", false);\n            defaultParams.put(\"enable_percent_vwap_indicator\", false);\n            defaultParams.put(\"require_volume_spike\", false);\n            \n            defaultSettings.set(\"params\", defaultParams);\n            defaultSettings.put(\"token\", \"\");\n            defaultSettings.putArray(\"active_tickers\");\n            defaultSettings.put(\"timestamp\", LocalDateTime.now().toString());\n            \n            // Save default settings\n            objectMapper.writerWithDefaultPrettyPrinter()\n                    .writeValue(settingsFile, defaultSettings);\n            \n            return defaultSettings;\n        }\n        \n        // Load existing file\n        JsonNode existingSettings = objectMapper.readTree(settingsFile);\n        \n        // Ensure params node exists in loaded settings\n        if (!existingSettings.has(\"params\") || existingSettings.get(\"params\") == null) {\n            ObjectNode defaultParams = objectMapper.createObjectNode();\n            defaultParams.put(\"stddev_master\", 2.0);\n            defaultParams.put(\"period_master\", 20);\n            defaultParams.put(\"rsi_period\", 14);\n            defaultParams.put(\"rsi_threshold\", -0.5);\n            defaultParams.put(\"warmup_data_points\", 75);\n            defaultParams.put(\"require_spike_quality\", false);\n            defaultParams.put(\"require_rsi_condition\", false);\n            defaultParams.put(\"require_price_condition\", false);\n            defaultParams.put(\"require_obv_condition\", false);\n            defaultParams.put(\"require_bollinger_condition\", false);\n            defaultParams.put(\"enable_adx_indicator\", false);\n            defaultParams.put(\"enable_percent_vwap_indicator\", false);\n            defaultParams.put(\"require_volume_spike\", false);\n            \n            ((ObjectNode) existingSettings).set(\"params\", defaultParams);\n            \n            // Save the updated settings\n            objectMapper.writerWithDefaultPrettyPrinter()\n                    .writeValue(settingsFile, existingSettings);\n        }\n        \n        return existingSettings;\n    }    \n    /**\n     * Show success alert\n     */\n    private void showSuccess(String title, String message) {\n        Alert alert = new Alert(Alert.AlertType.INFORMATION);\n        alert.setTitle(title);\n        alert.setHeaderText(null);\n        alert.setContentText(message);\n        alert.showAndWait();\n    }\n    \n    /**\n     * Show error alert\n     */\n    private void showError(String title, String message) {\n        Alert alert = new Alert(Alert.AlertType.ERROR);\n        alert.setTitle(title);\n        alert.setHeaderText(null);\n        alert.setContentText(message);\n        alert.showAndWait();\n    }\n    \n    /**\n     * Show warning alert\n     */\n    private void showWarning(String title, String message) {\n        Alert alert = new Alert(Alert.AlertType.WARNING);\n        alert.setTitle(title);\n        alert.setHeaderText(null);\n        alert.setContentText(message);\n        alert.showAndWait();\n    }\n    \n    /**\n     * Show info alert\n     */\n    private void showInfo(String title, String message) {\n        Alert alert = new Alert(Alert.AlertType.INFORMATION);\n        alert.setTitle(title);\n        alert.setHeaderText(null);\n        alert.setContentText(message);\n        alert.showAndWait();\n    }\n    \n    /**\n     * Check if notification should be shown based on cooldown period\n     * NOW RESPECTS: debug mode bypass and configurable cooldown\n     */\n    private boolean shouldShowNotification(String symbol, String notificationType) {\n        // Debug mode: ALWAYS show notifications (bypass cooldown)\n        if (debugModeShowAllDecisions) {\n            System.out.println(\" DEBUG MODE: Bypassing cooldown for \" + symbol + \" \" + notificationType);\n            return true;\n        }\n        \n        String key = symbol + \":\" + notificationType;\n        long now = System.currentTimeMillis();\n        Long lastTime = lastNotificationTime.get(key);\n        \n        if (lastTime != null && (now - lastTime) < notificationCooldownMs) {\n            long remainingMs = notificationCooldownMs - (now - lastTime);\n            System.out.println(\" Cooldown active for \" + symbol + \" \" + notificationType + \n                             \" (wait \" + (remainingMs / 1000) + \"s)\");\n            return false; // Too soon, suppress\n        }\n        \n        lastNotificationTime.put(key, now);\n        return true;\n    }\n    \n    /**\n     * Show detailed buy signal alert with all metrics using system tray notification\n     * CRITICAL FIX: Now checks notification result and alerts on failure\n     */\n    private void showBuySignalAlert(com.spiketrade.proto.SpikeSignalsProto.BuySignal signal) {\n        // Debounce to prevent notification spam (unless in debug mode)\n        if (!shouldShowNotification(signal.getSymbol(), \"BUY\")) {\n            if (!debugModeShowAllDecisions) {\n                System.out.println(\" Suppressed duplicate BUY notification for \" + signal.getSymbol() + \" (cooldown active)\");\n                return;\n            }\n        }\n        \n        StringBuilder details = new StringBuilder();\n        \n        if (signal.getPredictedTimeToTargetMinutes() > 0) {\n            int minutes = signal.getPredictedTimeToTargetMinutes();\n            String timeframe;\n            if (minutes < 60) {\n                timeframe = minutes + \" min\";\n            } else if (minutes < 1440) {\n                int hours = minutes / 60;\n                int mins = minutes % 60;\n                timeframe = hours + \"h \" + mins + \"m\";\n            } else {\n                int days = minutes / 1440;\n                int hours = (minutes % 1440) / 60;\n                timeframe = days + \"d \" + hours + \"h\";\n            }\n            details.append(String.format(\"Target: %.1f%% in %s\", signal.getPredictedGainTarget(), timeframe));\n        }\n        \n        if (signal.hasIndicators()) {\n            com.spiketrade.proto.SpikeSignalsProto.Indicators ind = signal.getIndicators();\n            if (details.length() > 0) {\n                details.append(\"\\n\");\n            }\n            details.append(String.format(\"RSI: %.2f | Price ROC: %.2f%% | Vol ROC: %.2f%%\", \n                                        ind.getRsi(), ind.getPriceRoc(), ind.getVolumeRoc()));\n        }\n        \n        // Send notification (async - failures are logged by NotificationService)\n        notificationService.showBuySignal(\n            signal.getSymbol(), \n            signal.getPrice(), \n            signal.getSignalProbability(), \n            details.toString()\n        );\n    }\n    \n    /**\n     * Show detailed sell warning alert with all metrics using system tray notification\n     */\n    private void showSellWarningAlert(SellWarning warning) {\n        // Debounce to prevent notification spam\n        if (!shouldShowNotification(warning.symbol, \"SELL_WARNING\")) {\n            System.out.println(\" Suppressed duplicate SELL WARNING notification for \" + warning.symbol + \" (cooldown active)\");\n            return;\n        }\n        \n        notificationService.showSellWarning(\n            warning.symbol,\n            warning.price,\n            warning.warningProbability,\n            warning.reason\n        );\n    }\n    \n    /**\n     * Update parameters with optional callback when backend confirms the update.\n     * This ensures deterministic synchronization before operations like backtesting.\n     */\n    private void updateParametersAndThen(Runnable onSuccess) {\n        updateParametersInternal(onSuccess);\n    }\n    \n    private void runBacktest() {\n        // Validate inputs\n        String symbol = backtestSymbolEntry.getText().trim().toUpperCase();\n        String startDate = backtestStartDate.getText().trim();\n        String endDate = backtestEndDate.getText().trim();\n        \n        if (symbol.isEmpty()) {\n            showWarning(\"Missing Symbol\", \"Please enter a stock symbol to backtest.\");\n            return;\n        }\n        \n        if (startDate.isEmpty() || endDate.isEmpty()) {\n            showWarning(\"Missing Dates\", \"Please enter both start and end dates (YYYY-MM-DD).\");\n            return;\n        }\n        \n        // Capture all parameter values from UI controls (must be on FX thread)\n        final BacktestParameters params = buildBacktestParametersFromUI();\n        final double capital = params.totalCapital;\n        \n        // BUG FIX #1: Sync parameters to backend before running backtest\n        // Chain backtest execution off config update completion for deterministic sync\n        System.out.println(\" Syncing parameters to backend before backtest...\");\n        updateParametersAndThen(() -> {\n            System.out.println(\" Backend config confirmed. Fetching historical data...\");\n            // Call backend to fetch historical data (using 1-minute intervals and 500 bars)\n            grpcClient.getHistoricalData(symbol, CHART_INTERVAL_MINUTES, NUM_HISTORICAL_BARS, new TradingServiceClient.HistoricalDataCallback() {\n            @Override\n            public void onData(List<com.spiketrade.proto.MarketDataProto.Candle> candles) {\n                Platform.runLater(() -> {\n                    // Clear previous results\n                    backtestTable.getItems().clear();\n                    \n                    if (candles.isEmpty()) {\n                        showWarning(\"No Data\", \"No historical data available for the specified period.\");\n                        return;\n                    }\n                    \n                    // Run backtest simulation with parameter snapshot\n                    List<BacktestTrade> trades = simulateBacktest(symbol, candles, capital, params);\n                    \n                    // Add trades to table\n                    for (BacktestTrade trade : trades) {\n                        backtestTable.getItems().add(trade);\n                    }\n                    \n                    // Calculate comprehensive statistics\n                    double totalProfit = 0;\n                    double totalWinProfit = 0;\n                    double totalLossAmount = 0;\n                    int winners = 0;\n                    int losers = 0;\n                    double totalAccuracy = 0;\n                    int predictionsWithTarget = 0;\n                    double runningCapital = capital;\n                    double peakCapital = capital;\n                    double maxDrawdown = 0;\n                    List<Double> returns = new ArrayList<>();\n                    \n                    for (BacktestTrade trade : trades) {\n                        double pl = trade.getProfitLoss();\n                        totalProfit += pl;\n                        runningCapital += pl;\n                        \n                        if (pl > 0) {\n                            winners++;\n                            totalWinProfit += pl;\n                        } else if (pl < 0) {\n                            losers++;\n                            totalLossAmount += Math.abs(pl);\n                        }\n                        \n                        // Track returns for Sharpe ratio\n                        double tradeReturn = (pl / capital) * 100;\n                        returns.add(tradeReturn);\n                        \n                        // Track max drawdown\n                        if (runningCapital > peakCapital) {\n                            peakCapital = runningCapital;\n                        }\n                        double currentDrawdown = ((peakCapital - runningCapital) / peakCapital) * 100;\n                        if (currentDrawdown > maxDrawdown) {\n                            maxDrawdown = currentDrawdown;\n                        }\n                        \n                        if (trade.getActualTimeToTarget() != null && trade.getActualTimeToTarget() > 0) {\n                            totalAccuracy += trade.getPredictionAccuracyPercent();\n                            predictionsWithTarget++;\n                        }\n                    }\n                    \n                    double winRate = trades.isEmpty() ? 0 : (double) winners / trades.size() * 100;\n                    double returnPercent = (totalProfit / capital) * 100;\n                    double avgAccuracy = predictionsWithTarget > 0 ? totalAccuracy / predictionsWithTarget : 0.0;\n                    \n                    // Calculate Profit Factor (total wins / total losses)\n                    double profitFactor = (totalLossAmount > 0) ? (totalWinProfit / totalLossAmount) : \n                                         (totalWinProfit > 0 ? 999.0 : 0.0);\n                    \n                    // Calculate Sharpe Ratio (risk-adjusted returns)\n                    double sharpeRatio = 0.0;\n                    if (returns.size() > 1) {\n                        double avgReturn = returns.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);\n                        double variance = returns.stream()\n                            .mapToDouble(r -> Math.pow(r - avgReturn, 2))\n                            .average().orElse(0.0);\n                        double stdDev = Math.sqrt(variance);\n                        sharpeRatio = (stdDev > 0) ? (avgReturn / stdDev) : 0.0;\n                    }\n                    \n                    // Update metric cards\n                    updateMetricCard(totalProfitCard, String.format(\"$%.2f\", totalProfit), totalProfit > 0);\n                    updateMetricCard(totalTradesCard, String.valueOf(trades.size()), true);\n                    updateMetricCard(winRateCard, String.format(\"%.1f%%\", winRate), winRate >= 50);\n                    updateMetricCard(profitFactorCard, String.format(\"%.2f\", profitFactor), profitFactor > 1.0);\n                    updateMetricCard(maxDrawdownCard, String.format(\"%.1f%%\", maxDrawdown), maxDrawdown < 20);\n                    updateMetricCard(sharpeCard, String.format(\"%.2f\", sharpeRatio), sharpeRatio > 1.0);\n                    \n                    // Calculate additional analytics\n                    double avgWin = winners > 0 ? (totalWinProfit / winners) : 0;\n                    double avgLoss = losers > 0 ? (totalLossAmount / losers) : 0;\n                    double riskRewardRatio = avgLoss > 0 ? (avgWin / avgLoss) : 0;\n                    double recoveryFactor = maxDrawdown > 0 ? (totalProfit / (capital * maxDrawdown / 100)) : 0;\n                    \n                    showSuccess(\"Backtest Complete\", \n                               String.format(\"Backtest Results for %s\\n\\n\" +\n                                           \"Period: %s to %s\\n\" +\n                                           \"Data Points: %d candles\\n\" +\n                                           \"Initial Capital: $%.2f\\n\\n\" +\n                                           \" PERFORMANCE METRICS \\n\" +\n                                           \"Total Trades: %d\\n\" +\n                                           \"Winners: %d | Losers: %d\\n\" +\n                                           \"Win Rate: %.1f%%\\n\" +\n                                           \"Profit Factor: %.2f\\n\" +\n                                           \"Sharpe Ratio: %.2f\\n\\n\" +\n                                           \"Total Profit/Loss: $%.2f\\n\" +\n                                           \"Return: %.2f%%\\n\" +\n                                           \"Max Drawdown: %.1f%%\\n\" +\n                                           \"Recovery Factor: %.2f\\n\\n\" +\n                                           \" TRADE ANALYTICS \\n\" +\n                                           \"Average Win: $%.2f\\n\" +\n                                           \"Average Loss: $%.2f\\n\" +\n                                           \"Risk/Reward Ratio: %.2f\\n\" +\n                                           \"Average Buy Signal Probability: %.1f%%\\n\\n\" +\n                                           \" PREDICTION ACCURACY \\n\" +\n                                           \"Predictions with Target Hit: %d\\n\" +\n                                           \"Average Prediction Accuracy: %.1f%%\",\n                                           symbol, startDate, endDate, candles.size(), capital,\n                                           trades.size(), winners, losers, winRate,\n                                           profitFactor, sharpeRatio,\n                                           totalProfit, returnPercent,\n                                           maxDrawdown, recoveryFactor,\n                                           avgWin, avgLoss, riskRewardRatio,\n                                           lastBacktestAvgProbability * 100,\n                                           predictionsWithTarget, avgAccuracy));\n                });\n            }\n            \n            @Override\n            public void onError(String error) {\n                Platform.runLater(() -> {\n                    showError(\"Backtest Failed\", \n                             \"Failed to fetch historical data:\\n\\n\" + error +\n                             \"\\n\\nMake sure the backend is running and connected to Questrade.\");\n                });\n            }\n            });\n        });\n    }\n    \n    /**\n     * Simulate backtest trades using spike detection algorithm with configured parameters\n     * PRIORITY 1: Now uses statistical calibration instead of arbitrary weights\n     * \n     * @param params Immutable snapshot of all configuration values (captured on FX thread)\n     */\n    private List<BacktestTrade> simulateBacktest(String symbol, List<com.spiketrade.proto.MarketDataProto.Candle> candles, \n                                                  double capital, BacktestParameters params) {\n        List<BacktestTrade> trades = new ArrayList<>();\n        List<Double> buyProbabilities = new ArrayList<>();\n        \n        // Track active indicators at entry for calibration\n        java.util.Set<String> entryIndicators = new java.util.HashSet<>();\n        \n        // Use target gain from parameter snapshot (not UI)\n        double targetGainPercent = params.targetGainPct;\n        \n        // Debug: Confirm we're using snapshot parameters, not UI values\n        System.out.println(\" BACKTEST EXECUTING with snapshot: targetGain=\" + targetGainPercent + \"%, equityPerTrade=$\" + params.equityPerTradePct + \", comboThreshold=\" + params.comboThreshold);\n        \n        com.spiketrade.backend.PredictionEngine predictionEngine = new com.spiketrade.backend.PredictionEngine();\n        \n        // Use parameters from the immutable snapshot (captured on FX thread)\n        int rsiPeriod = params.rsiPeriod;\n        int rocPeriod = params.rocPeriod;\n        double comboThreshold = params.comboThreshold;\n        double stopLossPct = params.stopLossPct;\n        double initialProfitFloorPct = params.initialProfitFloorPct;\n        double subsequentProfitFloorPct = params.subsequentProfitFloorPct;\n        int minDataPoints = params.minDataPoints;\n        \n        // ROC periods from parameter snapshot\n        int rsiRocPeriod = params.rsiRocPeriod;\n        int mfiRocPeriod = params.mfiRocPeriod;\n        int obvRocPeriod = params.obvRocPeriod;\n        int vwapRocPeriod = params.vwapRocPeriod;\n        int percentBRocPeriod = params.percentBRocPeriod;\n        \n        // RSI oversold threshold - kept as constant since no dedicated slider exists\n        // TODO: Add dedicated RSI oversold threshold slider (0-100 range) in future\n        final double rsiOversoldThreshold = 40.0;\n        \n        Double entryPrice = null;\n        int entryIndex = -1;\n        int shares = 0;\n        double remainingCash = capital;\n        double currentProfitFloor = 0.0;\n        \n        Double predictedGainTarget = null;\n        Integer predictedTimeToTarget = null;\n        Integer actualTimeToTarget = null;\n        \n        // Track historical indicator values for multi-period ROC calculations\n        java.util.Deque<Double> rsiHistory = new java.util.LinkedList<>();\n        java.util.Deque<Double> mfiHistory = new java.util.LinkedList<>();\n        java.util.Deque<Double> obvHistory = new java.util.LinkedList<>();\n        java.util.Deque<Double> vwapHistory = new java.util.LinkedList<>();\n        java.util.Deque<Double> percentBHistory = new java.util.LinkedList<>();\n        \n        // Need enough data for indicator calculations\n        if (candles.size() < minDataPoints) {\n            System.out.println(\"Backtest: Not enough data points (\" + candles.size() + \" < \" + minDataPoints + \")\");\n            return trades;\n        }\n        \n        for (int i = minDataPoints; i < candles.size(); i++) {\n            double open = candles.get(i).getOpen();\n            double high = candles.get(i).getHigh();\n            double low = candles.get(i).getLow();\n            double close = candles.get(i).getClose();\n            long timestamp = candles.get(i).getTimestampMs();\n            String timeStr = java.time.Instant.ofEpochMilli(timestamp)\n                .atZone(java.time.ZoneId.of(\"America/New_York\"))\n                .format(java.time.format.DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));\n            \n            // Check if we're in a position\n            if (entryPrice != null) {\n                // FIX #1: Check intrabar movement (high/low) for stop-loss and targets\n                // Calculate stop and target levels\n                double stopPrice = entryPrice * (1.0 - stopLossPct);\n                double profitFloorPrice = currentProfitFloor > 0 ? entryPrice * (1.0 + currentProfitFloor) : 0;\n                \n                // Track actual time to target using high price\n                if (predictedGainTarget != null && actualTimeToTarget == -1) {\n                    double targetPrice = entryPrice * (1.0 + predictedGainTarget / 100.0);\n                    if (high >= targetPrice) {\n                        actualTimeToTarget = (i - entryIndex) * 5;\n                    }\n                }\n                \n                // Update profit floor based on high price of candle\n                double highProfitPct = ((high - entryPrice) / entryPrice);\n                if (highProfitPct >= initialProfitFloorPct) {\n                    // Once we hit initial profit floor, lock in break-even (0%)\n                    if (currentProfitFloor == 0.0 && highProfitPct >= initialProfitFloorPct && highProfitPct < (initialProfitFloorPct + subsequentProfitFloorPct)) {\n                        currentProfitFloor = 0.0;\n                    }\n                    // As profit increases, ratchet up the floor\n                    else if (highProfitPct >= (initialProfitFloorPct + subsequentProfitFloorPct)) {\n                        // Calculate how many subsequent floors we've passed\n                        double floorsAboveInitial = Math.floor((highProfitPct - initialProfitFloorPct) / subsequentProfitFloorPct);\n                        // Set floor to previous level (lock in profit at one increment below current)\n                        double newFloor = initialProfitFloorPct + ((floorsAboveInitial - 1) * subsequentProfitFloorPct);\n                        if (newFloor > currentProfitFloor) {\n                            currentProfitFloor = newFloor;\n                        }\n                    }\n                    profitFloorPrice = currentProfitFloor > 0 ? entryPrice * (1.0 + currentProfitFloor) : 0;\n                }\n                \n                // Check if stop OR profit floor was hit during this candle (worst-case: assume stop triggers first)\n                boolean stopLossHit = (close <= stopPrice);\n                boolean profitFloorHit = (profitFloorPrice > 0 && close <= profitFloorPrice);                \n                if (stopLossHit || profitFloorHit) {\n                    // Exit position - determine exit price with worst-case assumption\n                    double exitPrice;\n                    String exitReason;\n                    \n                    if (stopLossHit) {\n                        // Stop loss hit - exit at stop price\n                        exitPrice = stopPrice;\n                        exitReason = \"Stop Loss (\" + String.format(\"%.1f\", stopLossPct*100) + \"%)\";\n                    } else {\n                        // Profit floor hit - exit at profit floor price\n                        exitPrice = profitFloorPrice;\n                        exitReason = \"Profit Floor (\" + String.format(\"%.1f\", currentProfitFloor*100) + \"%)\";\n                    }\n                    \n                    // FIX #2: Apply realistic slippage to exit for small-cap stocks (0.4-0.6% worse execution)\n                    // Small-caps have wide bid-ask spreads and low liquidity causing higher slippage\n                    double exitSlippage = 0.001; // 0.5% slippage on exits (realistic for small-caps)\n                    exitPrice = exitPrice * (1.0 - exitSlippage); // Worse fill for seller\n                    \n                    double profitLoss = (exitPrice - entryPrice) * shares;\n                    double profitLossPercent = ((exitPrice - entryPrice) / entryPrice) * 100;\n                    remainingCash += exitPrice * shares;\n                    String entryTimeStr = java.time.Instant.ofEpochMilli(candles.get(entryIndex).getTimestampMs())\n                        .atZone(java.time.ZoneId.of(\"America/New_York\"))\n                        .format(java.time.format.DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));\n                    \n                    double predictionAccuracy = 0.0;\n                    if (predictedTimeToTarget != null && actualTimeToTarget != null && actualTimeToTarget > 0) {\n                        double error = Math.abs(actualTimeToTarget - predictedTimeToTarget);\n                        predictionAccuracy = Math.max(0, 100.0 - (error / predictedTimeToTarget * 100.0));\n                    }\n                    \n                    List<Double> futurePrices = new ArrayList<>();\n                    for (int futIdx = entryIndex; futIdx < Math.min(candles.size(), entryIndex + 300); futIdx++) {\n                        futurePrices.add(candles.get(futIdx).getClose());\n                    }\n                    \n                    if (predictedGainTarget != null) {\n                        com.spiketrade.backend.BuySignal recordSignal = new com.spiketrade.backend.BuySignal();\n                        recordSignal.symbol = symbol;\n                        recordSignal.price = entryPrice;\n                        recordSignal.indicators = new com.spiketrade.backend.IndicatorsData();\n                        recordSignal.spikes = new ArrayList<>();\n                        // FIX: Pass ROC periods to recordPattern for accurate future predictions\n                        predictionEngine.recordPattern(symbol, recordSignal, entryPrice, futurePrices, 1, \n                                                      rocPeriod, rsiPeriod, rocPeriod);  // priceRocPeriod, rsiRocPeriod, volumeRocPeriod\n                    }\n                    \n                    trades.add(new BacktestTrade(\n                        entryTimeStr,\n                        timeStr,\n                        entryPrice,\n                        exitPrice,\n                        shares,\n                        profitLoss,\n                        profitLossPercent,\n                        exitReason,\n                        predictedGainTarget != null ? predictedGainTarget : 0.0,\n                        predictedTimeToTarget != null ? predictedTimeToTarget : -1,\n                        actualTimeToTarget != null ? actualTimeToTarget : -1,\n                        predictionAccuracy\n                    ));\n                    \n                    // PRIORITY 1: Record trade outcome for calibration\n                    boolean wasWinner = profitLoss > 0;\n                    calibrationService.recordTradeOutcome(entryIndicators, wasWinner);\n                    \n                    entryPrice = null;\n                    shares = 0;\n                    currentProfitFloor = 0.0;\n                    predictedGainTarget = null;\n                    predictedTimeToTarget = null;\n                    actualTimeToTarget = null;\n                    entryIndicators.clear(); // Clear for next trade\n                }\n            } else {\n                // FIX #3: Calculate indicators using PREVIOUS candle data only (no look-ahead bias)\n                // Use data up to i-1, not including current candle i\n                List<Double> closes = new ArrayList<>();\n                List<Double> volumes = new ArrayList<>();\n                List<com.spiketrade.proto.MarketDataProto.Candle> candleWindow = new ArrayList<>();\n                \n                for (int j = Math.max(0, i - 100); j < i; j++) {  //  FIXED\n                    closes.add(candles.get(j).getClose());\n                    volumes.add((double) candles.get(j).getVolume());\n                    candleWindow.add(candles.get(j));\n                }\n                \n                // Calculate RSI using only previous candles\n                double rsi = calculateRSI(closes, rsiPeriod);\n                \n                \n                // Calculate MFI (Money Flow Index) - requires high, low, close, volume\n                int mfiPeriod = params.mfiPeriod;\n                double mfi = calculateMFI(candleWindow, mfiPeriod);\n                \n                // Calculate OBV (On-Balance Volume)\n                double obv = calculateOBV(candleWindow);\n                \n                // Calculate VWAP (Volume Weighted Average Price)\n                double vwap = calculateVWAP(candleWindow);\n                \n                // Calculate Bollinger %B\n                // FIX #6: Use configurable standard deviation multiplier from params instead of hardcoded 2.0\n                int bbLength = params.bbLength;\n                double percentB = calculateBollingerPercentB(closes, bbLength, params.bbStdDevMultiplier);\n                \n                // Calculate Price ROC (normalized to per-minute basis)\n                double priceRoc = 0;\n                if (closes.size() > rocPeriod) {\n                    int idx = closes.size() - 1;\n                    int prevIdx = idx - rocPeriod;\n                    double totalRoc = ((closes.get(idx) - closes.get(prevIdx)) / closes.get(prevIdx)) * 100.0;\n                    int totalMinutes = rocPeriod * CHART_INTERVAL_MINUTES;\n                    priceRoc = (totalMinutes > 0) ? totalRoc / totalMinutes : 0.0;\n                }\n                \n                // Calculate Volume ROC (normalized to per-minute basis)\n                double volumeRoc = 0;\n                if (volumes.size() > rocPeriod) {\n                    int idx = volumes.size() - 1;\n                    int prevIdx = idx - rocPeriod;\n                    if (volumes.get(prevIdx) > 0) {\n                        double totalRoc = ((volumes.get(idx) - volumes.get(prevIdx)) / volumes.get(prevIdx)) * 100.0;\n                        int totalMinutes = rocPeriod * CHART_INTERVAL_MINUTES;\n                        volumeRoc = (totalMinutes > 0) ? totalRoc / totalMinutes : 0.0;\n                    }\n                }\n                \n                // Store current values in history for multi-period ROC calculations\n                rsiHistory.add(rsi);\n                if (rsiHistory.size() > rsiRocPeriod + 1) rsiHistory.removeFirst();\n                \n                mfiHistory.add(mfi);\n                if (mfiHistory.size() > mfiRocPeriod + 1) mfiHistory.removeFirst();\n                \n                obvHistory.add(obv);\n                if (obvHistory.size() > obvRocPeriod + 1) obvHistory.removeFirst();\n                \n                vwapHistory.add(vwap);\n                if (vwapHistory.size() > vwapRocPeriod + 1) vwapHistory.removeFirst();\n                \n                percentBHistory.add(percentB);\n                if (percentBHistory.size() > percentBRocPeriod + 1) percentBHistory.removeFirst();\n                \n                // Calculate ROC for all indicators using configured periods from sliders (normalized to per-minute basis)\n                double rsiRoc = 0.0;\n                if (rsiHistory.size() > rsiRocPeriod) {\n                    double oldRsi = ((java.util.LinkedList<Double>)rsiHistory).get(0);\n                    double totalRoc = (oldRsi != 0) ? ((rsi - oldRsi) / oldRsi) * 100.0 : 0.0;\n                    int totalMinutes = rsiRocPeriod * CHART_INTERVAL_MINUTES;\n                    rsiRoc = (totalMinutes > 0) ? totalRoc / totalMinutes : 0.0;\n                }\n                \n                double mfiRoc = 0.0;\n                if (mfiHistory.size() > mfiRocPeriod) {\n                    double oldMfi = ((java.util.LinkedList<Double>)mfiHistory).get(0);\n                    double totalRoc = (oldMfi != 0) ? ((mfi - oldMfi) / oldMfi) * 100.0 : 0.0;\n                    int totalMinutes = mfiRocPeriod * CHART_INTERVAL_MINUTES;\n                    mfiRoc = (totalMinutes > 0) ? totalRoc / totalMinutes : 0.0;\n                }\n                \n                double obvRoc = 0.0;\n                if (obvHistory.size() > obvRocPeriod) {\n                    double oldObv = ((java.util.LinkedList<Double>)obvHistory).get(0);\n                    double totalRoc = (oldObv != 0) ? ((obv - oldObv) / oldObv) * 100.0 : 0.0;\n                    int totalMinutes = obvRocPeriod * CHART_INTERVAL_MINUTES;\n                    obvRoc = (totalMinutes > 0) ? totalRoc / totalMinutes : 0.0;\n                }\n                \n                double vwapRoc = 0.0;\n                if (vwapHistory.size() > vwapRocPeriod) {\n                    double oldVwap = ((java.util.LinkedList<Double>)vwapHistory).get(0);\n                    double totalRoc = (oldVwap != 0) ? ((vwap - oldVwap) / oldVwap) * 100.0 : 0.0;\n                    int totalMinutes = vwapRocPeriod * CHART_INTERVAL_MINUTES;\n                    vwapRoc = (totalMinutes > 0) ? totalRoc / totalMinutes : 0.0;\n                }\n                \n                double percentBRoc = 0.0;\n                if (percentBHistory.size() > percentBRocPeriod) {\n                    double oldPercentB = ((java.util.LinkedList<Double>)percentBHistory).get(0);\n                    double totalRoc = (oldPercentB != 0) ? ((percentB - oldPercentB) / oldPercentB) * 100.0 : 0.0;\n                    int totalMinutes = percentBRocPeriod * CHART_INTERVAL_MINUTES;\n                    percentBRoc = (totalMinutes > 0) ? totalRoc / totalMinutes : 0.0;\n                }\n                \n                // ===== CALCULATE PENNY STOCK INDICATORS =====\n                // Use penny stock indicator parameters from snapshot\n                int macdFastPeriod = params.macdFastPeriod;\n                int macdSlowPeriod = params.macdSlowPeriod;\n                int macdSignalPeriod = params.macdSignalPeriod;\n                int stochPeriod = params.stochPeriod;\n                int stochKSmooth = params.stochKSmooth;\n                int stochDSmooth = params.stochDSmooth;\n                double stochOversoldThresh = params.stochOversoldThresh;\n                int rvolPeriod = params.rvolPeriod;\n                double rvolThreshold = params.rvolThreshold;\n                int ema9Period = params.ema9Period;\n                int ema20Period = params.ema20Period;\n                int ema50Period = params.ema50Period;\n                double volSpikeThreshold = params.volSpikeThreshold;\n                \n                // Calculate MACD\n                double[] macd = calculateMACD(closes, macdFastPeriod, macdSlowPeriod, macdSignalPeriod);\n                double macdHistogram = macd[2];\n                \n                // Calculate EMAs\n                double ema9 = calculateEMA(closes, ema9Period);\n                double ema20 = calculateEMA(closes, ema20Period);\n                double ema50 = calculateEMA(closes, ema50Period);\n                \n                // Calculate Stochastic\n                double[] stoch = calculateStochastic(candleWindow, stochPeriod, stochKSmooth, stochDSmooth);\n                double stochK = stoch[0];\n                \n                // Calculate RVOL\n                double rvol = calculateRVOL(candleWindow, rvolPeriod);\n                \n                // Current price for EMA checks\n                double currentPrice = closes.get(closes.size() - 1);\n                \n                \n                // Calculate Z-scores for spike detection - ALL indicators (matches live trading)\n                double priceRocZScore = calculateZScore(closes, rocPeriod);\n                double volumeRocZScore = volumes.size() > rocPeriod ? calculateZScore(volumes, rocPeriod) : 0;\n                \n                // Calculate Z-scores for indicator ROCs using their respective histories\n                double rsiRocZScore = 0.0;\n                if (rsiHistory.size() > rsiRocPeriod) {\n                    java.util.List<Double> rsiRocValues = new java.util.ArrayList<>();\n                    for (int j = 0; j < rsiHistory.size() - 1; j++) {\n                        double oldVal = ((java.util.LinkedList<Double>)rsiHistory).get(j);\n                        double newVal = ((java.util.LinkedList<Double>)rsiHistory).get(j + 1);\n                        if (oldVal != 0) rsiRocValues.add(((newVal - oldVal) / oldVal) * 100.0);\n                    }\n                    if (rsiRocValues.size() > 2) {\n                        double mean = rsiRocValues.stream().mapToDouble(Double::doubleValue).average().orElse(0);\n                        double variance = rsiRocValues.stream().mapToDouble(v -> Math.pow(v - mean, 2)).average().orElse(0);\n                        double stdDev = Math.sqrt(variance);\n                        if (stdDev > 0) rsiRocZScore = Math.abs((rsiRoc - mean) / stdDev);\n                    }\n                }\n                \n                double obvRocZScore = 0.0;\n                if (obvHistory.size() > obvRocPeriod) {\n                    java.util.List<Double> obvRocValues = new java.util.ArrayList<>();\n                    for (int j = 0; j < obvHistory.size() - 1; j++) {\n                        double oldVal = ((java.util.LinkedList<Double>)obvHistory).get(j);\n                        double newVal = ((java.util.LinkedList<Double>)obvHistory).get(j + 1);\n                        if (oldVal != 0) obvRocValues.add(((newVal - oldVal) / oldVal) * 100.0);\n                    }\n                    if (obvRocValues.size() > 2) {\n                        double mean = obvRocValues.stream().mapToDouble(Double::doubleValue).average().orElse(0);\n                        double variance = obvRocValues.stream().mapToDouble(v -> Math.pow(v - mean, 2)).average().orElse(0);\n                        double stdDev = Math.sqrt(variance);\n                        if (stdDev > 0) obvRocZScore = Math.abs((obvRoc - mean) / stdDev);\n                    }\n                }\n                \n                double mfiRocZScore = 0.0;\n                if (mfiHistory.size() > mfiRocPeriod) {\n                    java.util.List<Double> mfiRocValues = new java.util.ArrayList<>();\n                    for (int j = 0; j < mfiHistory.size() - 1; j++) {\n                        double oldVal = ((java.util.LinkedList<Double>)mfiHistory).get(j);\n                        double newVal = ((java.util.LinkedList<Double>)mfiHistory).get(j + 1);\n                        if (oldVal != 0) mfiRocValues.add(((newVal - oldVal) / oldVal) * 100.0);\n                    }\n                    if (mfiRocValues.size() > 2) {\n                        double mean = mfiRocValues.stream().mapToDouble(Double::doubleValue).average().orElse(0);\n                        double variance = mfiRocValues.stream().mapToDouble(v -> Math.pow(v - mean, 2)).average().orElse(0);\n                        double stdDev = Math.sqrt(variance);\n                        if (stdDev > 0) mfiRocZScore = Math.abs((mfiRoc - mean) / stdDev);\n                    }\n                }\n                \n                double percentBRocZScore = 0.0;\n                if (percentBHistory.size() > percentBRocPeriod) {\n                    java.util.List<Double> percentBRocValues = new java.util.ArrayList<>();\n                    for (int j = 0; j < percentBHistory.size() - 1; j++) {\n                        double oldVal = ((java.util.LinkedList<Double>)percentBHistory).get(j);\n                        double newVal = ((java.util.LinkedList<Double>)percentBHistory).get(j + 1);\n                        if (oldVal != 0) percentBRocValues.add(((newVal - oldVal) / oldVal) * 100.0);\n                    }\n                    if (percentBRocValues.size() > 2) {\n                        double mean = percentBRocValues.stream().mapToDouble(Double::doubleValue).average().orElse(0);\n                        double variance = percentBRocValues.stream().mapToDouble(v -> Math.pow(v - mean, 2)).average().orElse(0);\n                        double stdDev = Math.sqrt(variance);\n                        if (stdDev > 0) percentBRocZScore = Math.abs((percentBRoc - mean) / stdDev);\n                    }\n                }\n                \n                double vwapRocZScore = 0.0;\n                if (vwapHistory.size() > vwapRocPeriod) {\n                    java.util.List<Double> vwapRocValues = new java.util.ArrayList<>();\n                    for (int j = 0; j < vwapHistory.size() - 1; j++) {\n                        double oldVal = ((java.util.LinkedList<Double>)vwapHistory).get(j);\n                        double newVal = ((java.util.LinkedList<Double>)vwapHistory).get(j + 1);\n                        if (oldVal != 0) vwapRocValues.add(((newVal - oldVal) / oldVal) * 100.0);\n                    }\n                    if (vwapRocValues.size() > 2) {\n                        double mean = vwapRocValues.stream().mapToDouble(Double::doubleValue).average().orElse(0);\n                        double variance = vwapRocValues.stream().mapToDouble(v -> Math.pow(v - mean, 2)).average().orElse(0);\n                        double stdDev = Math.sqrt(variance);\n                        if (stdDev > 0) vwapRocZScore = Math.abs((vwapRoc - mean) / stdDev);\n                    }\n                }\n                \n                // Get spike Z-score thresholds from parameter snapshot\n                double priceSpikeZThreshold = params.priceSpikeZThreshold;\n                double volumeSpikeZThreshold = params.volumeSpikeZThreshold;\n                double rsiSpikeZThreshold = params.rsiSpikeZThreshold;\n                double obvSpikeZThreshold = params.obvSpikeZThreshold;\n                double mfiSpikeZThreshold = params.mfiSpikeZThreshold;\n                double percentBSpikeZThreshold = params.percentBSpikeZThreshold;\n                double vwapSpikeZThreshold = params.vwapSpikeZThreshold;\n                \n                // Spike detection using configured thresholds (matches live trading - symmetric for all indicators)\n                boolean priceSpike = Math.abs(priceRocZScore) > priceSpikeZThreshold;\n                boolean volumeSpike = Math.abs(volumeRocZScore) > volumeSpikeZThreshold;\n                boolean rsiSpike = Math.abs(rsiRocZScore) > rsiSpikeZThreshold;\n                boolean obvSpike = Math.abs(obvRocZScore) > obvSpikeZThreshold;\n                boolean mfiSpike = Math.abs(mfiRocZScore) > mfiSpikeZThreshold;\n                boolean percentBSpike = Math.abs(percentBRocZScore) > percentBSpikeZThreshold;\n                boolean vwapSpike = Math.abs(vwapRocZScore) > vwapSpikeZThreshold;\n                \n                // RSI oversold condition (40 is standard oversold threshold)\n                boolean rsiOversold = rsi < rsiOversoldThreshold;\n                \n                // ========== PRIORITY 1: USE STATISTICAL CALIBRATION INSTEAD OF ARBITRARY WEIGHTS ==========\n                // Build signal probability using actual win rates from calibration data\n                // Each indicator's weight is based on its measured historical performance\n                \n                double signalProbability = 0.0;\n                int enabledConditions = 0;\n                java.util.Set<String> currentIndicators = new java.util.HashSet<>();\n                \n                // 1. Check spike quality if enabled - checks ALL indicator spikes (matches live trading)\n                if (params.requireSpikeQuality) {\n                    enabledConditions++;\n                    // Any spike detected across all indicators qualifies as spike quality\n                    if (priceSpike || volumeSpike || rsiSpike || obvSpike || mfiSpike || percentBSpike || vwapSpike) {\n                        signalProbability += calibrationService.getWeight(\"spike_quality\");\n                        currentIndicators.add(\"spike_quality\");\n                    }\n                }\n                \n                // 2. Check price condition if enabled\n                if (params.requirePriceCondition) {\n                    enabledConditions++;\n                    if (priceRoc > params.priceRocThreshold) {\n                        signalProbability += calibrationService.getWeight(\"price_roc\");\n                        currentIndicators.add(\"price_roc\");\n                    }\n                }\n                \n                // 3. Check RSI condition if enabled\n                if (params.requireRsiCondition) {\n                    enabledConditions++;\n                    if (rsiOversold && rsiRoc < params.rsiRocThreshold) {\n                        signalProbability += calibrationService.getWeight(\"rsi_oversold\");\n                        currentIndicators.add(\"rsi_oversold\");\n                    }\n                }\n                \n                // 4. Check OBV condition if enabled\n                if (params.requireObvCondition) {\n                    enabledConditions++;\n                    if (obvRoc > params.obvRocThreshold) {\n                        signalProbability += calibrationService.getWeight(\"obv_roc\");\n                        currentIndicators.add(\"obv_roc\");\n                    }\n                }\n                \n                // 5. Check MFI (Money Flow Index) condition if enabled\n                if (params.requireMfiCondition) {\n                    enabledConditions++;\n                    if (mfi < 30 && mfiRoc > params.mfiRocThreshold) {\n                        signalProbability += calibrationService.getWeight(\"mfi\");\n                        currentIndicators.add(\"mfi\");\n                    }\n                }\n                \n                // 6. Check Bollinger Band condition if enabled\n                if (params.requireBollingerCondition) {\n                    enabledConditions++;\n                    if (percentB < 0.2 && percentBRoc > params.percentBRocThreshold) {\n                        signalProbability += calibrationService.getWeight(\"bollinger\");\n                        currentIndicators.add(\"bollinger\");\n                    }\n                }\n                \n                // 7. Check VWAP indicator if enabled\n                if (params.enableVwapIndicator) {\n                    enabledConditions++;\n                    // currentPrice already declared at line 4273\n                    if (currentPrice < vwap && vwapRoc > params.vwapRocThreshold) {\n                        signalProbability += calibrationService.getWeight(\"vwap\");\n                        currentIndicators.add(\"vwap\");\n                    }\n                }\n                \n                // 8. Check ADX indicator if enabled (using price_roc as proxy)\n                if (params.enableAdxIndicator) {\n                    enabledConditions++;\n                    if (Math.abs(priceRoc) > 1.0) {\n                        signalProbability += calibrationService.getWeight(\"price_roc\");\n                        currentIndicators.add(\"price_roc\");\n                    }\n                }\n                \n                // 9. Check volume spike if enabled\n                if (params.requireVolumeSpike) {\n                    enabledConditions++;\n                    if (volumeSpike) {\n                        signalProbability += calibrationService.getWeight(\"volume_spike\");\n                        currentIndicators.add(\"volume_spike\");\n                    }\n                }\n                \n                \n                \n                // 10. Check MACD Histogram ROC (predictive convergence) if enabled (penny stock indicator)\n                if (params.enableMacdHistogramRoc) {\n                    enabledConditions++;\n                    // Predictive trigger: histogram <= 0 AND rising at threshold rate\n                    // Calculate histogram ROC: (H_t - H_{t-1}) / P_t\n                    double macdHistogramRoc = 0.0;\n                    if (i > 0 && i < closes.size()) {\n                        List<Double> prevCloses = closes.subList(0, i);\n                        if (prevCloses.size() >= Math.max(macdFastPeriod, macdSlowPeriod)) {\n                            double[] prevMacd = calculateMACD(prevCloses, macdFastPeriod, macdSlowPeriod, macdSignalPeriod);\n                            double deltaH = macdHistogram - prevMacd[2];\n                            macdHistogramRoc = deltaH / currentPrice;\n                        }\n                    }\n                    // Convert threshold from % to decimal (e.g., 0.5 -> 0.005)\n                    double thresholdDecimal = params.macdHistogramRocThreshold / 100.0;\n                    if (macdHistogram <= 0 && macdHistogramRoc >= thresholdDecimal) {\n                        signalProbability += calibrationService.getWeight(\"macd_predictive\");\n                        currentIndicators.add(\"macd_predictive\");\n                    }\n                }\n                \n                // 11. Check Stochastic oversold (penny stock indicator)\n                if (params.enableStochasticIndicator) {\n                    enabledConditions++;\n                    if (stochK < stochOversoldThresh) {\n                        signalProbability += calibrationService.getWeight(\"stoch_oversold\");\n                        currentIndicators.add(\"stoch_oversold\");\n                    }\n                }\n                \n                // 12. Check RVOL above threshold (penny stock indicator)\n                if (params.enableRvolIndicator) {\n                    enabledConditions++;\n                    if (rvol > rvolThreshold) {\n                        signalProbability += calibrationService.getWeight(\"rvol_high\");\n                        currentIndicators.add(\"rvol_high\");\n                    }\n                }\n                \n                // 13. Check EMA trend filter (penny stock indicator)\n                if (params.enableEmaIndicator) {\n                    enabledConditions++;\n                    if (currentPrice < ema9 && currentPrice < ema20 && currentPrice < ema50) {\n                        signalProbability += calibrationService.getWeight(\"ema_downtrend\");\n                        currentIndicators.add(\"ema_downtrend\");\n                    }\n                }\n                \n                \n                // FIX #3: Use logistic function instead of simple averaging\n                // This provides a proper probabilistic model that accounts for diminishing returns\n                // when multiple correlated indicators agree\n                if (enabledConditions > 0) {\n                    // Center the logit score around 0 by subtracting 0.5 * enabledConditions\n                    // This makes signalProbability = 0.5 when all indicators are at 50% win rate\n                    double logitScore = signalProbability - (0.5 * enabledConditions);\n                    \n                    // Apply logistic sigmoid function: P = 1 / (1 + exp(-z))\n                    // This ensures output is always in [0, 1] and accounts for indicator correlations\n                    signalProbability = 1.0 / (1.0 + Math.exp(-logitScore));\n                } else {\n                    // FIX: No conditions enabled = zero signal probability (not neutral 0.5)\n                    // This ensures backtest produces ZERO signals when all checkboxes are unchecked\n                    signalProbability = 0.0;\n                }\n                \n                // Generate buy signal if probability exceeds configured threshold\n                boolean buySignal = signalProbability >= comboThreshold;\n                \n                \n                // FIX #3: Execute entry at NEXT candle's open, not current candle's close\n                // Signal generated at end of candle i-1, execute at open of candle i\n                if (buySignal) {\n                    double entrySlippage = 0.001; \n                    double currentOpen = candles.get(i).getOpen();  \n                    double executionPrice = currentOpen * (1.0 + entrySlippage);                    // FIX #2: Apply realistic entry slippage for small-cap stocks (0.3-0.5% worse execution)\n                    // Small-caps have wide bid-ask spreads and low liquidity causing higher slippage\n\n                    \n                    if (remainingCash > executionPrice) {\n                        // Track buy signal probability\n                        buyProbabilities.add(signalProbability);\n                        \n                        // Enter position - use equity per trade from parameter snapshot (not UI)\n                        double equityPerTrade = params.equityPerTradePct;\n                        shares = (int) Math.min(equityPerTrade / executionPrice, (remainingCash * 0.9) / executionPrice);\n                        \n                        if (shares > 0) {\n                            entryPrice = executionPrice;\n                            entryIndex = i; // Entry happens at next candle\n                            remainingCash -= entryPrice * shares;\n                            \n                            // PRIORITY 1: Store active indicators for calibration at exit\n                            entryIndicators.clear();\n                            entryIndicators.addAll(currentIndicators);\n                        \n                            com.spiketrade.backend.BuySignal mockSignal = new com.spiketrade.backend.BuySignal();\n                            mockSignal.symbol = symbol;\n                            mockSignal.price = executionPrice; // Use actual execution price, not close\n                            mockSignal.signalProbability = signalProbability;\n                            mockSignal.indicators = new com.spiketrade.backend.IndicatorsData();\n                            mockSignal.indicators.priceRoc = priceRoc;\n                            mockSignal.indicators.volumeRoc = volumeRoc;\n                            mockSignal.indicators.rsiRoc = rsiRoc;\n                            mockSignal.indicators.obvRoc = obvRoc;\n                            mockSignal.indicators.mfiRoc = mfiRoc;\n                            mockSignal.indicators.percentBRoc = percentBRoc;\n                            mockSignal.indicators.vwapRoc = vwapRoc;\n                            mockSignal.spikes = new ArrayList<>();\n                            \n                            com.spiketrade.backend.SpikeRecord priceRocSpike = new com.spiketrade.backend.SpikeRecord();\n                            priceRocSpike.spikeType = \"price_roc\";\n                            priceRocSpike.statisticalZScore = priceRocZScore;\n                            mockSignal.spikes.add(priceRocSpike);\n                            \n                            com.spiketrade.backend.SpikeRecord volumeRocSpike = new com.spiketrade.backend.SpikeRecord();\n                            volumeRocSpike.spikeType = \"volume_roc\";\n                            volumeRocSpike.statisticalZScore = volumeRocZScore;\n                            mockSignal.spikes.add(volumeRocSpike);\n                            \n                            // FIX: Pass ROC periods to prediction engine for accurate timeframe calculations\n                            com.spiketrade.backend.PredictionEngine.PredictionResult prediction = \n                                predictionEngine.predictTimeToTarget(symbol, mockSignal, targetGainPercent,\n                                                                    rocPeriod, rsiPeriod, rocPeriod);\n                            \n                            if (prediction != null) {\n                                predictedGainTarget = prediction.targetGainPercent;\n                                predictedTimeToTarget = prediction.predictedMinutes;\n                                actualTimeToTarget = -1;\n                                \n                                System.out.println(String.format(\"Backtest BUY: %s @ $%.2f | Prob: %.2f | Predicted: %.1f%% in %s\",\n                                    timeStr, entryPrice, signalProbability, \n                                    predictedGainTarget, prediction.getFormattedTimeframe()));\n                            } else {\n                                predictedGainTarget = null;\n                                predictedTimeToTarget = null;\n                                actualTimeToTarget = null;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Close any remaining position at the end\n        if (entryPrice != null && shares > 0) {\n            double exitPrice = candles.get(candles.size() - 1).getClose();\n            \n            // FIX #2: Apply realistic exit slippage for small-cap stocks to end-of-period close\n            double exitSlippage = 0.001; // 0.5% slippage on exits (realistic for small-caps)\n            exitPrice = exitPrice * (1.0 - exitSlippage);\n            \n            double profitLoss = (exitPrice - entryPrice) * shares;\n            double profitLossPercent = ((exitPrice - entryPrice) / entryPrice) * 100;\n            \n            String entryTimeStr = java.time.Instant.ofEpochMilli(candles.get(entryIndex).getTimestampMs())\n                .atZone(java.time.ZoneId.of(\"America/New_York\"))\n                .format(java.time.format.DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));\n            String exitTimeStr = java.time.Instant.ofEpochMilli(candles.get(candles.size() - 1).getTimestampMs())\n                .atZone(java.time.ZoneId.of(\"America/New_York\"))\n                .format(java.time.format.DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));\n            \n            double predictionAccuracy = 0.0;\n            if (predictedTimeToTarget != null && actualTimeToTarget != null && actualTimeToTarget > 0) {\n                double error = Math.abs(actualTimeToTarget - predictedTimeToTarget);\n                predictionAccuracy = Math.max(0, 100.0 - (error / predictedTimeToTarget * 100.0));\n            }\n            \n            trades.add(new BacktestTrade(\n                entryTimeStr,\n                exitTimeStr,\n                entryPrice,\n                exitPrice,\n                shares,\n                profitLoss,\n                profitLossPercent,\n                \"End of Period\",\n                predictedGainTarget != null ? predictedGainTarget : 0.0,\n                predictedTimeToTarget != null ? predictedTimeToTarget : -1,\n                actualTimeToTarget != null ? actualTimeToTarget : -1,\n                predictionAccuracy\n            ));\n        }\n        \n        // Calculate and store average probability\n        if (!buyProbabilities.isEmpty()) {\n            double sum = 0.0;\n            for (double prob : buyProbabilities) {\n                sum += prob;\n            }\n            lastBacktestAvgProbability = sum / buyProbabilities.size();\n        } else {\n            lastBacktestAvgProbability = 0.0;\n        }\n        \n        return trades;\n    }\n    \n    \n    /**\n     * Stop optimization early and show current best results\n     */\n    private void stopOptimization() {\n        if (!optimizationRunning) {\n            return;\n        }\n        \n        stopOptimizationRequested = true;\n        \n        Platform.runLater(() -> {\n            optimizeProgressLabel.setText(\" Stopping optimization... presenting current best results\");\n            stopOptimizationButton.setDisable(true);\n        });\n    }\n    \n    /**\n     * Run comprehensive settings optimization to find best profit and win rate configurations\n     */\n    private void runOptimization() {\n        if (optimizationRunning) {\n            showWarning(\"Optimization Running\", \"Optimization is already in progress. Please wait.\");\n            return;\n        }\n        \n        String symbol = backtestSymbolEntry.getText().trim().toUpperCase();\n        String startDate = backtestStartDate.getText().trim();\n        String endDate = backtestEndDate.getText().trim();\n        \n        if (symbol.isEmpty()) {\n            showWarning(\"Invalid Symbol\", \"Please enter a valid ticker symbol.\");\n            return;\n        }\n        \n        optimizationRunning = true;\n        stopOptimizationRequested = false;\n        optimizeButton.setDisable(true);\n        runBacktestButton.setDisable(true);\n        optimizeProgressLabel.setText(\" Starting optimization...\");\n        \n        // Show stop button\n        stopOptimizationButton.setVisible(true);\n        stopOptimizationButton.setManaged(true);\n        stopOptimizationButton.setDisable(false);\n        \n        // Capture base parameters from UI BEFORE starting background thread (must be on FX thread)\n        final BacktestParameters baseParams = buildBacktestParametersFromUI();\n        \n        // Run optimization in background thread\n        new Thread(() -> {\n            try {\n                // Fetch historical data first\n                final List<com.spiketrade.proto.MarketDataProto.Candle>[] candlesArray = new List[1];\n                final boolean[] fetchComplete = {false};\n                final String[] errorMessage = {null};\n                \n                Platform.runLater(() -> optimizeProgressLabel.setText(\" Fetching historical data for \" + symbol + \"...\"));\n                \n                grpcClient.getHistoricalData(symbol, CHART_INTERVAL_MINUTES, NUM_HISTORICAL_BARS, new TradingServiceClient.HistoricalDataCallback() {\n                    @Override\n                    public void onData(List<com.spiketrade.proto.MarketDataProto.Candle> candles) {\n                        candlesArray[0] = candles;\n                        fetchComplete[0] = true;\n                    }\n                    \n                    @Override\n                    public void onError(String error) {\n                        errorMessage[0] = error;\n                        fetchComplete[0] = true;\n                    }\n                });\n                \n                // Wait for data fetch\n                while (!fetchComplete[0]) {\n                    Thread.sleep(100);\n                }\n                \n                if (errorMessage[0] != null || candlesArray[0] == null) {\n                    Platform.runLater(() -> {\n                        showError(\"Data Fetch Failed\", \"Failed to fetch historical data:\\n\\n\" + errorMessage[0]);\n                        optimizeButton.setDisable(false);\n                        runBacktestButton.setDisable(false);\n                        optimizeProgressLabel.setText(\"\");\n                        optimizationRunning = false;\n                    });\n                    return;\n                }\n                \n                List<com.spiketrade.proto.MarketDataProto.Candle> candles = candlesArray[0];\n                \n                // Run optimization with base parameters snapshot\n                // Capital comes from configuration tab via baseParams\n                OptimizationResult[] results = optimizeSettings(symbol, candles, baseParams.totalCapital, baseParams);\n                bestProfitResult = results[0];\n                bestWinRateResult = results[1];\n                \n                // Show results\n                Platform.runLater(() -> {\n                    optimizeButton.setDisable(false);\n                    runBacktestButton.setDisable(false);\n                    stopOptimizationButton.setVisible(false);\n                    stopOptimizationButton.setManaged(false);\n                    \n                    if (stopOptimizationRequested) {\n                        optimizeProgressLabel.setText(\" Optimization stopped early - showing best results found\");\n                    } else {\n                        optimizeProgressLabel.setText(\" Optimization complete!\");\n                    }\n                    \n                    showOptimizationResults(bestProfitResult, bestWinRateResult);\n                    optimizationRunning = false;\n                    stopOptimizationRequested = false;\n                });\n                \n            } catch (Exception e) {\n                e.printStackTrace();\n                Platform.runLater(() -> {\n                    showError(\"Optimization Failed\", \"Error during optimization:\\n\\n\" + e.getMessage());\n                    optimizeButton.setDisable(false);\n                    runBacktestButton.setDisable(false);\n                    stopOptimizationButton.setVisible(false);\n                    stopOptimizationButton.setManaged(false);\n                    optimizeProgressLabel.setText(\"\");\n                    optimizationRunning = false;\n                });\n            }\n        }).start();\n    }\n    \n    /**\n     * Optimize settings by testing chunked parameter ranges (Configuration tab only)\n     * Signal Rules tab is assumed to have all checkboxes enabled - user configures after optimization\n     * Returns [bestProfitResult, bestWinRateResult]\n     * \n     * FIX #3: Implements train/test split to prevent overfitting\n     * - Optimizes on first 2/3 of data (training set)\n     * - Validates on last 1/3 of data (test set)\n     * - Reports both in-sample and out-of-sample performance\n     * \n     * @param baseParams Base parameter snapshot captured on FX thread (for non-optimized parameters)\n     */\n    private OptimizationResult[] optimizeSettings(String symbol, List<com.spiketrade.proto.MarketDataProto.Candle> candles, \n                                                   double capital, BacktestParameters baseParams) throws InterruptedException {\n        // FIX #3: Split data into train (first 2/3) and test (last 1/3) sets\n        // This prevents overfitting by ensuring parameters are validated on unseen data\n        int trainSize = (candles.size() * 2) / 3;\n        List<com.spiketrade.proto.MarketDataProto.Candle> trainData = candles.subList(0, trainSize);\n        List<com.spiketrade.proto.MarketDataProto.Candle> testData = candles.subList(trainSize, candles.size());\n        \n        System.out.println(String.format(\"\\n FIX #3: Train/Test Split Enabled\"));\n        System.out.println(String.format(\"   Total data: %d candles\", candles.size()));\n        System.out.println(String.format(\"   Training set: %d candles (%.0f%%)\", trainData.size(), (double)trainData.size()/candles.size()*100));\n        System.out.println(String.format(\"   Test set: %d candles (%.0f%%)\\n\", testData.size(), (double)testData.size()/candles.size()*100));\n        \n        OptimizationResult bestProfit = null;\n        OptimizationResult bestWinRate = null;\n        \n        // Save original signal rules state\n        final boolean[] savedSignalRules = saveSignalRulesState();\n        \n        // ========== 14-PARAMETER OPTIMIZATION (+ 23 available for manual tuning) ==========\n        // 12 Configuration Sliders (4-5 values each)\n        // 9 Signal Rules (on/off combinations)\n        \n        // Core Trading Parameters (5 sliders - 4 values each)\n        double[] comboThresholds = {0.3, 0.6, 0.9, 1.2};  // 4 values\n        int[] rsiPeriods = {7, 14, 28, 42};  // 4 values\n        int[] buyPeriods = {10, 20, 35, 50};  // 4 values\n        double[] stopLossValues = {1.0, 2.5, 4.0, 6.0};  // 4 values\n        double[] profitFloorValues = {2.0, 4.5, 7.0, 10.0};  // 4 values\n        \n        // Spike Thresholds (3 sliders - 4 values each)\n        double[] priceSpikeThresholds = {0.5, 1.2, 2.0, 3.0};  // 4 values\n        double[] volumeSpikeThresholds = {0.3, 0.8, 1.3, 2.0};  // 4 values\n        double[] rsiSpikeThresholds = {0.2, 0.5, 0.9, 1.3};  // 4 values\n        \n        // Regular ROC Thresholds (2 sliders - 4 values each)\n        double[] priceRocThresholds = {1.0, 2.5, 4.5, 7.0};  // 4 values\n        double[] volumeRocThresholds = {10.0, 25.0, 45.0, 70.0};  // 4 values\n        \n        // Indicator Windows (2 sliders - 5 values each)\n        int[] bbLengths = {15, 20, 30, 40, 50};  // 5 values\n        int[] mfiPeriods = {7, 10, 14, 20, 28};  // 5 values\n        \n        \n        // ===== PENNY STOCK PARAMETERS (14 new parameters) =====\n        // MACD Parameters\n        int[] macdFastPeriods = {5, 8, 12, 15};  // 4 values (default 8)\n        int[] macdSlowPeriods = {13, 17, 21, 26};  // 4 values (default 17)\n        int[] macdSignalPeriods = {5, 7, 9, 12};  // 4 values (default 9)\n        \n        // Stochastic Parameters\n        int[] stochasticPeriods = {10, 14, 18, 21};  // 4 values (default 14)\n        int[] stochasticKSmooths = {1, 3, 5};  // 3 values (default 3)\n        int[] stochasticDSmooths = {1, 3, 5};  // 3 values (default 3)\n        double[] stochasticOversoldThresholds = {15.0, 20.0, 25.0, 30.0};  // 4 values (default 20)\n        \n        // RVOL Parameters\n        int[] rvolPeriods = {15, 20, 25, 30};  // 4 values (default 20)\n        double[] rvolThresholds = {1.5, 2.0, 2.5, 3.0};  // 4 values (default 2.0)\n        \n        // EMA Parameters\n        int[] ema9Periods = {7, 9, 11, 13};  // 4 values (default 9)\n        int[] ema20Periods = {15, 20, 25, 30};  // 4 values (default 20)\n        int[] ema50Periods = {40, 50, 60, 70};  // 4 values (default 50)\n        \n        // Volume Spike Threshold\n        double[] volSpikeThresholds = {1.5, 2.0, 2.5, 3.0};  // 4 values (default 2.0)\n        \n        // ===== MISSING ROC THRESHOLDS (5 new parameters) =====\n        double[] rsiRocThresholds = {-7.0, -5.0, -3.0, -1.0};  // 4 values (negative for oversold)\n        double[] obvRocThresholds = {5.0, 10.0, 15.0, 20.0};  // 4 values\n        double[] mfiRocThresholds = {5.0, 10.0, 15.0, 20.0};  // 4 values\n        double[] percentBRocThresholds = {5.0, 10.0, 15.0, 20.0};  // 4 values\n        double[] vwapRocThresholds = {0.5, 1.0, 1.5, 2.0};  // 4 values\n        \n        // ===== MISSING SPIKE Z-THRESHOLDS (4 new parameters) =====\n        double[] spikeObvZThresholds = {0.5, 1.0, 1.5, 2.0};  // 4 values\n        double[] spikeMfiZThresholds = {0.5, 1.0, 1.5, 2.0};  // 4 values\n        double[] spikePercentBZThresholds = {0.5, 1.0, 1.5, 2.0};  // 4 values\n        double[] spikeVwapZThresholds = {0.5, 1.0, 1.5, 2.0};  // 4 values\n        \n        // Signal Rules: Test strategic combinations instead of all 512\n        // We'll test: All On, All Off, and key strategic combinations\n        boolean[][] signalCombinations = {\n            // All enabled (baseline)\n            {true, true, true, true, true, true, true, true, true},\n            // All disabled (control)\n            {false, false, false, false, false, false, false, false, false},\n            // Core signals only\n            {true, true, false, false, false, false, false, false, false},\n            // Volume-focused\n            {false, false, false, true, false, false, false, false, true},\n            // Technical indicators\n            {false, false, true, false, true, true, false, false, false},\n            // Momentum + Volume\n            {false, true, true, true, false, false, false, false, true},\n            // Full technical\n            {false, false, true, true, true, true, true, true, false},\n            // Price + Volume quality\n            {true, false, false, true, false, false, false, false, true},\n            // Advanced indicators\n            {false, false, false, false, false, true, true, true, false},\n            // Best of each category\n            {true, false, true, true, false, true, false, true, true},\n            // Spike quality focus\n            {true, true, false, false, false, false, false, false, false},\n            // Conservative (fewer signals)\n            {true, true, true, true, true, false, false, false, false},\n            // Aggressive (all momentum)\n            {false, true, true, false, true, false, true, false, false},\n            // Volume intelligence\n            {false, false, false, true, false, false, true, false, true},\n            // Price action\n            {true, true, false, false, false, true, false, false, false}\n        };\n        \n        // Signal rule names for reference\n        // 0: requireSpikeQuality, 1: requirePriceCondition, 2: requireRsiCondition\n        // 3: requireObvCondition, 4: requireMfiCondition, 5: requireBollingerCondition\n        // 6: enableVwapIndicator, 7: enableAdxIndicator, 8: requireVolumeSpike\n        \n        int sliderCombinations = comboThresholds.length * rsiPeriods.length * buyPeriods.length *\n                                 stopLossValues.length * profitFloorValues.length *\n                                 priceSpikeThresholds.length * volumeSpikeThresholds.length *\n                                 rsiSpikeThresholds.length * priceRocThresholds.length *\n                                 volumeRocThresholds.length * bbLengths.length * mfiPeriods.length *\n                                 stochasticOversoldThresholds.length * rvolThresholds.length;\n        int totalCombinations = sliderCombinations * signalCombinations.length;\n        \n        int testedCombinations = 0;\n        int maxTests = 100000;  // Increased limit for comprehensive search\n        int skipFactor = Math.max(1, totalCombinations / maxTests);\n        \n        Platform.runLater(() -> {\n            optimizeProgressLabel.setText(String.format(\" ULTIMATE optimization - 14 parameters, ~%d tests...\",\n                                                       Math.min(totalCombinations, maxTests)));\n        });\n        \n        int combinationIndex = 0;\n        \n        // FIX #8: Optimization performance - Keep Platform.runLater to avoid FX thread violations\n        // But remove Thread.sleep to dramatically improve speed (saves 300+ seconds)\n        // Outer loop: Signal rule combinations\n        for (boolean[] signalCombo : signalCombinations) {\n            \n            // FIX #7: Check stop flag at the beginning of outer loop to exit promptly\n            if (stopOptimizationRequested) {\n                break;\n            }\n            \n            final boolean spike = signalCombo[0];\n            final boolean price = signalCombo[1];\n            final boolean rsi = signalCombo[2];\n            final boolean obv = signalCombo[3];\n            final boolean mfi = signalCombo[4];\n            final boolean bb = signalCombo[5];\n            final boolean vwap = signalCombo[6];\n            final boolean adx = signalCombo[7];\n            final boolean volSpike = signalCombo[8];\n            \n            // FIX #8: Queue UI updates but don't block with Thread.sleep - much faster!\n            Platform.runLater(() -> {\n                requireSpikeQuality.setSelected(spike);\n                requirePriceCondition.setSelected(price);\n                requireRsiCondition.setSelected(rsi);\n                requireObvCondition.setSelected(obv);\n                requireMfiCondition.setSelected(mfi);\n                requireBollingerCondition.setSelected(bb);\n                enableVwapIndicator.setSelected(vwap);\n                enableAdxIndicator.setSelected(adx);\n                requireVolumeSpike.setSelected(volSpike);\n            });\n            // FIX #8: Removed Thread.sleep(20) here - saves 300ms total for 15 signal combos\n            \n            // Inner loops: Configuration sliders\n            for (double comboThreshold : comboThresholds) {\n                for (int rsiPeriod : rsiPeriods) {\n                    for (int buyPeriod : buyPeriods) {\n                        for (double stopLoss : stopLossValues) {\n                            for (double profitFloor : profitFloorValues) {\n                                for (double priceSpikeThreshold : priceSpikeThresholds) {\n                                    for (double volumeSpikeThreshold : volumeSpikeThresholds) {\n                                        for (double rsiSpikeThreshold : rsiSpikeThresholds) {\n                                            for (double priceRocThreshold : priceRocThresholds) {\n                                                for (double volumeRocThreshold : volumeRocThresholds) {\n                                                    for (int bbLength : bbLengths) {\n                                                        for (double stochOversold : stochasticOversoldThresholds) {\n                                                            for (double rvolThresh : rvolThresholds) {\n                                                                for (int mfiPeriod : mfiPeriods) {\n                                                            \n                                                            // Check if stop requested\n                                                            if (stopOptimizationRequested) {\n                                                                break;\n                                                            }\n                                                            \n                                                            // Smart sampling\n                                                            if (combinationIndex % skipFactor != 0) {\n                                                                combinationIndex++;\n                                                                continue;\n                                                            }\n                                                            combinationIndex++;\n                                                            \n                                                            // FIX #8: Queue slider updates on FX thread but DON'T block with Thread.sleep\n                                                            // Removed Thread.sleep(3) saves 300+ seconds total (100,000 iterations  3ms)\n                                                            final double fComboThreshold = comboThreshold;\n                                                            final int fRsiPeriod = rsiPeriod;\n                                                            final int fBuyPeriod = buyPeriod;\n                                                            final double fStopLoss = stopLoss;\n                                                            final double fProfitFloor = profitFloor;\n                                                            final double fPriceSpikeThreshold = priceSpikeThreshold;\n                                                            final double fVolumeSpikeThreshold = volumeSpikeThreshold;\n                                                            final double fRsiSpikeThreshold = rsiSpikeThreshold;\n                                                            final double fPriceRocThreshold = priceRocThreshold;\n                                                            final double fVolumeRocThreshold = volumeRocThreshold;\n                                                            final int fBbLength = bbLength;\n                                                            final int fMfiPeriod = mfiPeriod;\n                                                                            final double fStochOversold = stochOversold;\n                                                                            final double fRvolThresh = rvolThresh;\n                                                            \n                                                            Platform.runLater(() -> {\n                                                                comboSignalThresholdSlider.setValue(fComboThreshold);\n                                                                regularRsiRocPeriodSlider.setValue(fRsiPeriod);\n                                                                periodSlider.setValue(fBuyPeriod);\n                                                                stopLossPctSlider.setValue(fStopLoss);\n                                                                initialProfitFloorPctSlider.setValue(fProfitFloor);\n                                                                spikePriceRocZThresholdSlider.setValue(fPriceSpikeThreshold);\n                                                                spikeVolumeRocZThresholdSlider.setValue(fVolumeSpikeThreshold);\n                                                                spikeRsiRocZThresholdSlider.setValue(fRsiSpikeThreshold);\n                                                                regularPriceRocThresholdSlider.setValue(fPriceRocThreshold);\n                                                                regularVolumeRocThresholdSlider.setValue(fVolumeRocThreshold);\n                                                                bbLengthMinutesSlider.setValue(fBbLength);\n                                                                mfiPeriodMinutesSlider.setValue(fMfiPeriod);\n                                                                stochasticOversoldThresholdSlider.setValue(fStochOversold);\n                                                                rvolThresholdSlider.setValue(fRvolThresh);\n                                                            });\n                                                            // FIX #8: Removed Thread.sleep(3) here - massive speedup!\n                                                            \n                                                            // Build BacktestParameters from loop variables + base snapshot\n                                                            BacktestParameters params = new BacktestParameters(\n                                                                rsiPeriod, buyPeriod, comboThreshold, stopLoss / 100.0,\n                                                                profitFloor / 100.0, baseParams.subsequentProfitFloorPct, baseParams.minDataPoints,\n                                                                rsiPeriod, baseParams.mfiRocPeriod, baseParams.obvRocPeriod, baseParams.vwapRocPeriod,\n                                                                baseParams.percentBRocPeriod, buyPeriod, buyPeriod,\n                                                                mfiPeriod, bbLength,\n                                                                baseParams.bbStdDevMultiplier,\n                                                                baseParams.macdFastPeriod, baseParams.macdSlowPeriod, baseParams.macdSignalPeriod, baseParams.macdHistogramRocThreshold,\n                                                                baseParams.stochPeriod, baseParams.stochKSmooth, baseParams.stochDSmooth, stochOversold,\n                                                                baseParams.rvolPeriod, rvolThresh,\n                                                                baseParams.ema9Period, baseParams.ema20Period, baseParams.ema50Period, baseParams.volSpikeThreshold,\n                                                                priceSpikeThreshold, volumeSpikeThreshold, rsiSpikeThreshold,\n                                                                baseParams.obvSpikeZThreshold, baseParams.mfiSpikeZThreshold, baseParams.percentBSpikeZThreshold, baseParams.vwapSpikeZThreshold,\n                                                                priceRocThreshold, baseParams.rsiRocThreshold, baseParams.obvRocThreshold,\n                                                                baseParams.mfiRocThreshold, baseParams.percentBRocThreshold, baseParams.vwapRocThreshold,\n                                                                volumeRocThreshold,\n                                                                spike, price, rsi, obv, mfi, bb, vwap, adx, volSpike,\n                                                                baseParams.enableMacdHistogramRoc, baseParams.enableStochasticIndicator, baseParams.enableRvolIndicator,\n                                                                baseParams.enableEmaIndicator,\n                                                                baseParams.targetGainPct,\n                                                                baseParams.equityPerTradePct,\n                                                                baseParams.totalCapital\n                                                            );\n                                                            \n                                                            // FIX #3: Run backtest on TRAINING data only (not full dataset)\n                                                            List<BacktestTrade> trades = simulateBacktest(symbol, trainData, capital, params);\n                                                            \n                                                            double totalProfit = 0;\n                                                            int winners = 0;\n                                                            for (BacktestTrade trade : trades) {\n                                                                totalProfit += trade.getProfitLoss();\n                                                                if (trade.getProfitLoss() > 0) winners++;\n                                                            }\n                                                            \n                                                            double winRate = trades.isEmpty() ? 0 : (double) winners / trades.size() * 100;\n                                                            \n                                                            // Store all 21 parameters\n                                                            Map<String, Object> settings = new HashMap<>();\n                                                            settings.put(\"comboThreshold\", comboThreshold);\n                                                            settings.put(\"rsiPeriod\", rsiPeriod);\n                                                            settings.put(\"buyPeriod\", buyPeriod);\n                                                            settings.put(\"stopLoss\", stopLoss);\n                                                            settings.put(\"profitFloor\", profitFloor);\n                                                            settings.put(\"priceSpikeThreshold\", priceSpikeThreshold);\n                                                            settings.put(\"volumeSpikeThreshold\", volumeSpikeThreshold);\n                                                            settings.put(\"rsiSpikeThreshold\", rsiSpikeThreshold);\n                                                            settings.put(\"priceRocThreshold\", priceRocThreshold);\n                                                            settings.put(\"volumeRocThreshold\", volumeRocThreshold);\n                                                            settings.put(\"bbLength\", bbLength);\n                                                            settings.put(\"mfiPeriod\", mfiPeriod);\n                                                            settings.put(\"stochOversoldThreshold\", stochOversold);\n                                                            settings.put(\"rvolThreshold\", rvolThresh);\n                                                            settings.put(\"spikeQuality\", spike);\n                                                            settings.put(\"priceCondition\", price);\n                                                            settings.put(\"rsiCondition\", rsi);\n                                                            settings.put(\"obvCondition\", obv);\n                                                            settings.put(\"mfiCondition\", mfi);\n                                                            settings.put(\"bollingerCondition\", bb);\n                                                            settings.put(\"vwapIndicator\", vwap);\n                                                            settings.put(\"adxIndicator\", adx);\n                                                            settings.put(\"volumeSpike\", volSpike);\n                                                            \n                                                            // Build signal rules description\n                                                            StringBuilder signalDesc = new StringBuilder();\n                                                            if (spike) signalDesc.append(\"SpikeQ \");\n                                                            if (price) signalDesc.append(\"Price \");\n                                                            if (rsi) signalDesc.append(\"RSI \");\n                                                            if (obv) signalDesc.append(\"OBV \");\n                                                            if (mfi) signalDesc.append(\"MFI \");\n                                                            if (bb) signalDesc.append(\"BB \");\n                                                            if (vwap) signalDesc.append(\"VWAP \");\n                                                            if (adx) signalDesc.append(\"ADX \");\n                                                            if (volSpike) signalDesc.append(\"VolSpike\");\n                                                            String signalRulesDesc = signalDesc.length() > 0 ? signalDesc.toString().trim() : \"No Signals\";\n                                                            \n                                                            OptimizationResult result = new OptimizationResult(totalProfit, winRate, trades.size(), settings, signalRulesDesc);\n                                                            \n                                                            if (bestProfit == null || totalProfit > bestProfit.getTotalProfit()) {\n                                                                bestProfit = result;\n                                                            }\n                                                            \n                                                            if (bestWinRate == null || (trades.size() >= 5 && winRate > bestWinRate.getWinRate())) {\n                                                                bestWinRate = result;\n                                                            }\n                                                            \n                                                            testedCombinations++;\n                                                            final int currentCombinations = testedCombinations;\n                                                            final int estimatedTotal = Math.min(totalCombinations, maxTests);\n                                                            final int progress = (int) ((double) currentCombinations / estimatedTotal * 100);\n                                                            \n                                                            if (currentCombinations % 50 == 0) {\n                                                                final OptimizationResult currentBestProfit = bestProfit;\n                                                                final OptimizationResult currentBestWinRate = bestWinRate;\n                                                                Platform.runLater(() -> {\n                                                                    optimizeProgressLabel.setText(String.format(\n                                                                        \" %d%% (%d/%d) | Best: $%.2f @ %.1f%% | Signals: %s\",\n                                                                        progress, currentCombinations, estimatedTotal,\n                                                                        currentBestProfit != null ? currentBestProfit.getTotalProfit() : 0,\n                                                                        currentBestWinRate != null ? currentBestWinRate.getWinRate() : 0,\n                                                                        signalRulesDesc\n                                                                    ));\n                                                                });\n                                                            }\n                                                        }\n                                                            }\n                                                            if (stopOptimizationRequested) break;\n                                                        }\n                                                        if (stopOptimizationRequested) break;\n                                                        if (stopOptimizationRequested) break;\n                                                    }\n                                                    if (stopOptimizationRequested) break;\n                                                }\n                                                if (stopOptimizationRequested) break;\n                                            }\n                                            if (stopOptimizationRequested) break;\n                                        }\n                                        if (stopOptimizationRequested) break;\n                                    }\n                                    if (stopOptimizationRequested) break;\n                                }\n                                if (stopOptimizationRequested) break;\n                            }\n                            if (stopOptimizationRequested) break;\n                        }\n                        if (stopOptimizationRequested) break;\n                    }\n                    if (stopOptimizationRequested) break;\n                }\n                if (stopOptimizationRequested) break;\n            }\n            if (stopOptimizationRequested) break;\n        }\n        \n        // FIX #3: Validate best parameters on TEST data (out-of-sample validation)\n        if (bestProfit != null) {\n            System.out.println(\"\\n FIX #3: Validating Best Profit Parameters on Test Set...\");\n            BacktestParameters bestProfitParams = createParamsFromSettings(bestProfit.getSettings(), baseParams);\n            List<BacktestTrade> testTrades = simulateBacktest(symbol, testData, capital, bestProfitParams);\n            \n            double testProfit = 0;\n            int testWinners = 0;\n            for (BacktestTrade trade : testTrades) {\n                testProfit += trade.getProfitLoss();\n                if (trade.getProfitLoss() > 0) testWinners++;\n            }\n            double testWinRate = testTrades.isEmpty() ? 0 : (double) testWinners / testTrades.size() * 100;\n            \n            System.out.println(String.format(\"   In-Sample (Train):  $%.2f profit, %.1f%% win rate, %d trades\",\n                bestProfit.getTotalProfit(), bestProfit.getWinRate(), bestProfit.getTradeCount()));\n            System.out.println(String.format(\"   Out-of-Sample (Test): $%.2f profit, %.1f%% win rate, %d trades\",\n                testProfit, testWinRate, testTrades.size()));\n            \n            // Add validation metrics to result\n            bestProfit.setValidationProfit(testProfit);\n            bestProfit.setValidationWinRate(testWinRate);\n            bestProfit.setValidationTradeCount(testTrades.size());\n        }\n        \n        if (bestWinRate != null && bestWinRate != bestProfit) {\n            System.out.println(\"\\n FIX #3: Validating Best Win Rate Parameters on Test Set...\");\n            BacktestParameters bestWinRateParams = createParamsFromSettings(bestWinRate.getSettings(), baseParams);\n            List<BacktestTrade> testTrades = simulateBacktest(symbol, testData, capital, bestWinRateParams);\n            \n            double testProfit = 0;\n            int testWinners = 0;\n            for (BacktestTrade trade : testTrades) {\n                testProfit += trade.getProfitLoss();\n                if (trade.getProfitLoss() > 0) testWinners++;\n            }\n            double testWinRate = testTrades.isEmpty() ? 0 : (double) testWinners / testTrades.size() * 100;\n            \n            System.out.println(String.format(\"   In-Sample (Train):  $%.2f profit, %.1f%% win rate, %d trades\",\n                bestWinRate.getTotalProfit(), bestWinRate.getWinRate(), bestWinRate.getTradeCount()));\n            System.out.println(String.format(\"   Out-of-Sample (Test): $%.2f profit, %.1f%% win rate, %d trades\\n\",\n                testProfit, testWinRate, testTrades.size()));\n            \n            // Add validation metrics to result\n            bestWinRate.setValidationProfit(testProfit);\n            bestWinRate.setValidationWinRate(testWinRate);\n            bestWinRate.setValidationTradeCount(testTrades.size());\n        }\n        \n        // FIX #8: Restore original signal rules on FX thread (no Thread.sleep needed)\n        Platform.runLater(() -> restoreSignalRulesState(savedSignalRules));\n        \n        return new OptimizationResult[]{bestProfit, bestWinRate};\n    }\n    \n    /**\n     * FIX #3: Create BacktestParameters from optimization settings map\n     * Used for validating optimized parameters on test data\n     */\n    private BacktestParameters createParamsFromSettings(Map<String, Object> settings, BacktestParameters baseParams) {\n        return new BacktestParameters(\n            (int) settings.get(\"rsiPeriod\"),\n            (int) settings.get(\"buyPeriod\"),\n            (double) settings.get(\"comboThreshold\"),\n            (double) settings.get(\"stopLoss\") / 100.0,\n            (double) settings.get(\"profitFloor\") / 100.0,\n            baseParams.subsequentProfitFloorPct,\n            baseParams.minDataPoints,\n            (int) settings.get(\"rsiPeriod\"),\n            baseParams.mfiRocPeriod,\n            baseParams.obvRocPeriod,\n            baseParams.vwapRocPeriod,\n            baseParams.percentBRocPeriod,\n            (int) settings.get(\"buyPeriod\"),\n            (int) settings.get(\"buyPeriod\"),\n            (int) settings.get(\"mfiPeriod\"),\n            (int) settings.get(\"bbLength\"),\n            baseParams.bbStdDevMultiplier,  // FIX #6: Include bbStdDevMultiplier\n            baseParams.macdFastPeriod,\n            baseParams.macdSlowPeriod,\n            baseParams.macdSignalPeriod,\n            baseParams.macdHistogramRocThreshold,\n            baseParams.stochPeriod,\n            baseParams.stochKSmooth,\n            baseParams.stochDSmooth,\n            (double) settings.get(\"stochOversoldThreshold\"),\n            baseParams.rvolPeriod,\n            (double) settings.get(\"rvolThreshold\"),\n            baseParams.ema9Period,\n            baseParams.ema20Period,\n            baseParams.ema50Period,\n            baseParams.volSpikeThreshold,\n            (double) settings.get(\"priceSpikeThreshold\"),\n            (double) settings.get(\"volumeSpikeThreshold\"),\n            (double) settings.get(\"rsiSpikeThreshold\"),\n            baseParams.obvSpikeZThreshold,\n            baseParams.mfiSpikeZThreshold,\n            baseParams.percentBSpikeZThreshold,\n            baseParams.vwapSpikeZThreshold,\n            (double) settings.get(\"priceRocThreshold\"),\n            baseParams.rsiRocThreshold,\n            baseParams.obvRocThreshold,\n            baseParams.mfiRocThreshold,\n            baseParams.percentBRocThreshold,\n            baseParams.vwapRocThreshold,\n            (double) settings.get(\"volumeRocThreshold\"),\n            (boolean) settings.get(\"spikeQuality\"),\n            (boolean) settings.get(\"priceCondition\"),\n            (boolean) settings.get(\"rsiCondition\"),\n            (boolean) settings.get(\"obvCondition\"),\n            (boolean) settings.get(\"mfiCondition\"),\n            (boolean) settings.get(\"bollingerCondition\"),\n            (boolean) settings.get(\"vwapIndicator\"),\n            (boolean) settings.get(\"adxIndicator\"),\n            (boolean) settings.get(\"volumeSpike\"),\n            baseParams.enableMacdHistogramRoc,\n            baseParams.enableStochasticIndicator,\n            baseParams.enableRvolIndicator,\n            baseParams.enableEmaIndicator,\n            baseParams.targetGainPct,\n            baseParams.equityPerTradePct,\n            baseParams.totalCapital\n        );\n    }\n    \n    /**\n     * Save current signal rules checkbox states\n     */\n    private boolean[] saveSignalRulesState() {\n        return new boolean[]{\n            requireSpikeQuality.isSelected(),\n            requirePriceCondition.isSelected(),\n            requireRsiCondition.isSelected(),\n            requireObvCondition.isSelected(),\n            requireMfiCondition.isSelected(),\n            requireBollingerCondition.isSelected(),\n            enableVwapIndicator.isSelected(),\n            enableAdxIndicator.isSelected(),\n            requireVolumeSpike.isSelected()\n        };\n    }\n    \n    /**\n     * Restore signal rules checkbox states\n     */\n    private void restoreSignalRulesState(boolean[] states) {\n        requireSpikeQuality.setSelected(states[0]);\n        requirePriceCondition.setSelected(states[1]);\n        requireRsiCondition.setSelected(states[2]);\n        requireObvCondition.setSelected(states[3]);\n        requireMfiCondition.setSelected(states[4]);\n        requireBollingerCondition.setSelected(states[5]);\n        enableVwapIndicator.setSelected(states[6]);\n        enableAdxIndicator.setSelected(states[7]);\n        requireVolumeSpike.setSelected(states[8]);\n    }\n    \n    /**\n     * Apply signal rules combination based on bitmap\n     */\n    private void applySignalRulesCombination(int bitmap) {\n        Platform.runLater(() -> {\n            requireSpikeQuality.setSelected((bitmap & 1) != 0);\n            requirePriceCondition.setSelected((bitmap & 2) != 0);\n            requireRsiCondition.setSelected((bitmap & 4) != 0);\n            requireObvCondition.setSelected((bitmap & 8) != 0);\n            requireMfiCondition.setSelected((bitmap & 16) != 0);\n            requireBollingerCondition.setSelected((bitmap & 32) != 0);\n            enableVwapIndicator.setSelected((bitmap & 64) != 0);\n            enableAdxIndicator.setSelected((bitmap & 128) != 0);\n            requireVolumeSpike.setSelected((bitmap & 256) != 0);\n        });\n    }\n    \n    /**\n     * Get description of signal rules combination\n     */\n    private String getSignalRulesDescription(int bitmap) {\n        List<String> enabled = new ArrayList<>();\n        if ((bitmap & 1) != 0) enabled.add(\"Spike Quality\");\n        if ((bitmap & 2) != 0) enabled.add(\"Price\");\n        if ((bitmap & 4) != 0) enabled.add(\"RSI\");\n        if ((bitmap & 8) != 0) enabled.add(\"OBV\");\n        if ((bitmap & 16) != 0) enabled.add(\"MFI\");\n        if ((bitmap & 32) != 0) enabled.add(\"Bollinger\");\n        if ((bitmap & 64) != 0) enabled.add(\"VWAP\");\n        if ((bitmap & 128) != 0) enabled.add(\"ADX\");\n        if ((bitmap & 256) != 0) enabled.add(\"Volume Spike\");\n        \n        return enabled.isEmpty() ? \"All Disabled\" : String.join(\", \", enabled);\n    }\n    \n    /**\n     * Show optimization results in a popup window\n     */\n    private void showOptimizationResults(OptimizationResult bestProfit, OptimizationResult bestWinRate) {\n        // Clear previous results\n        optimizationResultsSection.getChildren().clear();\n        \n        // Choose the best overall result (prefer profit if significantly better, otherwise win rate)\n        final OptimizationResult[] bestResult = new OptimizationResult[]{bestProfit};\n        String resultTitle = \" BEST OPTIMIZATION: HIGHEST PROFIT\";\n        \n        if (bestWinRate != null && bestWinRate.getTotalTrades() >= 5) {\n            // If win rate is significantly better and has decent trades, prefer it\n            if (bestWinRate.getWinRate() > bestProfit.getWinRate() + 10) {\n                bestResult[0] = bestWinRate;\n                resultTitle = \" BEST OPTIMIZATION: HIGHEST WIN RATE\";\n            }\n        }\n        \n        // Title\n        Label titleLabel = new Label(\" OPTIMIZATION COMPLETE\");\n        titleLabel.setStyle(\"-fx-font-size: 20px; -fx-font-weight: bold; -fx-text-fill: #92400E;\");\n        \n        Label subtitleLabel = new Label(resultTitle);\n        subtitleLabel.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold; -fx-text-fill: #78350F;\");\n        \n        // Metrics\n        GridPane metricsGrid = new GridPane();\n        metricsGrid.setHgap(15);\n        metricsGrid.setVgap(8);\n        \n        Label profitLabel = new Label(\"Total Profit:\");\n        profitLabel.setStyle(\"-fx-font-size: 12px; -fx-font-weight: bold;\");\n        Label profitValue = new Label(String.format(\"$%.2f\", bestResult[0].getTotalProfit()));\n        profitValue.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold; -fx-text-fill: \" + \n                            (bestResult[0].getTotalProfit() > 0 ? \"#D1D5DB\" : \"#6B7280\") + \";\");\n        \n        Label winRateLabel = new Label(\"Win Rate:\");\n        winRateLabel.setStyle(\"-fx-font-size: 12px; -fx-font-weight: bold;\");\n        Label winRateValue = new Label(String.format(\"%.1f%%\", bestResult[0].getWinRate()));\n        winRateValue.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold; -fx-text-fill: #78350F;\");\n        \n        Label tradesLabel = new Label(\"Trades:\");\n        tradesLabel.setStyle(\"-fx-font-size: 12px; -fx-font-weight: bold;\");\n        Label tradesValue = new Label(String.format(\"%d\", bestResult[0].getTotalTrades()));\n        tradesValue.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold; -fx-text-fill: #78350F;\");\n        \n        metricsGrid.add(profitLabel, 0, 0);\n        metricsGrid.add(profitValue, 1, 0);\n        metricsGrid.add(winRateLabel, 2, 0);\n        metricsGrid.add(winRateValue, 3, 0);\n        metricsGrid.add(tradesLabel, 4, 0);\n        metricsGrid.add(tradesValue, 5, 0);\n        \n        // Settings\n        Map<String, Object> settings = bestResult[0].getSettings();\n        String settingsText = String.format(\n            \" Combo Signal Threshold: %.1f%%\\n\" +\n            \" RSI Period: %d min\\n\" +\n            \" Buy Period: %d min\\n\" +\n            \" Stop Loss: %.1f%%\\n\" +\n            \" Profit Floor: %.1f%%\\n\" +\n            \" Signal Rules: %s\",\n            ((Number) settings.get(\"comboThreshold\")).doubleValue() * 100,\n            settings.get(\"rsiPeriod\"),\n            settings.get(\"buyPeriod\"),\n            settings.get(\"stopLoss\"),\n            settings.get(\"profitFloor\"),\n            bestResult[0].getSignalRulesConfig()\n        );\n        \n        Label settingsLabel = new Label(settingsText);\n        settingsLabel.setStyle(\"-fx-font-size: 11px; -fx-text-fill: #78350F; -fx-padding: 10; \" +\n                              \"-fx-background-color: #1F2937; -fx-background-radius: 6;\");\n        settingsLabel.setWrapText(true);\n        \n        // Apply button\n        Button applyButton = new Button(\" Apply These Optimized Settings\");\n        applyButton.getStyleClass().add(\"button-green\");\n        applyButton.setPrefWidth(280);\n        applyButton.setPrefHeight(45);\n        applyButton.setStyle(\"-fx-font-size: 14px; -fx-font-weight: bold;\");\n        applyButton.setOnAction(e -> applyOptimizedSettings(bestResult[0]));\n        \n        HBox buttonBox = new HBox(applyButton);\n        buttonBox.setAlignment(Pos.CENTER);\n        \n        optimizationResultsSection.getChildren().addAll(titleLabel, subtitleLabel, metricsGrid, settingsLabel, buttonBox);\n        optimizationResultsSection.setVisible(true);\n        optimizationResultsSection.setManaged(true);\n    }\n    \n    \n    /**\n     * Apply optimized settings to the application\n     * These settings will be used for both backtesting and live trading\n     */\n    private void applyOptimizedSettings(OptimizationResult result) {\n        Map<String, Object> settings = result.getSettings();\n        \n        // Apply Configuration tab slider settings (affects both backtest and live trading)\n        comboSignalThresholdSlider.setValue(((Number) settings.get(\"comboThreshold\")).doubleValue());\n        regularRsiRocPeriodSlider.setValue(((Number) settings.get(\"rsiPeriod\")).intValue());\n        periodSlider.setValue(((Number) settings.get(\"buyPeriod\")).intValue());\n        stopLossPctSlider.setValue(((Number) settings.get(\"stopLoss\")).doubleValue());\n        initialProfitFloorPctSlider.setValue(((Number) settings.get(\"profitFloor\")).doubleValue());\n        \n        // Apply signal rules from description (user can further customize in Signal Rules tab)\n        String rulesDesc = result.getSignalRulesConfig();\n        requireSpikeQuality.setSelected(rulesDesc.contains(\"Spike Quality\") || rulesDesc.contains(\"All Signal Rules\"));\n        requirePriceCondition.setSelected(rulesDesc.contains(\"Price\") || rulesDesc.contains(\"All Signal Rules\"));\n        requireRsiCondition.setSelected(rulesDesc.contains(\"RSI\") || rulesDesc.contains(\"All Signal Rules\"));\n        requireObvCondition.setSelected(rulesDesc.contains(\"OBV\") || rulesDesc.contains(\"All Signal Rules\"));\n        requireMfiCondition.setSelected(rulesDesc.contains(\"MFI\") || rulesDesc.contains(\"All Signal Rules\"));\n        requireBollingerCondition.setSelected(rulesDesc.contains(\"Bollinger\") || rulesDesc.contains(\"All Signal Rules\"));\n        enableVwapIndicator.setSelected(rulesDesc.contains(\"VWAP\") || rulesDesc.contains(\"All Signal Rules\"));\n        enableAdxIndicator.setSelected(rulesDesc.contains(\"ADX\") || rulesDesc.contains(\"All Signal Rules\"));\n        requireVolumeSpike.setSelected(rulesDesc.contains(\"Volume Spike\") || rulesDesc.contains(\"All Signal Rules\"));\n        \n        // Apply configuration changes to backend (for both backtesting and live trading)\n        // Note: updateParameters() will show its own success dialog when backend confirms\n        updateParameters();\n        \n        System.out.println(\" OPTIMIZED SETTINGS APPLIED:\");\n        System.out.println(\"   Combo Signal Threshold: \" + String.format(\"%.1f%%\", ((Number) settings.get(\"comboThreshold\")).doubleValue() * 100));\n        System.out.println(\"   RSI Period: \" + settings.get(\"rsiPeriod\") + \" minutes\");\n        System.out.println(\"   Buy Period: \" + settings.get(\"buyPeriod\") + \" minutes\");\n        System.out.println(\"   Stop Loss: \" + settings.get(\"stopLoss\") + \"%\");\n        System.out.println(\"   Initial Profit Floor: \" + settings.get(\"profitFloor\") + \"%\");\n        System.out.println(\"   Signal Rules: \" + rulesDesc);\n        System.out.println(\"These settings will be used for both backtesting and live trading.\");\n    }\n    \n    private void addTicker() {\n        String symbol = tickerSymbolEntry.getText().trim().toUpperCase();\n        \n        if (symbol.isEmpty()) {\n            showWarning(\"Invalid Symbol\", \"Please enter a valid ticker symbol.\");\n            return;\n        }\n        \n        // Check if ticker already exists\n        for (TickerData ticker : tickerTable.getItems()) {\n            if (ticker.getSymbol().equals(symbol)) {\n                showWarning(\"Duplicate Ticker\", \"The ticker '\" + symbol + \"' is already in the list.\");\n                return;\n            }\n        }\n        \n        // Add ticker to table with initial placeholder data (including new indicators)\n        TickerData newTicker = new TickerData(symbol, 0.0, 0.0, \"No Position\", \"$0.00\", \n                                              0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                                              0.0, 0.0, 0.0, 0.0, 50.0, 50.0, 1.0, false);\n        \n        // Initialize tracking maps\n        symbolToProbabilityMap.put(symbol, 0.0);\n        symbolToPositionMap.put(symbol, \"No Position\");\n        tickerTable.getItems().add(newTicker);\n        \n        // STEP 1: Start trading FIRST (sets backend isTrading flag)\n        // BUT: Only if trading is not already active (prevents \"Trading is already active\" error)\n        if (!appState.isTradingEnabled()) {\n            System.out.println(\" DEBUG: Starting trading for \" + symbol);\n            grpcClient.startTrading(java.util.Arrays.asList(symbol), new TradingServiceClient.TradingControlCallback() {\n                @Override\n                public void onSuccess(String message) {\n                    Platform.runLater(() -> {\n                        System.out.println(\" Trading started for \" + symbol);\n                        \n                        // Update trading button state to reflect that trading is now active\n                        appState.setTradingEnabled(true);\n                        tradingToggleButton.setText(\" TRADING ACTIVE\");\n                        tradingToggleButton.getStyleClass().remove(\"button-red\");\n                        tradingToggleButton.getStyleClass().add(\"button-green\");\n                        warmupStatusLabel.setText(\" SYSTEM: ACTIVE\");\n                        warmupStatusLabel.setStyle(\"-fx-font-size: 9px; -fx-text-fill: #D1D5DB;\");\n                        System.out.println(\" Trading button updated to ACTIVE state\");\n                    });\n                }\n                \n                @Override\n                public void onError(String error) {\n                    Platform.runLater(() -> {\n                        System.err.println(\" Failed to start trading for \" + symbol + \": \" + error);\n                    });\n                }\n            });\n        } else {\n            System.out.println(\" Trading already active, skipping startTrading() for \" + symbol);\n        }\n        \n        // STEP 2: Start streaming quotes SECOND (after trading is enabled)\n        System.out.println(\" DEBUG: Starting quote stream for \" + symbol);\n        grpcClient.streamQuotes(java.util.Arrays.asList(symbol), new TradingServiceClient.QuoteCallback() {\n            @Override\n            public void onQuote(com.spiketrade.proto.MarketDataProto.Quote quote) {\n                Platform.runLater(() -> {\n                    String quoteSymbol = quote.getSymbol();\n                    double currentPrice = quote.getPrice();\n                    \n                    // PRIORITY 3: Extract bid/ask prices and calculate spread\n                    double bid = quote.getBid();\n                    double ask = quote.getAsk();\n                    \n                    // Store bid/ask prices\n                    symbolToBidMap.put(quoteSymbol, bid);\n                    symbolToAskMap.put(quoteSymbol, ask);\n                    \n                    // Calculate spread percentage\n                    double spread = 0.0;\n                    if (bid > 0 && ask > 0) {\n                        spread = ((ask - bid) / bid) * 100.0;\n                        symbolToSpreadMap.put(quoteSymbol, spread);\n                        \n                        if (spread > 1.0) { // Log if spread exceeds 1%\n                            System.out.println(String.format(\" WIDE SPREAD: %s bid=$%.2f ask=$%.2f spread=%.2f%%\",\n                                quoteSymbol, bid, ask, spread));\n                        }\n                    }\n                    \n                    // CRITICAL FIX: Extract probability from quote stream (continuous updates)\n                    Double quoteProbability = quote.hasSignalProbability() ? quote.getSignalProbability() : null;\n                    if (quoteProbability != null) {\n                        symbolToProbabilityMap.put(quoteSymbol, quoteProbability);\n                    }\n                    double probability = symbolToProbabilityMap.getOrDefault(quoteSymbol, 0.0);\n                    \n                    // CRITICAL FIX: Extract ALL indicators from full indicators data (if available)\n                    Double rsi = null, priceRoc = null, volumeRoc = null, obvRoc = null;\n                    Double mfi = null, bollingerPosition = null, percentB = null, vwap = null;\n                    Double macdHistogram = null, ema9 = null, ema20 = null, ema50 = null;\n                    Double stochK = null, stochD = null, rvol = null, atr = null;\n                    Boolean volumeSpike = null;\n                    \n                    if (quote.hasIndicators()) {\n                        com.spiketrade.proto.MarketDataProto.IndicatorsData indicators = quote.getIndicators();\n                        // Extract all indicators with null-safe checks\n                        rsi = indicators.getRsi() > 0 ? indicators.getRsi() : null;\n                        priceRoc = indicators.getPriceRoc() != 0.0 ? indicators.getPriceRoc() : null;\n                        volumeRoc = indicators.getVolumeRoc() != 0.0 ? indicators.getVolumeRoc() : null;\n                        obvRoc = indicators.getObvRoc() != 0.0 ? indicators.getObvRoc() : null;\n                        mfi = indicators.getMfi() > 0 ? indicators.getMfi() : null;\n                        bollingerPosition = indicators.getBollingerPosition() != 0.0 ? indicators.getBollingerPosition() : null;\n                        percentB = indicators.getPercentB() != 0.0 ? indicators.getPercentB() : null;\n                        vwap = indicators.getVwap() > 0 ? indicators.getVwap() : null;\n                        \n                        // CRITICAL: Extract MACD and other new indicators\n                        macdHistogram = indicators.getMacdHistogram() != 0.0 ? indicators.getMacdHistogram() : null;\n                        ema9 = indicators.getEma9() > 0 ? indicators.getEma9() : null;\n                        ema20 = indicators.getEma20() > 0 ? indicators.getEma20() : null;\n                        ema50 = indicators.getEma50() > 0 ? indicators.getEma50() : null;\n                        stochK = indicators.getStochK() >= 0 ? indicators.getStochK() : null;\n                        stochD = indicators.getStochD() >= 0 ? indicators.getStochD() : null;\n                        rvol = indicators.getRvol() > 0 ? indicators.getRvol() : null;\n                        volumeSpike = indicators.getVolumeSpike();\n                        \n                        // CRITICAL FIX: Extract ATR (Average True Range)\n                        atr = indicators.getAtr() > 0 ? indicators.getAtr() : null;\n                    } else {\n                        // Fallback to legacy individual fields if full indicators not available\n                        rsi = quote.getRsi() > 0 ? quote.getRsi() : null;\n                        priceRoc = quote.getPriceRoc() != 0.0 ? quote.getPriceRoc() : null;\n                        volumeRoc = quote.getVolumeRoc() != 0.0 ? quote.getVolumeRoc() : null;\n                        obvRoc = quote.getObv() != 0.0 ? quote.getObv() : null;\n                        mfi = quote.getMfi() > 0 ? quote.getMfi() : null;\n                        bollingerPosition = quote.getBollingerPosition() != 0.0 ? quote.getBollingerPosition() : null;\n                        percentB = quote.getPercentB() != 0.0 ? quote.getPercentB() : null;\n                        vwap = quote.getVwap() > 0 ? quote.getVwap() : null;\n                        \n                        // CRITICAL FIX: Also check for ATR in legacy Quote field\n                        if (quote.hasAtr()) {\n                            atr = quote.getAtr() > 0 ? quote.getAtr() : null;\n                        }\n                    }\n                    \n                    System.out.println(\" QUOTE UPDATE: \" + quoteSymbol + \" @ $\" + currentPrice + \n                                     String.format(\" | Bid: $%.2f | Ask: $%.2f | Spread: %.2f%% | Prob: %.1f%%\", \n                                                  bid, ask, spread, probability * 100) +\n                                     (rsi != null ? String.format(\" | RSI: %.2f | PriceROC: %.2f | MACD: %.4f | ATR: %.4f\", \n                                      rsi, priceRoc != null ? priceRoc : 0.0, macdHistogram != null ? macdHistogram : 0.0, atr != null ? atr : 0.0) : \" | Indicators warming up\"));\n                    \n                    // Store price history\n                    storePricePoint(quoteSymbol, currentPrice);\n                    \n                    // CRITICAL FIX: Pass ALL indicators including MACD and ATR to ticker table update\n                    updateTickerTableRowWithAllIndicators(quoteSymbol, currentPrice, probability, \n                        rsi, priceRoc, volumeRoc, obvRoc, mfi, bollingerPosition, percentB, vwap, atr,\n                        macdHistogram, ema9, ema20, ema50, stochK, stochD, rvol, volumeSpike);\n                    \n                    // Check exit conditions if in position\n                    if (symbolToEntryPriceMap.containsKey(quoteSymbol)) {\n                        checkExitConditions(quoteSymbol, currentPrice);\n                    }\n                    \n                    String position = symbolToPositionMap.getOrDefault(quoteSymbol, \"No Position\");\n                    System.out.println(\" UPDATED TABLE: \" + quoteSymbol + \n                                     \" | Price: $\" + currentPrice + \n                                     \" | Prob: \" + (probability * 100) + \"%\" +\n                                     \" | Pos: \" + position);\n                });\n            }\n            \n            @Override\n            public void onError(String error) {\n                Platform.runLater(() -> {\n                    System.err.println(\"Quote stream error for \" + symbol + \": \" + error);\n                });\n            }\n            \n            @Override\n            public void onCompleted() {\n                Platform.runLater(() -> {\n                    System.out.println(\"Quote stream completed for \" + symbol);\n                });\n            }\n        });\n        \n        // CRITICAL FIX: Start polling for this symbol immediately (don't wait for trading to be enabled)\n        System.out.println(\" Starting indicator polling for \" + symbol);\n        List<String> currentSymbols = new ArrayList<>();\n        currentSymbols.add(symbol);\n        startProbabilityPolling(currentSymbols);\n        \n        // STEP 3: Start streaming signals THIRD (after trading is enabled and quotes are flowing)\n        System.out.println(\" DEBUG: Starting signal stream for \" + symbol);\n        grpcClient.streamSignals(java.util.Arrays.asList(symbol), 0.0, new TradingServiceClient.SignalCallback() {\n            @Override\n            public void onSignal(com.spiketrade.proto.SpikeSignalsProto.BuySignal signal) {\n                Platform.runLater(() -> {\n                    String signalSymbol = signal.getSymbol();\n                    double probability = signal.getSignalProbability();\n                    \n                    System.out.println(\" SIGNAL RECEIVED: \" + signalSymbol + \n                                     \" | Probability: \" + (probability * 100) + \"%\");\n                    \n                    // Extract ALL indicators from the signal (including new ones)\n                    com.spiketrade.proto.SpikeSignalsProto.Indicators ind = signal.getIndicators();\n                    double rsi = ind.getRsi();\n                    double priceRoc = ind.getPriceRoc();\n                    double volumeRoc = ind.getVolumeRoc();\n                    double obvRoc = ind.getObvRoc();\n                    double mfi = ind.getMfi();\n                    double bollingerPosition = ind.getBollingerPosition();\n                    double percentB = ind.getPercentB();\n                    double vwap = ind.getVwap();\n                    \n                    // Extract NEW indicators\n                    double macdHistogram = ind.getMacdHistogram();\n                    double ema9 = ind.getEma9();\n                    double ema20 = ind.getEma20();\n                    double ema50 = ind.getEma50();\n                    double stochK = ind.getStochK();\n                    double stochD = ind.getStochD();\n                    double rvol = ind.getRvol();\n                    boolean volumeSpike = ind.getVolumeSpike();\n                    \n                    System.out.println(\" INDICATORS: RSI=\" + rsi + \n                                     \" | Price ROC=\" + priceRoc + \n                                     \" | Volume ROC=\" + volumeRoc +\n                                     \" | OBV ROC=\" + obvRoc +\n                                     \" | MFI=\" + mfi +\n                                     \" | %B=\" + percentB +\n                                     \" | VWAP=\" + vwap +\n                                     \" | MACD Hist=\" + macdHistogram +\n                                     \" | EMA9=\" + ema9 +\n                                     \" | Stoch K/D=\" + stochK + \"/\" + stochD +\n                                     \" | RVOL=\" + rvol);\n                    \n                    // Update probability map\n                    symbolToProbabilityMap.put(signalSymbol, probability);\n                    \n                    // Update ticker table with ALL indicators\n                    updateTickerTableRow(signalSymbol, null, probability, rsi, priceRoc, volumeRoc, \n                                        obvRoc, mfi, bollingerPosition, percentB, vwap, null);\n                    \n                    // Also update the NEW indicators directly on the ticker object\n                    for (TickerData ticker : tickerTable.getItems()) {\n                        if (ticker.getSymbol().equals(signalSymbol)) {\n                            ticker.setMacdHistogram(macdHistogram);\n                            ticker.setEma9(ema9);\n                            ticker.setEma20(ema20);\n                            ticker.setEma50(ema50);\n                            ticker.setStochK(stochK);\n                            ticker.setStochD(stochD);\n                            ticker.setRvol(rvol);\n                            ticker.setVolumeSpike(volumeSpike);\n                            break;\n                        }\n                    }\n                    \n                    System.out.println(\" UPDATED TICKER: \" + signalSymbol + \n                                     \" with probability=\" + (probability * 100) + \"%\");\n                    \n                    // Show notification for ALL buy signals (no threshold filtering)\n                    System.out.println(\" TRIGGERING BUY SIGNAL NOTIFICATION for \" + signalSymbol + \n                                     \" (probability: \" + (probability * 100) + \"%)\");\n                    showBuySignalAlert(signal);\n                });\n            }\n            \n            @Override\n            public void onError(String error) {\n                Platform.runLater(() -> {\n                    System.err.println(\"Signal stream error for \" + symbol + \": \" + error);\n                });\n            }\n            \n            @Override\n            public void onCompleted() {\n                Platform.runLater(() -> {\n                    System.out.println(\"Signal stream completed for \" + symbol);\n                });\n            }\n        });\n        \n        showSuccess(\"Ticker Added\", \n                   \"Successfully added '\" + symbol + \"' to the watchlist.\\n\\n\" +\n                   \"Live price updates and signal analysis will stream from the backend.\");\n        \n        tickerSymbolEntry.clear();\n        tickerSymbolEntry.requestFocus();\n    }\n    \n    private void removeAllTickers() {\n        if (tickerTable.getItems().isEmpty()) {\n            showInfo(\"No Tickers\", \"The ticker list is already empty.\");\n            return;\n        }\n        \n        Alert confirm = new Alert(Alert.AlertType.CONFIRMATION);\n        confirm.setTitle(\"Confirm Removal\");\n        confirm.setHeaderText(null);\n        confirm.setContentText(\"Are you sure you want to remove all \" + tickerTable.getItems().size() + \" tickers?\");\n        \n        confirm.showAndWait().ifPresent(response -> {\n            if (response == ButtonType.OK) {\n                List<String> symbolsToStop = tickerTable.getItems().stream()\n                    .map(TickerData::getSymbol)\n                    .collect(java.util.stream.Collectors.toList());\n                \n                if (!symbolsToStop.isEmpty()) {\n                    grpcClient.stopStreaming(symbolsToStop);\n                    System.out.println(\" Stopped gRPC streams for \" + symbolsToStop.size() + \" symbols.\");\n                }\n                \n                // Clear all tracking maps\n                symbolToProbabilityMap.clear();\n                symbolToPositionMap.clear();\n                symbolToEntryPriceMap.clear();\n                symbolToSharesMap.clear();\n                symbolToBidMap.clear();\n                symbolToAskMap.clear();\n                symbolToSpreadMap.clear();\n                symbolToAtrMap.clear(); // ATR cache\n                \n                // FIX #7: Clear price history map to prevent memory leak\n                priceHistoryMap.clear();\n                lastKnownIndicators.clear();\n                symbolToLastSellWarningCheck.clear();\n                \n                // Clear table\n                tickerTable.getItems().clear();\n                showSuccess(\"Tickers Cleared\", \"All tickers have been removed from the watchlist and streams stopped.\");\n            }\n        });\n    }\n    \n    /**\n     * Remove individual ticker and clean up all associated data\n     * FIX #3: Prevents memory leak by clearing per-symbol caches\n     */\n    private void removeTicker(String symbol) {\n        // Check if ticker exists\n        TickerData tickerToRemove = null;\n        for (TickerData ticker : tickerTable.getItems()) {\n            if (ticker.getSymbol().equals(symbol)) {\n                tickerToRemove = ticker;\n                break;\n            }\n        }\n        \n        if (tickerToRemove == null) {\n            return;\n        }\n        \n        // Confirm removal if in position\n        if (symbolToEntryPriceMap.containsKey(symbol)) {\n            Alert confirm = new Alert(Alert.AlertType.CONFIRMATION);\n            confirm.setTitle(\"Confirm Removal\");\n            confirm.setHeaderText(null);\n            confirm.setContentText(\"You have an open position in \" + symbol + \".\\n\\n\" +\n                                  \"Are you sure you want to remove this ticker?\\n\" +\n                                  \"The position will remain open but will no longer be monitored.\");\n            \n            if (confirm.showAndWait().orElse(ButtonType.CANCEL) != ButtonType.OK) {\n                return;\n            }\n        }\n        \n        // Stop gRPC streams for this symbol\n        grpcClient.stopStreaming(java.util.Arrays.asList(symbol));\n        System.out.println(\" Stopped gRPC streams for \" + symbol);\n        \n        // FIX #3: Clean up ALL per-symbol maps to prevent memory leak\n        symbolToProbabilityMap.remove(symbol);\n        symbolToPositionMap.remove(symbol);\n        symbolToEntryPriceMap.remove(symbol);\n        symbolToSharesMap.remove(symbol);\n        symbolToBidMap.remove(symbol);\n        symbolToAskMap.remove(symbol);\n        symbolToSpreadMap.remove(symbol);\n        symbolToAtrMap.remove(symbol); // ATR cache\n        \n        // Clear price history for this symbol\n        priceHistoryMap.remove(symbol);\n        \n        // Clear cached indicators\n        lastKnownIndicators.remove(symbol);\n        \n        // Clear sell warning tracking\n        symbolToLastSellWarningCheck.remove(symbol);\n        \n        // Clear notification tracking to prevent memory leaks\n        lastNotificationTime.remove(symbol + \":BUY\");\n        lastNotificationTime.remove(symbol + \":SELL\");\n        lastNotificationTime.remove(symbol + \":SELL_WARNING\");\n        \n        // Remove from table\n        tickerTable.getItems().remove(tickerToRemove);\n        \n        System.out.println(\" Removed ticker \" + symbol + \" and cleaned up all associated data\");\n        statusLabel.setText(\"Removed ticker: \" + symbol);\n    }\n    \n    /**\n     * Test signal detection for the selected ticker in the table\n     */\n    private void testSignalForSelectedTicker() {\n        TickerData selectedTicker = tickerTable.getSelectionModel().getSelectedItem();\n        \n        if (selectedTicker == null) {\n            showWarning(\"No Selection\", \"Please select a ticker from the table to test signal detection.\");\n            return;\n        }\n        \n        String symbol = selectedTicker.getSymbol();\n        \n        System.out.println(\" TEST SIGNAL: Manually requesting signal detection for \" + symbol);\n        \n        // Request analysis status which will trigger signal detection\n        grpcClient.getAnalysisStatus(symbol, new TradingServiceClient.AnalysisStatusCallback() {\n            @Override\n            public void onStatus(com.spiketrade.proto.SpikeSignalsProto.AnalysisStatus status) {\n                Platform.runLater(() -> {\n                    System.out.println(\" ANALYSIS STATUS for \" + symbol + \":\");\n                    System.out.println(\"  Ready: \" + status.getReadyForTrading());\n                    System.out.println(\"  Data Points: \" + status.getDataPointsCollected());\n                    System.out.println(\"  Warmup Required: \" + status.getWarmupRequired());\n                    System.out.println(\"  Total Spikes: \" + status.getTotalSpikesDetected());\n                    System.out.println(\"  Buy Signals: \" + status.getBuySignalsGenerated());\n                    System.out.println(\"  Latest Buy Probability: \" + (status.getLatestBuyProbability() * 100) + \"%\");\n                    \n                    if (status.getReadyForTrading()) {\n                        // Show notification for ANY buy signal (no threshold check)\n                        if (status.getLatestBuyProbability() > 0) {\n                            // Create a test buy signal to show notification\n                            com.spiketrade.proto.SpikeSignalsProto.BuySignal.Builder testSignal = \n                                com.spiketrade.proto.SpikeSignalsProto.BuySignal.newBuilder();\n                            testSignal.setSymbol(symbol);\n                            testSignal.setPrice(selectedTicker.getPrice());\n                            testSignal.setSignalProbability(status.getLatestBuyProbability());\n                            \n                            if (status.hasLatestIndicators()) {\n                                testSignal.setIndicators(status.getLatestIndicators());\n                            }\n                            \n                            System.out.println(\" SHOWING BUY SIGNAL NOTIFICATION for \" + symbol + \n                                             \" with probability \" + (status.getLatestBuyProbability() * 100) + \"%\");\n                            \n                            // Show the notification\n                            showBuySignalAlert(testSignal.build());\n                        } else {\n                            showInfo(\"Signal Test\", \n                                   \"Signal analysis is active for \" + symbol + \".\\n\\n\" +\n                                   \"Status: Ready for Trading\\n\" +\n                                   \"Data Points Collected: \" + status.getDataPointsCollected() + \"\\n\" +\n                                   \"Total Spikes: \" + status.getTotalSpikesDetected() + \"\\n\" +\n                                   \"Buy Signals: \" + status.getBuySignalsGenerated() + \"\\n\" +\n                                   \"Current Buy Probability: \" + String.format(\"%.1f%%\", status.getLatestBuyProbability() * 100));\n                        }\n                    } else {\n                        int remaining = status.getWarmupRequired() - status.getDataPointsCollected();\n                        showWarning(\"Not Ready\", \n                                  \"Signal analysis not ready for \" + symbol + \".\\n\\n\" +\n                                  \"Data points collected: \" + status.getDataPointsCollected() + \"\\n\" +\n                                  \"Warmup required: \" + status.getWarmupRequired() + \"\\n\" +\n                                  \"Remaining: \" + remaining + \" data points\");\n                    }\n                });\n            }\n            \n            @Override\n            public void onError(String error) {\n                Platform.runLater(() -> {\n                    System.err.println(\"Error getting analysis status for \" + symbol + \": \" + error);\n                    showError(\"Test Failed\", \n                            \"Failed to test signal detection for \" + symbol + \":\\n\\n\" + error);\n                });\n            }\n        });\n    }\n    \n    /**\n     * Save warmup settings to JSON file\n     * FIXED VERSION - matches actual GUI components\n     */\n    /**\n     * Update the explanation label for the current timeframe mode\n     */\n    private void updateTimeframeExplanation(Label label, TimeframeMode mode) {\n        String explanation = String.format(\"Example: RSI Period 14 = %d minutes of 1-minute candles\", \n                                          14 * mode.getMultiplier());\n        label.setText(explanation);\n    }\n    \n    /**\n     * Update all slider limits based on current timeframe mode\n     * This scales parameter ranges while maintaining 1-minute chart granularity\n     */\n    private void updateAllSliderLimits() {\n        int multiplier = currentTimeframeMode.getMultiplier();\n        \n        // Period-based sliders (these scale with timeframe)\n        if (periodSlider != null) {\n            double currentValue = periodSlider.getValue();\n            periodSlider.setMax(100 * multiplier);\n            periodSlider.setMajorTickUnit(20 * multiplier);\n            periodSlider.setValue(Math.min(currentValue, periodSlider.getMax()));\n        }\n        \n        if (regularPriceRocPeriodSlider != null) {\n            double currentValue = regularPriceRocPeriodSlider.getValue();\n            regularPriceRocPeriodSlider.setMax(100 * multiplier);\n            regularPriceRocPeriodSlider.setMajorTickUnit(20 * multiplier);\n            regularPriceRocPeriodSlider.setValue(Math.min(currentValue, regularPriceRocPeriodSlider.getMax()));\n        }\n        \n        if (regularRsiRocPeriodSlider != null) {\n            double currentValue = regularRsiRocPeriodSlider.getValue();\n            regularRsiRocPeriodSlider.setMax(100 * multiplier);\n            regularRsiRocPeriodSlider.setMajorTickUnit(20 * multiplier);\n            regularRsiRocPeriodSlider.setValue(Math.min(currentValue, regularRsiRocPeriodSlider.getMax()));\n        }\n        \n        if (regularObvRocPeriodSlider != null) {\n            double currentValue = regularObvRocPeriodSlider.getValue();\n            regularObvRocPeriodSlider.setMax(100 * multiplier);\n            regularObvRocPeriodSlider.setMajorTickUnit(20 * multiplier);\n            regularObvRocPeriodSlider.setValue(Math.min(currentValue, regularObvRocPeriodSlider.getMax()));\n        }\n        \n        if (regularMfiRocPeriodSlider != null) {\n            double currentValue = regularMfiRocPeriodSlider.getValue();\n            regularMfiRocPeriodSlider.setMax(100 * multiplier);\n            regularMfiRocPeriodSlider.setMajorTickUnit(20 * multiplier);\n            regularMfiRocPeriodSlider.setValue(Math.min(currentValue, regularMfiRocPeriodSlider.getMax()));\n        }\n        \n        if (regularPercentBRocPeriodSlider != null) {\n            double currentValue = regularPercentBRocPeriodSlider.getValue();\n            regularPercentBRocPeriodSlider.setMax(100 * multiplier);\n            regularPercentBRocPeriodSlider.setMajorTickUnit(20 * multiplier);\n            regularPercentBRocPeriodSlider.setValue(Math.min(currentValue, regularPercentBRocPeriodSlider.getMax()));\n        }\n        \n        if (regularVwapRocPeriodSlider != null) {\n            double currentValue = regularVwapRocPeriodSlider.getValue();\n            regularVwapRocPeriodSlider.setMax(100 * multiplier);\n            regularVwapRocPeriodSlider.setMajorTickUnit(20 * multiplier);\n            regularVwapRocPeriodSlider.setValue(Math.min(currentValue, regularVwapRocPeriodSlider.getMax()));\n        }\n        \n        if (regularVolumeRocPeriodSlider != null) {\n            double currentValue = regularVolumeRocPeriodSlider.getValue();\n            regularVolumeRocPeriodSlider.setMax(100 * multiplier);\n            regularVolumeRocPeriodSlider.setMajorTickUnit(20 * multiplier);\n            regularVolumeRocPeriodSlider.setValue(Math.min(currentValue, regularVolumeRocPeriodSlider.getMax()));\n        }\n        \n        if (bbLengthMinutesSlider != null) {\n            double currentValue = bbLengthMinutesSlider.getValue();\n            bbLengthMinutesSlider.setMax(100 * multiplier);\n            bbLengthMinutesSlider.setMajorTickUnit(20 * multiplier);\n            bbLengthMinutesSlider.setValue(Math.min(currentValue, bbLengthMinutesSlider.getMax()));\n        }\n        \n        if (mfiPeriodMinutesSlider != null) {\n            double currentValue = mfiPeriodMinutesSlider.getValue();\n            mfiPeriodMinutesSlider.setMax(100 * multiplier);\n            mfiPeriodMinutesSlider.setMajorTickUnit(20 * multiplier);\n            mfiPeriodMinutesSlider.setValue(Math.min(currentValue, mfiPeriodMinutesSlider.getMax()));\n        }\n        \n        if (vwapPeriodMinutesSlider != null) {\n            double currentValue = vwapPeriodMinutesSlider.getValue();\n            vwapPeriodMinutesSlider.setMax(100 * multiplier);\n            vwapPeriodMinutesSlider.setMajorTickUnit(20 * multiplier);\n            vwapPeriodMinutesSlider.setValue(Math.min(currentValue, vwapPeriodMinutesSlider.getMax()));\n        }\n    ","size_bytes":360000},"src/main/java/com/spiketrade/model/PricePoint.java":{"content":"package com.spiketrade.model;\n\npublic class PricePoint {\n    private String timestamp;\n    private double price;\n    \n    public PricePoint(String timestamp, double price) {\n        this.timestamp = timestamp;\n        this.price = price;\n    }\n    \n    public String getTimestamp() { return timestamp; }\n    public double getPrice() { return price; }\n}\n","size_bytes":353},"build/generated/source/proto/main/java/com/spiketrade/proto/ConfigProto.java":{"content":"// Generated by the protocol buffer compiler.  DO NOT EDIT!\n// source: config.proto\n\n// Protobuf Java Version: 3.25.1\npackage com.spiketrade.proto;\n\npublic final class ConfigProto {\n  private ConfigProto() {}\n  public static void registerAllExtensions(\n      com.google.protobuf.ExtensionRegistryLite registry) {\n  }\n\n  public static void registerAllExtensions(\n      com.google.protobuf.ExtensionRegistry registry) {\n    registerAllExtensions(\n        (com.google.protobuf.ExtensionRegistryLite) registry);\n  }\n  public interface TradingConfigOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.TradingConfig)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <pre>\n     * Window parameters\n     * </pre>\n     *\n     * <code>int32 buy_period_minutes = 1;</code>\n     * @return The buyPeriodMinutes.\n     */\n    int getBuyPeriodMinutes();\n\n    /**\n     * <code>int32 bb_length_minutes = 2;</code>\n     * @return The bbLengthMinutes.\n     */\n    int getBbLengthMinutes();\n\n    /**\n     * <code>int32 rsi_length_minutes = 3;</code>\n     * @return The rsiLengthMinutes.\n     */\n    int getRsiLengthMinutes();\n\n    /**\n     * <code>int32 price_roc_period_minutes = 4;</code>\n     * @return The priceRocPeriodMinutes.\n     */\n    int getPriceRocPeriodMinutes();\n\n    /**\n     * <code>int32 obv_roc_period_minutes = 5;</code>\n     * @return The obvRocPeriodMinutes.\n     */\n    int getObvRocPeriodMinutes();\n\n    /**\n     * <code>int32 mfi_period_minutes = 6;</code>\n     * @return The mfiPeriodMinutes.\n     */\n    int getMfiPeriodMinutes();\n\n    /**\n     * <code>int32 mfi_roc_period_minutes = 7;</code>\n     * @return The mfiRocPeriodMinutes.\n     */\n    int getMfiRocPeriodMinutes();\n\n    /**\n     * <code>int32 vwap_period_minutes = 8;</code>\n     * @return The vwapPeriodMinutes.\n     */\n    int getVwapPeriodMinutes();\n\n    /**\n     * <code>int32 data_points = 9;</code>\n     * @return The dataPoints.\n     */\n    int getDataPoints();\n\n    /**\n     * <code>int32 warmup_data_points = 10;</code>\n     * @return The warmupDataPoints.\n     */\n    int getWarmupDataPoints();\n\n    /**\n     * <pre>\n     * Spike ROC Threshold parameters (Z-score based)\n     * </pre>\n     *\n     * <code>double spike_price_roc_z_threshold = 20;</code>\n     * @return The spikePriceRocZThreshold.\n     */\n    double getSpikePriceRocZThreshold();\n\n    /**\n     * <code>double spike_rsi_roc_z_threshold = 21;</code>\n     * @return The spikeRsiRocZThreshold.\n     */\n    double getSpikeRsiRocZThreshold();\n\n    /**\n     * <code>double spike_obv_roc_z_threshold = 22;</code>\n     * @return The spikeObvRocZThreshold.\n     */\n    double getSpikeObvRocZThreshold();\n\n    /**\n     * <code>double spike_mfi_roc_z_threshold = 23;</code>\n     * @return The spikeMfiRocZThreshold.\n     */\n    double getSpikeMfiRocZThreshold();\n\n    /**\n     * <code>double spike_percent_b_roc_z_threshold = 24;</code>\n     * @return The spikePercentBRocZThreshold.\n     */\n    double getSpikePercentBRocZThreshold();\n\n    /**\n     * <code>double spike_vwap_roc_z_threshold = 25;</code>\n     * @return The spikeVwapRocZThreshold.\n     */\n    double getSpikeVwapRocZThreshold();\n\n    /**\n     * <code>double spike_volume_roc_z_threshold = 26;</code>\n     * @return The spikeVolumeRocZThreshold.\n     */\n    double getSpikeVolumeRocZThreshold();\n\n    /**\n     * <pre>\n     * Regular ROC Threshold parameters (absolute %)\n     * </pre>\n     *\n     * <code>double regular_price_roc_threshold = 31;</code>\n     * @return The regularPriceRocThreshold.\n     */\n    double getRegularPriceRocThreshold();\n\n    /**\n     * <code>double regular_rsi_roc_threshold = 32;</code>\n     * @return The regularRsiRocThreshold.\n     */\n    double getRegularRsiRocThreshold();\n\n    /**\n     * <code>double regular_obv_roc_threshold = 33;</code>\n     * @return The regularObvRocThreshold.\n     */\n    double getRegularObvRocThreshold();\n\n    /**\n     * <code>double regular_mfi_roc_threshold = 34;</code>\n     * @return The regularMfiRocThreshold.\n     */\n    double getRegularMfiRocThreshold();\n\n    /**\n     * <code>double regular_percent_b_roc_threshold = 35;</code>\n     * @return The regularPercentBRocThreshold.\n     */\n    double getRegularPercentBRocThreshold();\n\n    /**\n     * <code>double regular_vwap_roc_threshold = 36;</code>\n     * @return The regularVwapRocThreshold.\n     */\n    double getRegularVwapRocThreshold();\n\n    /**\n     * <code>double regular_volume_roc_threshold = 37;</code>\n     * @return The regularVolumeRocThreshold.\n     */\n    double getRegularVolumeRocThreshold();\n\n    /**\n     * <pre>\n     * Regular ROC Period parameters (minutes)\n     * </pre>\n     *\n     * <code>int32 regular_price_roc_period = 60;</code>\n     * @return The regularPriceRocPeriod.\n     */\n    int getRegularPriceRocPeriod();\n\n    /**\n     * <code>int32 regular_rsi_roc_period = 61;</code>\n     * @return The regularRsiRocPeriod.\n     */\n    int getRegularRsiRocPeriod();\n\n    /**\n     * <code>int32 regular_obv_roc_period = 62;</code>\n     * @return The regularObvRocPeriod.\n     */\n    int getRegularObvRocPeriod();\n\n    /**\n     * <code>int32 regular_mfi_roc_period = 63;</code>\n     * @return The regularMfiRocPeriod.\n     */\n    int getRegularMfiRocPeriod();\n\n    /**\n     * <code>int32 regular_percent_b_roc_period = 64;</code>\n     * @return The regularPercentBRocPeriod.\n     */\n    int getRegularPercentBRocPeriod();\n\n    /**\n     * <code>int32 regular_vwap_roc_period = 65;</code>\n     * @return The regularVwapRocPeriod.\n     */\n    int getRegularVwapRocPeriod();\n\n    /**\n     * <code>int32 regular_volume_roc_period = 66;</code>\n     * @return The regularVolumeRocPeriod.\n     */\n    int getRegularVolumeRocPeriod();\n\n    /**\n     * <code>double combo_signal_threshold = 27;</code>\n     * @return The comboSignalThreshold.\n     */\n    double getComboSignalThreshold();\n\n    /**\n     * <code>double high_prob_threshold = 28;</code>\n     * @return The highProbThreshold.\n     */\n    double getHighProbThreshold();\n\n    /**\n     * <code>double stop_loss_pct = 29;</code>\n     * @return The stopLossPct.\n     */\n    double getStopLossPct();\n\n    /**\n     * <code>double spike_cooldown_stddev_threshold = 30;</code>\n     * @return The spikeCooldownStddevThreshold.\n     */\n    double getSpikeCooldownStddevThreshold();\n\n    /**\n     * <pre>\n     * Trading parameters\n     * </pre>\n     *\n     * <code>double equity_per_trade = 40;</code>\n     * @return The equityPerTrade.\n     */\n    double getEquityPerTrade();\n\n    /**\n     * <code>double max_open_trades = 41;</code>\n     * @return The maxOpenTrades.\n     */\n    double getMaxOpenTrades();\n\n    /**\n     * <code>double total_equity_available = 42;</code>\n     * @return The totalEquityAvailable.\n     */\n    double getTotalEquityAvailable();\n\n    /**\n     * <pre>\n     * Boolean flags\n     * </pre>\n     *\n     * <code>bool enable_price_roc_spike = 50;</code>\n     * @return The enablePriceRocSpike.\n     */\n    boolean getEnablePriceRocSpike();\n\n    /**\n     * <code>bool enable_rsi_roc_spike = 51;</code>\n     * @return The enableRsiRocSpike.\n     */\n    boolean getEnableRsiRocSpike();\n\n    /**\n     * <code>bool enable_obv_roc_spike = 52;</code>\n     * @return The enableObvRocSpike.\n     */\n    boolean getEnableObvRocSpike();\n\n    /**\n     * <code>bool enable_mfi_roc_spike = 53;</code>\n     * @return The enableMfiRocSpike.\n     */\n    boolean getEnableMfiRocSpike();\n\n    /**\n     * <code>bool enable_percent_b_roc_spike = 54;</code>\n     * @return The enablePercentBRocSpike.\n     */\n    boolean getEnablePercentBRocSpike();\n\n    /**\n     * <code>bool enable_vwap_roc_spike = 55;</code>\n     * @return The enableVwapRocSpike.\n     */\n    boolean getEnableVwapRocSpike();\n\n    /**\n     * <code>bool use_ml_spikes = 56;</code>\n     * @return The useMlSpikes.\n     */\n    boolean getUseMlSpikes();\n\n    /**\n     * <code>bool enable_cooldowns = 57;</code>\n     * @return The enableCooldowns.\n     */\n    boolean getEnableCooldowns();\n\n    /**\n     * <code>bool enable_adx_indicator = 58;</code>\n     * @return The enableAdxIndicator.\n     */\n    boolean getEnableAdxIndicator();\n\n    /**\n     * <code>bool enable_volume_roc_spike = 59;</code>\n     * @return The enableVolumeRocSpike.\n     */\n    boolean getEnableVolumeRocSpike();\n\n    /**\n     * <pre>\n     * NEW PENNY STOCK INDICATORS\n     * Enable/disable flags\n     * </pre>\n     *\n     * <code>bool enable_macd_histogram_roc = 70;</code>\n     * @return The enableMacdHistogramRoc.\n     */\n    boolean getEnableMacdHistogramRoc();\n\n    /**\n     * <code>bool enable_stochastic_indicator = 71;</code>\n     * @return The enableStochasticIndicator.\n     */\n    boolean getEnableStochasticIndicator();\n\n    /**\n     * <code>bool enable_rvol_indicator = 72;</code>\n     * @return The enableRvolIndicator.\n     */\n    boolean getEnableRvolIndicator();\n\n    /**\n     * <code>bool enable_ema_indicator = 73;</code>\n     * @return The enableEmaIndicator.\n     */\n    boolean getEnableEmaIndicator();\n\n    /**\n     * <code>bool enable_ema_trend_filter = 74;</code>\n     * @return The enableEmaTrendFilter.\n     */\n    boolean getEnableEmaTrendFilter();\n\n    /**\n     * <pre>\n     * MACD periods (optimized for volatile 1-min candles)\n     * </pre>\n     *\n     * <code>int32 macd_fast_period = 80;</code>\n     * @return The macdFastPeriod.\n     */\n    int getMacdFastPeriod();\n\n    /**\n     * <code>int32 macd_slow_period = 81;</code>\n     * @return The macdSlowPeriod.\n     */\n    int getMacdSlowPeriod();\n\n    /**\n     * <code>int32 macd_signal_period = 82;</code>\n     * @return The macdSignalPeriod.\n     */\n    int getMacdSignalPeriod();\n\n    /**\n     * <pre>\n     * MACD Histogram ROC threshold (as % of price) - predictive convergence detection\n     * </pre>\n     *\n     * <code>double macd_histogram_roc_threshold = 83;</code>\n     * @return The macdHistogramRocThreshold.\n     */\n    double getMacdHistogramRocThreshold();\n\n    /**\n     * <pre>\n     * Stochastic periods and thresholds\n     * </pre>\n     *\n     * <code>int32 stochastic_period = 85;</code>\n     * @return The stochasticPeriod.\n     */\n    int getStochasticPeriod();\n\n    /**\n     * <code>int32 stochastic_k_smooth = 86;</code>\n     * @return The stochasticKSmooth.\n     */\n    int getStochasticKSmooth();\n\n    /**\n     * <code>int32 stochastic_d_smooth = 87;</code>\n     * @return The stochasticDSmooth.\n     */\n    int getStochasticDSmooth();\n\n    /**\n     * <code>double stochastic_oversold_threshold = 88;</code>\n     * @return The stochasticOversoldThreshold.\n     */\n    double getStochasticOversoldThreshold();\n\n    /**\n     * <code>double stochastic_overbought_threshold = 89;</code>\n     * @return The stochasticOverboughtThreshold.\n     */\n    double getStochasticOverboughtThreshold();\n\n    /**\n     * <pre>\n     * Relative Volume (RVOL) settings\n     * </pre>\n     *\n     * <code>int32 rvol_period = 90;</code>\n     * @return The rvolPeriod.\n     */\n    int getRvolPeriod();\n\n    /**\n     * <code>double rvol_threshold = 91;</code>\n     * @return The rvolThreshold.\n     */\n    double getRvolThreshold();\n\n    /**\n     * <pre>\n     * EMA periods\n     * </pre>\n     *\n     * <code>int32 ema9_period = 95;</code>\n     * @return The ema9Period.\n     */\n    int getEma9Period();\n\n    /**\n     * <code>int32 ema20_period = 96;</code>\n     * @return The ema20Period.\n     */\n    int getEma20Period();\n\n    /**\n     * <code>int32 ema50_period = 97;</code>\n     * @return The ema50Period.\n     */\n    int getEma50Period();\n\n    /**\n     * <pre>\n     * Volume spike detection\n     * </pre>\n     *\n     * <code>double volume_spike_threshold = 98;</code>\n     * @return The volumeSpikeThreshold.\n     */\n    double getVolumeSpikeThreshold();\n\n    /**\n     * <pre>\n     * Timeframe multiplier for candle aggregation (1=1min, 10=10min, 30=30min, 60=1hour, 180=3hours)\n     * This tells the backend what timeframe to aggregate candles into before analysis\n     * </pre>\n     *\n     * <code>int32 timeframe_multiplier = 99;</code>\n     * @return The timeframeMultiplier.\n     */\n    int getTimeframeMultiplier();\n  }\n  /**\n   * <pre>\n   * Trading configuration\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.TradingConfig}\n   */\n  public static final class TradingConfig extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.TradingConfig)\n      TradingConfigOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use TradingConfig.newBuilder() to construct.\n    private TradingConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private TradingConfig() {\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new TradingConfig();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_TradingConfig_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_TradingConfig_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.ConfigProto.TradingConfig.class, com.spiketrade.proto.ConfigProto.TradingConfig.Builder.class);\n    }\n\n    public static final int BUY_PERIOD_MINUTES_FIELD_NUMBER = 1;\n    private int buyPeriodMinutes_ = 0;\n    /**\n     * <pre>\n     * Window parameters\n     * </pre>\n     *\n     * <code>int32 buy_period_minutes = 1;</code>\n     * @return The buyPeriodMinutes.\n     */\n    @java.lang.Override\n    public int getBuyPeriodMinutes() {\n      return buyPeriodMinutes_;\n    }\n\n    public static final int BB_LENGTH_MINUTES_FIELD_NUMBER = 2;\n    private int bbLengthMinutes_ = 0;\n    /**\n     * <code>int32 bb_length_minutes = 2;</code>\n     * @return The bbLengthMinutes.\n     */\n    @java.lang.Override\n    public int getBbLengthMinutes() {\n      return bbLengthMinutes_;\n    }\n\n    public static final int RSI_LENGTH_MINUTES_FIELD_NUMBER = 3;\n    private int rsiLengthMinutes_ = 0;\n    /**\n     * <code>int32 rsi_length_minutes = 3;</code>\n     * @return The rsiLengthMinutes.\n     */\n    @java.lang.Override\n    public int getRsiLengthMinutes() {\n      return rsiLengthMinutes_;\n    }\n\n    public static final int PRICE_ROC_PERIOD_MINUTES_FIELD_NUMBER = 4;\n    private int priceRocPeriodMinutes_ = 0;\n    /**\n     * <code>int32 price_roc_period_minutes = 4;</code>\n     * @return The priceRocPeriodMinutes.\n     */\n    @java.lang.Override\n    public int getPriceRocPeriodMinutes() {\n      return priceRocPeriodMinutes_;\n    }\n\n    public static final int OBV_ROC_PERIOD_MINUTES_FIELD_NUMBER = 5;\n    private int obvRocPeriodMinutes_ = 0;\n    /**\n     * <code>int32 obv_roc_period_minutes = 5;</code>\n     * @return The obvRocPeriodMinutes.\n     */\n    @java.lang.Override\n    public int getObvRocPeriodMinutes() {\n      return obvRocPeriodMinutes_;\n    }\n\n    public static final int MFI_PERIOD_MINUTES_FIELD_NUMBER = 6;\n    private int mfiPeriodMinutes_ = 0;\n    /**\n     * <code>int32 mfi_period_minutes = 6;</code>\n     * @return The mfiPeriodMinutes.\n     */\n    @java.lang.Override\n    public int getMfiPeriodMinutes() {\n      return mfiPeriodMinutes_;\n    }\n\n    public static final int MFI_ROC_PERIOD_MINUTES_FIELD_NUMBER = 7;\n    private int mfiRocPeriodMinutes_ = 0;\n    /**\n     * <code>int32 mfi_roc_period_minutes = 7;</code>\n     * @return The mfiRocPeriodMinutes.\n     */\n    @java.lang.Override\n    public int getMfiRocPeriodMinutes() {\n      return mfiRocPeriodMinutes_;\n    }\n\n    public static final int VWAP_PERIOD_MINUTES_FIELD_NUMBER = 8;\n    private int vwapPeriodMinutes_ = 0;\n    /**\n     * <code>int32 vwap_period_minutes = 8;</code>\n     * @return The vwapPeriodMinutes.\n     */\n    @java.lang.Override\n    public int getVwapPeriodMinutes() {\n      return vwapPeriodMinutes_;\n    }\n\n    public static final int DATA_POINTS_FIELD_NUMBER = 9;\n    private int dataPoints_ = 0;\n    /**\n     * <code>int32 data_points = 9;</code>\n     * @return The dataPoints.\n     */\n    @java.lang.Override\n    public int getDataPoints() {\n      return dataPoints_;\n    }\n\n    public static final int WARMUP_DATA_POINTS_FIELD_NUMBER = 10;\n    private int warmupDataPoints_ = 0;\n    /**\n     * <code>int32 warmup_data_points = 10;</code>\n     * @return The warmupDataPoints.\n     */\n    @java.lang.Override\n    public int getWarmupDataPoints() {\n      return warmupDataPoints_;\n    }\n\n    public static final int SPIKE_PRICE_ROC_Z_THRESHOLD_FIELD_NUMBER = 20;\n    private double spikePriceRocZThreshold_ = 0D;\n    /**\n     * <pre>\n     * Spike ROC Threshold parameters (Z-score based)\n     * </pre>\n     *\n     * <code>double spike_price_roc_z_threshold = 20;</code>\n     * @return The spikePriceRocZThreshold.\n     */\n    @java.lang.Override\n    public double getSpikePriceRocZThreshold() {\n      return spikePriceRocZThreshold_;\n    }\n\n    public static final int SPIKE_RSI_ROC_Z_THRESHOLD_FIELD_NUMBER = 21;\n    private double spikeRsiRocZThreshold_ = 0D;\n    /**\n     * <code>double spike_rsi_roc_z_threshold = 21;</code>\n     * @return The spikeRsiRocZThreshold.\n     */\n    @java.lang.Override\n    public double getSpikeRsiRocZThreshold() {\n      return spikeRsiRocZThreshold_;\n    }\n\n    public static final int SPIKE_OBV_ROC_Z_THRESHOLD_FIELD_NUMBER = 22;\n    private double spikeObvRocZThreshold_ = 0D;\n    /**\n     * <code>double spike_obv_roc_z_threshold = 22;</code>\n     * @return The spikeObvRocZThreshold.\n     */\n    @java.lang.Override\n    public double getSpikeObvRocZThreshold() {\n      return spikeObvRocZThreshold_;\n    }\n\n    public static final int SPIKE_MFI_ROC_Z_THRESHOLD_FIELD_NUMBER = 23;\n    private double spikeMfiRocZThreshold_ = 0D;\n    /**\n     * <code>double spike_mfi_roc_z_threshold = 23;</code>\n     * @return The spikeMfiRocZThreshold.\n     */\n    @java.lang.Override\n    public double getSpikeMfiRocZThreshold() {\n      return spikeMfiRocZThreshold_;\n    }\n\n    public static final int SPIKE_PERCENT_B_ROC_Z_THRESHOLD_FIELD_NUMBER = 24;\n    private double spikePercentBRocZThreshold_ = 0D;\n    /**\n     * <code>double spike_percent_b_roc_z_threshold = 24;</code>\n     * @return The spikePercentBRocZThreshold.\n     */\n    @java.lang.Override\n    public double getSpikePercentBRocZThreshold() {\n      return spikePercentBRocZThreshold_;\n    }\n\n    public static final int SPIKE_VWAP_ROC_Z_THRESHOLD_FIELD_NUMBER = 25;\n    private double spikeVwapRocZThreshold_ = 0D;\n    /**\n     * <code>double spike_vwap_roc_z_threshold = 25;</code>\n     * @return The spikeVwapRocZThreshold.\n     */\n    @java.lang.Override\n    public double getSpikeVwapRocZThreshold() {\n      return spikeVwapRocZThreshold_;\n    }\n\n    public static final int SPIKE_VOLUME_ROC_Z_THRESHOLD_FIELD_NUMBER = 26;\n    private double spikeVolumeRocZThreshold_ = 0D;\n    /**\n     * <code>double spike_volume_roc_z_threshold = 26;</code>\n     * @return The spikeVolumeRocZThreshold.\n     */\n    @java.lang.Override\n    public double getSpikeVolumeRocZThreshold() {\n      return spikeVolumeRocZThreshold_;\n    }\n\n    public static final int REGULAR_PRICE_ROC_THRESHOLD_FIELD_NUMBER = 31;\n    private double regularPriceRocThreshold_ = 0D;\n    /**\n     * <pre>\n     * Regular ROC Threshold parameters (absolute %)\n     * </pre>\n     *\n     * <code>double regular_price_roc_threshold = 31;</code>\n     * @return The regularPriceRocThreshold.\n     */\n    @java.lang.Override\n    public double getRegularPriceRocThreshold() {\n      return regularPriceRocThreshold_;\n    }\n\n    public static final int REGULAR_RSI_ROC_THRESHOLD_FIELD_NUMBER = 32;\n    private double regularRsiRocThreshold_ = 0D;\n    /**\n     * <code>double regular_rsi_roc_threshold = 32;</code>\n     * @return The regularRsiRocThreshold.\n     */\n    @java.lang.Override\n    public double getRegularRsiRocThreshold() {\n      return regularRsiRocThreshold_;\n    }\n\n    public static final int REGULAR_OBV_ROC_THRESHOLD_FIELD_NUMBER = 33;\n    private double regularObvRocThreshold_ = 0D;\n    /**\n     * <code>double regular_obv_roc_threshold = 33;</code>\n     * @return The regularObvRocThreshold.\n     */\n    @java.lang.Override\n    public double getRegularObvRocThreshold() {\n      return regularObvRocThreshold_;\n    }\n\n    public static final int REGULAR_MFI_ROC_THRESHOLD_FIELD_NUMBER = 34;\n    private double regularMfiRocThreshold_ = 0D;\n    /**\n     * <code>double regular_mfi_roc_threshold = 34;</code>\n     * @return The regularMfiRocThreshold.\n     */\n    @java.lang.Override\n    public double getRegularMfiRocThreshold() {\n      return regularMfiRocThreshold_;\n    }\n\n    public static final int REGULAR_PERCENT_B_ROC_THRESHOLD_FIELD_NUMBER = 35;\n    private double regularPercentBRocThreshold_ = 0D;\n    /**\n     * <code>double regular_percent_b_roc_threshold = 35;</code>\n     * @return The regularPercentBRocThreshold.\n     */\n    @java.lang.Override\n    public double getRegularPercentBRocThreshold() {\n      return regularPercentBRocThreshold_;\n    }\n\n    public static final int REGULAR_VWAP_ROC_THRESHOLD_FIELD_NUMBER = 36;\n    private double regularVwapRocThreshold_ = 0D;\n    /**\n     * <code>double regular_vwap_roc_threshold = 36;</code>\n     * @return The regularVwapRocThreshold.\n     */\n    @java.lang.Override\n    public double getRegularVwapRocThreshold() {\n      return regularVwapRocThreshold_;\n    }\n\n    public static final int REGULAR_VOLUME_ROC_THRESHOLD_FIELD_NUMBER = 37;\n    private double regularVolumeRocThreshold_ = 0D;\n    /**\n     * <code>double regular_volume_roc_threshold = 37;</code>\n     * @return The regularVolumeRocThreshold.\n     */\n    @java.lang.Override\n    public double getRegularVolumeRocThreshold() {\n      return regularVolumeRocThreshold_;\n    }\n\n    public static final int REGULAR_PRICE_ROC_PERIOD_FIELD_NUMBER = 60;\n    private int regularPriceRocPeriod_ = 0;\n    /**\n     * <pre>\n     * Regular ROC Period parameters (minutes)\n     * </pre>\n     *\n     * <code>int32 regular_price_roc_period = 60;</code>\n     * @return The regularPriceRocPeriod.\n     */\n    @java.lang.Override\n    public int getRegularPriceRocPeriod() {\n      return regularPriceRocPeriod_;\n    }\n\n    public static final int REGULAR_RSI_ROC_PERIOD_FIELD_NUMBER = 61;\n    private int regularRsiRocPeriod_ = 0;\n    /**\n     * <code>int32 regular_rsi_roc_period = 61;</code>\n     * @return The regularRsiRocPeriod.\n     */\n    @java.lang.Override\n    public int getRegularRsiRocPeriod() {\n      return regularRsiRocPeriod_;\n    }\n\n    public static final int REGULAR_OBV_ROC_PERIOD_FIELD_NUMBER = 62;\n    private int regularObvRocPeriod_ = 0;\n    /**\n     * <code>int32 regular_obv_roc_period = 62;</code>\n     * @return The regularObvRocPeriod.\n     */\n    @java.lang.Override\n    public int getRegularObvRocPeriod() {\n      return regularObvRocPeriod_;\n    }\n\n    public static final int REGULAR_MFI_ROC_PERIOD_FIELD_NUMBER = 63;\n    private int regularMfiRocPeriod_ = 0;\n    /**\n     * <code>int32 regular_mfi_roc_period = 63;</code>\n     * @return The regularMfiRocPeriod.\n     */\n    @java.lang.Override\n    public int getRegularMfiRocPeriod() {\n      return regularMfiRocPeriod_;\n    }\n\n    public static final int REGULAR_PERCENT_B_ROC_PERIOD_FIELD_NUMBER = 64;\n    private int regularPercentBRocPeriod_ = 0;\n    /**\n     * <code>int32 regular_percent_b_roc_period = 64;</code>\n     * @return The regularPercentBRocPeriod.\n     */\n    @java.lang.Override\n    public int getRegularPercentBRocPeriod() {\n      return regularPercentBRocPeriod_;\n    }\n\n    public static final int REGULAR_VWAP_ROC_PERIOD_FIELD_NUMBER = 65;\n    private int regularVwapRocPeriod_ = 0;\n    /**\n     * <code>int32 regular_vwap_roc_period = 65;</code>\n     * @return The regularVwapRocPeriod.\n     */\n    @java.lang.Override\n    public int getRegularVwapRocPeriod() {\n      return regularVwapRocPeriod_;\n    }\n\n    public static final int REGULAR_VOLUME_ROC_PERIOD_FIELD_NUMBER = 66;\n    private int regularVolumeRocPeriod_ = 0;\n    /**\n     * <code>int32 regular_volume_roc_period = 66;</code>\n     * @return The regularVolumeRocPeriod.\n     */\n    @java.lang.Override\n    public int getRegularVolumeRocPeriod() {\n      return regularVolumeRocPeriod_;\n    }\n\n    public static final int COMBO_SIGNAL_THRESHOLD_FIELD_NUMBER = 27;\n    private double comboSignalThreshold_ = 0D;\n    /**\n     * <code>double combo_signal_threshold = 27;</code>\n     * @return The comboSignalThreshold.\n     */\n    @java.lang.Override\n    public double getComboSignalThreshold() {\n      return comboSignalThreshold_;\n    }\n\n    public static final int HIGH_PROB_THRESHOLD_FIELD_NUMBER = 28;\n    private double highProbThreshold_ = 0D;\n    /**\n     * <code>double high_prob_threshold = 28;</code>\n     * @return The highProbThreshold.\n     */\n    @java.lang.Override\n    public double getHighProbThreshold() {\n      return highProbThreshold_;\n    }\n\n    public static final int STOP_LOSS_PCT_FIELD_NUMBER = 29;\n    private double stopLossPct_ = 0D;\n    /**\n     * <code>double stop_loss_pct = 29;</code>\n     * @return The stopLossPct.\n     */\n    @java.lang.Override\n    public double getStopLossPct() {\n      return stopLossPct_;\n    }\n\n    public static final int SPIKE_COOLDOWN_STDDEV_THRESHOLD_FIELD_NUMBER = 30;\n    private double spikeCooldownStddevThreshold_ = 0D;\n    /**\n     * <code>double spike_cooldown_stddev_threshold = 30;</code>\n     * @return The spikeCooldownStddevThreshold.\n     */\n    @java.lang.Override\n    public double getSpikeCooldownStddevThreshold() {\n      return spikeCooldownStddevThreshold_;\n    }\n\n    public static final int EQUITY_PER_TRADE_FIELD_NUMBER = 40;\n    private double equityPerTrade_ = 0D;\n    /**\n     * <pre>\n     * Trading parameters\n     * </pre>\n     *\n     * <code>double equity_per_trade = 40;</code>\n     * @return The equityPerTrade.\n     */\n    @java.lang.Override\n    public double getEquityPerTrade() {\n      return equityPerTrade_;\n    }\n\n    public static final int MAX_OPEN_TRADES_FIELD_NUMBER = 41;\n    private double maxOpenTrades_ = 0D;\n    /**\n     * <code>double max_open_trades = 41;</code>\n     * @return The maxOpenTrades.\n     */\n    @java.lang.Override\n    public double getMaxOpenTrades() {\n      return maxOpenTrades_;\n    }\n\n    public static final int TOTAL_EQUITY_AVAILABLE_FIELD_NUMBER = 42;\n    private double totalEquityAvailable_ = 0D;\n    /**\n     * <code>double total_equity_available = 42;</code>\n     * @return The totalEquityAvailable.\n     */\n    @java.lang.Override\n    public double getTotalEquityAvailable() {\n      return totalEquityAvailable_;\n    }\n\n    public static final int ENABLE_PRICE_ROC_SPIKE_FIELD_NUMBER = 50;\n    private boolean enablePriceRocSpike_ = false;\n    /**\n     * <pre>\n     * Boolean flags\n     * </pre>\n     *\n     * <code>bool enable_price_roc_spike = 50;</code>\n     * @return The enablePriceRocSpike.\n     */\n    @java.lang.Override\n    public boolean getEnablePriceRocSpike() {\n      return enablePriceRocSpike_;\n    }\n\n    public static final int ENABLE_RSI_ROC_SPIKE_FIELD_NUMBER = 51;\n    private boolean enableRsiRocSpike_ = false;\n    /**\n     * <code>bool enable_rsi_roc_spike = 51;</code>\n     * @return The enableRsiRocSpike.\n     */\n    @java.lang.Override\n    public boolean getEnableRsiRocSpike() {\n      return enableRsiRocSpike_;\n    }\n\n    public static final int ENABLE_OBV_ROC_SPIKE_FIELD_NUMBER = 52;\n    private boolean enableObvRocSpike_ = false;\n    /**\n     * <code>bool enable_obv_roc_spike = 52;</code>\n     * @return The enableObvRocSpike.\n     */\n    @java.lang.Override\n    public boolean getEnableObvRocSpike() {\n      return enableObvRocSpike_;\n    }\n\n    public static final int ENABLE_MFI_ROC_SPIKE_FIELD_NUMBER = 53;\n    private boolean enableMfiRocSpike_ = false;\n    /**\n     * <code>bool enable_mfi_roc_spike = 53;</code>\n     * @return The enableMfiRocSpike.\n     */\n    @java.lang.Override\n    public boolean getEnableMfiRocSpike() {\n      return enableMfiRocSpike_;\n    }\n\n    public static final int ENABLE_PERCENT_B_ROC_SPIKE_FIELD_NUMBER = 54;\n    private boolean enablePercentBRocSpike_ = false;\n    /**\n     * <code>bool enable_percent_b_roc_spike = 54;</code>\n     * @return The enablePercentBRocSpike.\n     */\n    @java.lang.Override\n    public boolean getEnablePercentBRocSpike() {\n      return enablePercentBRocSpike_;\n    }\n\n    public static final int ENABLE_VWAP_ROC_SPIKE_FIELD_NUMBER = 55;\n    private boolean enableVwapRocSpike_ = false;\n    /**\n     * <code>bool enable_vwap_roc_spike = 55;</code>\n     * @return The enableVwapRocSpike.\n     */\n    @java.lang.Override\n    public boolean getEnableVwapRocSpike() {\n      return enableVwapRocSpike_;\n    }\n\n    public static final int USE_ML_SPIKES_FIELD_NUMBER = 56;\n    private boolean useMlSpikes_ = false;\n    /**\n     * <code>bool use_ml_spikes = 56;</code>\n     * @return The useMlSpikes.\n     */\n    @java.lang.Override\n    public boolean getUseMlSpikes() {\n      return useMlSpikes_;\n    }\n\n    public static final int ENABLE_COOLDOWNS_FIELD_NUMBER = 57;\n    private boolean enableCooldowns_ = false;\n    /**\n     * <code>bool enable_cooldowns = 57;</code>\n     * @return The enableCooldowns.\n     */\n    @java.lang.Override\n    public boolean getEnableCooldowns() {\n      return enableCooldowns_;\n    }\n\n    public static final int ENABLE_ADX_INDICATOR_FIELD_NUMBER = 58;\n    private boolean enableAdxIndicator_ = false;\n    /**\n     * <code>bool enable_adx_indicator = 58;</code>\n     * @return The enableAdxIndicator.\n     */\n    @java.lang.Override\n    public boolean getEnableAdxIndicator() {\n      return enableAdxIndicator_;\n    }\n\n    public static final int ENABLE_VOLUME_ROC_SPIKE_FIELD_NUMBER = 59;\n    private boolean enableVolumeRocSpike_ = false;\n    /**\n     * <code>bool enable_volume_roc_spike = 59;</code>\n     * @return The enableVolumeRocSpike.\n     */\n    @java.lang.Override\n    public boolean getEnableVolumeRocSpike() {\n      return enableVolumeRocSpike_;\n    }\n\n    public static final int ENABLE_MACD_HISTOGRAM_ROC_FIELD_NUMBER = 70;\n    private boolean enableMacdHistogramRoc_ = false;\n    /**\n     * <pre>\n     * NEW PENNY STOCK INDICATORS\n     * Enable/disable flags\n     * </pre>\n     *\n     * <code>bool enable_macd_histogram_roc = 70;</code>\n     * @return The enableMacdHistogramRoc.\n     */\n    @java.lang.Override\n    public boolean getEnableMacdHistogramRoc() {\n      return enableMacdHistogramRoc_;\n    }\n\n    public static final int ENABLE_STOCHASTIC_INDICATOR_FIELD_NUMBER = 71;\n    private boolean enableStochasticIndicator_ = false;\n    /**\n     * <code>bool enable_stochastic_indicator = 71;</code>\n     * @return The enableStochasticIndicator.\n     */\n    @java.lang.Override\n    public boolean getEnableStochasticIndicator() {\n      return enableStochasticIndicator_;\n    }\n\n    public static final int ENABLE_RVOL_INDICATOR_FIELD_NUMBER = 72;\n    private boolean enableRvolIndicator_ = false;\n    /**\n     * <code>bool enable_rvol_indicator = 72;</code>\n     * @return The enableRvolIndicator.\n     */\n    @java.lang.Override\n    public boolean getEnableRvolIndicator() {\n      return enableRvolIndicator_;\n    }\n\n    public static final int ENABLE_EMA_INDICATOR_FIELD_NUMBER = 73;\n    private boolean enableEmaIndicator_ = false;\n    /**\n     * <code>bool enable_ema_indicator = 73;</code>\n     * @return The enableEmaIndicator.\n     */\n    @java.lang.Override\n    public boolean getEnableEmaIndicator() {\n      return enableEmaIndicator_;\n    }\n\n    public static final int ENABLE_EMA_TREND_FILTER_FIELD_NUMBER = 74;\n    private boolean enableEmaTrendFilter_ = false;\n    /**\n     * <code>bool enable_ema_trend_filter = 74;</code>\n     * @return The enableEmaTrendFilter.\n     */\n    @java.lang.Override\n    public boolean getEnableEmaTrendFilter() {\n      return enableEmaTrendFilter_;\n    }\n\n    public static final int MACD_FAST_PERIOD_FIELD_NUMBER = 80;\n    private int macdFastPeriod_ = 0;\n    /**\n     * <pre>\n     * MACD periods (optimized for volatile 1-min candles)\n     * </pre>\n     *\n     * <code>int32 macd_fast_period = 80;</code>\n     * @return The macdFastPeriod.\n     */\n    @java.lang.Override\n    public int getMacdFastPeriod() {\n      return macdFastPeriod_;\n    }\n\n    public static final int MACD_SLOW_PERIOD_FIELD_NUMBER = 81;\n    private int macdSlowPeriod_ = 0;\n    /**\n     * <code>int32 macd_slow_period = 81;</code>\n     * @return The macdSlowPeriod.\n     */\n    @java.lang.Override\n    public int getMacdSlowPeriod() {\n      return macdSlowPeriod_;\n    }\n\n    public static final int MACD_SIGNAL_PERIOD_FIELD_NUMBER = 82;\n    private int macdSignalPeriod_ = 0;\n    /**\n     * <code>int32 macd_signal_period = 82;</code>\n     * @return The macdSignalPeriod.\n     */\n    @java.lang.Override\n    public int getMacdSignalPeriod() {\n      return macdSignalPeriod_;\n    }\n\n    public static final int MACD_HISTOGRAM_ROC_THRESHOLD_FIELD_NUMBER = 83;\n    private double macdHistogramRocThreshold_ = 0D;\n    /**\n     * <pre>\n     * MACD Histogram ROC threshold (as % of price) - predictive convergence detection\n     * </pre>\n     *\n     * <code>double macd_histogram_roc_threshold = 83;</code>\n     * @return The macdHistogramRocThreshold.\n     */\n    @java.lang.Override\n    public double getMacdHistogramRocThreshold() {\n      return macdHistogramRocThreshold_;\n    }\n\n    public static final int STOCHASTIC_PERIOD_FIELD_NUMBER = 85;\n    private int stochasticPeriod_ = 0;\n    /**\n     * <pre>\n     * Stochastic periods and thresholds\n     * </pre>\n     *\n     * <code>int32 stochastic_period = 85;</code>\n     * @return The stochasticPeriod.\n     */\n    @java.lang.Override\n    public int getStochasticPeriod() {\n      return stochasticPeriod_;\n    }\n\n    public static final int STOCHASTIC_K_SMOOTH_FIELD_NUMBER = 86;\n    private int stochasticKSmooth_ = 0;\n    /**\n     * <code>int32 stochastic_k_smooth = 86;</code>\n     * @return The stochasticKSmooth.\n     */\n    @java.lang.Override\n    public int getStochasticKSmooth() {\n      return stochasticKSmooth_;\n    }\n\n    public static final int STOCHASTIC_D_SMOOTH_FIELD_NUMBER = 87;\n    private int stochasticDSmooth_ = 0;\n    /**\n     * <code>int32 stochastic_d_smooth = 87;</code>\n     * @return The stochasticDSmooth.\n     */\n    @java.lang.Override\n    public int getStochasticDSmooth() {\n      return stochasticDSmooth_;\n    }\n\n    public static final int STOCHASTIC_OVERSOLD_THRESHOLD_FIELD_NUMBER = 88;\n    private double stochasticOversoldThreshold_ = 0D;\n    /**\n     * <code>double stochastic_oversold_threshold = 88;</code>\n     * @return The stochasticOversoldThreshold.\n     */\n    @java.lang.Override\n    public double getStochasticOversoldThreshold() {\n      return stochasticOversoldThreshold_;\n    }\n\n    public static final int STOCHASTIC_OVERBOUGHT_THRESHOLD_FIELD_NUMBER = 89;\n    private double stochasticOverboughtThreshold_ = 0D;\n    /**\n     * <code>double stochastic_overbought_threshold = 89;</code>\n     * @return The stochasticOverboughtThreshold.\n     */\n    @java.lang.Override\n    public double getStochasticOverboughtThreshold() {\n      return stochasticOverboughtThreshold_;\n    }\n\n    public static final int RVOL_PERIOD_FIELD_NUMBER = 90;\n    private int rvolPeriod_ = 0;\n    /**\n     * <pre>\n     * Relative Volume (RVOL) settings\n     * </pre>\n     *\n     * <code>int32 rvol_period = 90;</code>\n     * @return The rvolPeriod.\n     */\n    @java.lang.Override\n    public int getRvolPeriod() {\n      return rvolPeriod_;\n    }\n\n    public static final int RVOL_THRESHOLD_FIELD_NUMBER = 91;\n    private double rvolThreshold_ = 0D;\n    /**\n     * <code>double rvol_threshold = 91;</code>\n     * @return The rvolThreshold.\n     */\n    @java.lang.Override\n    public double getRvolThreshold() {\n      return rvolThreshold_;\n    }\n\n    public static final int EMA9_PERIOD_FIELD_NUMBER = 95;\n    private int ema9Period_ = 0;\n    /**\n     * <pre>\n     * EMA periods\n     * </pre>\n     *\n     * <code>int32 ema9_period = 95;</code>\n     * @return The ema9Period.\n     */\n    @java.lang.Override\n    public int getEma9Period() {\n      return ema9Period_;\n    }\n\n    public static final int EMA20_PERIOD_FIELD_NUMBER = 96;\n    private int ema20Period_ = 0;\n    /**\n     * <code>int32 ema20_period = 96;</code>\n     * @return The ema20Period.\n     */\n    @java.lang.Override\n    public int getEma20Period() {\n      return ema20Period_;\n    }\n\n    public static final int EMA50_PERIOD_FIELD_NUMBER = 97;\n    private int ema50Period_ = 0;\n    /**\n     * <code>int32 ema50_period = 97;</code>\n     * @return The ema50Period.\n     */\n    @java.lang.Override\n    public int getEma50Period() {\n      return ema50Period_;\n    }\n\n    public static final int VOLUME_SPIKE_THRESHOLD_FIELD_NUMBER = 98;\n    private double volumeSpikeThreshold_ = 0D;\n    /**\n     * <pre>\n     * Volume spike detection\n     * </pre>\n     *\n     * <code>double volume_spike_threshold = 98;</code>\n     * @return The volumeSpikeThreshold.\n     */\n    @java.lang.Override\n    public double getVolumeSpikeThreshold() {\n      return volumeSpikeThreshold_;\n    }\n\n    public static final int TIMEFRAME_MULTIPLIER_FIELD_NUMBER = 99;\n    private int timeframeMultiplier_ = 0;\n    /**\n     * <pre>\n     * Timeframe multiplier for candle aggregation (1=1min, 10=10min, 30=30min, 60=1hour, 180=3hours)\n     * This tells the backend what timeframe to aggregate candles into before analysis\n     * </pre>\n     *\n     * <code>int32 timeframe_multiplier = 99;</code>\n     * @return The timeframeMultiplier.\n     */\n    @java.lang.Override\n    public int getTimeframeMultiplier() {\n      return timeframeMultiplier_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (buyPeriodMinutes_ != 0) {\n        output.writeInt32(1, buyPeriodMinutes_);\n      }\n      if (bbLengthMinutes_ != 0) {\n        output.writeInt32(2, bbLengthMinutes_);\n      }\n      if (rsiLengthMinutes_ != 0) {\n        output.writeInt32(3, rsiLengthMinutes_);\n      }\n      if (priceRocPeriodMinutes_ != 0) {\n        output.writeInt32(4, priceRocPeriodMinutes_);\n      }\n      if (obvRocPeriodMinutes_ != 0) {\n        output.writeInt32(5, obvRocPeriodMinutes_);\n      }\n      if (mfiPeriodMinutes_ != 0) {\n        output.writeInt32(6, mfiPeriodMinutes_);\n      }\n      if (mfiRocPeriodMinutes_ != 0) {\n        output.writeInt32(7, mfiRocPeriodMinutes_);\n      }\n      if (vwapPeriodMinutes_ != 0) {\n        output.writeInt32(8, vwapPeriodMinutes_);\n      }\n      if (dataPoints_ != 0) {\n        output.writeInt32(9, dataPoints_);\n      }\n      if (warmupDataPoints_ != 0) {\n        output.writeInt32(10, warmupDataPoints_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikePriceRocZThreshold_) != 0) {\n        output.writeDouble(20, spikePriceRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeRsiRocZThreshold_) != 0) {\n        output.writeDouble(21, spikeRsiRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeObvRocZThreshold_) != 0) {\n        output.writeDouble(22, spikeObvRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeMfiRocZThreshold_) != 0) {\n        output.writeDouble(23, spikeMfiRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikePercentBRocZThreshold_) != 0) {\n        output.writeDouble(24, spikePercentBRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeVwapRocZThreshold_) != 0) {\n        output.writeDouble(25, spikeVwapRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeVolumeRocZThreshold_) != 0) {\n        output.writeDouble(26, spikeVolumeRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(comboSignalThreshold_) != 0) {\n        output.writeDouble(27, comboSignalThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(highProbThreshold_) != 0) {\n        output.writeDouble(28, highProbThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stopLossPct_) != 0) {\n        output.writeDouble(29, stopLossPct_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeCooldownStddevThreshold_) != 0) {\n        output.writeDouble(30, spikeCooldownStddevThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularPriceRocThreshold_) != 0) {\n        output.writeDouble(31, regularPriceRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularRsiRocThreshold_) != 0) {\n        output.writeDouble(32, regularRsiRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularObvRocThreshold_) != 0) {\n        output.writeDouble(33, regularObvRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularMfiRocThreshold_) != 0) {\n        output.writeDouble(34, regularMfiRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularPercentBRocThreshold_) != 0) {\n        output.writeDouble(35, regularPercentBRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularVwapRocThreshold_) != 0) {\n        output.writeDouble(36, regularVwapRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularVolumeRocThreshold_) != 0) {\n        output.writeDouble(37, regularVolumeRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(equityPerTrade_) != 0) {\n        output.writeDouble(40, equityPerTrade_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(maxOpenTrades_) != 0) {\n        output.writeDouble(41, maxOpenTrades_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(totalEquityAvailable_) != 0) {\n        output.writeDouble(42, totalEquityAvailable_);\n      }\n      if (enablePriceRocSpike_ != false) {\n        output.writeBool(50, enablePriceRocSpike_);\n      }\n      if (enableRsiRocSpike_ != false) {\n        output.writeBool(51, enableRsiRocSpike_);\n      }\n      if (enableObvRocSpike_ != false) {\n        output.writeBool(52, enableObvRocSpike_);\n      }\n      if (enableMfiRocSpike_ != false) {\n        output.writeBool(53, enableMfiRocSpike_);\n      }\n      if (enablePercentBRocSpike_ != false) {\n        output.writeBool(54, enablePercentBRocSpike_);\n      }\n      if (enableVwapRocSpike_ != false) {\n        output.writeBool(55, enableVwapRocSpike_);\n      }\n      if (useMlSpikes_ != false) {\n        output.writeBool(56, useMlSpikes_);\n      }\n      if (enableCooldowns_ != false) {\n        output.writeBool(57, enableCooldowns_);\n      }\n      if (enableAdxIndicator_ != false) {\n        output.writeBool(58, enableAdxIndicator_);\n      }\n      if (enableVolumeRocSpike_ != false) {\n        output.writeBool(59, enableVolumeRocSpike_);\n      }\n      if (regularPriceRocPeriod_ != 0) {\n        output.writeInt32(60, regularPriceRocPeriod_);\n      }\n      if (regularRsiRocPeriod_ != 0) {\n        output.writeInt32(61, regularRsiRocPeriod_);\n      }\n      if (regularObvRocPeriod_ != 0) {\n        output.writeInt32(62, regularObvRocPeriod_);\n      }\n      if (regularMfiRocPeriod_ != 0) {\n        output.writeInt32(63, regularMfiRocPeriod_);\n      }\n      if (regularPercentBRocPeriod_ != 0) {\n        output.writeInt32(64, regularPercentBRocPeriod_);\n      }\n      if (regularVwapRocPeriod_ != 0) {\n        output.writeInt32(65, regularVwapRocPeriod_);\n      }\n      if (regularVolumeRocPeriod_ != 0) {\n        output.writeInt32(66, regularVolumeRocPeriod_);\n      }\n      if (enableMacdHistogramRoc_ != false) {\n        output.writeBool(70, enableMacdHistogramRoc_);\n      }\n      if (enableStochasticIndicator_ != false) {\n        output.writeBool(71, enableStochasticIndicator_);\n      }\n      if (enableRvolIndicator_ != false) {\n        output.writeBool(72, enableRvolIndicator_);\n      }\n      if (enableEmaIndicator_ != false) {\n        output.writeBool(73, enableEmaIndicator_);\n      }\n      if (enableEmaTrendFilter_ != false) {\n        output.writeBool(74, enableEmaTrendFilter_);\n      }\n      if (macdFastPeriod_ != 0) {\n        output.writeInt32(80, macdFastPeriod_);\n      }\n      if (macdSlowPeriod_ != 0) {\n        output.writeInt32(81, macdSlowPeriod_);\n      }\n      if (macdSignalPeriod_ != 0) {\n        output.writeInt32(82, macdSignalPeriod_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdHistogramRocThreshold_) != 0) {\n        output.writeDouble(83, macdHistogramRocThreshold_);\n      }\n      if (stochasticPeriod_ != 0) {\n        output.writeInt32(85, stochasticPeriod_);\n      }\n      if (stochasticKSmooth_ != 0) {\n        output.writeInt32(86, stochasticKSmooth_);\n      }\n      if (stochasticDSmooth_ != 0) {\n        output.writeInt32(87, stochasticDSmooth_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochasticOversoldThreshold_) != 0) {\n        output.writeDouble(88, stochasticOversoldThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochasticOverboughtThreshold_) != 0) {\n        output.writeDouble(89, stochasticOverboughtThreshold_);\n      }\n      if (rvolPeriod_ != 0) {\n        output.writeInt32(90, rvolPeriod_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rvolThreshold_) != 0) {\n        output.writeDouble(91, rvolThreshold_);\n      }\n      if (ema9Period_ != 0) {\n        output.writeInt32(95, ema9Period_);\n      }\n      if (ema20Period_ != 0) {\n        output.writeInt32(96, ema20Period_);\n      }\n      if (ema50Period_ != 0) {\n        output.writeInt32(97, ema50Period_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeSpikeThreshold_) != 0) {\n        output.writeDouble(98, volumeSpikeThreshold_);\n      }\n      if (timeframeMultiplier_ != 0) {\n        output.writeInt32(99, timeframeMultiplier_);\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (buyPeriodMinutes_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(1, buyPeriodMinutes_);\n      }\n      if (bbLengthMinutes_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(2, bbLengthMinutes_);\n      }\n      if (rsiLengthMinutes_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(3, rsiLengthMinutes_);\n      }\n      if (priceRocPeriodMinutes_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(4, priceRocPeriodMinutes_);\n      }\n      if (obvRocPeriodMinutes_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(5, obvRocPeriodMinutes_);\n      }\n      if (mfiPeriodMinutes_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(6, mfiPeriodMinutes_);\n      }\n      if (mfiRocPeriodMinutes_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(7, mfiRocPeriodMinutes_);\n      }\n      if (vwapPeriodMinutes_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(8, vwapPeriodMinutes_);\n      }\n      if (dataPoints_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(9, dataPoints_);\n      }\n      if (warmupDataPoints_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(10, warmupDataPoints_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikePriceRocZThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(20, spikePriceRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeRsiRocZThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(21, spikeRsiRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeObvRocZThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(22, spikeObvRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeMfiRocZThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(23, spikeMfiRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikePercentBRocZThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(24, spikePercentBRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeVwapRocZThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(25, spikeVwapRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeVolumeRocZThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(26, spikeVolumeRocZThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(comboSignalThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(27, comboSignalThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(highProbThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(28, highProbThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stopLossPct_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(29, stopLossPct_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(spikeCooldownStddevThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(30, spikeCooldownStddevThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularPriceRocThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(31, regularPriceRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularRsiRocThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(32, regularRsiRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularObvRocThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(33, regularObvRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularMfiRocThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(34, regularMfiRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularPercentBRocThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(35, regularPercentBRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularVwapRocThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(36, regularVwapRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(regularVolumeRocThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(37, regularVolumeRocThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(equityPerTrade_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(40, equityPerTrade_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(maxOpenTrades_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(41, maxOpenTrades_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(totalEquityAvailable_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(42, totalEquityAvailable_);\n      }\n      if (enablePriceRocSpike_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(50, enablePriceRocSpike_);\n      }\n      if (enableRsiRocSpike_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(51, enableRsiRocSpike_);\n      }\n      if (enableObvRocSpike_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(52, enableObvRocSpike_);\n      }\n      if (enableMfiRocSpike_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(53, enableMfiRocSpike_);\n      }\n      if (enablePercentBRocSpike_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(54, enablePercentBRocSpike_);\n      }\n      if (enableVwapRocSpike_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(55, enableVwapRocSpike_);\n      }\n      if (useMlSpikes_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(56, useMlSpikes_);\n      }\n      if (enableCooldowns_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(57, enableCooldowns_);\n      }\n      if (enableAdxIndicator_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(58, enableAdxIndicator_);\n      }\n      if (enableVolumeRocSpike_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(59, enableVolumeRocSpike_);\n      }\n      if (regularPriceRocPeriod_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(60, regularPriceRocPeriod_);\n      }\n      if (regularRsiRocPeriod_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(61, regularRsiRocPeriod_);\n      }\n      if (regularObvRocPeriod_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(62, regularObvRocPeriod_);\n      }\n      if (regularMfiRocPeriod_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(63, regularMfiRocPeriod_);\n      }\n      if (regularPercentBRocPeriod_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(64, regularPercentBRocPeriod_);\n      }\n      if (regularVwapRocPeriod_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(65, regularVwapRocPeriod_);\n      }\n      if (regularVolumeRocPeriod_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(66, regularVolumeRocPeriod_);\n      }\n      if (enableMacdHistogramRoc_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(70, enableMacdHistogramRoc_);\n      }\n      if (enableStochasticIndicator_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(71, enableStochasticIndicator_);\n      }\n      if (enableRvolIndicator_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(72, enableRvolIndicator_);\n      }\n      if (enableEmaIndicator_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(73, enableEmaIndicator_);\n      }\n      if (enableEmaTrendFilter_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(74, enableEmaTrendFilter_);\n      }\n      if (macdFastPeriod_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(80, macdFastPeriod_);\n      }\n      if (macdSlowPeriod_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(81, macdSlowPeriod_);\n      }\n      if (macdSignalPeriod_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(82, macdSignalPeriod_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(macdHistogramRocThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(83, macdHistogramRocThreshold_);\n      }\n      if (stochasticPeriod_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(85, stochasticPeriod_);\n      }\n      if (stochasticKSmooth_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(86, stochasticKSmooth_);\n      }\n      if (stochasticDSmooth_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(87, stochasticDSmooth_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochasticOversoldThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(88, stochasticOversoldThreshold_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(stochasticOverboughtThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(89, stochasticOverboughtThreshold_);\n      }\n      if (rvolPeriod_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(90, rvolPeriod_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(rvolThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(91, rvolThreshold_);\n      }\n      if (ema9Period_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(95, ema9Period_);\n      }\n      if (ema20Period_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(96, ema20Period_);\n      }\n      if (ema50Period_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(97, ema50Period_);\n      }\n      if (java.lang.Double.doubleToRawLongBits(volumeSpikeThreshold_) != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeDoubleSize(98, volumeSpikeThreshold_);\n      }\n      if (timeframeMultiplier_ != 0) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt32Size(99, timeframeMultiplier_);\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.ConfigProto.TradingConfig)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.ConfigProto.TradingConfig other = (com.spiketrade.proto.ConfigProto.TradingConfig) obj;\n\n      if (getBuyPeriodMinutes()\n          != other.getBuyPeriodMinutes()) return false;\n      if (getBbLengthMinutes()\n          != other.getBbLengthMinutes()) return false;\n      if (getRsiLengthMinutes()\n          != other.getRsiLengthMinutes()) return false;\n      if (getPriceRocPeriodMinutes()\n          != other.getPriceRocPeriodMinutes()) return false;\n      if (getObvRocPeriodMinutes()\n          != other.getObvRocPeriodMinutes()) return false;\n      if (getMfiPeriodMinutes()\n          != other.getMfiPeriodMinutes()) return false;\n      if (getMfiRocPeriodMinutes()\n          != other.getMfiRocPeriodMinutes()) return false;\n      if (getVwapPeriodMinutes()\n          != other.getVwapPeriodMinutes()) return false;\n      if (getDataPoints()\n          != other.getDataPoints()) return false;\n      if (getWarmupDataPoints()\n          != other.getWarmupDataPoints()) return false;\n      if (java.lang.Double.doubleToLongBits(getSpikePriceRocZThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getSpikePriceRocZThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getSpikeRsiRocZThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getSpikeRsiRocZThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getSpikeObvRocZThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getSpikeObvRocZThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getSpikeMfiRocZThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getSpikeMfiRocZThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getSpikePercentBRocZThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getSpikePercentBRocZThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getSpikeVwapRocZThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getSpikeVwapRocZThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getSpikeVolumeRocZThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getSpikeVolumeRocZThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getRegularPriceRocThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getRegularPriceRocThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getRegularRsiRocThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getRegularRsiRocThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getRegularObvRocThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getRegularObvRocThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getRegularMfiRocThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getRegularMfiRocThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getRegularPercentBRocThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getRegularPercentBRocThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getRegularVwapRocThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getRegularVwapRocThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getRegularVolumeRocThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getRegularVolumeRocThreshold())) return false;\n      if (getRegularPriceRocPeriod()\n          != other.getRegularPriceRocPeriod()) return false;\n      if (getRegularRsiRocPeriod()\n          != other.getRegularRsiRocPeriod()) return false;\n      if (getRegularObvRocPeriod()\n          != other.getRegularObvRocPeriod()) return false;\n      if (getRegularMfiRocPeriod()\n          != other.getRegularMfiRocPeriod()) return false;\n      if (getRegularPercentBRocPeriod()\n          != other.getRegularPercentBRocPeriod()) return false;\n      if (getRegularVwapRocPeriod()\n          != other.getRegularVwapRocPeriod()) return false;\n      if (getRegularVolumeRocPeriod()\n          != other.getRegularVolumeRocPeriod()) return false;\n      if (java.lang.Double.doubleToLongBits(getComboSignalThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getComboSignalThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getHighProbThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getHighProbThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getStopLossPct())\n          != java.lang.Double.doubleToLongBits(\n              other.getStopLossPct())) return false;\n      if (java.lang.Double.doubleToLongBits(getSpikeCooldownStddevThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getSpikeCooldownStddevThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getEquityPerTrade())\n          != java.lang.Double.doubleToLongBits(\n              other.getEquityPerTrade())) return false;\n      if (java.lang.Double.doubleToLongBits(getMaxOpenTrades())\n          != java.lang.Double.doubleToLongBits(\n              other.getMaxOpenTrades())) return false;\n      if (java.lang.Double.doubleToLongBits(getTotalEquityAvailable())\n          != java.lang.Double.doubleToLongBits(\n              other.getTotalEquityAvailable())) return false;\n      if (getEnablePriceRocSpike()\n          != other.getEnablePriceRocSpike()) return false;\n      if (getEnableRsiRocSpike()\n          != other.getEnableRsiRocSpike()) return false;\n      if (getEnableObvRocSpike()\n          != other.getEnableObvRocSpike()) return false;\n      if (getEnableMfiRocSpike()\n          != other.getEnableMfiRocSpike()) return false;\n      if (getEnablePercentBRocSpike()\n          != other.getEnablePercentBRocSpike()) return false;\n      if (getEnableVwapRocSpike()\n          != other.getEnableVwapRocSpike()) return false;\n      if (getUseMlSpikes()\n          != other.getUseMlSpikes()) return false;\n      if (getEnableCooldowns()\n          != other.getEnableCooldowns()) return false;\n      if (getEnableAdxIndicator()\n          != other.getEnableAdxIndicator()) return false;\n      if (getEnableVolumeRocSpike()\n          != other.getEnableVolumeRocSpike()) return false;\n      if (getEnableMacdHistogramRoc()\n          != other.getEnableMacdHistogramRoc()) return false;\n      if (getEnableStochasticIndicator()\n          != other.getEnableStochasticIndicator()) return false;\n      if (getEnableRvolIndicator()\n          != other.getEnableRvolIndicator()) return false;\n      if (getEnableEmaIndicator()\n          != other.getEnableEmaIndicator()) return false;\n      if (getEnableEmaTrendFilter()\n          != other.getEnableEmaTrendFilter()) return false;\n      if (getMacdFastPeriod()\n          != other.getMacdFastPeriod()) return false;\n      if (getMacdSlowPeriod()\n          != other.getMacdSlowPeriod()) return false;\n      if (getMacdSignalPeriod()\n          != other.getMacdSignalPeriod()) return false;\n      if (java.lang.Double.doubleToLongBits(getMacdHistogramRocThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getMacdHistogramRocThreshold())) return false;\n      if (getStochasticPeriod()\n          != other.getStochasticPeriod()) return false;\n      if (getStochasticKSmooth()\n          != other.getStochasticKSmooth()) return false;\n      if (getStochasticDSmooth()\n          != other.getStochasticDSmooth()) return false;\n      if (java.lang.Double.doubleToLongBits(getStochasticOversoldThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getStochasticOversoldThreshold())) return false;\n      if (java.lang.Double.doubleToLongBits(getStochasticOverboughtThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getStochasticOverboughtThreshold())) return false;\n      if (getRvolPeriod()\n          != other.getRvolPeriod()) return false;\n      if (java.lang.Double.doubleToLongBits(getRvolThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getRvolThreshold())) return false;\n      if (getEma9Period()\n          != other.getEma9Period()) return false;\n      if (getEma20Period()\n          != other.getEma20Period()) return false;\n      if (getEma50Period()\n          != other.getEma50Period()) return false;\n      if (java.lang.Double.doubleToLongBits(getVolumeSpikeThreshold())\n          != java.lang.Double.doubleToLongBits(\n              other.getVolumeSpikeThreshold())) return false;\n      if (getTimeframeMultiplier()\n          != other.getTimeframeMultiplier()) return false;\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + BUY_PERIOD_MINUTES_FIELD_NUMBER;\n      hash = (53 * hash) + getBuyPeriodMinutes();\n      hash = (37 * hash) + BB_LENGTH_MINUTES_FIELD_NUMBER;\n      hash = (53 * hash) + getBbLengthMinutes();\n      hash = (37 * hash) + RSI_LENGTH_MINUTES_FIELD_NUMBER;\n      hash = (53 * hash) + getRsiLengthMinutes();\n      hash = (37 * hash) + PRICE_ROC_PERIOD_MINUTES_FIELD_NUMBER;\n      hash = (53 * hash) + getPriceRocPeriodMinutes();\n      hash = (37 * hash) + OBV_ROC_PERIOD_MINUTES_FIELD_NUMBER;\n      hash = (53 * hash) + getObvRocPeriodMinutes();\n      hash = (37 * hash) + MFI_PERIOD_MINUTES_FIELD_NUMBER;\n      hash = (53 * hash) + getMfiPeriodMinutes();\n      hash = (37 * hash) + MFI_ROC_PERIOD_MINUTES_FIELD_NUMBER;\n      hash = (53 * hash) + getMfiRocPeriodMinutes();\n      hash = (37 * hash) + VWAP_PERIOD_MINUTES_FIELD_NUMBER;\n      hash = (53 * hash) + getVwapPeriodMinutes();\n      hash = (37 * hash) + DATA_POINTS_FIELD_NUMBER;\n      hash = (53 * hash) + getDataPoints();\n      hash = (37 * hash) + WARMUP_DATA_POINTS_FIELD_NUMBER;\n      hash = (53 * hash) + getWarmupDataPoints();\n      hash = (37 * hash) + SPIKE_PRICE_ROC_Z_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getSpikePriceRocZThreshold()));\n      hash = (37 * hash) + SPIKE_RSI_ROC_Z_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getSpikeRsiRocZThreshold()));\n      hash = (37 * hash) + SPIKE_OBV_ROC_Z_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getSpikeObvRocZThreshold()));\n      hash = (37 * hash) + SPIKE_MFI_ROC_Z_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getSpikeMfiRocZThreshold()));\n      hash = (37 * hash) + SPIKE_PERCENT_B_ROC_Z_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getSpikePercentBRocZThreshold()));\n      hash = (37 * hash) + SPIKE_VWAP_ROC_Z_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getSpikeVwapRocZThreshold()));\n      hash = (37 * hash) + SPIKE_VOLUME_ROC_Z_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getSpikeVolumeRocZThreshold()));\n      hash = (37 * hash) + REGULAR_PRICE_ROC_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRegularPriceRocThreshold()));\n      hash = (37 * hash) + REGULAR_RSI_ROC_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRegularRsiRocThreshold()));\n      hash = (37 * hash) + REGULAR_OBV_ROC_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRegularObvRocThreshold()));\n      hash = (37 * hash) + REGULAR_MFI_ROC_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRegularMfiRocThreshold()));\n      hash = (37 * hash) + REGULAR_PERCENT_B_ROC_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRegularPercentBRocThreshold()));\n      hash = (37 * hash) + REGULAR_VWAP_ROC_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRegularVwapRocThreshold()));\n      hash = (37 * hash) + REGULAR_VOLUME_ROC_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRegularVolumeRocThreshold()));\n      hash = (37 * hash) + REGULAR_PRICE_ROC_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getRegularPriceRocPeriod();\n      hash = (37 * hash) + REGULAR_RSI_ROC_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getRegularRsiRocPeriod();\n      hash = (37 * hash) + REGULAR_OBV_ROC_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getRegularObvRocPeriod();\n      hash = (37 * hash) + REGULAR_MFI_ROC_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getRegularMfiRocPeriod();\n      hash = (37 * hash) + REGULAR_PERCENT_B_ROC_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getRegularPercentBRocPeriod();\n      hash = (37 * hash) + REGULAR_VWAP_ROC_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getRegularVwapRocPeriod();\n      hash = (37 * hash) + REGULAR_VOLUME_ROC_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getRegularVolumeRocPeriod();\n      hash = (37 * hash) + COMBO_SIGNAL_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getComboSignalThreshold()));\n      hash = (37 * hash) + HIGH_PROB_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getHighProbThreshold()));\n      hash = (37 * hash) + STOP_LOSS_PCT_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getStopLossPct()));\n      hash = (37 * hash) + SPIKE_COOLDOWN_STDDEV_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getSpikeCooldownStddevThreshold()));\n      hash = (37 * hash) + EQUITY_PER_TRADE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getEquityPerTrade()));\n      hash = (37 * hash) + MAX_OPEN_TRADES_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMaxOpenTrades()));\n      hash = (37 * hash) + TOTAL_EQUITY_AVAILABLE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getTotalEquityAvailable()));\n      hash = (37 * hash) + ENABLE_PRICE_ROC_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnablePriceRocSpike());\n      hash = (37 * hash) + ENABLE_RSI_ROC_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnableRsiRocSpike());\n      hash = (37 * hash) + ENABLE_OBV_ROC_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnableObvRocSpike());\n      hash = (37 * hash) + ENABLE_MFI_ROC_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnableMfiRocSpike());\n      hash = (37 * hash) + ENABLE_PERCENT_B_ROC_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnablePercentBRocSpike());\n      hash = (37 * hash) + ENABLE_VWAP_ROC_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnableVwapRocSpike());\n      hash = (37 * hash) + USE_ML_SPIKES_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getUseMlSpikes());\n      hash = (37 * hash) + ENABLE_COOLDOWNS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnableCooldowns());\n      hash = (37 * hash) + ENABLE_ADX_INDICATOR_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnableAdxIndicator());\n      hash = (37 * hash) + ENABLE_VOLUME_ROC_SPIKE_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnableVolumeRocSpike());\n      hash = (37 * hash) + ENABLE_MACD_HISTOGRAM_ROC_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnableMacdHistogramRoc());\n      hash = (37 * hash) + ENABLE_STOCHASTIC_INDICATOR_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnableStochasticIndicator());\n      hash = (37 * hash) + ENABLE_RVOL_INDICATOR_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnableRvolIndicator());\n      hash = (37 * hash) + ENABLE_EMA_INDICATOR_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnableEmaIndicator());\n      hash = (37 * hash) + ENABLE_EMA_TREND_FILTER_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getEnableEmaTrendFilter());\n      hash = (37 * hash) + MACD_FAST_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getMacdFastPeriod();\n      hash = (37 * hash) + MACD_SLOW_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getMacdSlowPeriod();\n      hash = (37 * hash) + MACD_SIGNAL_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getMacdSignalPeriod();\n      hash = (37 * hash) + MACD_HISTOGRAM_ROC_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getMacdHistogramRocThreshold()));\n      hash = (37 * hash) + STOCHASTIC_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getStochasticPeriod();\n      hash = (37 * hash) + STOCHASTIC_K_SMOOTH_FIELD_NUMBER;\n      hash = (53 * hash) + getStochasticKSmooth();\n      hash = (37 * hash) + STOCHASTIC_D_SMOOTH_FIELD_NUMBER;\n      hash = (53 * hash) + getStochasticDSmooth();\n      hash = (37 * hash) + STOCHASTIC_OVERSOLD_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getStochasticOversoldThreshold()));\n      hash = (37 * hash) + STOCHASTIC_OVERBOUGHT_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getStochasticOverboughtThreshold()));\n      hash = (37 * hash) + RVOL_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getRvolPeriod();\n      hash = (37 * hash) + RVOL_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getRvolThreshold()));\n      hash = (37 * hash) + EMA9_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getEma9Period();\n      hash = (37 * hash) + EMA20_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getEma20Period();\n      hash = (37 * hash) + EMA50_PERIOD_FIELD_NUMBER;\n      hash = (53 * hash) + getEma50Period();\n      hash = (37 * hash) + VOLUME_SPIKE_THRESHOLD_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          java.lang.Double.doubleToLongBits(getVolumeSpikeThreshold()));\n      hash = (37 * hash) + TIMEFRAME_MULTIPLIER_FIELD_NUMBER;\n      hash = (53 * hash) + getTimeframeMultiplier();\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.ConfigProto.TradingConfig parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.ConfigProto.TradingConfig parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.ConfigProto.TradingConfig parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.ConfigProto.TradingConfig parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.ConfigProto.TradingConfig parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.ConfigProto.TradingConfig parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.ConfigProto.TradingConfig parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.ConfigProto.TradingConfig parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.ConfigProto.TradingConfig parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.ConfigProto.TradingConfig parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.ConfigProto.TradingConfig parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.ConfigProto.TradingConfig parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.ConfigProto.TradingConfig prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Trading configuration\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.TradingConfig}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.TradingConfig)\n        com.spiketrade.proto.ConfigProto.TradingConfigOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_TradingConfig_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_TradingConfig_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.ConfigProto.TradingConfig.class, com.spiketrade.proto.ConfigProto.TradingConfig.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.ConfigProto.TradingConfig.newBuilder()\n      private Builder() {\n\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        bitField1_ = 0;\n        bitField2_ = 0;\n        buyPeriodMinutes_ = 0;\n        bbLengthMinutes_ = 0;\n        rsiLengthMinutes_ = 0;\n        priceRocPeriodMinutes_ = 0;\n        obvRocPeriodMinutes_ = 0;\n        mfiPeriodMinutes_ = 0;\n        mfiRocPeriodMinutes_ = 0;\n        vwapPeriodMinutes_ = 0;\n        dataPoints_ = 0;\n        warmupDataPoints_ = 0;\n        spikePriceRocZThreshold_ = 0D;\n        spikeRsiRocZThreshold_ = 0D;\n        spikeObvRocZThreshold_ = 0D;\n        spikeMfiRocZThreshold_ = 0D;\n        spikePercentBRocZThreshold_ = 0D;\n        spikeVwapRocZThreshold_ = 0D;\n        spikeVolumeRocZThreshold_ = 0D;\n        regularPriceRocThreshold_ = 0D;\n        regularRsiRocThreshold_ = 0D;\n        regularObvRocThreshold_ = 0D;\n        regularMfiRocThreshold_ = 0D;\n        regularPercentBRocThreshold_ = 0D;\n        regularVwapRocThreshold_ = 0D;\n        regularVolumeRocThreshold_ = 0D;\n        regularPriceRocPeriod_ = 0;\n        regularRsiRocPeriod_ = 0;\n        regularObvRocPeriod_ = 0;\n        regularMfiRocPeriod_ = 0;\n        regularPercentBRocPeriod_ = 0;\n        regularVwapRocPeriod_ = 0;\n        regularVolumeRocPeriod_ = 0;\n        comboSignalThreshold_ = 0D;\n        highProbThreshold_ = 0D;\n        stopLossPct_ = 0D;\n        spikeCooldownStddevThreshold_ = 0D;\n        equityPerTrade_ = 0D;\n        maxOpenTrades_ = 0D;\n        totalEquityAvailable_ = 0D;\n        enablePriceRocSpike_ = false;\n        enableRsiRocSpike_ = false;\n        enableObvRocSpike_ = false;\n        enableMfiRocSpike_ = false;\n        enablePercentBRocSpike_ = false;\n        enableVwapRocSpike_ = false;\n        useMlSpikes_ = false;\n        enableCooldowns_ = false;\n        enableAdxIndicator_ = false;\n        enableVolumeRocSpike_ = false;\n        enableMacdHistogramRoc_ = false;\n        enableStochasticIndicator_ = false;\n        enableRvolIndicator_ = false;\n        enableEmaIndicator_ = false;\n        enableEmaTrendFilter_ = false;\n        macdFastPeriod_ = 0;\n        macdSlowPeriod_ = 0;\n        macdSignalPeriod_ = 0;\n        macdHistogramRocThreshold_ = 0D;\n        stochasticPeriod_ = 0;\n        stochasticKSmooth_ = 0;\n        stochasticDSmooth_ = 0;\n        stochasticOversoldThreshold_ = 0D;\n        stochasticOverboughtThreshold_ = 0D;\n        rvolPeriod_ = 0;\n        rvolThreshold_ = 0D;\n        ema9Period_ = 0;\n        ema20Period_ = 0;\n        ema50Period_ = 0;\n        volumeSpikeThreshold_ = 0D;\n        timeframeMultiplier_ = 0;\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_TradingConfig_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.ConfigProto.TradingConfig getDefaultInstanceForType() {\n        return com.spiketrade.proto.ConfigProto.TradingConfig.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.ConfigProto.TradingConfig build() {\n        com.spiketrade.proto.ConfigProto.TradingConfig result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.ConfigProto.TradingConfig buildPartial() {\n        com.spiketrade.proto.ConfigProto.TradingConfig result = new com.spiketrade.proto.ConfigProto.TradingConfig(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        if (bitField1_ != 0) { buildPartial1(result); }\n        if (bitField2_ != 0) { buildPartial2(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.ConfigProto.TradingConfig result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.buyPeriodMinutes_ = buyPeriodMinutes_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.bbLengthMinutes_ = bbLengthMinutes_;\n        }\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.rsiLengthMinutes_ = rsiLengthMinutes_;\n        }\n        if (((from_bitField0_ & 0x00000008) != 0)) {\n          result.priceRocPeriodMinutes_ = priceRocPeriodMinutes_;\n        }\n        if (((from_bitField0_ & 0x00000010) != 0)) {\n          result.obvRocPeriodMinutes_ = obvRocPeriodMinutes_;\n        }\n        if (((from_bitField0_ & 0x00000020) != 0)) {\n          result.mfiPeriodMinutes_ = mfiPeriodMinutes_;\n        }\n        if (((from_bitField0_ & 0x00000040) != 0)) {\n          result.mfiRocPeriodMinutes_ = mfiRocPeriodMinutes_;\n        }\n        if (((from_bitField0_ & 0x00000080) != 0)) {\n          result.vwapPeriodMinutes_ = vwapPeriodMinutes_;\n        }\n        if (((from_bitField0_ & 0x00000100) != 0)) {\n          result.dataPoints_ = dataPoints_;\n        }\n        if (((from_bitField0_ & 0x00000200) != 0)) {\n          result.warmupDataPoints_ = warmupDataPoints_;\n        }\n        if (((from_bitField0_ & 0x00000400) != 0)) {\n          result.spikePriceRocZThreshold_ = spikePriceRocZThreshold_;\n        }\n        if (((from_bitField0_ & 0x00000800) != 0)) {\n          result.spikeRsiRocZThreshold_ = spikeRsiRocZThreshold_;\n        }\n        if (((from_bitField0_ & 0x00001000) != 0)) {\n          result.spikeObvRocZThreshold_ = spikeObvRocZThreshold_;\n        }\n        if (((from_bitField0_ & 0x00002000) != 0)) {\n          result.spikeMfiRocZThreshold_ = spikeMfiRocZThreshold_;\n        }\n        if (((from_bitField0_ & 0x00004000) != 0)) {\n          result.spikePercentBRocZThreshold_ = spikePercentBRocZThreshold_;\n        }\n        if (((from_bitField0_ & 0x00008000) != 0)) {\n          result.spikeVwapRocZThreshold_ = spikeVwapRocZThreshold_;\n        }\n        if (((from_bitField0_ & 0x00010000) != 0)) {\n          result.spikeVolumeRocZThreshold_ = spikeVolumeRocZThreshold_;\n        }\n        if (((from_bitField0_ & 0x00020000) != 0)) {\n          result.regularPriceRocThreshold_ = regularPriceRocThreshold_;\n        }\n        if (((from_bitField0_ & 0x00040000) != 0)) {\n          result.regularRsiRocThreshold_ = regularRsiRocThreshold_;\n        }\n        if (((from_bitField0_ & 0x00080000) != 0)) {\n          result.regularObvRocThreshold_ = regularObvRocThreshold_;\n        }\n        if (((from_bitField0_ & 0x00100000) != 0)) {\n          result.regularMfiRocThreshold_ = regularMfiRocThreshold_;\n        }\n        if (((from_bitField0_ & 0x00200000) != 0)) {\n          result.regularPercentBRocThreshold_ = regularPercentBRocThreshold_;\n        }\n        if (((from_bitField0_ & 0x00400000) != 0)) {\n          result.regularVwapRocThreshold_ = regularVwapRocThreshold_;\n        }\n        if (((from_bitField0_ & 0x00800000) != 0)) {\n          result.regularVolumeRocThreshold_ = regularVolumeRocThreshold_;\n        }\n        if (((from_bitField0_ & 0x01000000) != 0)) {\n          result.regularPriceRocPeriod_ = regularPriceRocPeriod_;\n        }\n        if (((from_bitField0_ & 0x02000000) != 0)) {\n          result.regularRsiRocPeriod_ = regularRsiRocPeriod_;\n        }\n        if (((from_bitField0_ & 0x04000000) != 0)) {\n          result.regularObvRocPeriod_ = regularObvRocPeriod_;\n        }\n        if (((from_bitField0_ & 0x08000000) != 0)) {\n          result.regularMfiRocPeriod_ = regularMfiRocPeriod_;\n        }\n        if (((from_bitField0_ & 0x10000000) != 0)) {\n          result.regularPercentBRocPeriod_ = regularPercentBRocPeriod_;\n        }\n        if (((from_bitField0_ & 0x20000000) != 0)) {\n          result.regularVwapRocPeriod_ = regularVwapRocPeriod_;\n        }\n        if (((from_bitField0_ & 0x40000000) != 0)) {\n          result.regularVolumeRocPeriod_ = regularVolumeRocPeriod_;\n        }\n        if (((from_bitField0_ & 0x80000000) != 0)) {\n          result.comboSignalThreshold_ = comboSignalThreshold_;\n        }\n      }\n\n      private void buildPartial1(com.spiketrade.proto.ConfigProto.TradingConfig result) {\n        int from_bitField1_ = bitField1_;\n        if (((from_bitField1_ & 0x00000001) != 0)) {\n          result.highProbThreshold_ = highProbThreshold_;\n        }\n        if (((from_bitField1_ & 0x00000002) != 0)) {\n          result.stopLossPct_ = stopLossPct_;\n        }\n        if (((from_bitField1_ & 0x00000004) != 0)) {\n          result.spikeCooldownStddevThreshold_ = spikeCooldownStddevThreshold_;\n        }\n        if (((from_bitField1_ & 0x00000008) != 0)) {\n          result.equityPerTrade_ = equityPerTrade_;\n        }\n        if (((from_bitField1_ & 0x00000010) != 0)) {\n          result.maxOpenTrades_ = maxOpenTrades_;\n        }\n        if (((from_bitField1_ & 0x00000020) != 0)) {\n          result.totalEquityAvailable_ = totalEquityAvailable_;\n        }\n        if (((from_bitField1_ & 0x00000040) != 0)) {\n          result.enablePriceRocSpike_ = enablePriceRocSpike_;\n        }\n        if (((from_bitField1_ & 0x00000080) != 0)) {\n          result.enableRsiRocSpike_ = enableRsiRocSpike_;\n        }\n        if (((from_bitField1_ & 0x00000100) != 0)) {\n          result.enableObvRocSpike_ = enableObvRocSpike_;\n        }\n        if (((from_bitField1_ & 0x00000200) != 0)) {\n          result.enableMfiRocSpike_ = enableMfiRocSpike_;\n        }\n        if (((from_bitField1_ & 0x00000400) != 0)) {\n          result.enablePercentBRocSpike_ = enablePercentBRocSpike_;\n        }\n        if (((from_bitField1_ & 0x00000800) != 0)) {\n          result.enableVwapRocSpike_ = enableVwapRocSpike_;\n        }\n        if (((from_bitField1_ & 0x00001000) != 0)) {\n          result.useMlSpikes_ = useMlSpikes_;\n        }\n        if (((from_bitField1_ & 0x00002000) != 0)) {\n          result.enableCooldowns_ = enableCooldowns_;\n        }\n        if (((from_bitField1_ & 0x00004000) != 0)) {\n          result.enableAdxIndicator_ = enableAdxIndicator_;\n        }\n        if (((from_bitField1_ & 0x00008000) != 0)) {\n          result.enableVolumeRocSpike_ = enableVolumeRocSpike_;\n        }\n        if (((from_bitField1_ & 0x00010000) != 0)) {\n          result.enableMacdHistogramRoc_ = enableMacdHistogramRoc_;\n        }\n        if (((from_bitField1_ & 0x00020000) != 0)) {\n          result.enableStochasticIndicator_ = enableStochasticIndicator_;\n        }\n        if (((from_bitField1_ & 0x00040000) != 0)) {\n          result.enableRvolIndicator_ = enableRvolIndicator_;\n        }\n        if (((from_bitField1_ & 0x00080000) != 0)) {\n          result.enableEmaIndicator_ = enableEmaIndicator_;\n        }\n        if (((from_bitField1_ & 0x00100000) != 0)) {\n          result.enableEmaTrendFilter_ = enableEmaTrendFilter_;\n        }\n        if (((from_bitField1_ & 0x00200000) != 0)) {\n          result.macdFastPeriod_ = macdFastPeriod_;\n        }\n        if (((from_bitField1_ & 0x00400000) != 0)) {\n          result.macdSlowPeriod_ = macdSlowPeriod_;\n        }\n        if (((from_bitField1_ & 0x00800000) != 0)) {\n          result.macdSignalPeriod_ = macdSignalPeriod_;\n        }\n        if (((from_bitField1_ & 0x01000000) != 0)) {\n          result.macdHistogramRocThreshold_ = macdHistogramRocThreshold_;\n        }\n        if (((from_bitField1_ & 0x02000000) != 0)) {\n          result.stochasticPeriod_ = stochasticPeriod_;\n        }\n        if (((from_bitField1_ & 0x04000000) != 0)) {\n          result.stochasticKSmooth_ = stochasticKSmooth_;\n        }\n        if (((from_bitField1_ & 0x08000000) != 0)) {\n          result.stochasticDSmooth_ = stochasticDSmooth_;\n        }\n        if (((from_bitField1_ & 0x10000000) != 0)) {\n          result.stochasticOversoldThreshold_ = stochasticOversoldThreshold_;\n        }\n        if (((from_bitField1_ & 0x20000000) != 0)) {\n          result.stochasticOverboughtThreshold_ = stochasticOverboughtThreshold_;\n        }\n        if (((from_bitField1_ & 0x40000000) != 0)) {\n          result.rvolPeriod_ = rvolPeriod_;\n        }\n        if (((from_bitField1_ & 0x80000000) != 0)) {\n          result.rvolThreshold_ = rvolThreshold_;\n        }\n      }\n\n      private void buildPartial2(com.spiketrade.proto.ConfigProto.TradingConfig result) {\n        int from_bitField2_ = bitField2_;\n        if (((from_bitField2_ & 0x00000001) != 0)) {\n          result.ema9Period_ = ema9Period_;\n        }\n        if (((from_bitField2_ & 0x00000002) != 0)) {\n          result.ema20Period_ = ema20Period_;\n        }\n        if (((from_bitField2_ & 0x00000004) != 0)) {\n          result.ema50Period_ = ema50Period_;\n        }\n        if (((from_bitField2_ & 0x00000008) != 0)) {\n          result.volumeSpikeThreshold_ = volumeSpikeThreshold_;\n        }\n        if (((from_bitField2_ & 0x00000010) != 0)) {\n          result.timeframeMultiplier_ = timeframeMultiplier_;\n        }\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.ConfigProto.TradingConfig) {\n          return mergeFrom((com.spiketrade.proto.ConfigProto.TradingConfig)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.ConfigProto.TradingConfig other) {\n        if (other == com.spiketrade.proto.ConfigProto.TradingConfig.getDefaultInstance()) return this;\n        if (other.getBuyPeriodMinutes() != 0) {\n          setBuyPeriodMinutes(other.getBuyPeriodMinutes());\n        }\n        if (other.getBbLengthMinutes() != 0) {\n          setBbLengthMinutes(other.getBbLengthMinutes());\n        }\n        if (other.getRsiLengthMinutes() != 0) {\n          setRsiLengthMinutes(other.getRsiLengthMinutes());\n        }\n        if (other.getPriceRocPeriodMinutes() != 0) {\n          setPriceRocPeriodMinutes(other.getPriceRocPeriodMinutes());\n        }\n        if (other.getObvRocPeriodMinutes() != 0) {\n          setObvRocPeriodMinutes(other.getObvRocPeriodMinutes());\n        }\n        if (other.getMfiPeriodMinutes() != 0) {\n          setMfiPeriodMinutes(other.getMfiPeriodMinutes());\n        }\n        if (other.getMfiRocPeriodMinutes() != 0) {\n          setMfiRocPeriodMinutes(other.getMfiRocPeriodMinutes());\n        }\n        if (other.getVwapPeriodMinutes() != 0) {\n          setVwapPeriodMinutes(other.getVwapPeriodMinutes());\n        }\n        if (other.getDataPoints() != 0) {\n          setDataPoints(other.getDataPoints());\n        }\n        if (other.getWarmupDataPoints() != 0) {\n          setWarmupDataPoints(other.getWarmupDataPoints());\n        }\n        if (other.getSpikePriceRocZThreshold() != 0D) {\n          setSpikePriceRocZThreshold(other.getSpikePriceRocZThreshold());\n        }\n        if (other.getSpikeRsiRocZThreshold() != 0D) {\n          setSpikeRsiRocZThreshold(other.getSpikeRsiRocZThreshold());\n        }\n        if (other.getSpikeObvRocZThreshold() != 0D) {\n          setSpikeObvRocZThreshold(other.getSpikeObvRocZThreshold());\n        }\n        if (other.getSpikeMfiRocZThreshold() != 0D) {\n          setSpikeMfiRocZThreshold(other.getSpikeMfiRocZThreshold());\n        }\n        if (other.getSpikePercentBRocZThreshold() != 0D) {\n          setSpikePercentBRocZThreshold(other.getSpikePercentBRocZThreshold());\n        }\n        if (other.getSpikeVwapRocZThreshold() != 0D) {\n          setSpikeVwapRocZThreshold(other.getSpikeVwapRocZThreshold());\n        }\n        if (other.getSpikeVolumeRocZThreshold() != 0D) {\n          setSpikeVolumeRocZThreshold(other.getSpikeVolumeRocZThreshold());\n        }\n        if (other.getRegularPriceRocThreshold() != 0D) {\n          setRegularPriceRocThreshold(other.getRegularPriceRocThreshold());\n        }\n        if (other.getRegularRsiRocThreshold() != 0D) {\n          setRegularRsiRocThreshold(other.getRegularRsiRocThreshold());\n        }\n        if (other.getRegularObvRocThreshold() != 0D) {\n          setRegularObvRocThreshold(other.getRegularObvRocThreshold());\n        }\n        if (other.getRegularMfiRocThreshold() != 0D) {\n          setRegularMfiRocThreshold(other.getRegularMfiRocThreshold());\n        }\n        if (other.getRegularPercentBRocThreshold() != 0D) {\n          setRegularPercentBRocThreshold(other.getRegularPercentBRocThreshold());\n        }\n        if (other.getRegularVwapRocThreshold() != 0D) {\n          setRegularVwapRocThreshold(other.getRegularVwapRocThreshold());\n        }\n        if (other.getRegularVolumeRocThreshold() != 0D) {\n          setRegularVolumeRocThreshold(other.getRegularVolumeRocThreshold());\n        }\n        if (other.getRegularPriceRocPeriod() != 0) {\n          setRegularPriceRocPeriod(other.getRegularPriceRocPeriod());\n        }\n        if (other.getRegularRsiRocPeriod() != 0) {\n          setRegularRsiRocPeriod(other.getRegularRsiRocPeriod());\n        }\n        if (other.getRegularObvRocPeriod() != 0) {\n          setRegularObvRocPeriod(other.getRegularObvRocPeriod());\n        }\n        if (other.getRegularMfiRocPeriod() != 0) {\n          setRegularMfiRocPeriod(other.getRegularMfiRocPeriod());\n        }\n        if (other.getRegularPercentBRocPeriod() != 0) {\n          setRegularPercentBRocPeriod(other.getRegularPercentBRocPeriod());\n        }\n        if (other.getRegularVwapRocPeriod() != 0) {\n          setRegularVwapRocPeriod(other.getRegularVwapRocPeriod());\n        }\n        if (other.getRegularVolumeRocPeriod() != 0) {\n          setRegularVolumeRocPeriod(other.getRegularVolumeRocPeriod());\n        }\n        if (other.getComboSignalThreshold() != 0D) {\n          setComboSignalThreshold(other.getComboSignalThreshold());\n        }\n        if (other.getHighProbThreshold() != 0D) {\n          setHighProbThreshold(other.getHighProbThreshold());\n        }\n        if (other.getStopLossPct() != 0D) {\n          setStopLossPct(other.getStopLossPct());\n        }\n        if (other.getSpikeCooldownStddevThreshold() != 0D) {\n          setSpikeCooldownStddevThreshold(other.getSpikeCooldownStddevThreshold());\n        }\n        if (other.getEquityPerTrade() != 0D) {\n          setEquityPerTrade(other.getEquityPerTrade());\n        }\n        if (other.getMaxOpenTrades() != 0D) {\n          setMaxOpenTrades(other.getMaxOpenTrades());\n        }\n        if (other.getTotalEquityAvailable() != 0D) {\n          setTotalEquityAvailable(other.getTotalEquityAvailable());\n        }\n        if (other.getEnablePriceRocSpike() != false) {\n          setEnablePriceRocSpike(other.getEnablePriceRocSpike());\n        }\n        if (other.getEnableRsiRocSpike() != false) {\n          setEnableRsiRocSpike(other.getEnableRsiRocSpike());\n        }\n        if (other.getEnableObvRocSpike() != false) {\n          setEnableObvRocSpike(other.getEnableObvRocSpike());\n        }\n        if (other.getEnableMfiRocSpike() != false) {\n          setEnableMfiRocSpike(other.getEnableMfiRocSpike());\n        }\n        if (other.getEnablePercentBRocSpike() != false) {\n          setEnablePercentBRocSpike(other.getEnablePercentBRocSpike());\n        }\n        if (other.getEnableVwapRocSpike() != false) {\n          setEnableVwapRocSpike(other.getEnableVwapRocSpike());\n        }\n        if (other.getUseMlSpikes() != false) {\n          setUseMlSpikes(other.getUseMlSpikes());\n        }\n        if (other.getEnableCooldowns() != false) {\n          setEnableCooldowns(other.getEnableCooldowns());\n        }\n        if (other.getEnableAdxIndicator() != false) {\n          setEnableAdxIndicator(other.getEnableAdxIndicator());\n        }\n        if (other.getEnableVolumeRocSpike() != false) {\n          setEnableVolumeRocSpike(other.getEnableVolumeRocSpike());\n        }\n        if (other.getEnableMacdHistogramRoc() != false) {\n          setEnableMacdHistogramRoc(other.getEnableMacdHistogramRoc());\n        }\n        if (other.getEnableStochasticIndicator() != false) {\n          setEnableStochasticIndicator(other.getEnableStochasticIndicator());\n        }\n        if (other.getEnableRvolIndicator() != false) {\n          setEnableRvolIndicator(other.getEnableRvolIndicator());\n        }\n        if (other.getEnableEmaIndicator() != false) {\n          setEnableEmaIndicator(other.getEnableEmaIndicator());\n        }\n        if (other.getEnableEmaTrendFilter() != false) {\n          setEnableEmaTrendFilter(other.getEnableEmaTrendFilter());\n        }\n        if (other.getMacdFastPeriod() != 0) {\n          setMacdFastPeriod(other.getMacdFastPeriod());\n        }\n        if (other.getMacdSlowPeriod() != 0) {\n          setMacdSlowPeriod(other.getMacdSlowPeriod());\n        }\n        if (other.getMacdSignalPeriod() != 0) {\n          setMacdSignalPeriod(other.getMacdSignalPeriod());\n        }\n        if (other.getMacdHistogramRocThreshold() != 0D) {\n          setMacdHistogramRocThreshold(other.getMacdHistogramRocThreshold());\n        }\n        if (other.getStochasticPeriod() != 0) {\n          setStochasticPeriod(other.getStochasticPeriod());\n        }\n        if (other.getStochasticKSmooth() != 0) {\n          setStochasticKSmooth(other.getStochasticKSmooth());\n        }\n        if (other.getStochasticDSmooth() != 0) {\n          setStochasticDSmooth(other.getStochasticDSmooth());\n        }\n        if (other.getStochasticOversoldThreshold() != 0D) {\n          setStochasticOversoldThreshold(other.getStochasticOversoldThreshold());\n        }\n        if (other.getStochasticOverboughtThreshold() != 0D) {\n          setStochasticOverboughtThreshold(other.getStochasticOverboughtThreshold());\n        }\n        if (other.getRvolPeriod() != 0) {\n          setRvolPeriod(other.getRvolPeriod());\n        }\n        if (other.getRvolThreshold() != 0D) {\n          setRvolThreshold(other.getRvolThreshold());\n        }\n        if (other.getEma9Period() != 0) {\n          setEma9Period(other.getEma9Period());\n        }\n        if (other.getEma20Period() != 0) {\n          setEma20Period(other.getEma20Period());\n        }\n        if (other.getEma50Period() != 0) {\n          setEma50Period(other.getEma50Period());\n        }\n        if (other.getVolumeSpikeThreshold() != 0D) {\n          setVolumeSpikeThreshold(other.getVolumeSpikeThreshold());\n        }\n        if (other.getTimeframeMultiplier() != 0) {\n          setTimeframeMultiplier(other.getTimeframeMultiplier());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 8: {\n                buyPeriodMinutes_ = input.readInt32();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 8\n              case 16: {\n                bbLengthMinutes_ = input.readInt32();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 16\n              case 24: {\n                rsiLengthMinutes_ = input.readInt32();\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 24\n              case 32: {\n                priceRocPeriodMinutes_ = input.readInt32();\n                bitField0_ |= 0x00000008;\n                break;\n              } // case 32\n              case 40: {\n                obvRocPeriodMinutes_ = input.readInt32();\n                bitField0_ |= 0x00000010;\n                break;\n              } // case 40\n              case 48: {\n                mfiPeriodMinutes_ = input.readInt32();\n                bitField0_ |= 0x00000020;\n                break;\n              } // case 48\n              case 56: {\n                mfiRocPeriodMinutes_ = input.readInt32();\n                bitField0_ |= 0x00000040;\n                break;\n              } // case 56\n              case 64: {\n                vwapPeriodMinutes_ = input.readInt32();\n                bitField0_ |= 0x00000080;\n                break;\n              } // case 64\n              case 72: {\n                dataPoints_ = input.readInt32();\n                bitField0_ |= 0x00000100;\n                break;\n              } // case 72\n              case 80: {\n                warmupDataPoints_ = input.readInt32();\n                bitField0_ |= 0x00000200;\n                break;\n              } // case 80\n              case 161: {\n                spikePriceRocZThreshold_ = input.readDouble();\n                bitField0_ |= 0x00000400;\n                break;\n              } // case 161\n              case 169: {\n                spikeRsiRocZThreshold_ = input.readDouble();\n                bitField0_ |= 0x00000800;\n                break;\n              } // case 169\n              case 177: {\n                spikeObvRocZThreshold_ = input.readDouble();\n                bitField0_ |= 0x00001000;\n                break;\n              } // case 177\n              case 185: {\n                spikeMfiRocZThreshold_ = input.readDouble();\n                bitField0_ |= 0x00002000;\n                break;\n              } // case 185\n              case 193: {\n                spikePercentBRocZThreshold_ = input.readDouble();\n                bitField0_ |= 0x00004000;\n                break;\n              } // case 193\n              case 201: {\n                spikeVwapRocZThreshold_ = input.readDouble();\n                bitField0_ |= 0x00008000;\n                break;\n              } // case 201\n              case 209: {\n                spikeVolumeRocZThreshold_ = input.readDouble();\n                bitField0_ |= 0x00010000;\n                break;\n              } // case 209\n              case 217: {\n                comboSignalThreshold_ = input.readDouble();\n                bitField0_ |= 0x80000000;\n                break;\n              } // case 217\n              case 225: {\n                highProbThreshold_ = input.readDouble();\n                bitField1_ |= 0x00000001;\n                break;\n              } // case 225\n              case 233: {\n                stopLossPct_ = input.readDouble();\n                bitField1_ |= 0x00000002;\n                break;\n              } // case 233\n              case 241: {\n                spikeCooldownStddevThreshold_ = input.readDouble();\n                bitField1_ |= 0x00000004;\n                break;\n              } // case 241\n              case 249: {\n                regularPriceRocThreshold_ = input.readDouble();\n                bitField0_ |= 0x00020000;\n                break;\n              } // case 249\n              case 257: {\n                regularRsiRocThreshold_ = input.readDouble();\n                bitField0_ |= 0x00040000;\n                break;\n              } // case 257\n              case 265: {\n                regularObvRocThreshold_ = input.readDouble();\n                bitField0_ |= 0x00080000;\n                break;\n              } // case 265\n              case 273: {\n                regularMfiRocThreshold_ = input.readDouble();\n                bitField0_ |= 0x00100000;\n                break;\n              } // case 273\n              case 281: {\n                regularPercentBRocThreshold_ = input.readDouble();\n                bitField0_ |= 0x00200000;\n                break;\n              } // case 281\n              case 289: {\n                regularVwapRocThreshold_ = input.readDouble();\n                bitField0_ |= 0x00400000;\n                break;\n              } // case 289\n              case 297: {\n                regularVolumeRocThreshold_ = input.readDouble();\n                bitField0_ |= 0x00800000;\n                break;\n              } // case 297\n              case 321: {\n                equityPerTrade_ = input.readDouble();\n                bitField1_ |= 0x00000008;\n                break;\n              } // case 321\n              case 329: {\n                maxOpenTrades_ = input.readDouble();\n                bitField1_ |= 0x00000010;\n                break;\n              } // case 329\n              case 337: {\n                totalEquityAvailable_ = input.readDouble();\n                bitField1_ |= 0x00000020;\n                break;\n              } // case 337\n              case 400: {\n                enablePriceRocSpike_ = input.readBool();\n                bitField1_ |= 0x00000040;\n                break;\n              } // case 400\n              case 408: {\n                enableRsiRocSpike_ = input.readBool();\n                bitField1_ |= 0x00000080;\n                break;\n              } // case 408\n              case 416: {\n                enableObvRocSpike_ = input.readBool();\n                bitField1_ |= 0x00000100;\n                break;\n              } // case 416\n              case 424: {\n                enableMfiRocSpike_ = input.readBool();\n                bitField1_ |= 0x00000200;\n                break;\n              } // case 424\n              case 432: {\n                enablePercentBRocSpike_ = input.readBool();\n                bitField1_ |= 0x00000400;\n                break;\n              } // case 432\n              case 440: {\n                enableVwapRocSpike_ = input.readBool();\n                bitField1_ |= 0x00000800;\n                break;\n              } // case 440\n              case 448: {\n                useMlSpikes_ = input.readBool();\n                bitField1_ |= 0x00001000;\n                break;\n              } // case 448\n              case 456: {\n                enableCooldowns_ = input.readBool();\n                bitField1_ |= 0x00002000;\n                break;\n              } // case 456\n              case 464: {\n                enableAdxIndicator_ = input.readBool();\n                bitField1_ |= 0x00004000;\n                break;\n              } // case 464\n              case 472: {\n                enableVolumeRocSpike_ = input.readBool();\n                bitField1_ |= 0x00008000;\n                break;\n              } // case 472\n              case 480: {\n                regularPriceRocPeriod_ = input.readInt32();\n                bitField0_ |= 0x01000000;\n                break;\n              } // case 480\n              case 488: {\n                regularRsiRocPeriod_ = input.readInt32();\n                bitField0_ |= 0x02000000;\n                break;\n              } // case 488\n              case 496: {\n                regularObvRocPeriod_ = input.readInt32();\n                bitField0_ |= 0x04000000;\n                break;\n              } // case 496\n              case 504: {\n                regularMfiRocPeriod_ = input.readInt32();\n                bitField0_ |= 0x08000000;\n                break;\n              } // case 504\n              case 512: {\n                regularPercentBRocPeriod_ = input.readInt32();\n                bitField0_ |= 0x10000000;\n                break;\n              } // case 512\n              case 520: {\n                regularVwapRocPeriod_ = input.readInt32();\n                bitField0_ |= 0x20000000;\n                break;\n              } // case 520\n              case 528: {\n                regularVolumeRocPeriod_ = input.readInt32();\n                bitField0_ |= 0x40000000;\n                break;\n              } // case 528\n              case 560: {\n                enableMacdHistogramRoc_ = input.readBool();\n                bitField1_ |= 0x00010000;\n                break;\n              } // case 560\n              case 568: {\n                enableStochasticIndicator_ = input.readBool();\n                bitField1_ |= 0x00020000;\n                break;\n              } // case 568\n              case 576: {\n                enableRvolIndicator_ = input.readBool();\n                bitField1_ |= 0x00040000;\n                break;\n              } // case 576\n              case 584: {\n                enableEmaIndicator_ = input.readBool();\n                bitField1_ |= 0x00080000;\n                break;\n              } // case 584\n              case 592: {\n                enableEmaTrendFilter_ = input.readBool();\n                bitField1_ |= 0x00100000;\n                break;\n              } // case 592\n              case 640: {\n                macdFastPeriod_ = input.readInt32();\n                bitField1_ |= 0x00200000;\n                break;\n              } // case 640\n              case 648: {\n                macdSlowPeriod_ = input.readInt32();\n                bitField1_ |= 0x00400000;\n                break;\n              } // case 648\n              case 656: {\n                macdSignalPeriod_ = input.readInt32();\n                bitField1_ |= 0x00800000;\n                break;\n              } // case 656\n              case 665: {\n                macdHistogramRocThreshold_ = input.readDouble();\n                bitField1_ |= 0x01000000;\n                break;\n              } // case 665\n              case 680: {\n                stochasticPeriod_ = input.readInt32();\n                bitField1_ |= 0x02000000;\n                break;\n              } // case 680\n              case 688: {\n                stochasticKSmooth_ = input.readInt32();\n                bitField1_ |= 0x04000000;\n                break;\n              } // case 688\n              case 696: {\n                stochasticDSmooth_ = input.readInt32();\n                bitField1_ |= 0x08000000;\n                break;\n              } // case 696\n              case 705: {\n                stochasticOversoldThreshold_ = input.readDouble();\n                bitField1_ |= 0x10000000;\n                break;\n              } // case 705\n              case 713: {\n                stochasticOverboughtThreshold_ = input.readDouble();\n                bitField1_ |= 0x20000000;\n                break;\n              } // case 713\n              case 720: {\n                rvolPeriod_ = input.readInt32();\n                bitField1_ |= 0x40000000;\n                break;\n              } // case 720\n              case 729: {\n                rvolThreshold_ = input.readDouble();\n                bitField1_ |= 0x80000000;\n                break;\n              } // case 729\n              case 760: {\n                ema9Period_ = input.readInt32();\n                bitField2_ |= 0x00000001;\n                break;\n              } // case 760\n              case 768: {\n                ema20Period_ = input.readInt32();\n                bitField2_ |= 0x00000002;\n                break;\n              } // case 768\n              case 776: {\n                ema50Period_ = input.readInt32();\n                bitField2_ |= 0x00000004;\n                break;\n              } // case 776\n              case 785: {\n                volumeSpikeThreshold_ = input.readDouble();\n                bitField2_ |= 0x00000008;\n                break;\n              } // case 785\n              case 792: {\n                timeframeMultiplier_ = input.readInt32();\n                bitField2_ |= 0x00000010;\n                break;\n              } // case 792\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n      private int bitField1_;\n      private int bitField2_;\n\n      private int buyPeriodMinutes_ ;\n      /**\n       * <pre>\n       * Window parameters\n       * </pre>\n       *\n       * <code>int32 buy_period_minutes = 1;</code>\n       * @return The buyPeriodMinutes.\n       */\n      @java.lang.Override\n      public int getBuyPeriodMinutes() {\n        return buyPeriodMinutes_;\n      }\n      /**\n       * <pre>\n       * Window parameters\n       * </pre>\n       *\n       * <code>int32 buy_period_minutes = 1;</code>\n       * @param value The buyPeriodMinutes to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBuyPeriodMinutes(int value) {\n\n        buyPeriodMinutes_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Window parameters\n       * </pre>\n       *\n       * <code>int32 buy_period_minutes = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBuyPeriodMinutes() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        buyPeriodMinutes_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int bbLengthMinutes_ ;\n      /**\n       * <code>int32 bb_length_minutes = 2;</code>\n       * @return The bbLengthMinutes.\n       */\n      @java.lang.Override\n      public int getBbLengthMinutes() {\n        return bbLengthMinutes_;\n      }\n      /**\n       * <code>int32 bb_length_minutes = 2;</code>\n       * @param value The bbLengthMinutes to set.\n       * @return This builder for chaining.\n       */\n      public Builder setBbLengthMinutes(int value) {\n\n        bbLengthMinutes_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 bb_length_minutes = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearBbLengthMinutes() {\n        bitField0_ = (bitField0_ & ~0x00000002);\n        bbLengthMinutes_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int rsiLengthMinutes_ ;\n      /**\n       * <code>int32 rsi_length_minutes = 3;</code>\n       * @return The rsiLengthMinutes.\n       */\n      @java.lang.Override\n      public int getRsiLengthMinutes() {\n        return rsiLengthMinutes_;\n      }\n      /**\n       * <code>int32 rsi_length_minutes = 3;</code>\n       * @param value The rsiLengthMinutes to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRsiLengthMinutes(int value) {\n\n        rsiLengthMinutes_ = value;\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 rsi_length_minutes = 3;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRsiLengthMinutes() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        rsiLengthMinutes_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int priceRocPeriodMinutes_ ;\n      /**\n       * <code>int32 price_roc_period_minutes = 4;</code>\n       * @return The priceRocPeriodMinutes.\n       */\n      @java.lang.Override\n      public int getPriceRocPeriodMinutes() {\n        return priceRocPeriodMinutes_;\n      }\n      /**\n       * <code>int32 price_roc_period_minutes = 4;</code>\n       * @param value The priceRocPeriodMinutes to set.\n       * @return This builder for chaining.\n       */\n      public Builder setPriceRocPeriodMinutes(int value) {\n\n        priceRocPeriodMinutes_ = value;\n        bitField0_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 price_roc_period_minutes = 4;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearPriceRocPeriodMinutes() {\n        bitField0_ = (bitField0_ & ~0x00000008);\n        priceRocPeriodMinutes_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int obvRocPeriodMinutes_ ;\n      /**\n       * <code>int32 obv_roc_period_minutes = 5;</code>\n       * @return The obvRocPeriodMinutes.\n       */\n      @java.lang.Override\n      public int getObvRocPeriodMinutes() {\n        return obvRocPeriodMinutes_;\n      }\n      /**\n       * <code>int32 obv_roc_period_minutes = 5;</code>\n       * @param value The obvRocPeriodMinutes to set.\n       * @return This builder for chaining.\n       */\n      public Builder setObvRocPeriodMinutes(int value) {\n\n        obvRocPeriodMinutes_ = value;\n        bitField0_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 obv_roc_period_minutes = 5;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearObvRocPeriodMinutes() {\n        bitField0_ = (bitField0_ & ~0x00000010);\n        obvRocPeriodMinutes_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int mfiPeriodMinutes_ ;\n      /**\n       * <code>int32 mfi_period_minutes = 6;</code>\n       * @return The mfiPeriodMinutes.\n       */\n      @java.lang.Override\n      public int getMfiPeriodMinutes() {\n        return mfiPeriodMinutes_;\n      }\n      /**\n       * <code>int32 mfi_period_minutes = 6;</code>\n       * @param value The mfiPeriodMinutes to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMfiPeriodMinutes(int value) {\n\n        mfiPeriodMinutes_ = value;\n        bitField0_ |= 0x00000020;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 mfi_period_minutes = 6;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMfiPeriodMinutes() {\n        bitField0_ = (bitField0_ & ~0x00000020);\n        mfiPeriodMinutes_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int mfiRocPeriodMinutes_ ;\n      /**\n       * <code>int32 mfi_roc_period_minutes = 7;</code>\n       * @return The mfiRocPeriodMinutes.\n       */\n      @java.lang.Override\n      public int getMfiRocPeriodMinutes() {\n        return mfiRocPeriodMinutes_;\n      }\n      /**\n       * <code>int32 mfi_roc_period_minutes = 7;</code>\n       * @param value The mfiRocPeriodMinutes to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMfiRocPeriodMinutes(int value) {\n\n        mfiRocPeriodMinutes_ = value;\n        bitField0_ |= 0x00000040;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 mfi_roc_period_minutes = 7;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMfiRocPeriodMinutes() {\n        bitField0_ = (bitField0_ & ~0x00000040);\n        mfiRocPeriodMinutes_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int vwapPeriodMinutes_ ;\n      /**\n       * <code>int32 vwap_period_minutes = 8;</code>\n       * @return The vwapPeriodMinutes.\n       */\n      @java.lang.Override\n      public int getVwapPeriodMinutes() {\n        return vwapPeriodMinutes_;\n      }\n      /**\n       * <code>int32 vwap_period_minutes = 8;</code>\n       * @param value The vwapPeriodMinutes to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVwapPeriodMinutes(int value) {\n\n        vwapPeriodMinutes_ = value;\n        bitField0_ |= 0x00000080;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 vwap_period_minutes = 8;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVwapPeriodMinutes() {\n        bitField0_ = (bitField0_ & ~0x00000080);\n        vwapPeriodMinutes_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int dataPoints_ ;\n      /**\n       * <code>int32 data_points = 9;</code>\n       * @return The dataPoints.\n       */\n      @java.lang.Override\n      public int getDataPoints() {\n        return dataPoints_;\n      }\n      /**\n       * <code>int32 data_points = 9;</code>\n       * @param value The dataPoints to set.\n       * @return This builder for chaining.\n       */\n      public Builder setDataPoints(int value) {\n\n        dataPoints_ = value;\n        bitField0_ |= 0x00000100;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 data_points = 9;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearDataPoints() {\n        bitField0_ = (bitField0_ & ~0x00000100);\n        dataPoints_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int warmupDataPoints_ ;\n      /**\n       * <code>int32 warmup_data_points = 10;</code>\n       * @return The warmupDataPoints.\n       */\n      @java.lang.Override\n      public int getWarmupDataPoints() {\n        return warmupDataPoints_;\n      }\n      /**\n       * <code>int32 warmup_data_points = 10;</code>\n       * @param value The warmupDataPoints to set.\n       * @return This builder for chaining.\n       */\n      public Builder setWarmupDataPoints(int value) {\n\n        warmupDataPoints_ = value;\n        bitField0_ |= 0x00000200;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 warmup_data_points = 10;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearWarmupDataPoints() {\n        bitField0_ = (bitField0_ & ~0x00000200);\n        warmupDataPoints_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private double spikePriceRocZThreshold_ ;\n      /**\n       * <pre>\n       * Spike ROC Threshold parameters (Z-score based)\n       * </pre>\n       *\n       * <code>double spike_price_roc_z_threshold = 20;</code>\n       * @return The spikePriceRocZThreshold.\n       */\n      @java.lang.Override\n      public double getSpikePriceRocZThreshold() {\n        return spikePriceRocZThreshold_;\n      }\n      /**\n       * <pre>\n       * Spike ROC Threshold parameters (Z-score based)\n       * </pre>\n       *\n       * <code>double spike_price_roc_z_threshold = 20;</code>\n       * @param value The spikePriceRocZThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSpikePriceRocZThreshold(double value) {\n\n        spikePriceRocZThreshold_ = value;\n        bitField0_ |= 0x00000400;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Spike ROC Threshold parameters (Z-score based)\n       * </pre>\n       *\n       * <code>double spike_price_roc_z_threshold = 20;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSpikePriceRocZThreshold() {\n        bitField0_ = (bitField0_ & ~0x00000400);\n        spikePriceRocZThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double spikeRsiRocZThreshold_ ;\n      /**\n       * <code>double spike_rsi_roc_z_threshold = 21;</code>\n       * @return The spikeRsiRocZThreshold.\n       */\n      @java.lang.Override\n      public double getSpikeRsiRocZThreshold() {\n        return spikeRsiRocZThreshold_;\n      }\n      /**\n       * <code>double spike_rsi_roc_z_threshold = 21;</code>\n       * @param value The spikeRsiRocZThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSpikeRsiRocZThreshold(double value) {\n\n        spikeRsiRocZThreshold_ = value;\n        bitField0_ |= 0x00000800;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double spike_rsi_roc_z_threshold = 21;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSpikeRsiRocZThreshold() {\n        bitField0_ = (bitField0_ & ~0x00000800);\n        spikeRsiRocZThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double spikeObvRocZThreshold_ ;\n      /**\n       * <code>double spike_obv_roc_z_threshold = 22;</code>\n       * @return The spikeObvRocZThreshold.\n       */\n      @java.lang.Override\n      public double getSpikeObvRocZThreshold() {\n        return spikeObvRocZThreshold_;\n      }\n      /**\n       * <code>double spike_obv_roc_z_threshold = 22;</code>\n       * @param value The spikeObvRocZThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSpikeObvRocZThreshold(double value) {\n\n        spikeObvRocZThreshold_ = value;\n        bitField0_ |= 0x00001000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double spike_obv_roc_z_threshold = 22;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSpikeObvRocZThreshold() {\n        bitField0_ = (bitField0_ & ~0x00001000);\n        spikeObvRocZThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double spikeMfiRocZThreshold_ ;\n      /**\n       * <code>double spike_mfi_roc_z_threshold = 23;</code>\n       * @return The spikeMfiRocZThreshold.\n       */\n      @java.lang.Override\n      public double getSpikeMfiRocZThreshold() {\n        return spikeMfiRocZThreshold_;\n      }\n      /**\n       * <code>double spike_mfi_roc_z_threshold = 23;</code>\n       * @param value The spikeMfiRocZThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSpikeMfiRocZThreshold(double value) {\n\n        spikeMfiRocZThreshold_ = value;\n        bitField0_ |= 0x00002000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double spike_mfi_roc_z_threshold = 23;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSpikeMfiRocZThreshold() {\n        bitField0_ = (bitField0_ & ~0x00002000);\n        spikeMfiRocZThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double spikePercentBRocZThreshold_ ;\n      /**\n       * <code>double spike_percent_b_roc_z_threshold = 24;</code>\n       * @return The spikePercentBRocZThreshold.\n       */\n      @java.lang.Override\n      public double getSpikePercentBRocZThreshold() {\n        return spikePercentBRocZThreshold_;\n      }\n      /**\n       * <code>double spike_percent_b_roc_z_threshold = 24;</code>\n       * @param value The spikePercentBRocZThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSpikePercentBRocZThreshold(double value) {\n\n        spikePercentBRocZThreshold_ = value;\n        bitField0_ |= 0x00004000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double spike_percent_b_roc_z_threshold = 24;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSpikePercentBRocZThreshold() {\n        bitField0_ = (bitField0_ & ~0x00004000);\n        spikePercentBRocZThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double spikeVwapRocZThreshold_ ;\n      /**\n       * <code>double spike_vwap_roc_z_threshold = 25;</code>\n       * @return The spikeVwapRocZThreshold.\n       */\n      @java.lang.Override\n      public double getSpikeVwapRocZThreshold() {\n        return spikeVwapRocZThreshold_;\n      }\n      /**\n       * <code>double spike_vwap_roc_z_threshold = 25;</code>\n       * @param value The spikeVwapRocZThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSpikeVwapRocZThreshold(double value) {\n\n        spikeVwapRocZThreshold_ = value;\n        bitField0_ |= 0x00008000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double spike_vwap_roc_z_threshold = 25;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSpikeVwapRocZThreshold() {\n        bitField0_ = (bitField0_ & ~0x00008000);\n        spikeVwapRocZThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double spikeVolumeRocZThreshold_ ;\n      /**\n       * <code>double spike_volume_roc_z_threshold = 26;</code>\n       * @return The spikeVolumeRocZThreshold.\n       */\n      @java.lang.Override\n      public double getSpikeVolumeRocZThreshold() {\n        return spikeVolumeRocZThreshold_;\n      }\n      /**\n       * <code>double spike_volume_roc_z_threshold = 26;</code>\n       * @param value The spikeVolumeRocZThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSpikeVolumeRocZThreshold(double value) {\n\n        spikeVolumeRocZThreshold_ = value;\n        bitField0_ |= 0x00010000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double spike_volume_roc_z_threshold = 26;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSpikeVolumeRocZThreshold() {\n        bitField0_ = (bitField0_ & ~0x00010000);\n        spikeVolumeRocZThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double regularPriceRocThreshold_ ;\n      /**\n       * <pre>\n       * Regular ROC Threshold parameters (absolute %)\n       * </pre>\n       *\n       * <code>double regular_price_roc_threshold = 31;</code>\n       * @return The regularPriceRocThreshold.\n       */\n      @java.lang.Override\n      public double getRegularPriceRocThreshold() {\n        return regularPriceRocThreshold_;\n      }\n      /**\n       * <pre>\n       * Regular ROC Threshold parameters (absolute %)\n       * </pre>\n       *\n       * <code>double regular_price_roc_threshold = 31;</code>\n       * @param value The regularPriceRocThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularPriceRocThreshold(double value) {\n\n        regularPriceRocThreshold_ = value;\n        bitField0_ |= 0x00020000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Regular ROC Threshold parameters (absolute %)\n       * </pre>\n       *\n       * <code>double regular_price_roc_threshold = 31;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularPriceRocThreshold() {\n        bitField0_ = (bitField0_ & ~0x00020000);\n        regularPriceRocThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double regularRsiRocThreshold_ ;\n      /**\n       * <code>double regular_rsi_roc_threshold = 32;</code>\n       * @return The regularRsiRocThreshold.\n       */\n      @java.lang.Override\n      public double getRegularRsiRocThreshold() {\n        return regularRsiRocThreshold_;\n      }\n      /**\n       * <code>double regular_rsi_roc_threshold = 32;</code>\n       * @param value The regularRsiRocThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularRsiRocThreshold(double value) {\n\n        regularRsiRocThreshold_ = value;\n        bitField0_ |= 0x00040000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double regular_rsi_roc_threshold = 32;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularRsiRocThreshold() {\n        bitField0_ = (bitField0_ & ~0x00040000);\n        regularRsiRocThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double regularObvRocThreshold_ ;\n      /**\n       * <code>double regular_obv_roc_threshold = 33;</code>\n       * @return The regularObvRocThreshold.\n       */\n      @java.lang.Override\n      public double getRegularObvRocThreshold() {\n        return regularObvRocThreshold_;\n      }\n      /**\n       * <code>double regular_obv_roc_threshold = 33;</code>\n       * @param value The regularObvRocThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularObvRocThreshold(double value) {\n\n        regularObvRocThreshold_ = value;\n        bitField0_ |= 0x00080000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double regular_obv_roc_threshold = 33;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularObvRocThreshold() {\n        bitField0_ = (bitField0_ & ~0x00080000);\n        regularObvRocThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double regularMfiRocThreshold_ ;\n      /**\n       * <code>double regular_mfi_roc_threshold = 34;</code>\n       * @return The regularMfiRocThreshold.\n       */\n      @java.lang.Override\n      public double getRegularMfiRocThreshold() {\n        return regularMfiRocThreshold_;\n      }\n      /**\n       * <code>double regular_mfi_roc_threshold = 34;</code>\n       * @param value The regularMfiRocThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularMfiRocThreshold(double value) {\n\n        regularMfiRocThreshold_ = value;\n        bitField0_ |= 0x00100000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double regular_mfi_roc_threshold = 34;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularMfiRocThreshold() {\n        bitField0_ = (bitField0_ & ~0x00100000);\n        regularMfiRocThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double regularPercentBRocThreshold_ ;\n      /**\n       * <code>double regular_percent_b_roc_threshold = 35;</code>\n       * @return The regularPercentBRocThreshold.\n       */\n      @java.lang.Override\n      public double getRegularPercentBRocThreshold() {\n        return regularPercentBRocThreshold_;\n      }\n      /**\n       * <code>double regular_percent_b_roc_threshold = 35;</code>\n       * @param value The regularPercentBRocThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularPercentBRocThreshold(double value) {\n\n        regularPercentBRocThreshold_ = value;\n        bitField0_ |= 0x00200000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double regular_percent_b_roc_threshold = 35;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularPercentBRocThreshold() {\n        bitField0_ = (bitField0_ & ~0x00200000);\n        regularPercentBRocThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double regularVwapRocThreshold_ ;\n      /**\n       * <code>double regular_vwap_roc_threshold = 36;</code>\n       * @return The regularVwapRocThreshold.\n       */\n      @java.lang.Override\n      public double getRegularVwapRocThreshold() {\n        return regularVwapRocThreshold_;\n      }\n      /**\n       * <code>double regular_vwap_roc_threshold = 36;</code>\n       * @param value The regularVwapRocThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularVwapRocThreshold(double value) {\n\n        regularVwapRocThreshold_ = value;\n        bitField0_ |= 0x00400000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double regular_vwap_roc_threshold = 36;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularVwapRocThreshold() {\n        bitField0_ = (bitField0_ & ~0x00400000);\n        regularVwapRocThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double regularVolumeRocThreshold_ ;\n      /**\n       * <code>double regular_volume_roc_threshold = 37;</code>\n       * @return The regularVolumeRocThreshold.\n       */\n      @java.lang.Override\n      public double getRegularVolumeRocThreshold() {\n        return regularVolumeRocThreshold_;\n      }\n      /**\n       * <code>double regular_volume_roc_threshold = 37;</code>\n       * @param value The regularVolumeRocThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularVolumeRocThreshold(double value) {\n\n        regularVolumeRocThreshold_ = value;\n        bitField0_ |= 0x00800000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double regular_volume_roc_threshold = 37;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularVolumeRocThreshold() {\n        bitField0_ = (bitField0_ & ~0x00800000);\n        regularVolumeRocThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private int regularPriceRocPeriod_ ;\n      /**\n       * <pre>\n       * Regular ROC Period parameters (minutes)\n       * </pre>\n       *\n       * <code>int32 regular_price_roc_period = 60;</code>\n       * @return The regularPriceRocPeriod.\n       */\n      @java.lang.Override\n      public int getRegularPriceRocPeriod() {\n        return regularPriceRocPeriod_;\n      }\n      /**\n       * <pre>\n       * Regular ROC Period parameters (minutes)\n       * </pre>\n       *\n       * <code>int32 regular_price_roc_period = 60;</code>\n       * @param value The regularPriceRocPeriod to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularPriceRocPeriod(int value) {\n\n        regularPriceRocPeriod_ = value;\n        bitField0_ |= 0x01000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Regular ROC Period parameters (minutes)\n       * </pre>\n       *\n       * <code>int32 regular_price_roc_period = 60;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularPriceRocPeriod() {\n        bitField0_ = (bitField0_ & ~0x01000000);\n        regularPriceRocPeriod_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int regularRsiRocPeriod_ ;\n      /**\n       * <code>int32 regular_rsi_roc_period = 61;</code>\n       * @return The regularRsiRocPeriod.\n       */\n      @java.lang.Override\n      public int getRegularRsiRocPeriod() {\n        return regularRsiRocPeriod_;\n      }\n      /**\n       * <code>int32 regular_rsi_roc_period = 61;</code>\n       * @param value The regularRsiRocPeriod to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularRsiRocPeriod(int value) {\n\n        regularRsiRocPeriod_ = value;\n        bitField0_ |= 0x02000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 regular_rsi_roc_period = 61;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularRsiRocPeriod() {\n        bitField0_ = (bitField0_ & ~0x02000000);\n        regularRsiRocPeriod_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int regularObvRocPeriod_ ;\n      /**\n       * <code>int32 regular_obv_roc_period = 62;</code>\n       * @return The regularObvRocPeriod.\n       */\n      @java.lang.Override\n      public int getRegularObvRocPeriod() {\n        return regularObvRocPeriod_;\n      }\n      /**\n       * <code>int32 regular_obv_roc_period = 62;</code>\n       * @param value The regularObvRocPeriod to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularObvRocPeriod(int value) {\n\n        regularObvRocPeriod_ = value;\n        bitField0_ |= 0x04000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 regular_obv_roc_period = 62;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularObvRocPeriod() {\n        bitField0_ = (bitField0_ & ~0x04000000);\n        regularObvRocPeriod_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int regularMfiRocPeriod_ ;\n      /**\n       * <code>int32 regular_mfi_roc_period = 63;</code>\n       * @return The regularMfiRocPeriod.\n       */\n      @java.lang.Override\n      public int getRegularMfiRocPeriod() {\n        return regularMfiRocPeriod_;\n      }\n      /**\n       * <code>int32 regular_mfi_roc_period = 63;</code>\n       * @param value The regularMfiRocPeriod to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularMfiRocPeriod(int value) {\n\n        regularMfiRocPeriod_ = value;\n        bitField0_ |= 0x08000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 regular_mfi_roc_period = 63;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularMfiRocPeriod() {\n        bitField0_ = (bitField0_ & ~0x08000000);\n        regularMfiRocPeriod_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int regularPercentBRocPeriod_ ;\n      /**\n       * <code>int32 regular_percent_b_roc_period = 64;</code>\n       * @return The regularPercentBRocPeriod.\n       */\n      @java.lang.Override\n      public int getRegularPercentBRocPeriod() {\n        return regularPercentBRocPeriod_;\n      }\n      /**\n       * <code>int32 regular_percent_b_roc_period = 64;</code>\n       * @param value The regularPercentBRocPeriod to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularPercentBRocPeriod(int value) {\n\n        regularPercentBRocPeriod_ = value;\n        bitField0_ |= 0x10000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 regular_percent_b_roc_period = 64;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularPercentBRocPeriod() {\n        bitField0_ = (bitField0_ & ~0x10000000);\n        regularPercentBRocPeriod_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int regularVwapRocPeriod_ ;\n      /**\n       * <code>int32 regular_vwap_roc_period = 65;</code>\n       * @return The regularVwapRocPeriod.\n       */\n      @java.lang.Override\n      public int getRegularVwapRocPeriod() {\n        return regularVwapRocPeriod_;\n      }\n      /**\n       * <code>int32 regular_vwap_roc_period = 65;</code>\n       * @param value The regularVwapRocPeriod to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularVwapRocPeriod(int value) {\n\n        regularVwapRocPeriod_ = value;\n        bitField0_ |= 0x20000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 regular_vwap_roc_period = 65;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularVwapRocPeriod() {\n        bitField0_ = (bitField0_ & ~0x20000000);\n        regularVwapRocPeriod_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int regularVolumeRocPeriod_ ;\n      /**\n       * <code>int32 regular_volume_roc_period = 66;</code>\n       * @return The regularVolumeRocPeriod.\n       */\n      @java.lang.Override\n      public int getRegularVolumeRocPeriod() {\n        return regularVolumeRocPeriod_;\n      }\n      /**\n       * <code>int32 regular_volume_roc_period = 66;</code>\n       * @param value The regularVolumeRocPeriod to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRegularVolumeRocPeriod(int value) {\n\n        regularVolumeRocPeriod_ = value;\n        bitField0_ |= 0x40000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 regular_volume_roc_period = 66;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRegularVolumeRocPeriod() {\n        bitField0_ = (bitField0_ & ~0x40000000);\n        regularVolumeRocPeriod_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private double comboSignalThreshold_ ;\n      /**\n       * <code>double combo_signal_threshold = 27;</code>\n       * @return The comboSignalThreshold.\n       */\n      @java.lang.Override\n      public double getComboSignalThreshold() {\n        return comboSignalThreshold_;\n      }\n      /**\n       * <code>double combo_signal_threshold = 27;</code>\n       * @param value The comboSignalThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setComboSignalThreshold(double value) {\n\n        comboSignalThreshold_ = value;\n        bitField0_ |= 0x80000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double combo_signal_threshold = 27;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearComboSignalThreshold() {\n        bitField0_ = (bitField0_ & ~0x80000000);\n        comboSignalThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double highProbThreshold_ ;\n      /**\n       * <code>double high_prob_threshold = 28;</code>\n       * @return The highProbThreshold.\n       */\n      @java.lang.Override\n      public double getHighProbThreshold() {\n        return highProbThreshold_;\n      }\n      /**\n       * <code>double high_prob_threshold = 28;</code>\n       * @param value The highProbThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setHighProbThreshold(double value) {\n\n        highProbThreshold_ = value;\n        bitField1_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double high_prob_threshold = 28;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearHighProbThreshold() {\n        bitField1_ = (bitField1_ & ~0x00000001);\n        highProbThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double stopLossPct_ ;\n      /**\n       * <code>double stop_loss_pct = 29;</code>\n       * @return The stopLossPct.\n       */\n      @java.lang.Override\n      public double getStopLossPct() {\n        return stopLossPct_;\n      }\n      /**\n       * <code>double stop_loss_pct = 29;</code>\n       * @param value The stopLossPct to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStopLossPct(double value) {\n\n        stopLossPct_ = value;\n        bitField1_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double stop_loss_pct = 29;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStopLossPct() {\n        bitField1_ = (bitField1_ & ~0x00000002);\n        stopLossPct_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double spikeCooldownStddevThreshold_ ;\n      /**\n       * <code>double spike_cooldown_stddev_threshold = 30;</code>\n       * @return The spikeCooldownStddevThreshold.\n       */\n      @java.lang.Override\n      public double getSpikeCooldownStddevThreshold() {\n        return spikeCooldownStddevThreshold_;\n      }\n      /**\n       * <code>double spike_cooldown_stddev_threshold = 30;</code>\n       * @param value The spikeCooldownStddevThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSpikeCooldownStddevThreshold(double value) {\n\n        spikeCooldownStddevThreshold_ = value;\n        bitField1_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double spike_cooldown_stddev_threshold = 30;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSpikeCooldownStddevThreshold() {\n        bitField1_ = (bitField1_ & ~0x00000004);\n        spikeCooldownStddevThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double equityPerTrade_ ;\n      /**\n       * <pre>\n       * Trading parameters\n       * </pre>\n       *\n       * <code>double equity_per_trade = 40;</code>\n       * @return The equityPerTrade.\n       */\n      @java.lang.Override\n      public double getEquityPerTrade() {\n        return equityPerTrade_;\n      }\n      /**\n       * <pre>\n       * Trading parameters\n       * </pre>\n       *\n       * <code>double equity_per_trade = 40;</code>\n       * @param value The equityPerTrade to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEquityPerTrade(double value) {\n\n        equityPerTrade_ = value;\n        bitField1_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Trading parameters\n       * </pre>\n       *\n       * <code>double equity_per_trade = 40;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEquityPerTrade() {\n        bitField1_ = (bitField1_ & ~0x00000008);\n        equityPerTrade_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double maxOpenTrades_ ;\n      /**\n       * <code>double max_open_trades = 41;</code>\n       * @return The maxOpenTrades.\n       */\n      @java.lang.Override\n      public double getMaxOpenTrades() {\n        return maxOpenTrades_;\n      }\n      /**\n       * <code>double max_open_trades = 41;</code>\n       * @param value The maxOpenTrades to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMaxOpenTrades(double value) {\n\n        maxOpenTrades_ = value;\n        bitField1_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double max_open_trades = 41;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMaxOpenTrades() {\n        bitField1_ = (bitField1_ & ~0x00000010);\n        maxOpenTrades_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double totalEquityAvailable_ ;\n      /**\n       * <code>double total_equity_available = 42;</code>\n       * @return The totalEquityAvailable.\n       */\n      @java.lang.Override\n      public double getTotalEquityAvailable() {\n        return totalEquityAvailable_;\n      }\n      /**\n       * <code>double total_equity_available = 42;</code>\n       * @param value The totalEquityAvailable to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTotalEquityAvailable(double value) {\n\n        totalEquityAvailable_ = value;\n        bitField1_ |= 0x00000020;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double total_equity_available = 42;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTotalEquityAvailable() {\n        bitField1_ = (bitField1_ & ~0x00000020);\n        totalEquityAvailable_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private boolean enablePriceRocSpike_ ;\n      /**\n       * <pre>\n       * Boolean flags\n       * </pre>\n       *\n       * <code>bool enable_price_roc_spike = 50;</code>\n       * @return The enablePriceRocSpike.\n       */\n      @java.lang.Override\n      public boolean getEnablePriceRocSpike() {\n        return enablePriceRocSpike_;\n      }\n      /**\n       * <pre>\n       * Boolean flags\n       * </pre>\n       *\n       * <code>bool enable_price_roc_spike = 50;</code>\n       * @param value The enablePriceRocSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnablePriceRocSpike(boolean value) {\n\n        enablePriceRocSpike_ = value;\n        bitField1_ |= 0x00000040;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Boolean flags\n       * </pre>\n       *\n       * <code>bool enable_price_roc_spike = 50;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnablePriceRocSpike() {\n        bitField1_ = (bitField1_ & ~0x00000040);\n        enablePriceRocSpike_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean enableRsiRocSpike_ ;\n      /**\n       * <code>bool enable_rsi_roc_spike = 51;</code>\n       * @return The enableRsiRocSpike.\n       */\n      @java.lang.Override\n      public boolean getEnableRsiRocSpike() {\n        return enableRsiRocSpike_;\n      }\n      /**\n       * <code>bool enable_rsi_roc_spike = 51;</code>\n       * @param value The enableRsiRocSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnableRsiRocSpike(boolean value) {\n\n        enableRsiRocSpike_ = value;\n        bitField1_ |= 0x00000080;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool enable_rsi_roc_spike = 51;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnableRsiRocSpike() {\n        bitField1_ = (bitField1_ & ~0x00000080);\n        enableRsiRocSpike_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean enableObvRocSpike_ ;\n      /**\n       * <code>bool enable_obv_roc_spike = 52;</code>\n       * @return The enableObvRocSpike.\n       */\n      @java.lang.Override\n      public boolean getEnableObvRocSpike() {\n        return enableObvRocSpike_;\n      }\n      /**\n       * <code>bool enable_obv_roc_spike = 52;</code>\n       * @param value The enableObvRocSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnableObvRocSpike(boolean value) {\n\n        enableObvRocSpike_ = value;\n        bitField1_ |= 0x00000100;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool enable_obv_roc_spike = 52;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnableObvRocSpike() {\n        bitField1_ = (bitField1_ & ~0x00000100);\n        enableObvRocSpike_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean enableMfiRocSpike_ ;\n      /**\n       * <code>bool enable_mfi_roc_spike = 53;</code>\n       * @return The enableMfiRocSpike.\n       */\n      @java.lang.Override\n      public boolean getEnableMfiRocSpike() {\n        return enableMfiRocSpike_;\n      }\n      /**\n       * <code>bool enable_mfi_roc_spike = 53;</code>\n       * @param value The enableMfiRocSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnableMfiRocSpike(boolean value) {\n\n        enableMfiRocSpike_ = value;\n        bitField1_ |= 0x00000200;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool enable_mfi_roc_spike = 53;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnableMfiRocSpike() {\n        bitField1_ = (bitField1_ & ~0x00000200);\n        enableMfiRocSpike_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean enablePercentBRocSpike_ ;\n      /**\n       * <code>bool enable_percent_b_roc_spike = 54;</code>\n       * @return The enablePercentBRocSpike.\n       */\n      @java.lang.Override\n      public boolean getEnablePercentBRocSpike() {\n        return enablePercentBRocSpike_;\n      }\n      /**\n       * <code>bool enable_percent_b_roc_spike = 54;</code>\n       * @param value The enablePercentBRocSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnablePercentBRocSpike(boolean value) {\n\n        enablePercentBRocSpike_ = value;\n        bitField1_ |= 0x00000400;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool enable_percent_b_roc_spike = 54;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnablePercentBRocSpike() {\n        bitField1_ = (bitField1_ & ~0x00000400);\n        enablePercentBRocSpike_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean enableVwapRocSpike_ ;\n      /**\n       * <code>bool enable_vwap_roc_spike = 55;</code>\n       * @return The enableVwapRocSpike.\n       */\n      @java.lang.Override\n      public boolean getEnableVwapRocSpike() {\n        return enableVwapRocSpike_;\n      }\n      /**\n       * <code>bool enable_vwap_roc_spike = 55;</code>\n       * @param value The enableVwapRocSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnableVwapRocSpike(boolean value) {\n\n        enableVwapRocSpike_ = value;\n        bitField1_ |= 0x00000800;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool enable_vwap_roc_spike = 55;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnableVwapRocSpike() {\n        bitField1_ = (bitField1_ & ~0x00000800);\n        enableVwapRocSpike_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean useMlSpikes_ ;\n      /**\n       * <code>bool use_ml_spikes = 56;</code>\n       * @return The useMlSpikes.\n       */\n      @java.lang.Override\n      public boolean getUseMlSpikes() {\n        return useMlSpikes_;\n      }\n      /**\n       * <code>bool use_ml_spikes = 56;</code>\n       * @param value The useMlSpikes to set.\n       * @return This builder for chaining.\n       */\n      public Builder setUseMlSpikes(boolean value) {\n\n        useMlSpikes_ = value;\n        bitField1_ |= 0x00001000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool use_ml_spikes = 56;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearUseMlSpikes() {\n        bitField1_ = (bitField1_ & ~0x00001000);\n        useMlSpikes_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean enableCooldowns_ ;\n      /**\n       * <code>bool enable_cooldowns = 57;</code>\n       * @return The enableCooldowns.\n       */\n      @java.lang.Override\n      public boolean getEnableCooldowns() {\n        return enableCooldowns_;\n      }\n      /**\n       * <code>bool enable_cooldowns = 57;</code>\n       * @param value The enableCooldowns to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnableCooldowns(boolean value) {\n\n        enableCooldowns_ = value;\n        bitField1_ |= 0x00002000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool enable_cooldowns = 57;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnableCooldowns() {\n        bitField1_ = (bitField1_ & ~0x00002000);\n        enableCooldowns_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean enableAdxIndicator_ ;\n      /**\n       * <code>bool enable_adx_indicator = 58;</code>\n       * @return The enableAdxIndicator.\n       */\n      @java.lang.Override\n      public boolean getEnableAdxIndicator() {\n        return enableAdxIndicator_;\n      }\n      /**\n       * <code>bool enable_adx_indicator = 58;</code>\n       * @param value The enableAdxIndicator to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnableAdxIndicator(boolean value) {\n\n        enableAdxIndicator_ = value;\n        bitField1_ |= 0x00004000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool enable_adx_indicator = 58;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnableAdxIndicator() {\n        bitField1_ = (bitField1_ & ~0x00004000);\n        enableAdxIndicator_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean enableVolumeRocSpike_ ;\n      /**\n       * <code>bool enable_volume_roc_spike = 59;</code>\n       * @return The enableVolumeRocSpike.\n       */\n      @java.lang.Override\n      public boolean getEnableVolumeRocSpike() {\n        return enableVolumeRocSpike_;\n      }\n      /**\n       * <code>bool enable_volume_roc_spike = 59;</code>\n       * @param value The enableVolumeRocSpike to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnableVolumeRocSpike(boolean value) {\n\n        enableVolumeRocSpike_ = value;\n        bitField1_ |= 0x00008000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool enable_volume_roc_spike = 59;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnableVolumeRocSpike() {\n        bitField1_ = (bitField1_ & ~0x00008000);\n        enableVolumeRocSpike_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean enableMacdHistogramRoc_ ;\n      /**\n       * <pre>\n       * NEW PENNY STOCK INDICATORS\n       * Enable/disable flags\n       * </pre>\n       *\n       * <code>bool enable_macd_histogram_roc = 70;</code>\n       * @return The enableMacdHistogramRoc.\n       */\n      @java.lang.Override\n      public boolean getEnableMacdHistogramRoc() {\n        return enableMacdHistogramRoc_;\n      }\n      /**\n       * <pre>\n       * NEW PENNY STOCK INDICATORS\n       * Enable/disable flags\n       * </pre>\n       *\n       * <code>bool enable_macd_histogram_roc = 70;</code>\n       * @param value The enableMacdHistogramRoc to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnableMacdHistogramRoc(boolean value) {\n\n        enableMacdHistogramRoc_ = value;\n        bitField1_ |= 0x00010000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * NEW PENNY STOCK INDICATORS\n       * Enable/disable flags\n       * </pre>\n       *\n       * <code>bool enable_macd_histogram_roc = 70;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnableMacdHistogramRoc() {\n        bitField1_ = (bitField1_ & ~0x00010000);\n        enableMacdHistogramRoc_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean enableStochasticIndicator_ ;\n      /**\n       * <code>bool enable_stochastic_indicator = 71;</code>\n       * @return The enableStochasticIndicator.\n       */\n      @java.lang.Override\n      public boolean getEnableStochasticIndicator() {\n        return enableStochasticIndicator_;\n      }\n      /**\n       * <code>bool enable_stochastic_indicator = 71;</code>\n       * @param value The enableStochasticIndicator to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnableStochasticIndicator(boolean value) {\n\n        enableStochasticIndicator_ = value;\n        bitField1_ |= 0x00020000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool enable_stochastic_indicator = 71;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnableStochasticIndicator() {\n        bitField1_ = (bitField1_ & ~0x00020000);\n        enableStochasticIndicator_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean enableRvolIndicator_ ;\n      /**\n       * <code>bool enable_rvol_indicator = 72;</code>\n       * @return The enableRvolIndicator.\n       */\n      @java.lang.Override\n      public boolean getEnableRvolIndicator() {\n        return enableRvolIndicator_;\n      }\n      /**\n       * <code>bool enable_rvol_indicator = 72;</code>\n       * @param value The enableRvolIndicator to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnableRvolIndicator(boolean value) {\n\n        enableRvolIndicator_ = value;\n        bitField1_ |= 0x00040000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool enable_rvol_indicator = 72;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnableRvolIndicator() {\n        bitField1_ = (bitField1_ & ~0x00040000);\n        enableRvolIndicator_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean enableEmaIndicator_ ;\n      /**\n       * <code>bool enable_ema_indicator = 73;</code>\n       * @return The enableEmaIndicator.\n       */\n      @java.lang.Override\n      public boolean getEnableEmaIndicator() {\n        return enableEmaIndicator_;\n      }\n      /**\n       * <code>bool enable_ema_indicator = 73;</code>\n       * @param value The enableEmaIndicator to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnableEmaIndicator(boolean value) {\n\n        enableEmaIndicator_ = value;\n        bitField1_ |= 0x00080000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool enable_ema_indicator = 73;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnableEmaIndicator() {\n        bitField1_ = (bitField1_ & ~0x00080000);\n        enableEmaIndicator_ = false;\n        onChanged();\n        return this;\n      }\n\n      private boolean enableEmaTrendFilter_ ;\n      /**\n       * <code>bool enable_ema_trend_filter = 74;</code>\n       * @return The enableEmaTrendFilter.\n       */\n      @java.lang.Override\n      public boolean getEnableEmaTrendFilter() {\n        return enableEmaTrendFilter_;\n      }\n      /**\n       * <code>bool enable_ema_trend_filter = 74;</code>\n       * @param value The enableEmaTrendFilter to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEnableEmaTrendFilter(boolean value) {\n\n        enableEmaTrendFilter_ = value;\n        bitField1_ |= 0x00100000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool enable_ema_trend_filter = 74;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEnableEmaTrendFilter() {\n        bitField1_ = (bitField1_ & ~0x00100000);\n        enableEmaTrendFilter_ = false;\n        onChanged();\n        return this;\n      }\n\n      private int macdFastPeriod_ ;\n      /**\n       * <pre>\n       * MACD periods (optimized for volatile 1-min candles)\n       * </pre>\n       *\n       * <code>int32 macd_fast_period = 80;</code>\n       * @return The macdFastPeriod.\n       */\n      @java.lang.Override\n      public int getMacdFastPeriod() {\n        return macdFastPeriod_;\n      }\n      /**\n       * <pre>\n       * MACD periods (optimized for volatile 1-min candles)\n       * </pre>\n       *\n       * <code>int32 macd_fast_period = 80;</code>\n       * @param value The macdFastPeriod to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMacdFastPeriod(int value) {\n\n        macdFastPeriod_ = value;\n        bitField1_ |= 0x00200000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * MACD periods (optimized for volatile 1-min candles)\n       * </pre>\n       *\n       * <code>int32 macd_fast_period = 80;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMacdFastPeriod() {\n        bitField1_ = (bitField1_ & ~0x00200000);\n        macdFastPeriod_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int macdSlowPeriod_ ;\n      /**\n       * <code>int32 macd_slow_period = 81;</code>\n       * @return The macdSlowPeriod.\n       */\n      @java.lang.Override\n      public int getMacdSlowPeriod() {\n        return macdSlowPeriod_;\n      }\n      /**\n       * <code>int32 macd_slow_period = 81;</code>\n       * @param value The macdSlowPeriod to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMacdSlowPeriod(int value) {\n\n        macdSlowPeriod_ = value;\n        bitField1_ |= 0x00400000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 macd_slow_period = 81;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMacdSlowPeriod() {\n        bitField1_ = (bitField1_ & ~0x00400000);\n        macdSlowPeriod_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int macdSignalPeriod_ ;\n      /**\n       * <code>int32 macd_signal_period = 82;</code>\n       * @return The macdSignalPeriod.\n       */\n      @java.lang.Override\n      public int getMacdSignalPeriod() {\n        return macdSignalPeriod_;\n      }\n      /**\n       * <code>int32 macd_signal_period = 82;</code>\n       * @param value The macdSignalPeriod to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMacdSignalPeriod(int value) {\n\n        macdSignalPeriod_ = value;\n        bitField1_ |= 0x00800000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 macd_signal_period = 82;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMacdSignalPeriod() {\n        bitField1_ = (bitField1_ & ~0x00800000);\n        macdSignalPeriod_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private double macdHistogramRocThreshold_ ;\n      /**\n       * <pre>\n       * MACD Histogram ROC threshold (as % of price) - predictive convergence detection\n       * </pre>\n       *\n       * <code>double macd_histogram_roc_threshold = 83;</code>\n       * @return The macdHistogramRocThreshold.\n       */\n      @java.lang.Override\n      public double getMacdHistogramRocThreshold() {\n        return macdHistogramRocThreshold_;\n      }\n      /**\n       * <pre>\n       * MACD Histogram ROC threshold (as % of price) - predictive convergence detection\n       * </pre>\n       *\n       * <code>double macd_histogram_roc_threshold = 83;</code>\n       * @param value The macdHistogramRocThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMacdHistogramRocThreshold(double value) {\n\n        macdHistogramRocThreshold_ = value;\n        bitField1_ |= 0x01000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * MACD Histogram ROC threshold (as % of price) - predictive convergence detection\n       * </pre>\n       *\n       * <code>double macd_histogram_roc_threshold = 83;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMacdHistogramRocThreshold() {\n        bitField1_ = (bitField1_ & ~0x01000000);\n        macdHistogramRocThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private int stochasticPeriod_ ;\n      /**\n       * <pre>\n       * Stochastic periods and thresholds\n       * </pre>\n       *\n       * <code>int32 stochastic_period = 85;</code>\n       * @return The stochasticPeriod.\n       */\n      @java.lang.Override\n      public int getStochasticPeriod() {\n        return stochasticPeriod_;\n      }\n      /**\n       * <pre>\n       * Stochastic periods and thresholds\n       * </pre>\n       *\n       * <code>int32 stochastic_period = 85;</code>\n       * @param value The stochasticPeriod to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStochasticPeriod(int value) {\n\n        stochasticPeriod_ = value;\n        bitField1_ |= 0x02000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Stochastic periods and thresholds\n       * </pre>\n       *\n       * <code>int32 stochastic_period = 85;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStochasticPeriod() {\n        bitField1_ = (bitField1_ & ~0x02000000);\n        stochasticPeriod_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int stochasticKSmooth_ ;\n      /**\n       * <code>int32 stochastic_k_smooth = 86;</code>\n       * @return The stochasticKSmooth.\n       */\n      @java.lang.Override\n      public int getStochasticKSmooth() {\n        return stochasticKSmooth_;\n      }\n      /**\n       * <code>int32 stochastic_k_smooth = 86;</code>\n       * @param value The stochasticKSmooth to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStochasticKSmooth(int value) {\n\n        stochasticKSmooth_ = value;\n        bitField1_ |= 0x04000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 stochastic_k_smooth = 86;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStochasticKSmooth() {\n        bitField1_ = (bitField1_ & ~0x04000000);\n        stochasticKSmooth_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int stochasticDSmooth_ ;\n      /**\n       * <code>int32 stochastic_d_smooth = 87;</code>\n       * @return The stochasticDSmooth.\n       */\n      @java.lang.Override\n      public int getStochasticDSmooth() {\n        return stochasticDSmooth_;\n      }\n      /**\n       * <code>int32 stochastic_d_smooth = 87;</code>\n       * @param value The stochasticDSmooth to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStochasticDSmooth(int value) {\n\n        stochasticDSmooth_ = value;\n        bitField1_ |= 0x08000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 stochastic_d_smooth = 87;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStochasticDSmooth() {\n        bitField1_ = (bitField1_ & ~0x08000000);\n        stochasticDSmooth_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private double stochasticOversoldThreshold_ ;\n      /**\n       * <code>double stochastic_oversold_threshold = 88;</code>\n       * @return The stochasticOversoldThreshold.\n       */\n      @java.lang.Override\n      public double getStochasticOversoldThreshold() {\n        return stochasticOversoldThreshold_;\n      }\n      /**\n       * <code>double stochastic_oversold_threshold = 88;</code>\n       * @param value The stochasticOversoldThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStochasticOversoldThreshold(double value) {\n\n        stochasticOversoldThreshold_ = value;\n        bitField1_ |= 0x10000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double stochastic_oversold_threshold = 88;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStochasticOversoldThreshold() {\n        bitField1_ = (bitField1_ & ~0x10000000);\n        stochasticOversoldThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private double stochasticOverboughtThreshold_ ;\n      /**\n       * <code>double stochastic_overbought_threshold = 89;</code>\n       * @return The stochasticOverboughtThreshold.\n       */\n      @java.lang.Override\n      public double getStochasticOverboughtThreshold() {\n        return stochasticOverboughtThreshold_;\n      }\n      /**\n       * <code>double stochastic_overbought_threshold = 89;</code>\n       * @param value The stochasticOverboughtThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setStochasticOverboughtThreshold(double value) {\n\n        stochasticOverboughtThreshold_ = value;\n        bitField1_ |= 0x20000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double stochastic_overbought_threshold = 89;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearStochasticOverboughtThreshold() {\n        bitField1_ = (bitField1_ & ~0x20000000);\n        stochasticOverboughtThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private int rvolPeriod_ ;\n      /**\n       * <pre>\n       * Relative Volume (RVOL) settings\n       * </pre>\n       *\n       * <code>int32 rvol_period = 90;</code>\n       * @return The rvolPeriod.\n       */\n      @java.lang.Override\n      public int getRvolPeriod() {\n        return rvolPeriod_;\n      }\n      /**\n       * <pre>\n       * Relative Volume (RVOL) settings\n       * </pre>\n       *\n       * <code>int32 rvol_period = 90;</code>\n       * @param value The rvolPeriod to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRvolPeriod(int value) {\n\n        rvolPeriod_ = value;\n        bitField1_ |= 0x40000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Relative Volume (RVOL) settings\n       * </pre>\n       *\n       * <code>int32 rvol_period = 90;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRvolPeriod() {\n        bitField1_ = (bitField1_ & ~0x40000000);\n        rvolPeriod_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private double rvolThreshold_ ;\n      /**\n       * <code>double rvol_threshold = 91;</code>\n       * @return The rvolThreshold.\n       */\n      @java.lang.Override\n      public double getRvolThreshold() {\n        return rvolThreshold_;\n      }\n      /**\n       * <code>double rvol_threshold = 91;</code>\n       * @param value The rvolThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setRvolThreshold(double value) {\n\n        rvolThreshold_ = value;\n        bitField1_ |= 0x80000000;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>double rvol_threshold = 91;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearRvolThreshold() {\n        bitField1_ = (bitField1_ & ~0x80000000);\n        rvolThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private int ema9Period_ ;\n      /**\n       * <pre>\n       * EMA periods\n       * </pre>\n       *\n       * <code>int32 ema9_period = 95;</code>\n       * @return The ema9Period.\n       */\n      @java.lang.Override\n      public int getEma9Period() {\n        return ema9Period_;\n      }\n      /**\n       * <pre>\n       * EMA periods\n       * </pre>\n       *\n       * <code>int32 ema9_period = 95;</code>\n       * @param value The ema9Period to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEma9Period(int value) {\n\n        ema9Period_ = value;\n        bitField2_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * EMA periods\n       * </pre>\n       *\n       * <code>int32 ema9_period = 95;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEma9Period() {\n        bitField2_ = (bitField2_ & ~0x00000001);\n        ema9Period_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int ema20Period_ ;\n      /**\n       * <code>int32 ema20_period = 96;</code>\n       * @return The ema20Period.\n       */\n      @java.lang.Override\n      public int getEma20Period() {\n        return ema20Period_;\n      }\n      /**\n       * <code>int32 ema20_period = 96;</code>\n       * @param value The ema20Period to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEma20Period(int value) {\n\n        ema20Period_ = value;\n        bitField2_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 ema20_period = 96;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEma20Period() {\n        bitField2_ = (bitField2_ & ~0x00000002);\n        ema20Period_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private int ema50Period_ ;\n      /**\n       * <code>int32 ema50_period = 97;</code>\n       * @return The ema50Period.\n       */\n      @java.lang.Override\n      public int getEma50Period() {\n        return ema50Period_;\n      }\n      /**\n       * <code>int32 ema50_period = 97;</code>\n       * @param value The ema50Period to set.\n       * @return This builder for chaining.\n       */\n      public Builder setEma50Period(int value) {\n\n        ema50Period_ = value;\n        bitField2_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>int32 ema50_period = 97;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearEma50Period() {\n        bitField2_ = (bitField2_ & ~0x00000004);\n        ema50Period_ = 0;\n        onChanged();\n        return this;\n      }\n\n      private double volumeSpikeThreshold_ ;\n      /**\n       * <pre>\n       * Volume spike detection\n       * </pre>\n       *\n       * <code>double volume_spike_threshold = 98;</code>\n       * @return The volumeSpikeThreshold.\n       */\n      @java.lang.Override\n      public double getVolumeSpikeThreshold() {\n        return volumeSpikeThreshold_;\n      }\n      /**\n       * <pre>\n       * Volume spike detection\n       * </pre>\n       *\n       * <code>double volume_spike_threshold = 98;</code>\n       * @param value The volumeSpikeThreshold to set.\n       * @return This builder for chaining.\n       */\n      public Builder setVolumeSpikeThreshold(double value) {\n\n        volumeSpikeThreshold_ = value;\n        bitField2_ |= 0x00000008;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Volume spike detection\n       * </pre>\n       *\n       * <code>double volume_spike_threshold = 98;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearVolumeSpikeThreshold() {\n        bitField2_ = (bitField2_ & ~0x00000008);\n        volumeSpikeThreshold_ = 0D;\n        onChanged();\n        return this;\n      }\n\n      private int timeframeMultiplier_ ;\n      /**\n       * <pre>\n       * Timeframe multiplier for candle aggregation (1=1min, 10=10min, 30=30min, 60=1hour, 180=3hours)\n       * This tells the backend what timeframe to aggregate candles into before analysis\n       * </pre>\n       *\n       * <code>int32 timeframe_multiplier = 99;</code>\n       * @return The timeframeMultiplier.\n       */\n      @java.lang.Override\n      public int getTimeframeMultiplier() {\n        return timeframeMultiplier_;\n      }\n      /**\n       * <pre>\n       * Timeframe multiplier for candle aggregation (1=1min, 10=10min, 30=30min, 60=1hour, 180=3hours)\n       * This tells the backend what timeframe to aggregate candles into before analysis\n       * </pre>\n       *\n       * <code>int32 timeframe_multiplier = 99;</code>\n       * @param value The timeframeMultiplier to set.\n       * @return This builder for chaining.\n       */\n      public Builder setTimeframeMultiplier(int value) {\n\n        timeframeMultiplier_ = value;\n        bitField2_ |= 0x00000010;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * Timeframe multiplier for candle aggregation (1=1min, 10=10min, 30=30min, 60=1hour, 180=3hours)\n       * This tells the backend what timeframe to aggregate candles into before analysis\n       * </pre>\n       *\n       * <code>int32 timeframe_multiplier = 99;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearTimeframeMultiplier() {\n        bitField2_ = (bitField2_ & ~0x00000010);\n        timeframeMultiplier_ = 0;\n        onChanged();\n        return this;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.TradingConfig)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.TradingConfig)\n    private static final com.spiketrade.proto.ConfigProto.TradingConfig DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.ConfigProto.TradingConfig();\n    }\n\n    public static com.spiketrade.proto.ConfigProto.TradingConfig getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<TradingConfig>\n        PARSER = new com.google.protobuf.AbstractParser<TradingConfig>() {\n      @java.lang.Override\n      public TradingConfig parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<TradingConfig> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<TradingConfig> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.ConfigProto.TradingConfig getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface ConfigUpdateRequestOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.ConfigUpdateRequest)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n     * @return Whether the config field is set.\n     */\n    boolean hasConfig();\n    /**\n     * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n     * @return The config.\n     */\n    com.spiketrade.proto.ConfigProto.TradingConfig getConfig();\n    /**\n     * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n     */\n    com.spiketrade.proto.ConfigProto.TradingConfigOrBuilder getConfigOrBuilder();\n  }\n  /**\n   * <pre>\n   * Configuration update request\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.ConfigUpdateRequest}\n   */\n  public static final class ConfigUpdateRequest extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.ConfigUpdateRequest)\n      ConfigUpdateRequestOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use ConfigUpdateRequest.newBuilder() to construct.\n    private ConfigUpdateRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private ConfigUpdateRequest() {\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new ConfigUpdateRequest();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_ConfigUpdateRequest_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_ConfigUpdateRequest_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.ConfigProto.ConfigUpdateRequest.class, com.spiketrade.proto.ConfigProto.ConfigUpdateRequest.Builder.class);\n    }\n\n    private int bitField0_;\n    public static final int CONFIG_FIELD_NUMBER = 1;\n    private com.spiketrade.proto.ConfigProto.TradingConfig config_;\n    /**\n     * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n     * @return Whether the config field is set.\n     */\n    @java.lang.Override\n    public boolean hasConfig() {\n      return ((bitField0_ & 0x00000001) != 0);\n    }\n    /**\n     * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n     * @return The config.\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.ConfigProto.TradingConfig getConfig() {\n      return config_ == null ? com.spiketrade.proto.ConfigProto.TradingConfig.getDefaultInstance() : config_;\n    }\n    /**\n     * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.ConfigProto.TradingConfigOrBuilder getConfigOrBuilder() {\n      return config_ == null ? com.spiketrade.proto.ConfigProto.TradingConfig.getDefaultInstance() : config_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (((bitField0_ & 0x00000001) != 0)) {\n        output.writeMessage(1, getConfig());\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (((bitField0_ & 0x00000001) != 0)) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(1, getConfig());\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.ConfigProto.ConfigUpdateRequest)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.ConfigProto.ConfigUpdateRequest other = (com.spiketrade.proto.ConfigProto.ConfigUpdateRequest) obj;\n\n      if (hasConfig() != other.hasConfig()) return false;\n      if (hasConfig()) {\n        if (!getConfig()\n            .equals(other.getConfig())) return false;\n      }\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      if (hasConfig()) {\n        hash = (37 * hash) + CONFIG_FIELD_NUMBER;\n        hash = (53 * hash) + getConfig().hashCode();\n      }\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.ConfigProto.ConfigUpdateRequest parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigUpdateRequest parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigUpdateRequest parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigUpdateRequest parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigUpdateRequest parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigUpdateRequest parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigUpdateRequest parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigUpdateRequest parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.ConfigProto.ConfigUpdateRequest parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.ConfigProto.ConfigUpdateRequest parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigUpdateRequest parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigUpdateRequest parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.ConfigProto.ConfigUpdateRequest prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Configuration update request\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.ConfigUpdateRequest}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.ConfigUpdateRequest)\n        com.spiketrade.proto.ConfigProto.ConfigUpdateRequestOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_ConfigUpdateRequest_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_ConfigUpdateRequest_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.ConfigProto.ConfigUpdateRequest.class, com.spiketrade.proto.ConfigProto.ConfigUpdateRequest.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.ConfigProto.ConfigUpdateRequest.newBuilder()\n      private Builder() {\n        maybeForceBuilderInitialization();\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n        maybeForceBuilderInitialization();\n      }\n      private void maybeForceBuilderInitialization() {\n        if (com.google.protobuf.GeneratedMessageV3\n                .alwaysUseFieldBuilders) {\n          getConfigFieldBuilder();\n        }\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        config_ = null;\n        if (configBuilder_ != null) {\n          configBuilder_.dispose();\n          configBuilder_ = null;\n        }\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_ConfigUpdateRequest_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.ConfigProto.ConfigUpdateRequest getDefaultInstanceForType() {\n        return com.spiketrade.proto.ConfigProto.ConfigUpdateRequest.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.ConfigProto.ConfigUpdateRequest build() {\n        com.spiketrade.proto.ConfigProto.ConfigUpdateRequest result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.ConfigProto.ConfigUpdateRequest buildPartial() {\n        com.spiketrade.proto.ConfigProto.ConfigUpdateRequest result = new com.spiketrade.proto.ConfigProto.ConfigUpdateRequest(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.ConfigProto.ConfigUpdateRequest result) {\n        int from_bitField0_ = bitField0_;\n        int to_bitField0_ = 0;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.config_ = configBuilder_ == null\n              ? config_\n              : configBuilder_.build();\n          to_bitField0_ |= 0x00000001;\n        }\n        result.bitField0_ |= to_bitField0_;\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.ConfigProto.ConfigUpdateRequest) {\n          return mergeFrom((com.spiketrade.proto.ConfigProto.ConfigUpdateRequest)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.ConfigProto.ConfigUpdateRequest other) {\n        if (other == com.spiketrade.proto.ConfigProto.ConfigUpdateRequest.getDefaultInstance()) return this;\n        if (other.hasConfig()) {\n          mergeConfig(other.getConfig());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 10: {\n                input.readMessage(\n                    getConfigFieldBuilder().getBuilder(),\n                    extensionRegistry);\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 10\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private com.spiketrade.proto.ConfigProto.TradingConfig config_;\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.ConfigProto.TradingConfig, com.spiketrade.proto.ConfigProto.TradingConfig.Builder, com.spiketrade.proto.ConfigProto.TradingConfigOrBuilder> configBuilder_;\n      /**\n       * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n       * @return Whether the config field is set.\n       */\n      public boolean hasConfig() {\n        return ((bitField0_ & 0x00000001) != 0);\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n       * @return The config.\n       */\n      public com.spiketrade.proto.ConfigProto.TradingConfig getConfig() {\n        if (configBuilder_ == null) {\n          return config_ == null ? com.spiketrade.proto.ConfigProto.TradingConfig.getDefaultInstance() : config_;\n        } else {\n          return configBuilder_.getMessage();\n        }\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n       */\n      public Builder setConfig(com.spiketrade.proto.ConfigProto.TradingConfig value) {\n        if (configBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          config_ = value;\n        } else {\n          configBuilder_.setMessage(value);\n        }\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n       */\n      public Builder setConfig(\n          com.spiketrade.proto.ConfigProto.TradingConfig.Builder builderForValue) {\n        if (configBuilder_ == null) {\n          config_ = builderForValue.build();\n        } else {\n          configBuilder_.setMessage(builderForValue.build());\n        }\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n       */\n      public Builder mergeConfig(com.spiketrade.proto.ConfigProto.TradingConfig value) {\n        if (configBuilder_ == null) {\n          if (((bitField0_ & 0x00000001) != 0) &&\n            config_ != null &&\n            config_ != com.spiketrade.proto.ConfigProto.TradingConfig.getDefaultInstance()) {\n            getConfigBuilder().mergeFrom(value);\n          } else {\n            config_ = value;\n          }\n        } else {\n          configBuilder_.mergeFrom(value);\n        }\n        if (config_ != null) {\n          bitField0_ |= 0x00000001;\n          onChanged();\n        }\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n       */\n      public Builder clearConfig() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        config_ = null;\n        if (configBuilder_ != null) {\n          configBuilder_.dispose();\n          configBuilder_ = null;\n        }\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n       */\n      public com.spiketrade.proto.ConfigProto.TradingConfig.Builder getConfigBuilder() {\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return getConfigFieldBuilder().getBuilder();\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n       */\n      public com.spiketrade.proto.ConfigProto.TradingConfigOrBuilder getConfigOrBuilder() {\n        if (configBuilder_ != null) {\n          return configBuilder_.getMessageOrBuilder();\n        } else {\n          return config_ == null ?\n              com.spiketrade.proto.ConfigProto.TradingConfig.getDefaultInstance() : config_;\n        }\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig config = 1;</code>\n       */\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.ConfigProto.TradingConfig, com.spiketrade.proto.ConfigProto.TradingConfig.Builder, com.spiketrade.proto.ConfigProto.TradingConfigOrBuilder> \n          getConfigFieldBuilder() {\n        if (configBuilder_ == null) {\n          configBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<\n              com.spiketrade.proto.ConfigProto.TradingConfig, com.spiketrade.proto.ConfigProto.TradingConfig.Builder, com.spiketrade.proto.ConfigProto.TradingConfigOrBuilder>(\n                  getConfig(),\n                  getParentForChildren(),\n                  isClean());\n          config_ = null;\n        }\n        return configBuilder_;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.ConfigUpdateRequest)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.ConfigUpdateRequest)\n    private static final com.spiketrade.proto.ConfigProto.ConfigUpdateRequest DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.ConfigProto.ConfigUpdateRequest();\n    }\n\n    public static com.spiketrade.proto.ConfigProto.ConfigUpdateRequest getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<ConfigUpdateRequest>\n        PARSER = new com.google.protobuf.AbstractParser<ConfigUpdateRequest>() {\n      @java.lang.Override\n      public ConfigUpdateRequest parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<ConfigUpdateRequest> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<ConfigUpdateRequest> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.ConfigProto.ConfigUpdateRequest getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  public interface ConfigResponseOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:spiketrade.proto.ConfigResponse)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <code>bool success = 1;</code>\n     * @return The success.\n     */\n    boolean getSuccess();\n\n    /**\n     * <code>string message = 2;</code>\n     * @return The message.\n     */\n    java.lang.String getMessage();\n    /**\n     * <code>string message = 2;</code>\n     * @return The bytes for message.\n     */\n    com.google.protobuf.ByteString\n        getMessageBytes();\n\n    /**\n     * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n     * @return Whether the currentConfig field is set.\n     */\n    boolean hasCurrentConfig();\n    /**\n     * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n     * @return The currentConfig.\n     */\n    com.spiketrade.proto.ConfigProto.TradingConfig getCurrentConfig();\n    /**\n     * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n     */\n    com.spiketrade.proto.ConfigProto.TradingConfigOrBuilder getCurrentConfigOrBuilder();\n  }\n  /**\n   * <pre>\n   * Configuration response\n   * </pre>\n   *\n   * Protobuf type {@code spiketrade.proto.ConfigResponse}\n   */\n  public static final class ConfigResponse extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:spiketrade.proto.ConfigResponse)\n      ConfigResponseOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use ConfigResponse.newBuilder() to construct.\n    private ConfigResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private ConfigResponse() {\n      message_ = \"\";\n    }\n\n    @java.lang.Override\n    @SuppressWarnings({\"unused\"})\n    protected java.lang.Object newInstance(\n        UnusedPrivateParameter unused) {\n      return new ConfigResponse();\n    }\n\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_ConfigResponse_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_ConfigResponse_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.spiketrade.proto.ConfigProto.ConfigResponse.class, com.spiketrade.proto.ConfigProto.ConfigResponse.Builder.class);\n    }\n\n    private int bitField0_;\n    public static final int SUCCESS_FIELD_NUMBER = 1;\n    private boolean success_ = false;\n    /**\n     * <code>bool success = 1;</code>\n     * @return The success.\n     */\n    @java.lang.Override\n    public boolean getSuccess() {\n      return success_;\n    }\n\n    public static final int MESSAGE_FIELD_NUMBER = 2;\n    @SuppressWarnings(\"serial\")\n    private volatile java.lang.Object message_ = \"\";\n    /**\n     * <code>string message = 2;</code>\n     * @return The message.\n     */\n    @java.lang.Override\n    public java.lang.String getMessage() {\n      java.lang.Object ref = message_;\n      if (ref instanceof java.lang.String) {\n        return (java.lang.String) ref;\n      } else {\n        com.google.protobuf.ByteString bs = \n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        message_ = s;\n        return s;\n      }\n    }\n    /**\n     * <code>string message = 2;</code>\n     * @return The bytes for message.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString\n        getMessageBytes() {\n      java.lang.Object ref = message_;\n      if (ref instanceof java.lang.String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        message_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n\n    public static final int CURRENT_CONFIG_FIELD_NUMBER = 3;\n    private com.spiketrade.proto.ConfigProto.TradingConfig currentConfig_;\n    /**\n     * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n     * @return Whether the currentConfig field is set.\n     */\n    @java.lang.Override\n    public boolean hasCurrentConfig() {\n      return ((bitField0_ & 0x00000001) != 0);\n    }\n    /**\n     * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n     * @return The currentConfig.\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.ConfigProto.TradingConfig getCurrentConfig() {\n      return currentConfig_ == null ? com.spiketrade.proto.ConfigProto.TradingConfig.getDefaultInstance() : currentConfig_;\n    }\n    /**\n     * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n     */\n    @java.lang.Override\n    public com.spiketrade.proto.ConfigProto.TradingConfigOrBuilder getCurrentConfigOrBuilder() {\n      return currentConfig_ == null ? com.spiketrade.proto.ConfigProto.TradingConfig.getDefaultInstance() : currentConfig_;\n    }\n\n    private byte memoizedIsInitialized = -1;\n    @java.lang.Override\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    @java.lang.Override\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (success_ != false) {\n        output.writeBool(1, success_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(message_)) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, message_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        output.writeMessage(3, getCurrentConfig());\n      }\n      getUnknownFields().writeTo(output);\n    }\n\n    @java.lang.Override\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (success_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(1, success_);\n      }\n      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(message_)) {\n        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, message_);\n      }\n      if (((bitField0_ & 0x00000001) != 0)) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(3, getCurrentConfig());\n      }\n      size += getUnknownFields().getSerializedSize();\n      memoizedSize = size;\n      return size;\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof com.spiketrade.proto.ConfigProto.ConfigResponse)) {\n        return super.equals(obj);\n      }\n      com.spiketrade.proto.ConfigProto.ConfigResponse other = (com.spiketrade.proto.ConfigProto.ConfigResponse) obj;\n\n      if (getSuccess()\n          != other.getSuccess()) return false;\n      if (!getMessage()\n          .equals(other.getMessage())) return false;\n      if (hasCurrentConfig() != other.hasCurrentConfig()) return false;\n      if (hasCurrentConfig()) {\n        if (!getCurrentConfig()\n            .equals(other.getCurrentConfig())) return false;\n      }\n      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n      return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptor().hashCode();\n      hash = (37 * hash) + SUCCESS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getSuccess());\n      hash = (37 * hash) + MESSAGE_FIELD_NUMBER;\n      hash = (53 * hash) + getMessage().hashCode();\n      if (hasCurrentConfig()) {\n        hash = (37 * hash) + CURRENT_CONFIG_FIELD_NUMBER;\n        hash = (53 * hash) + getCurrentConfig().hashCode();\n      }\n      hash = (29 * hash) + getUnknownFields().hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static com.spiketrade.proto.ConfigProto.ConfigResponse parseFrom(\n        java.nio.ByteBuffer data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigResponse parseFrom(\n        java.nio.ByteBuffer data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigResponse parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigResponse parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigResponse parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigResponse parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigResponse parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigResponse parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public static com.spiketrade.proto.ConfigProto.ConfigResponse parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n\n    public static com.spiketrade.proto.ConfigProto.ConfigResponse parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigResponse parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static com.spiketrade.proto.ConfigProto.ConfigResponse parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    @java.lang.Override\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(com.spiketrade.proto.ConfigProto.ConfigResponse prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    @java.lang.Override\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * Configuration response\n     * </pre>\n     *\n     * Protobuf type {@code spiketrade.proto.ConfigResponse}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:spiketrade.proto.ConfigResponse)\n        com.spiketrade.proto.ConfigProto.ConfigResponseOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_ConfigResponse_descriptor;\n      }\n\n      @java.lang.Override\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_ConfigResponse_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                com.spiketrade.proto.ConfigProto.ConfigResponse.class, com.spiketrade.proto.ConfigProto.ConfigResponse.Builder.class);\n      }\n\n      // Construct using com.spiketrade.proto.ConfigProto.ConfigResponse.newBuilder()\n      private Builder() {\n        maybeForceBuilderInitialization();\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n        maybeForceBuilderInitialization();\n      }\n      private void maybeForceBuilderInitialization() {\n        if (com.google.protobuf.GeneratedMessageV3\n                .alwaysUseFieldBuilders) {\n          getCurrentConfigFieldBuilder();\n        }\n      }\n      @java.lang.Override\n      public Builder clear() {\n        super.clear();\n        bitField0_ = 0;\n        success_ = false;\n        message_ = \"\";\n        currentConfig_ = null;\n        if (currentConfigBuilder_ != null) {\n          currentConfigBuilder_.dispose();\n          currentConfigBuilder_ = null;\n        }\n        return this;\n      }\n\n      @java.lang.Override\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return com.spiketrade.proto.ConfigProto.internal_static_spiketrade_proto_ConfigResponse_descriptor;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.ConfigProto.ConfigResponse getDefaultInstanceForType() {\n        return com.spiketrade.proto.ConfigProto.ConfigResponse.getDefaultInstance();\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.ConfigProto.ConfigResponse build() {\n        com.spiketrade.proto.ConfigProto.ConfigResponse result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      @java.lang.Override\n      public com.spiketrade.proto.ConfigProto.ConfigResponse buildPartial() {\n        com.spiketrade.proto.ConfigProto.ConfigResponse result = new com.spiketrade.proto.ConfigProto.ConfigResponse(this);\n        if (bitField0_ != 0) { buildPartial0(result); }\n        onBuilt();\n        return result;\n      }\n\n      private void buildPartial0(com.spiketrade.proto.ConfigProto.ConfigResponse result) {\n        int from_bitField0_ = bitField0_;\n        if (((from_bitField0_ & 0x00000001) != 0)) {\n          result.success_ = success_;\n        }\n        if (((from_bitField0_ & 0x00000002) != 0)) {\n          result.message_ = message_;\n        }\n        int to_bitField0_ = 0;\n        if (((from_bitField0_ & 0x00000004) != 0)) {\n          result.currentConfig_ = currentConfigBuilder_ == null\n              ? currentConfig_\n              : currentConfigBuilder_.build();\n          to_bitField0_ |= 0x00000001;\n        }\n        result.bitField0_ |= to_bitField0_;\n      }\n\n      @java.lang.Override\n      public Builder clone() {\n        return super.clone();\n      }\n      @java.lang.Override\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.setField(field, value);\n      }\n      @java.lang.Override\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return super.clearField(field);\n      }\n      @java.lang.Override\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return super.clearOneof(oneof);\n      }\n      @java.lang.Override\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, java.lang.Object value) {\n        return super.setRepeatedField(field, index, value);\n      }\n      @java.lang.Override\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          java.lang.Object value) {\n        return super.addRepeatedField(field, value);\n      }\n      @java.lang.Override\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof com.spiketrade.proto.ConfigProto.ConfigResponse) {\n          return mergeFrom((com.spiketrade.proto.ConfigProto.ConfigResponse)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(com.spiketrade.proto.ConfigProto.ConfigResponse other) {\n        if (other == com.spiketrade.proto.ConfigProto.ConfigResponse.getDefaultInstance()) return this;\n        if (other.getSuccess() != false) {\n          setSuccess(other.getSuccess());\n        }\n        if (!other.getMessage().isEmpty()) {\n          message_ = other.message_;\n          bitField0_ |= 0x00000002;\n          onChanged();\n        }\n        if (other.hasCurrentConfig()) {\n          mergeCurrentConfig(other.getCurrentConfig());\n        }\n        this.mergeUnknownFields(other.getUnknownFields());\n        onChanged();\n        return this;\n      }\n\n      @java.lang.Override\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      @java.lang.Override\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        if (extensionRegistry == null) {\n          throw new java.lang.NullPointerException();\n        }\n        try {\n          boolean done = false;\n          while (!done) {\n            int tag = input.readTag();\n            switch (tag) {\n              case 0:\n                done = true;\n                break;\n              case 8: {\n                success_ = input.readBool();\n                bitField0_ |= 0x00000001;\n                break;\n              } // case 8\n              case 18: {\n                message_ = input.readStringRequireUtf8();\n                bitField0_ |= 0x00000002;\n                break;\n              } // case 18\n              case 26: {\n                input.readMessage(\n                    getCurrentConfigFieldBuilder().getBuilder(),\n                    extensionRegistry);\n                bitField0_ |= 0x00000004;\n                break;\n              } // case 26\n              default: {\n                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n                  done = true; // was an endgroup tag\n                }\n                break;\n              } // default:\n            } // switch (tag)\n          } // while (!done)\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.unwrapIOException();\n        } finally {\n          onChanged();\n        } // finally\n        return this;\n      }\n      private int bitField0_;\n\n      private boolean success_ ;\n      /**\n       * <code>bool success = 1;</code>\n       * @return The success.\n       */\n      @java.lang.Override\n      public boolean getSuccess() {\n        return success_;\n      }\n      /**\n       * <code>bool success = 1;</code>\n       * @param value The success to set.\n       * @return This builder for chaining.\n       */\n      public Builder setSuccess(boolean value) {\n\n        success_ = value;\n        bitField0_ |= 0x00000001;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>bool success = 1;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearSuccess() {\n        bitField0_ = (bitField0_ & ~0x00000001);\n        success_ = false;\n        onChanged();\n        return this;\n      }\n\n      private java.lang.Object message_ = \"\";\n      /**\n       * <code>string message = 2;</code>\n       * @return The message.\n       */\n      public java.lang.String getMessage() {\n        java.lang.Object ref = message_;\n        if (!(ref instanceof java.lang.String)) {\n          com.google.protobuf.ByteString bs =\n              (com.google.protobuf.ByteString) ref;\n          java.lang.String s = bs.toStringUtf8();\n          message_ = s;\n          return s;\n        } else {\n          return (java.lang.String) ref;\n        }\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @return The bytes for message.\n       */\n      public com.google.protobuf.ByteString\n          getMessageBytes() {\n        java.lang.Object ref = message_;\n        if (ref instanceof String) {\n          com.google.protobuf.ByteString b = \n              com.google.protobuf.ByteString.copyFromUtf8(\n                  (java.lang.String) ref);\n          message_ = b;\n          return b;\n        } else {\n          return (com.google.protobuf.ByteString) ref;\n        }\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @param value The message to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMessage(\n          java.lang.String value) {\n        if (value == null) { throw new NullPointerException(); }\n        message_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @return This builder for chaining.\n       */\n      public Builder clearMessage() {\n        message_ = getDefaultInstance().getMessage();\n        bitField0_ = (bitField0_ & ~0x00000002);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>string message = 2;</code>\n       * @param value The bytes for message to set.\n       * @return This builder for chaining.\n       */\n      public Builder setMessageBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) { throw new NullPointerException(); }\n        checkByteStringIsUtf8(value);\n        message_ = value;\n        bitField0_ |= 0x00000002;\n        onChanged();\n        return this;\n      }\n\n      private com.spiketrade.proto.ConfigProto.TradingConfig currentConfig_;\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.ConfigProto.TradingConfig, com.spiketrade.proto.ConfigProto.TradingConfig.Builder, com.spiketrade.proto.ConfigProto.TradingConfigOrBuilder> currentConfigBuilder_;\n      /**\n       * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n       * @return Whether the currentConfig field is set.\n       */\n      public boolean hasCurrentConfig() {\n        return ((bitField0_ & 0x00000004) != 0);\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n       * @return The currentConfig.\n       */\n      public com.spiketrade.proto.ConfigProto.TradingConfig getCurrentConfig() {\n        if (currentConfigBuilder_ == null) {\n          return currentConfig_ == null ? com.spiketrade.proto.ConfigProto.TradingConfig.getDefaultInstance() : currentConfig_;\n        } else {\n          return currentConfigBuilder_.getMessage();\n        }\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n       */\n      public Builder setCurrentConfig(com.spiketrade.proto.ConfigProto.TradingConfig value) {\n        if (currentConfigBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          currentConfig_ = value;\n        } else {\n          currentConfigBuilder_.setMessage(value);\n        }\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n       */\n      public Builder setCurrentConfig(\n          com.spiketrade.proto.ConfigProto.TradingConfig.Builder builderForValue) {\n        if (currentConfigBuilder_ == null) {\n          currentConfig_ = builderForValue.build();\n        } else {\n          currentConfigBuilder_.setMessage(builderForValue.build());\n        }\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n       */\n      public Builder mergeCurrentConfig(com.spiketrade.proto.ConfigProto.TradingConfig value) {\n        if (currentConfigBuilder_ == null) {\n          if (((bitField0_ & 0x00000004) != 0) &&\n            currentConfig_ != null &&\n            currentConfig_ != com.spiketrade.proto.ConfigProto.TradingConfig.getDefaultInstance()) {\n            getCurrentConfigBuilder().mergeFrom(value);\n          } else {\n            currentConfig_ = value;\n          }\n        } else {\n          currentConfigBuilder_.mergeFrom(value);\n        }\n        if (currentConfig_ != null) {\n          bitField0_ |= 0x00000004;\n          onChanged();\n        }\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n       */\n      public Builder clearCurrentConfig() {\n        bitField0_ = (bitField0_ & ~0x00000004);\n        currentConfig_ = null;\n        if (currentConfigBuilder_ != null) {\n          currentConfigBuilder_.dispose();\n          currentConfigBuilder_ = null;\n        }\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n       */\n      public com.spiketrade.proto.ConfigProto.TradingConfig.Builder getCurrentConfigBuilder() {\n        bitField0_ |= 0x00000004;\n        onChanged();\n        return getCurrentConfigFieldBuilder().getBuilder();\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n       */\n      public com.spiketrade.proto.ConfigProto.TradingConfigOrBuilder getCurrentConfigOrBuilder() {\n        if (currentConfigBuilder_ != null) {\n          return currentConfigBuilder_.getMessageOrBuilder();\n        } else {\n          return currentConfig_ == null ?\n              com.spiketrade.proto.ConfigProto.TradingConfig.getDefaultInstance() : currentConfig_;\n        }\n      }\n      /**\n       * <code>.spiketrade.proto.TradingConfig current_config = 3;</code>\n       */\n      private com.google.protobuf.SingleFieldBuilderV3<\n          com.spiketrade.proto.ConfigProto.TradingConfig, com.spiketrade.proto.ConfigProto.TradingConfig.Builder, com.spiketrade.proto.ConfigProto.TradingConfigOrBuilder> \n          getCurrentConfigFieldBuilder() {\n        if (currentConfigBuilder_ == null) {\n          currentConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<\n              com.spiketrade.proto.ConfigProto.TradingConfig, com.spiketrade.proto.ConfigProto.TradingConfig.Builder, com.spiketrade.proto.ConfigProto.TradingConfigOrBuilder>(\n                  getCurrentConfig(),\n                  getParentForChildren(),\n                  isClean());\n          currentConfig_ = null;\n        }\n        return currentConfigBuilder_;\n      }\n      @java.lang.Override\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.setUnknownFields(unknownFields);\n      }\n\n      @java.lang.Override\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return super.mergeUnknownFields(unknownFields);\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:spiketrade.proto.ConfigResponse)\n    }\n\n    // @@protoc_insertion_point(class_scope:spiketrade.proto.ConfigResponse)\n    private static final com.spiketrade.proto.ConfigProto.ConfigResponse DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new com.spiketrade.proto.ConfigProto.ConfigResponse();\n    }\n\n    public static com.spiketrade.proto.ConfigProto.ConfigResponse getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<ConfigResponse>\n        PARSER = new com.google.protobuf.AbstractParser<ConfigResponse>() {\n      @java.lang.Override\n      public ConfigResponse parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n        Builder builder = newBuilder();\n        try {\n          builder.mergeFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          throw e.setUnfinishedMessage(builder.buildPartial());\n        } catch (com.google.protobuf.UninitializedMessageException e) {\n          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n        } catch (java.io.IOException e) {\n          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n              .setUnfinishedMessage(builder.buildPartial());\n        }\n        return builder.buildPartial();\n      }\n    };\n\n    public static com.google.protobuf.Parser<ConfigResponse> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<ConfigResponse> getParserForType() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.spiketrade.proto.ConfigProto.ConfigResponse getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  private static final com.google.protobuf.Descriptors.Descriptor\n    internal_static_spiketrade_proto_TradingConfig_descriptor;\n  private static final \n    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internal_static_spiketrade_proto_TradingConfig_fieldAccessorTable;\n  private static final com.google.protobuf.Descriptors.Descriptor\n    internal_static_spiketrade_proto_ConfigUpdateRequest_descriptor;\n  private static final \n    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internal_static_spiketrade_proto_ConfigUpdateRequest_fieldAccessorTable;\n  private static final com.google.protobuf.Descriptors.Descriptor\n    internal_static_spiketrade_proto_ConfigResponse_descriptor;\n  private static final \n    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internal_static_spiketrade_proto_ConfigResponse_fieldAccessorTable;\n\n  public static com.google.protobuf.Descriptors.FileDescriptor\n      getDescriptor() {\n    return descriptor;\n  }\n  private static  com.google.protobuf.Descriptors.FileDescriptor\n      descriptor;\n  static {\n    java.lang.String[] descriptorData = {\n      \"\\n\\014config.proto\\022\\020spiketrade.proto\\\"\\206\\021\\n\\rTra\" +\n      \"dingConfig\\022\\032\\n\\022buy_period_minutes\\030\\001 \\001(\\005\\022\\031\" +\n      \"\\n\\021bb_length_minutes\\030\\002 \\001(\\005\\022\\032\\n\\022rsi_length_\" +\n      \"minutes\\030\\003 \\001(\\005\\022 \\n\\030price_roc_period_minute\" +\n      \"s\\030\\004 \\001(\\005\\022\\036\\n\\026obv_roc_period_minutes\\030\\005 \\001(\\005\\022\" +\n      \"\\032\\n\\022mfi_period_minutes\\030\\006 \\001(\\005\\022\\036\\n\\026mfi_roc_p\" +\n      \"eriod_minutes\\030\\007 \\001(\\005\\022\\033\\n\\023vwap_period_minut\" +\n      \"es\\030\\010 \\001(\\005\\022\\023\\n\\013data_points\\030\\t \\001(\\005\\022\\032\\n\\022warmup_\" +\n      \"data_points\\030\\n \\001(\\005\\022#\\n\\033spike_price_roc_z_t\" +\n      \"hreshold\\030\\024 \\001(\\001\\022!\\n\\031spike_rsi_roc_z_thresh\" +\n      \"old\\030\\025 \\001(\\001\\022!\\n\\031spike_obv_roc_z_threshold\\030\\026\" +\n      \" \\001(\\001\\022!\\n\\031spike_mfi_roc_z_threshold\\030\\027 \\001(\\001\\022\" +\n      \"\\'\\n\\037spike_percent_b_roc_z_threshold\\030\\030 \\001(\\001\" +\n      \"\\022\\\"\\n\\032spike_vwap_roc_z_threshold\\030\\031 \\001(\\001\\022$\\n\\034\" +\n      \"spike_volume_roc_z_threshold\\030\\032 \\001(\\001\\022#\\n\\033re\" +\n      \"gular_price_roc_threshold\\030\\037 \\001(\\001\\022!\\n\\031regul\" +\n      \"ar_rsi_roc_threshold\\030  \\001(\\001\\022!\\n\\031regular_ob\" +\n      \"v_roc_threshold\\030! \\001(\\001\\022!\\n\\031regular_mfi_roc\" +\n      \"_threshold\\030\\\" \\001(\\001\\022\\'\\n\\037regular_percent_b_ro\" +\n      \"c_threshold\\030# \\001(\\001\\022\\\"\\n\\032regular_vwap_roc_th\" +\n      \"reshold\\030$ \\001(\\001\\022$\\n\\034regular_volume_roc_thre\" +\n      \"shold\\030% \\001(\\001\\022 \\n\\030regular_price_roc_period\\030\" +\n      \"< \\001(\\005\\022\\036\\n\\026regular_rsi_roc_period\\030= \\001(\\005\\022\\036\\n\" +\n      \"\\026regular_obv_roc_period\\030> \\001(\\005\\022\\036\\n\\026regular\" +\n      \"_mfi_roc_period\\030? \\001(\\005\\022$\\n\\034regular_percent\" +\n      \"_b_roc_period\\030@ \\001(\\005\\022\\037\\n\\027regular_vwap_roc_\" +\n      \"period\\030A \\001(\\005\\022!\\n\\031regular_volume_roc_perio\" +\n      \"d\\030B \\001(\\005\\022\\036\\n\\026combo_signal_threshold\\030\\033 \\001(\\001\\022\" +\n      \"\\033\\n\\023high_prob_threshold\\030\\034 \\001(\\001\\022\\025\\n\\rstop_los\" +\n      \"s_pct\\030\\035 \\001(\\001\\022\\'\\n\\037spike_cooldown_stddev_thr\" +\n      \"eshold\\030\\036 \\001(\\001\\022\\030\\n\\020equity_per_trade\\030( \\001(\\001\\022\\027\" +\n      \"\\n\\017max_open_trades\\030) \\001(\\001\\022\\036\\n\\026total_equity_\" +\n      \"available\\030* \\001(\\001\\022\\036\\n\\026enable_price_roc_spik\" +\n      \"e\\0302 \\001(\\010\\022\\034\\n\\024enable_rsi_roc_spike\\0303 \\001(\\010\\022\\034\\n\" +\n      \"\\024enable_obv_roc_spike\\0304 \\001(\\010\\022\\034\\n\\024enable_mf\" +\n      \"i_roc_spike\\0305 \\001(\\010\\022\\\"\\n\\032enable_percent_b_ro\" +\n      \"c_spike\\0306 \\001(\\010\\022\\035\\n\\025enable_vwap_roc_spike\\0307\" +\n      \" \\001(\\010\\022\\025\\n\\ruse_ml_spikes\\0308 \\001(\\010\\022\\030\\n\\020enable_co\" +\n      \"oldowns\\0309 \\001(\\010\\022\\034\\n\\024enable_adx_indicator\\030: \" +\n      \"\\001(\\010\\022\\037\\n\\027enable_volume_roc_spike\\030; \\001(\\010\\022!\\n\\031\" +\n      \"enable_macd_histogram_roc\\030F \\001(\\010\\022#\\n\\033enabl\" +\n      \"e_stochastic_indicator\\030G \\001(\\010\\022\\035\\n\\025enable_r\" +\n      \"vol_indicator\\030H \\001(\\010\\022\\034\\n\\024enable_ema_indica\" +\n      \"tor\\030I \\001(\\010\\022\\037\\n\\027enable_ema_trend_filter\\030J \\001\" +\n      \"(\\010\\022\\030\\n\\020macd_fast_period\\030P \\001(\\005\\022\\030\\n\\020macd_slo\" +\n      \"w_period\\030Q \\001(\\005\\022\\032\\n\\022macd_signal_period\\030R \\001\" +\n      \"(\\005\\022$\\n\\034macd_histogram_roc_threshold\\030S \\001(\\001\" +\n      \"\\022\\031\\n\\021stochastic_period\\030U \\001(\\005\\022\\033\\n\\023stochasti\" +\n      \"c_k_smooth\\030V \\001(\\005\\022\\033\\n\\023stochastic_d_smooth\\030\" +\n      \"W \\001(\\005\\022%\\n\\035stochastic_oversold_threshold\\030X\" +\n      \" \\001(\\001\\022\\'\\n\\037stochastic_overbought_threshold\\030\" +\n      \"Y \\001(\\001\\022\\023\\n\\013rvol_period\\030Z \\001(\\005\\022\\026\\n\\016rvol_thres\" +\n      \"hold\\030[ \\001(\\001\\022\\023\\n\\013ema9_period\\030_ \\001(\\005\\022\\024\\n\\014ema20\" +\n      \"_period\\030` \\001(\\005\\022\\024\\n\\014ema50_period\\030a \\001(\\005\\022\\036\\n\\026v\" +\n      \"olume_spike_threshold\\030b \\001(\\001\\022\\034\\n\\024timeframe\" +\n      \"_multiplier\\030c \\001(\\005\\\"F\\n\\023ConfigUpdateRequest\" +\n      \"\\022/\\n\\006config\\030\\001 \\001(\\0132\\037.spiketrade.proto.Trad\" +\n      \"ingConfig\\\"k\\n\\016ConfigResponse\\022\\017\\n\\007success\\030\\001\" +\n      \" \\001(\\010\\022\\017\\n\\007message\\030\\002 \\001(\\t\\0227\\n\\016current_config\\030\" +\n      \"\\003 \\001(\\0132\\037.spiketrade.proto.TradingConfigB#\" +\n      \"\\n\\024com.spiketrade.protoB\\013ConfigProtob\\006pro\" +\n      \"to3\"\n    };\n    descriptor = com.google.protobuf.Descriptors.FileDescriptor\n      .internalBuildGeneratedFileFrom(descriptorData,\n        new com.google.protobuf.Descriptors.FileDescriptor[] {\n        });\n    internal_static_spiketrade_proto_TradingConfig_descriptor =\n      getDescriptor().getMessageTypes().get(0);\n    internal_static_spiketrade_proto_TradingConfig_fieldAccessorTable = new\n      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(\n        internal_static_spiketrade_proto_TradingConfig_descriptor,\n        new java.lang.String[] { \"BuyPeriodMinutes\", \"BbLengthMinutes\", \"RsiLengthMinutes\", \"PriceRocPeriodMinutes\", \"ObvRocPeriodMinutes\", \"MfiPeriodMinutes\", \"MfiRocPeriodMinutes\", \"VwapPeriodMinutes\", \"DataPoints\", \"WarmupDataPoints\", \"SpikePriceRocZThreshold\", \"SpikeRsiRocZThreshold\", \"SpikeObvRocZThreshold\", \"SpikeMfiRocZThreshold\", \"SpikePercentBRocZThreshold\", \"SpikeVwapRocZThreshold\", \"SpikeVolumeRocZThreshold\", \"RegularPriceRocThreshold\", \"RegularRsiRocThreshold\", \"RegularObvRocThreshold\", \"RegularMfiRocThreshold\", \"RegularPercentBRocThreshold\", \"RegularVwapRocThreshold\", \"RegularVolumeRocThreshold\", \"RegularPriceRocPeriod\", \"RegularRsiRocPeriod\", \"RegularObvRocPeriod\", \"RegularMfiRocPeriod\", \"RegularPercentBRocPeriod\", \"RegularVwapRocPeriod\", \"RegularVolumeRocPeriod\", \"ComboSignalThreshold\", \"HighProbThreshold\", \"StopLossPct\", \"SpikeCooldownStddevThreshold\", \"EquityPerTrade\", \"MaxOpenTrades\", \"TotalEquityAvailable\", \"EnablePriceRocSpike\", \"EnableRsiRocSpike\", \"EnableObvRocSpike\", \"EnableMfiRocSpike\", \"EnablePercentBRocSpike\", \"EnableVwapRocSpike\", \"UseMlSpikes\", \"EnableCooldowns\", \"EnableAdxIndicator\", \"EnableVolumeRocSpike\", \"EnableMacdHistogramRoc\", \"EnableStochasticIndicator\", \"EnableRvolIndicator\", \"EnableEmaIndicator\", \"EnableEmaTrendFilter\", \"MacdFastPeriod\", \"MacdSlowPeriod\", \"MacdSignalPeriod\", \"MacdHistogramRocThreshold\", \"StochasticPeriod\", \"StochasticKSmooth\", \"StochasticDSmooth\", \"StochasticOversoldThreshold\", \"StochasticOverboughtThreshold\", \"RvolPeriod\", \"RvolThreshold\", \"Ema9Period\", \"Ema20Period\", \"Ema50Period\", \"VolumeSpikeThreshold\", \"TimeframeMultiplier\", });\n    internal_static_spiketrade_proto_ConfigUpdateRequest_descriptor =\n      getDescriptor().getMessageTypes().get(1);\n    internal_static_spiketrade_proto_ConfigUpdateRequest_fieldAccessorTable = new\n      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(\n        internal_static_spiketrade_proto_ConfigUpdateRequest_descriptor,\n        new java.lang.String[] { \"Config\", });\n    internal_static_spiketrade_proto_ConfigResponse_descriptor =\n      getDescriptor().getMessageTypes().get(2);\n    internal_static_spiketrade_proto_ConfigResponse_fieldAccessorTable = new\n      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(\n        internal_static_spiketrade_proto_ConfigResponse_descriptor,\n        new java.lang.String[] { \"Success\", \"Message\", \"CurrentConfig\", });\n  }\n\n  // @@protoc_insertion_point(outer_class_scope)\n}\n","size_bytes":254436},"build/extracted-include-protos/test/google/api/resource.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/descriptor.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/api/annotations;annotations\";\noption java_multiple_files = true;\noption java_outer_classname = \"ResourceProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\nextend google.protobuf.FieldOptions {\n  // An annotation that describes a resource reference, see\n  // [ResourceReference][].\n  google.api.ResourceReference resource_reference = 1055;\n}\n\nextend google.protobuf.FileOptions {\n  // An annotation that describes a resource definition without a corresponding\n  // message; see [ResourceDescriptor][].\n  repeated google.api.ResourceDescriptor resource_definition = 1053;\n}\n\nextend google.protobuf.MessageOptions {\n  // An annotation that describes a resource definition, see\n  // [ResourceDescriptor][].\n  google.api.ResourceDescriptor resource = 1053;\n}\n\n// A simple descriptor of a resource type.\n//\n// ResourceDescriptor annotates a resource message (either by means of a\n// protobuf annotation or use in the service config), and associates the\n// resource's schema, the resource type, and the pattern of the resource name.\n//\n// Example:\n//\n//     message Topic {\n//       // Indicates this message defines a resource schema.\n//       // Declares the resource type in the format of {service}/{kind}.\n//       // For Kubernetes resources, the format is {api group}/{kind}.\n//       option (google.api.resource) = {\n//         type: \"pubsub.googleapis.com/Topic\"\n//         pattern: \"projects/{project}/topics/{topic}\"\n//       };\n//     }\n//\n// The ResourceDescriptor Yaml config will look like:\n//\n//     resources:\n//     - type: \"pubsub.googleapis.com/Topic\"\n//       pattern: \"projects/{project}/topics/{topic}\"\n//\n// Sometimes, resources have multiple patterns, typically because they can\n// live under multiple parents.\n//\n// Example:\n//\n//     message LogEntry {\n//       option (google.api.resource) = {\n//         type: \"logging.googleapis.com/LogEntry\"\n//         pattern: \"projects/{project}/logs/{log}\"\n//         pattern: \"folders/{folder}/logs/{log}\"\n//         pattern: \"organizations/{organization}/logs/{log}\"\n//         pattern: \"billingAccounts/{billing_account}/logs/{log}\"\n//       };\n//     }\n//\n// The ResourceDescriptor Yaml config will look like:\n//\n//     resources:\n//     - type: 'logging.googleapis.com/LogEntry'\n//       pattern: \"projects/{project}/logs/{log}\"\n//       pattern: \"folders/{folder}/logs/{log}\"\n//       pattern: \"organizations/{organization}/logs/{log}\"\n//       pattern: \"billingAccounts/{billing_account}/logs/{log}\"\nmessage ResourceDescriptor {\n  // A description of the historical or future-looking state of the\n  // resource pattern.\n  enum History {\n    // The \"unset\" value.\n    HISTORY_UNSPECIFIED = 0;\n\n    // The resource originally had one pattern and launched as such, and\n    // additional patterns were added later.\n    ORIGINALLY_SINGLE_PATTERN = 1;\n\n    // The resource has one pattern, but the API owner expects to add more\n    // later. (This is the inverse of ORIGINALLY_SINGLE_PATTERN, and prevents\n    // that from being necessary once there are multiple patterns.)\n    FUTURE_MULTI_PATTERN = 2;\n  }\n\n  // A flag representing a specific style that a resource claims to conform to.\n  enum Style {\n    // The unspecified value. Do not use.\n    STYLE_UNSPECIFIED = 0;\n\n    // This resource is intended to be \"declarative-friendly\".\n    //\n    // Declarative-friendly resources must be more strictly consistent, and\n    // setting this to true communicates to tools that this resource should\n    // adhere to declarative-friendly expectations.\n    //\n    // Note: This is used by the API linter (linter.aip.dev) to enable\n    // additional checks.\n    DECLARATIVE_FRIENDLY = 1;\n  }\n\n  // The resource type. It must be in the format of\n  // {service_name}/{resource_type_kind}. The `resource_type_kind` must be\n  // singular and must not include version numbers.\n  //\n  // Example: `storage.googleapis.com/Bucket`\n  //\n  // The value of the resource_type_kind must follow the regular expression\n  // /[A-Za-z][a-zA-Z0-9]+/. It should start with an upper case character and\n  // should use PascalCase (UpperCamelCase). The maximum number of\n  // characters allowed for the `resource_type_kind` is 100.\n  string type = 1;\n\n  // Optional. The relative resource name pattern associated with this resource\n  // type. The DNS prefix of the full resource name shouldn't be specified here.\n  //\n  // The path pattern must follow the syntax, which aligns with HTTP binding\n  // syntax:\n  //\n  //     Template = Segment { \"/\" Segment } ;\n  //     Segment = LITERAL | Variable ;\n  //     Variable = \"{\" LITERAL \"}\" ;\n  //\n  // Examples:\n  //\n  //     - \"projects/{project}/topics/{topic}\"\n  //     - \"projects/{project}/knowledgeBases/{knowledge_base}\"\n  //\n  // The components in braces correspond to the IDs for each resource in the\n  // hierarchy. It is expected that, if multiple patterns are provided,\n  // the same component name (e.g. \"project\") refers to IDs of the same\n  // type of resource.\n  repeated string pattern = 2;\n\n  // Optional. The field on the resource that designates the resource name\n  // field. If omitted, this is assumed to be \"name\".\n  string name_field = 3;\n\n  // Optional. The historical or future-looking state of the resource pattern.\n  //\n  // Example:\n  //\n  //     // The InspectTemplate message originally only supported resource\n  //     // names with organization, and project was added later.\n  //     message InspectTemplate {\n  //       option (google.api.resource) = {\n  //         type: \"dlp.googleapis.com/InspectTemplate\"\n  //         pattern:\n  //         \"organizations/{organization}/inspectTemplates/{inspect_template}\"\n  //         pattern: \"projects/{project}/inspectTemplates/{inspect_template}\"\n  //         history: ORIGINALLY_SINGLE_PATTERN\n  //       };\n  //     }\n  History history = 4;\n\n  // The plural name used in the resource name and permission names, such as\n  // 'projects' for the resource name of 'projects/{project}' and the permission\n  // name of 'cloudresourcemanager.googleapis.com/projects.get'. It is the same\n  // concept of the `plural` field in k8s CRD spec\n  // https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/\n  //\n  // Note: The plural form is required even for singleton resources. See\n  // https://aip.dev/156\n  string plural = 5;\n\n  // The same concept of the `singular` field in k8s CRD spec\n  // https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/\n  // Such as \"project\" for the `resourcemanager.googleapis.com/Project` type.\n  string singular = 6;\n\n  // Style flag(s) for this resource.\n  // These indicate that a resource is expected to conform to a given\n  // style. See the specific style flags for additional information.\n  repeated Style style = 10;\n}\n\n// Defines a proto annotation that describes a string field that refers to\n// an API resource.\nmessage ResourceReference {\n  // The resource type that the annotated field references.\n  //\n  // Example:\n  //\n  //     message Subscription {\n  //       string topic = 2 [(google.api.resource_reference) = {\n  //         type: \"pubsub.googleapis.com/Topic\"\n  //       }];\n  //     }\n  //\n  // Occasionally, a field may reference an arbitrary resource. In this case,\n  // APIs use the special value * in their resource reference.\n  //\n  // Example:\n  //\n  //     message GetIamPolicyRequest {\n  //       string resource = 2 [(google.api.resource_reference) = {\n  //         type: \"*\"\n  //       }];\n  //     }\n  string type = 1;\n\n  // The resource type of a child collection that the annotated field\n  // references. This is useful for annotating the `parent` field that\n  // doesn't have a fixed resource type.\n  //\n  // Example:\n  //\n  //     message ListLogEntriesRequest {\n  //       string parent = 1 [(google.api.resource_reference) = {\n  //         child_type: \"logging.googleapis.com/LogEntry\"\n  //       };\n  //     }\n  string child_type = 2;\n}\n","size_bytes":8744},"build/extracted-include-protos/test/google/type/postal_address.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/postaladdress;postaladdress\";\noption java_multiple_files = true;\noption java_outer_classname = \"PostalAddressProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a postal address, e.g. for postal delivery or payments addresses.\n// Given a postal address, a postal service can deliver items to a premise, P.O.\n// Box or similar.\n// It is not intended to model geographical locations (roads, towns,\n// mountains).\n//\n// In typical usage an address would be created via user input or from importing\n// existing data, depending on the type of process.\n//\n// Advice on address input / editing:\n//  - Use an i18n-ready address widget such as\n//    https://github.com/google/libaddressinput)\n// - Users should not be presented with UI elements for input or editing of\n//   fields outside countries where that field is used.\n//\n// For more guidance on how to use this schema, please see:\n// https://support.google.com/business/answer/6397478\nmessage PostalAddress {\n  // The schema revision of the `PostalAddress`. This must be set to 0, which is\n  // the latest revision.\n  //\n  // All new revisions **must** be backward compatible with old revisions.\n  int32 revision = 1;\n\n  // Required. CLDR region code of the country/region of the address. This\n  // is never inferred and it is up to the user to ensure the value is\n  // correct. See http://cldr.unicode.org/ and\n  // http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html\n  // for details. Example: \"CH\" for Switzerland.\n  string region_code = 2;\n\n  // Optional. BCP-47 language code of the contents of this address (if\n  // known). This is often the UI language of the input form or is expected\n  // to match one of the languages used in the address' country/region, or their\n  // transliterated equivalents.\n  // This can affect formatting in certain countries, but is not critical\n  // to the correctness of the data and will never affect any validation or\n  // other non-formatting related operations.\n  //\n  // If this value is not known, it should be omitted (rather than specifying a\n  // possibly incorrect default).\n  //\n  // Examples: \"zh-Hant\", \"ja\", \"ja-Latn\", \"en\".\n  string language_code = 3;\n\n  // Optional. Postal code of the address. Not all countries use or require\n  // postal codes to be present, but where they are used, they may trigger\n  // additional validation with other parts of the address (e.g. state/zip\n  // validation in the U.S.A.).\n  string postal_code = 4;\n\n  // Optional. Additional, country-specific, sorting code. This is not used\n  // in most regions. Where it is used, the value is either a string like\n  // \"CEDEX\", optionally followed by a number (e.g. \"CEDEX 7\"), or just a number\n  // alone, representing the \"sector code\" (Jamaica), \"delivery area indicator\"\n  // (Malawi) or \"post office indicator\" (e.g. Cte d'Ivoire).\n  string sorting_code = 5;\n\n  // Optional. Highest administrative subdivision which is used for postal\n  // addresses of a country or region.\n  // For example, this can be a state, a province, an oblast, or a prefecture.\n  // Specifically, for Spain this is the province and not the autonomous\n  // community (e.g. \"Barcelona\" and not \"Catalonia\").\n  // Many countries don't use an administrative area in postal addresses. E.g.\n  // in Switzerland this should be left unpopulated.\n  string administrative_area = 6;\n\n  // Optional. Generally refers to the city/town portion of the address.\n  // Examples: US city, IT comune, UK post town.\n  // In regions of the world where localities are not well defined or do not fit\n  // into this structure well, leave locality empty and use address_lines.\n  string locality = 7;\n\n  // Optional. Sublocality of the address.\n  // For example, this can be neighborhoods, boroughs, districts.\n  string sublocality = 8;\n\n  // Unstructured address lines describing the lower levels of an address.\n  //\n  // Because values in address_lines do not have type information and may\n  // sometimes contain multiple values in a single field (e.g.\n  // \"Austin, TX\"), it is important that the line order is clear. The order of\n  // address lines should be \"envelope order\" for the country/region of the\n  // address. In places where this can vary (e.g. Japan), address_language is\n  // used to make it explicit (e.g. \"ja\" for large-to-small ordering and\n  // \"ja-Latn\" or \"en\" for small-to-large). This way, the most specific line of\n  // an address can be selected based on the language.\n  //\n  // The minimum permitted structural representation of an address consists\n  // of a region_code with all remaining information placed in the\n  // address_lines. It would be possible to format such an address very\n  // approximately without geocoding, but no semantic reasoning could be\n  // made about any of the address components until it was at least\n  // partially resolved.\n  //\n  // Creating an address only containing a region_code and address_lines, and\n  // then geocoding is the recommended way to handle completely unstructured\n  // addresses (as opposed to guessing which parts of the address should be\n  // localities or administrative areas).\n  repeated string address_lines = 9;\n\n  // Optional. The recipient at the address.\n  // This field may, under certain circumstances, contain multiline information.\n  // For example, it might contain \"care of\" information.\n  repeated string recipients = 10;\n\n  // Optional. The name of the organization at the address.\n  string organization = 11;\n}\n","size_bytes":6235},"build/extracted-include-protos/test/google/protobuf/type.proto":{"content":"// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage google.protobuf;\n\nimport \"google/protobuf/any.proto\";\nimport \"google/protobuf/source_context.proto\";\n\noption cc_enable_arenas = true;\noption java_package = \"com.google.protobuf\";\noption java_outer_classname = \"TypeProto\";\noption java_multiple_files = true;\noption objc_class_prefix = \"GPB\";\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\noption go_package = \"google.golang.org/protobuf/types/known/typepb\";\n\n// A protocol buffer message type.\nmessage Type {\n  // The fully qualified message name.\n  string name = 1;\n  // The list of fields.\n  repeated Field fields = 2;\n  // The list of types appearing in `oneof` definitions in this type.\n  repeated string oneofs = 3;\n  // The protocol buffer options.\n  repeated Option options = 4;\n  // The source context.\n  SourceContext source_context = 5;\n  // The source syntax.\n  Syntax syntax = 6;\n  // The source edition string, only valid when syntax is SYNTAX_EDITIONS.\n  string edition = 7;\n}\n\n// A single field of a message type.\nmessage Field {\n  // Basic field types.\n  enum Kind {\n    // Field type unknown.\n    TYPE_UNKNOWN = 0;\n    // Field type double.\n    TYPE_DOUBLE = 1;\n    // Field type float.\n    TYPE_FLOAT = 2;\n    // Field type int64.\n    TYPE_INT64 = 3;\n    // Field type uint64.\n    TYPE_UINT64 = 4;\n    // Field type int32.\n    TYPE_INT32 = 5;\n    // Field type fixed64.\n    TYPE_FIXED64 = 6;\n    // Field type fixed32.\n    TYPE_FIXED32 = 7;\n    // Field type bool.\n    TYPE_BOOL = 8;\n    // Field type string.\n    TYPE_STRING = 9;\n    // Field type group. Proto2 syntax only, and deprecated.\n    TYPE_GROUP = 10;\n    // Field type message.\n    TYPE_MESSAGE = 11;\n    // Field type bytes.\n    TYPE_BYTES = 12;\n    // Field type uint32.\n    TYPE_UINT32 = 13;\n    // Field type enum.\n    TYPE_ENUM = 14;\n    // Field type sfixed32.\n    TYPE_SFIXED32 = 15;\n    // Field type sfixed64.\n    TYPE_SFIXED64 = 16;\n    // Field type sint32.\n    TYPE_SINT32 = 17;\n    // Field type sint64.\n    TYPE_SINT64 = 18;\n  }\n\n  // Whether a field is optional, required, or repeated.\n  enum Cardinality {\n    // For fields with unknown cardinality.\n    CARDINALITY_UNKNOWN = 0;\n    // For optional fields.\n    CARDINALITY_OPTIONAL = 1;\n    // For required fields. Proto2 syntax only.\n    CARDINALITY_REQUIRED = 2;\n    // For repeated fields.\n    CARDINALITY_REPEATED = 3;\n  }\n\n  // The field type.\n  Kind kind = 1;\n  // The field cardinality.\n  Cardinality cardinality = 2;\n  // The field number.\n  int32 number = 3;\n  // The field name.\n  string name = 4;\n  // The field type URL, without the scheme, for message or enumeration\n  // types. Example: `\"type.googleapis.com/google.protobuf.Timestamp\"`.\n  string type_url = 6;\n  // The index of the field type in `Type.oneofs`, for message or enumeration\n  // types. The first type has index 1; zero means the type is not in the list.\n  int32 oneof_index = 7;\n  // Whether to use alternative packed wire representation.\n  bool packed = 8;\n  // The protocol buffer options.\n  repeated Option options = 9;\n  // The field JSON name.\n  string json_name = 10;\n  // The string value of the default value of this field. Proto2 syntax only.\n  string default_value = 11;\n}\n\n// Enum type definition.\nmessage Enum {\n  // Enum type name.\n  string name = 1;\n  // Enum value definitions.\n  repeated EnumValue enumvalue = 2;\n  // Protocol buffer options.\n  repeated Option options = 3;\n  // The source context.\n  SourceContext source_context = 4;\n  // The source syntax.\n  Syntax syntax = 5;\n  // The source edition string, only valid when syntax is SYNTAX_EDITIONS.\n  string edition = 6;\n}\n\n// Enum value definition.\nmessage EnumValue {\n  // Enum value name.\n  string name = 1;\n  // Enum value number.\n  int32 number = 2;\n  // Protocol buffer options.\n  repeated Option options = 3;\n}\n\n// A protocol buffer option, which can be attached to a message, field,\n// enumeration, etc.\nmessage Option {\n  // The option's name. For protobuf built-in options (options defined in\n  // descriptor.proto), this is the short name. For example, `\"map_entry\"`.\n  // For custom options, it should be the fully-qualified name. For example,\n  // `\"google.api.http\"`.\n  string name = 1;\n  // The option's value packed in an Any message. If the value is a primitive,\n  // the corresponding wrapper type defined in google/protobuf/wrappers.proto\n  // should be used. If the value is an enum, it should be stored as an int32\n  // value using the google.protobuf.Int32Value type.\n  Any value = 2;\n}\n\n// The syntax in which a protocol buffer element is defined.\nenum Syntax {\n  // Syntax `proto2`.\n  SYNTAX_PROTO2 = 0;\n  // Syntax `proto3`.\n  SYNTAX_PROTO3 = 1;\n  // Syntax `editions`.\n  SYNTAX_EDITIONS = 2;\n}\n","size_bytes":6367},"src/main/proto/market_data.proto":{"content":"syntax = \"proto3\";\n\npackage spiketrade.proto;\n\noption java_package = \"com.spiketrade.proto\";\noption java_outer_classname = \"MarketDataProto\";\n\n// Indicators data - Extended to include all technical indicators for continuous quote updates\nmessage IndicatorsData {\n  // Basic indicators\n  double rsi = 1;\n  double price_roc = 2;\n  double volume_roc = 3;\n  double volume = 4;\n  double obv = 5;\n  double mfi = 6;\n  double bollinger_position = 7;\n  double percent_b = 8;\n  double vwap = 9;\n  \n  // ROC (Rate of Change) indicators\n  double rsi_roc = 10;\n  double obv_roc = 11;\n  double mfi_roc = 12;\n  double bollinger_pos_roc = 13;\n  double percent_b_roc = 14;\n  double vwap_roc = 15;\n  \n  // MACD (Moving Average Convergence Divergence)\n  double macd_line = 16;\n  double macd_signal = 17;\n  double macd_histogram = 18;\n  \n  // EMA (Exponential Moving Average) - multiple periods\n  double ema_9 = 19;\n  double ema_20 = 20;\n  double ema_50 = 21;\n  \n  // Stochastic Oscillator\n  double stoch_k = 22;\n  double stoch_d = 23;\n  \n  // Relative Volume\n  double rvol = 24;\n  \n  // Volume Spike Detection\n  bool volume_spike = 25;\n  double volume_ratio = 26;\n  \n  // ATR (Average True Range)\n  double atr = 27;\n  \n  // Bollinger Band values (for completeness)\n  double bollinger_upper = 28;\n  double bollinger_lower = 29;\n}\n\n// Market data message\nmessage Quote {\n  string symbol = 1;\n  double price = 2;\n  int64 volume = 3;\n  double bid = 4;\n  double ask = 5; // NOTE: The next available field number is 7, not 5 or 6.\n  int64 timestamp_ms = 6;\n\n  // Individual indicator fields (legacy - deprecated, use indicators field instead)\n  double rsi = 7;\n  double price_roc = 8;\n  double volume_roc = 9;\n  double obv = 10;\n  double mfi = 11;\n  double bollinger_position = 12;\n  double percent_b = 13;\n  double vwap = 14;\n  \n  // Full indicators data (includes all technical indicators)\n  optional IndicatorsData indicators = 15;\n  \n  // Buy signal probability (0.0 to 1.0) - continuously calculated\n  optional double signal_probability = 16;\n  \n  // ATR for quick access\n  optional double atr = 17;\n}\n\n// OHLCV candle data\nmessage Candle {\n  int64 timestamp_ms = 1;\n  double open = 2;\n  double high = 3;\n  double low = 4;\n  double close = 5;\n  int64 volume = 6;\n}\n\n// Historical market data request\nmessage HistoricalDataRequest {\n  string symbol = 1;\n  int32 interval_minutes = 2;\n  int32 num_bars = 3;\n}\n\n// Historical market data response\nmessage HistoricalDataResponse {\n  string symbol = 1;\n  repeated Candle candles = 2;\n  string error_message = 3;\n}\n\n// Real-time quote stream\nmessage QuoteStreamRequest {\n  repeated string symbols = 1;\n}\n\n// Connection status\nmessage ConnectionStatus {\n  enum State {\n    DISCONNECTED = 0;\n    CONNECTED = 1;\n    DEGRADED = 2;\n    FAILED = 3;\n  }\n  State state = 1;\n  bool using_fallback = 2;\n  string fallback_reason = 3;\n  int32 consecutive_failures = 4;\n}\n","size_bytes":2882},"build/extracted-include-protos/main/google/type/interval.proto":{"content":"// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.type;\n\nimport \"google/protobuf/timestamp.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/type/interval;interval\";\noption java_multiple_files = true;\noption java_outer_classname = \"IntervalProto\";\noption java_package = \"com.google.type\";\noption objc_class_prefix = \"GTP\";\n\n// Represents a time interval, encoded as a Timestamp start (inclusive) and a\n// Timestamp end (exclusive).\n//\n// The start must be less than or equal to the end.\n// When the start equals the end, the interval is empty (matches no time).\n// When both start and end are unspecified, the interval matches any time.\nmessage Interval {\n  // Optional. Inclusive start of the interval.\n  //\n  // If specified, a Timestamp matching this interval will have to be the same\n  // or after the start.\n  google.protobuf.Timestamp start_time = 1;\n\n  // Optional. Exclusive end of the interval.\n  //\n  // If specified, a Timestamp matching this interval will have to be before the\n  // end.\n  google.protobuf.Timestamp end_time = 2;\n}\n","size_bytes":1667},"build/extracted-include-protos/main/google/api/httpbody.proto":{"content":"// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage google.api;\n\nimport \"google/protobuf/any.proto\";\n\noption cc_enable_arenas = true;\noption go_package = \"google.golang.org/genproto/googleapis/api/httpbody;httpbody\";\noption java_multiple_files = true;\noption java_outer_classname = \"HttpBodyProto\";\noption java_package = \"com.google.api\";\noption objc_class_prefix = \"GAPI\";\n\n// Message that represents an arbitrary HTTP body. It should only be used for\n// payload formats that can't be represented as JSON, such as raw binary or\n// an HTML page.\n//\n//\n// This message can be used both in streaming and non-streaming API methods in\n// the request as well as the response.\n//\n// It can be used as a top-level request field, which is convenient if one\n// wants to extract parameters from either the URL or HTTP template into the\n// request fields and also want access to the raw HTTP body.\n//\n// Example:\n//\n//     message GetResourceRequest {\n//       // A unique request id.\n//       string request_id = 1;\n//\n//       // The raw HTTP body is bound to this field.\n//       google.api.HttpBody http_body = 2;\n//\n//     }\n//\n//     service ResourceService {\n//       rpc GetResource(GetResourceRequest)\n//         returns (google.api.HttpBody);\n//       rpc UpdateResource(google.api.HttpBody)\n//         returns (google.protobuf.Empty);\n//\n//     }\n//\n// Example with streaming methods:\n//\n//     service CaldavService {\n//       rpc GetCalendar(stream google.api.HttpBody)\n//         returns (stream google.api.HttpBody);\n//       rpc UpdateCalendar(stream google.api.HttpBody)\n//         returns (stream google.api.HttpBody);\n//\n//     }\n//\n// Use of this type only changes how the request and response bodies are\n// handled, all other features will continue to work unchanged.\nmessage HttpBody {\n  // The HTTP Content-Type header value specifying the content type of the body.\n  string content_type = 1;\n\n  // The HTTP request/response body as raw binary.\n  bytes data = 2;\n\n  // Application specific response metadata. Must be set in the first response\n  // for streaming APIs.\n  repeated google.protobuf.Any extensions = 3;\n}\n","size_bytes":2693},"replit.md":{"content":"# SpikeTrade Trading Application\n\n## Overview\n\nSpikeTrade is a real-time trading signal detection and analysis platform built with JavaFX for the frontend and a gRPC-based backend service. The application monitors stock tickers using technical indicators (RSI, MACD, Bollinger Bands, MFI, OBV, VWAP, ATR, etc.) to identify high-probability buy signals based on price/volume spikes and pattern recognition. It supports automated trade execution with configurable risk management parameters including stop-loss, profit floors, and position sizing.\n\nThe system integrates with Questrade and Yahoo Finance APIs for real-time market data, with a fallback mechanism between providers. It features multi-symbol concurrent monitoring, streaming quote updates, machine learning-based spike detection, and multi-channel notifications (email, SMS, desktop alerts).\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture (JavaFX)\n\n**Technology Stack**: JavaFX application with CSS styling following Apple-inspired design system (greyscale palette with accent colors)\n\n**UI Structure**:\n- Tab-based interface with separate views for ticker analysis, trade tracking, and system settings\n- Real-time updating tables for ticker monitoring with 22+ technical indicators per symbol\n- Dual-stream data model: quote streams (price updates) + signal streams (buy signal events)\n- Platform.runLater() pattern for thread-safe UI updates from async callbacks\n\n**State Management**:\n- Centralized ApplicationState class managing trading status, open positions, and ticker list\n- In-memory maps for symbol-to-probability tracking and last notification timestamps\n- Notification debouncing with configurable cooldown (15 seconds default, 5-60s range) to prevent alert spam while not suppressing legitimate signals\n\n**Recent Fixes (Nov 2025) - Notification Reliability**:\n-  **Configurable Cooldown**: Reduced from 60s to 15s default with slider control (5-60s range) in Notifications tab to prevent legitimate buy signals from being suppressed during volatile markets\n-  **Debug Mode**: Added \"Show All Trade Decisions\" checkbox that bypasses cooldown and displays all trade evaluations for troubleshooting signal flow\n-  **Trade Rejection Alerts**: Added critical popup alerts when trades are rejected (max trades limit, wide spread) instead of silent console logging\n-  **Signal Stream Error Handling**: Added popup alerts and status bar updates when signal stream connection fails\n-  **Trade Tracker Sync**: Fixed table refresh issue by adding Platform.runLater() wrapper and explicit table.refresh() calls after adding trades\n-  **Notification Status Indicator**: Added visual status indicator to status bar showing \" NOTIFICATIONS OK\" or failure states\n-  **Critical Alert System**: Added alertCritical() method that guarantees delivery of critical alerts bypassing all cooldowns using modal dialogs\n\n**Known Limitations** (Minor):\n- Table refresh race conditions between quote updates and signal updates may cause indicator fields to appear empty\n- Probability polling only activates when trading is enabled AND tickers are already added (order-dependent initialization)\n- Missing indicator extraction: MACD, EMA9/20/50, Stochastic, RVOL, ATR are not passed from gRPC responses to UI update methods\n\n### Backend Architecture (gRPC Service)\n\n**Communication Protocol**: gRPC streaming for real-time quote delivery and signal notifications\n\n**Core Services**:\n- `TradingServiceClient`: Manages bidirectional streams with backend for quotes and buy signals\n- `streamQuotes()`: Continuous price/indicator updates for all monitored symbols\n- `streamSignals()`: Event-driven notifications when buy probability exceeds threshold\n- `getAnalysisStatus()`: Polling-based fallback for probability updates (10-second intervals)\n\n**Signal Generation Logic**:\n- Multi-indicator spike detection using z-score thresholds (configurable per indicator)\n- Regular rate-of-change analysis with independent thresholds for price, volume, RSI, MFI, OBV, VWAP\n- ML-based spike detection toggle (useMlSpikes flag in trading_settings.json)\n- Combo signal scoring with high-probability thresholds\n\n**Trade Execution Flow**:\n1. Signal detected  Check cooldown period (spike standard deviation threshold)\n2. Validate position limits (maxOpenTrades) and equity availability\n3. Calculate position size based on equityPerTrade setting\n4. Execute buy  Track in ApplicationState.tradeRecords\n5. Monitor for exit conditions (stop-loss % or profit floor %)\n\n**Risk Management**:\n- Stop-loss: 2% default (stopLossPct)\n- Profit protection: Initial 3% floor, subsequent 2% floor (trailing stops)\n- Position sizing: $1,000 per trade default, max 5 concurrent positions\n- Total equity limit: $10,000 default\n\n### Configuration System\n\n**JSON-based Settings**:\n- `trading_settings.json`: 50+ parameters for indicator periods, thresholds, position sizing, and signal rules\n- `emergency_config.json`: Rate limiting, API retry logic, connection fallback behavior\n\n**Rate Limiting Strategy**:\n- Yahoo Finance: 12 requests/minute with 2-second delays between calls\n- Questrade: 4 retry attempts with 1-second backoff\n- Intraday data limit: 7 days for Yahoo Finance\n\n**Connection Management**:\n- Primary: Questrade API with automatic fallback to Yahoo Finance if unavailable\n- Toggle flags for enabling/disabling each data provider independently\n\n### Notification Architecture\n\n**Multi-Channel Support**:\n- Email notifications (configured via UI with saved credentials)\n- SMS notifications (configured via UI with Twilio credentials)\n- Desktop/OS-level toast notifications (Windows Toast library)\n\n**Configuration Management (UPDATED Nov 2025)**:\n-  **Removed Replit Secrets dependency** - all configuration now done through UI\n-  **User input fields** for email (address, password, recipient) and SMS (Twilio SID, auth token, phone numbers)\n-  **Credential preservation** - password/token fields can be left blank when updating other fields\n-  **Validation** - prevents saving incomplete configurations or blank values\n-  **Persistence** - configuration saved to notification-config.properties file\n-  **Auto-population** - existing values loaded into UI fields on tab open\n\n**Notification Types**:\n- Buy signal alerts with symbol, price, probability, and indicator details\n- Sell signal alerts (profit targets reached)\n- Spike warnings (unusual price/volume activity)\n- Trade execution confirmations\n- Error conditions (connection failures, trade rejections)\n\n**Notification Reliability (FIXED Nov 2025)**:\n-  Notification failures are now logged to console for debugging\n-  Critical events (trade rejections, stream failures) use alertCritical() method that guarantees user sees them via modal dialogs\n-  Cooldown is now configurable (15s default, reduced from 60s) to prevent suppressing legitimate signals\n-  Debug mode checkbox allows users to see all trade evaluations and bypass cooldown for troubleshooting\n-  Status bar indicator shows notification system health at a glance\n\n### Error Handling (FIXED Nov 2025)\n\n**Previously Silent Failures - NOW FIXED**:\n1.  Trade rejections (max positions, wide spread) now show popup alerts with specific reasons\n2.  Notification delivery failures are logged to console; critical events use alertCritical() to guarantee visibility\n3.  Signal stream errors now show popup dialogs and update status bar indicator\n4.  Trade record additions now trigger immediate table refresh via Platform.runLater() + table.refresh()\n\n**Remaining Improvements** (Low Priority):\n- Notification retry mechanism for transient failures (currently logged only)\n- Backend warmup status indicator to prevent \"ready but not calculating\" confusion\n\n## External Dependencies\n\n### Market Data APIs\n\n**Questrade API**:\n- Purpose: Primary real-time quote provider\n- Authentication: Token-based (managed through Replit Secrets)\n- Rate limiting: 4 retries with exponential backoff\n- Fallback behavior: Automatic switch to Yahoo Finance on failure\n\n**Yahoo Finance API**:\n- Purpose: Secondary quote provider and historical data source\n- Rate limiting: 12 requests/minute maximum\n- Data constraints: Intraday data limited to 7-day lookback\n- Use case: Fallback when Questrade unavailable or for extended historical analysis\n\n### Communication Protocol\n\n**gRPC (Protocol Buffers)**:\n- Protobuf message definitions for Quote, BuySignal, AnalysisStatus\n- Bidirectional streaming for real-time data delivery\n- Backend service assumed to be running separately (host/port configured via Replit Secrets)\n\n### Notification Services\n\n**Email Service**:\n- Configuration: SMTP credentials stored in Replit Secrets\n- Initialization check: Must succeed for email notifications to function\n- No built-in retry logic for delivery failures\n\n**SMS Service**:\n- External provider (specific implementation not shown in provided files)\n- Configuration: API keys/credentials via Replit Secrets\n- Same initialization requirements as email\n\n**Desktop Notifications**:\n- Windows Toast library for native OS notifications\n- Platform-dependent (Windows only based on library name)\n- May fail silently if platform unsupported\n\n### Database/Persistence\n\n**Note**: No database schema files provided in repository. Trade records appear to be in-memory only (ApplicationState.tradeRecords list). Historical data persistence mechanism not evident from provided files. System may lose trade history on restart unless external persistence layer exists in backend service.\n\n### Build System\n\n**Java Build Tool**: Not explicitly shown in provided files, but JavaFX application suggests Maven or Gradle with JavaFX plugin dependencies.\n\n**Resource Management**:\n- CSS stylesheets in src/main/resources and build/resources\n- Protobuf definitions expected in separate proto files (not included in provided excerpt)\n- Configuration JSONs loaded from project root directory","size_bytes":10026}},"version":2}